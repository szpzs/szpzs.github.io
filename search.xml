<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Erlang垃圾回收细节以及它为何重要]]></title>
      <url>http://szpzs.oschina.io/2016/12/13/erlang-garbage-collection-details-and-why-it-matters/</url>
      <content type="html"><![CDATA[<p>Erlang尝试解决的一个主要问题就是为实现高水平响应的<a href="https://en.wikipedia.org/wiki/Real-time_computing" target="_blank" rel="external">软实时系统</a>创建一个平台。这样的系统需要快速的<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="external">垃圾回</a>收策略，这样就不会阻止系统以及时的方式进行响应。另外当我们认为Erlang是一门无破坏性修改特性的<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="external">不可改变</a>语言的时候，垃圾回收变得更重要，因为这样的语言有更高产生垃圾的几率。</p>
<a id="more"></a>
<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>在我们深入垃圾回收之前，了解Erlang进程的内存布局是很有必要的。Erlang进程的内存布局可以分为三个主要部分：进程控制块，栈和堆。这和Unix的进程布局非常像。</p>
<p><img src="/images/erlang-memory-layout.png" style="border:0;"></p>
<ul>
<li><strong>进程控制块</strong>：进程控制块持有进程的一些信息，诸如：它在进程表里的标识符（PID），当前状态（运行、等待），它的注册名字，初始化调用和当前调用；另外进程控制块还持有指向到达消息的指针，这些消息是<em>链接列表</em>的成员，它们存储在进程私有堆里。</li>
<li><strong>栈</strong>：它是一个向下增长的内存区域，它持有函数的进出参数，返回地址，本地变量以及计算表达式的临时空间。</li>
<li><strong>堆</strong>：它是一个向上增长的内存区域，它持有进程邮箱的实际消息，像<a href="http://www.erlang.org/doc/man/lists.html" target="_blank" rel="external">列表</a>和<a href="http://www.erlang.org/documentation/doc-5.8/doc/reference_manual/data_types.html" target="_blank" rel="external">元组</a>这样的复合数据，<a href="http://www.erlang.org/doc/man/binary.html" target="_blank" rel="external">二进制数据</a>，大于一个机器字的诸如浮点数对象。大于64字节的二进制数据不保存在进程私有堆里，这样的二进制数据叫做<em>Refc Binary</em>（引用计数二进制），它们存储在一个大<em>共享堆</em>，被那些有指向引用计数二进制数据指针的进程访问。那些指针叫做<em>ProcBin</em>并且存储在进程的私有堆里。</li>
</ul>
<h1 id="垃圾回收细节"><a href="#垃圾回收细节" class="headerlink" title="垃圾回收细节"></a>垃圾回收细节</h1><p>为了解释当前默认的Erlang垃圾回收机制，我们可以简单地说，一种是独立运行在每个Erlang进程私有堆内的分代复制垃圾回收，另一种是发生在全局共享堆的引用计数垃圾回收。</p>
<h2 id="私有堆垃圾回收"><a href="#私有堆垃圾回收" class="headerlink" title="私有堆垃圾回收"></a>私有堆垃圾回收</h2><p>私有堆的垃圾回收是分代的。分代垃圾回收将堆分成两个段：年轻代和老生代。分代的原理是：如果一个对象在一个垃圾回收周期存活下来，那么它短时间成为垃圾的机会就降低了。所以年轻代给新分配的数据使用，老生代给那些已经执行了指定次数的垃圾回收后还依然幸存下来的数据使用。这种分割为两个段的方式有助于垃圾回收减少在还没有变成垃圾的数据上进行不必要的垃圾回收过程。Erlang的垃圾回有两种策略：<em>分代的</em>（轻量级的）和<em>全扫描</em>（重量级的）。分代的垃圾回收只是回收年轻代堆，而全扫描垃圾回收则回收年轻代和老生的堆。现在让我们仔细看看一个新启动的Erlang进程在私有堆里的垃圾回收步骤：</p>
<p><strong>场景1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; No GC &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个短时存活的进程没有垃圾回收发生，它用的堆没有超过<em>min_heap_size</em>设置的值然后就终止了。在这个场景下，被进程使用的所有内存都被回收。</p>
<p><strong>场景2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个新创建的进程，它的数据增长超过<em>min_heap_size</em>设置的值，所以发生了一次全扫描垃圾回收，很明显因为在此之前从来没有发生过垃圾回收，所以就不存在年轻代和老生代两个段。在第一次全扫描垃圾回收后，堆被分割成年轻代和老生代，并且此后垃圾回收策略切换到分代的垃圾回收并且一直维持这种策略直到进程终止。</p>
<p><strong>场景3:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Generational &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在进程的生命周期里当垃圾回收策略从分代的垃圾回收再次切换到全扫描的垃圾回收的时候，这会有几种不同的情况。第一种情况是在一定数量的分代的垃圾回收发生后。这个一定的数量可以全局设置或者每个进程用<em>fullsweep_after</em>标志设置。每个进程的分代的垃圾回收次数统计和它切换到全扫描到垃圾回收前的分代的垃圾回收次数上限分别是进程的<em>minor_gcs</em>和<em>fullsweep_after</em>属性，同时这两个值可用<em>process_info(PID, garbage_collection)</em>的返回值来获得。第二种情况是分代的垃圾回收不能回收足够的内存的时候。最后一种情况是当<em>garbage_collection(PID)</em>函数被手工调用的时候。在这几种情况后，垃圾回收策略再次从全扫描的垃圾回收切换回分代的垃圾回收并且保持直到上述的情况发生。</p>
<p><strong>场景4:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Increase Heap &gt; Fullsweep &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在场景3里，如果第二次全扫描垃圾回收不能回收足够的内存，那么堆被增大，而垃圾回收策略再切换回全扫描垃圾回收，像一个新创建的进程一样。所有这四种场景可以反复发生。</p>
<p>那么现在的问题是，像Erlang这样的自动垃圾回收语言，上述这些知识为什么重要？首先这些知识能帮助你通过调优全局的或某个进程的垃圾回收的发生和策略来使得你的系统更快。其次从它的垃圾回收角度来开，我们可以理解使得Erlang成为一个软实时平台的主要原因之一。这是因为每一个进程都有它自己的私有堆和它自己的垃圾回收，因此每次在一个进程里垃圾回收发生只是让这个正在进行垃圾回收的进程停顿而不会停顿其他任何进程，这是一个软实时系统所需要的。</p>
<h2 id="共享堆垃圾回收"><a href="#共享堆垃圾回收" class="headerlink" title="共享堆垃圾回收"></a>共享堆垃圾回收</h2><p>共享堆垃圾回收是引用计数垃圾回收。每一个共享堆里的对象（Refc）都有一个引用它的计数器，这个计数器被其他对象（ProcBin）持有，而这个ProcBin对象存储在Erlang进程的私有堆里。如果一个对象的引用计数器的值变为0，这个对象变成不可访问，并且将被销毁。引用计数器方式的垃圾回收是如此的廉价而且帮助系统避免出现意外的长时间暂停同时促进了系统的响应。但是由于在设计你的参与者模式系统时不太熟悉的一些知名反模式可能会造成内存泄漏的麻烦。</p>
<ul>
<li>首先是当一个引用计数二进制数据被分割为子二进制数据。为了节省资源，子二进制数据并不是原二进制数据分割部分的新拷贝，而只是对这个分割部分的引用。然而除了原始二进制数据，这个子二进制数据的引用计数是一个新的引用，正如你能理解的，这将导致一个问题，原始二进制数据必须等它的子二进制数据被回收后才能回收。</li>
<li>另一个众所周知的问题是当有一类长期生存的中间件进程，它作为一个请求控制器或消息路由器来控制和传输大的引用计数二进制消息。因为这个进程和所有这些引用计数二进制数据关联，所以它们的计数器值就增加了。所以回收这些引用计数二进制数据依赖于回收所有的ProcBin对象，甚至包括这个中间件进程里的ProcBin对象。非常不幸的是，因为ProcBin只是一个指针，它非常廉价，以至于在这个中间件进程里要花很长时间才能遇到一次回收这个ProcBin对象。造成的结果就是，即使除了中间件进程外其他所有进程里的ProcBin对象都被回收了，引用计数二进制数据还是继续留存在共享堆里。</li>
</ul>
<p>共享堆很重要，因为它减少了进程间传递大二进制消息的IO开销。另外子二进制数据只是某个二进制数据的指针，所以它的创建是如此快速。但是按一般规律来说，为了更快而使用快捷方式是有代价的，代价就是要以某种方式好好设计你的系统不至于让你陷入到麻烦当中。另外针对引用计数二进制数据泄漏问题有一些著名的架构模式，这些在<a href="http://ferd.ca/" target="_blank" rel="external">Fred Hebert</a>的免费电子书 <a href="http://www.erlang-in-anger.com/" target="_blank" rel="external">Erlang in Anger</a> 里有详细的解释，我想我是没办法解释的比他更好。所以我强烈建议你读一下这本书。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>即使我们现在正在使用的语言，它像Erlang这样自己管理内存，但是也不能阻止我们去理解它是如何分配和回收内存的。不像<a href="https://golang.org/ref/mem" target="_blank" rel="external">Go语言内存模型文档</a>所建议的：“如果你必须读本文档剩下部分来理解你自己程序的行为，你就是太聪明了。不过别自作聪明。”，我相信我们必须足够聪明才能够使我们的系统更快更安全，有时候它不会发生除非我们更深地钻研挖进去理解它的本质。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/faq/academic.html" target="_blank" rel="external">Erlang的学时和历史疑问</a></li>
<li><a href="http://lampwww.epfl.ch/resources/lamp/teaching/advancedCompiler/2004/slides/ImplementationOfConcurrency_slides.pdf" target="_blank" rel="external">FPL和并发执行</a></li>
<li><a href="http://user.it.uu.se/~jesperw/publications/Wilhelmsson_lic.pdf" target="_blank" rel="external">消息传递并发的有效内存管理</a></li>
<li><a href="http://labouseur.com/courses/erlang/programming-parallel-with-erlang.pdf" target="_blank" rel="external">用Erlang编程并行世界</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang调度器的细节以及它为何重要]]></title>
      <url>http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/</url>
      <content type="html"><![CDATA[<p>有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">Erlang垃圾回收细节以及它为何重要</a>》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。</p>
<a id="more"></a>
<h1 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度"></a>什么是调度</h1><p>通常来说，调度就是一种分派工作给工作者的机制。所谓的工作可能是一个算数运算、字符串处理或者数据抽取，而工作者是一些资源，比如像<a href="https://en.wikipedia.org/wiki/Green_threads" target="_blank" rel="external">Green Thread</a>这样虚拟的资源或者像<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Native Thread</a>这样的物理资源。调度器以一种方式执行调度活度，最大限度地提高吞吐量和公平性，最大限度地降低响应时间和延时。调度是像操作系统和虚拟机这样的多任务系统的重要组成部分，它被分为两种类型：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29" target="_blank" rel="external">抢占式</a>：一个抢占式调度器在执行的任务间进行上下文切换，它有权力抢占（中断）任务并且在不需要被抢占任务的配合下的稍后恢复执行它们。实现这样的功能是基于如下几个因素，比如：任务的优先级，时间切片或者规约数。</li>
<li><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="external">协作式</a>：一个协作式调度器需要任务协作来进行上下文切换。在这种方式下，调度器简单地让任务周期性地或者空闲地时候自愿地释放控制权，然后启动一个新的任务并且再一次等待它自愿地归还控制权。</li>
</ul>
<p>现在的问题是，哪一种调度机制适合软实时系统，也就是这个系统必须在指定的时间内响应。协作式调度系统不能满足软实时系统的要求，因为其运行的任务可能永远也不会返还控制权或者在规定时限后返还控制权。所以软实时系统通常采用抢占式调度。</p>
<h1 id="Erlang的调度"><a href="#Erlang的调度" class="headerlink" title="Erlang的调度"></a>Erlang的调度</h1><p>Erlang作为一个多任务软实时平台采用的就是抢占式调度。Erlang调度器的职责就是选择一个进程并执行它的代码。它也处理垃圾回收和内存管理。如何选择一个进程来执行是基于每个进程可配置的优先级，并且同一优先级的进程是轮询地被调度的。另外，执行中的进程被抢占的因素是基于自上次该进程被选中执行后一定数量的<strong>规约数</strong>而不管它的优先级如何。规约数是每个进程的一个计数器，一般每调用一次函数，它就加一。当一个进程的计数器达到最大规约数时，就会抢占进程和进行上下文切换。例如，在Erlang/OTP R12B 计数器的最大值是2000规约数。</p>
<p>Erlang的任务调度有很长的发展历史。它随着时间而改变。这些改变受Erlang的SMP（对称多处理器）特性的改变而被影响。</p>
<h2 id="R11B之前的调度"><a href="#R11B之前的调度" class="headerlink" title="R11B之前的调度"></a>R11B之前的调度</h2><p>在R11B之前，Eralng还不支持SMP，因此它只有一个调度器运行在操作系统主进程的线程里，并且相应的只有一个<strong>运行队列</strong>。调度器从运行队列选择可运行的Erlang进程和IO任务来执行。</p>
<p><img src="/images/scheduling-before-r11b.png" style="border:0;"></p>
<p>这种方式不需要锁数据结构，但是这么写的应用无法利用并行的好处。</p>
<h2 id="R11B和R12B的调度"><a href="#R11B和R12B的调度" class="headerlink" title="R11B和R12B的调度"></a>R11B和R12B的调度</h2><p>SMP支持被加入Erlang虚拟机里，所以它可以有1到1024个运行在操作系统进程的线程里的调度器。然而，这个版本的调度器只能从一个共用运行队列里选取可执行任务。</p>
<p><img src="/images/scheduling-in-r11b-and-r12b.png" style="border:0;"></p>
<p>由于这种方式造成并行，使得所有共享数据结构都要用锁保护起来。例如运行队列本身就是一个必须被保护起来的共享数据结构。虽热锁会造成一些性能损失，但是新的调度器在多核处理器上带来的性能提升还是很可观的。</p>
<p>在这个版本里的一些瓶颈如下：</p>
<ul>
<li>当调度器增加后，共用运行队列成为瓶颈。</li>
<li>增加ETS表相关的锁，同时也影响到Mnesia。</li>
<li>当许多进程同时给一个进程发送消息的时候增加锁的冲突。</li>
<li>一个进程等待获取一个锁的时候会阻塞它的调度器。</li>
</ul>
<p>然而，每一个调度器分配一个运行队列的方案在下一个版本被选择来解决这些瓶颈。</p>
<h2 id="R13B后的调度"><a href="#R13B后的调度" class="headerlink" title="R13B后的调度"></a>R13B后的调度</h2><p>在这个版本，每个调度器有它自己的运行队列。在多核多调度器的系统里，这将减少锁冲突数量并且提升系统整体性能。</p>
<p><img src="/images/scheduling-after-r13b.png" style="border:0;"></p>
<p>这种方式在访问运行队列时锁冲突解决了，不过却引入了一些新问题：</p>
<ul>
<li>如何在运行队列中分配任务做到公平？</li>
<li>如果一个调度器被分配了过多的任务而另外的调度器却很清闲，这个问题如何解决？</li>
<li>基于什么样的命令一个调度器可以从一个过载的调度器偷任务？</li>
<li>要是我们启动了很多调度器，但是却很少任务，如何处理？</li>
</ul>
<p>这些问题使得Erlang开发团队引入一个概念使得调度公平和高效，这个概念就是<strong>迁移逻辑</strong>。它尝试在基于从系统收集来的统计数据上控制和平衡运行队列。</p>
<p>然而我们不应该让我们的调度一直维持现状，因为它很可能在将来的版本变得更好。</p>
<h1 id="控制和监督API"><a href="#控制和监督API" class="headerlink" title="控制和监督API"></a>控制和监督API</h1><p>有一些Erlang模拟器启动标志和一些内部控制和监督函数与调度器行为有关。</p>
<h2 id="调度线程"><a href="#调度线程" class="headerlink" title="调度线程"></a>调度线程</h2><p>当用erl启动脚本启动Erlang模拟器的时候，可以通过给+S标志传递两个用冒号分割的数字来指定最大可用调度线程数和在线调度线程数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S MaxAvailableSchedulers:OnlineSchedulers</div></pre></td></tr></table></figure>
<p>最大可用调度线程数只能在启动的时候指定而且在运行时是固定不变的，但是在线调度线程数可以在启动和运行时被指定和修改。例如我们可以在启动一个模拟器的时候指定16个最大调度线程和8个在线调度线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S 16:8</div></pre></td></tr></table></figure>
<p>然后在shell里在线调度线程可以被修改，如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; erlang:system_info(schedulers). <span class="comment">%% =&gt; returns 16</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_flag(schedulers_online, <span class="number">16</span>). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 16</span></div></pre></td></tr></table></figure>
<p>另外，使用+SP标志可以用百分比的方式设置这两个值。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>如前所述调度器基于进程的优先级来选择它们来执行。优先级可以在进程内通过调用erlang:process_flag/2函数来设置。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PID = spawn(<span class="keyword">fun</span>() -&gt;</div><div class="line">   <span class="comment">%% ...</span></div><div class="line">   <span class="keyword">end</span>).</div></pre></td></tr></table></figure>
<p>优先级可以是 low、normal、high、max 这些原子中的任何一个。默认优先级是normal，max优先级是保留给Erlang运行时内部使用不应被一般进程使用。</p>
<h2 id="运行队列统计"><a href="#运行队列统计" class="headerlink" title="运行队列统计"></a>运行队列统计</h2><p>如前所述运行队列持有准备好执行但未被调度器选中执行的进程。可以通过调用erlang:statistics(run_queue)获取在所有可用运行队列已经准备好可运行的进程数。作为一个真实例子，让我启动Erlang模拟器，给它4个在线调度器，并且给它们10个非常消耗CPU的并发进程。这些进程<a href="https://gist.github.com/hamidreza-s/9e3ed289f65759048875" target="_blank" rel="external">计算一个很大数字的素数</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%% 就绪</span></div><div class="line">&gt; erlang:statistics(online_schedulers). <span class="comment">%% =&gt; 4</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div><div class="line"></div><div class="line"><span class="comment">%% 并发创建10个重型进程</span></div><div class="line">&gt; [spawn(<span class="keyword">fun</span>() -&gt; calc:prime_numbers(<span class="number">10000000</span>) <span class="keyword">end</span>) || _ &lt;- lists:seq(<span class="number">1</span>, <span class="number">10</span>)].</div><div class="line"></div><div class="line"><span class="comment">%% 运行队列中还有任务要做</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 8</span></div><div class="line"></div><div class="line"><span class="comment">%% Erlang shell依然可以响应，非常棒！</span></div><div class="line">&gt; calc:prime_numbers(<span class="number">10</span>). <span class="comment">%% =&gt; [2, 3, 5, 7]</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 4</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div></pre></td></tr></table></figure>
<p>因为并发进程数大于在线调度器，这将花些时间让调度器执行运行队列里的进程并最终清空运行队列。有趣的是，创建了这些重型进程后，Erlang模拟器任然因为它的抢占式调度可以响应其他请求。Erlang的抢占式调度不会让这些重型进程消耗掉所有运行时，其他轻量并且重要的进程也可以被执行，这个特性在实现一个软实时系统的时候是非常棒的。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>虽然实现一个抢占式调度系统可能很复杂，但是在Erlang里这些不是开发者的责任，因为抢占式调度特性已经在Erlang虚拟机里。另一方面，当在一个软实时系统里系统以高水平的公平性和即时的响应需要扩展到所有处理资源的时候，跟踪、平衡、执行、迁移和抢占进程这些额外的处理成本是完全可负担的。顺便值得一提的是，完全抢占式调度是几乎所有操作系统都支持的特性，但在高层次的平台，语言或库里，Erlang虚拟机几乎是唯一完全抢占式调度的，因为JVM依赖于操作系统的调度器，CAF这个C++ actor库用协作式调度，Go也不是完全抢占式调度，还有诸如Python的Twisted，Ruby的Event Machine和Nodejs也不是完全抢占式调度的。这并不意味着对于所有的挑战这都是最好的选择，而是说我们如果要实现一个低延时的软实时系统，Erlang是一个好的选择。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/doc/man/erl.html" target="_blank" rel="external">erl脚本官方文档</a></li>
<li><a href="http://erlang.org/doc/man/erlang.html" target="_blank" rel="external">erlang模块官方文档</a></li>
<li><a href="http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html" target="_blank" rel="external">Erlang如何调度</a></li>
<li><a href="http://www.erlang.org/euc/08/euc_smp.pdf" target="_blank" rel="external">深入Erlang虚拟机</a></li>
<li><a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html" target="_blank" rel="external">Erlang调度器：它是如何工作的</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Rebar3热更新Erlang代码]]></title>
      <url>http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/</url>
      <content type="html"><![CDATA[<p>在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：</p>
<blockquote>
<p>代码热更新就是一门给正在飞奔的汽车换引擎的艺术。</p>
</blockquote>
<p>简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。</p>
<a id="more"></a>
<p>我们将创建一个样例项目，然后学习如何来做代码热更新。这个项目的代码我已经放在<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">这里</a>。让我们用rebar3来创建一个模版项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new release nine9s</div></pre></td></tr></table></figure>
<p>现在我们在我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config" target="_blank" rel="external">rebar.config</a>文件里增加cowboy和lager为依赖。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [</div><div class="line">	&#123;lager, &#123;git, <span class="string">"git://github.com/basho/lager.git"</span>, &#123;tag, <span class="string">"2.1.1"</span>&#125;&#125;&#125;,</div><div class="line">	&#123;cowboy, &#123;git, <span class="string">"https://github.com/ninenines/cowboy.git"</span>, &#123;tag, <span class="string">"2.0.0-pre.1"</span>&#125;&#125;&#125;</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>为了更加真实的体验，请按如下修改我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config#L14-L15" target="_blank" rel="external">rebar.config</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;relx, [</div><div class="line">		&#123;release, &#123;'nine9s', <span class="string">"0.1.0"</span>&#125;, ['nine9s', sasl]&#125;,</div><div class="line">		&#123;sys_config, <span class="string">"./config/sys.config"</span>&#125;,</div><div class="line">		&#123;vm_args, <span class="string">"./config/vm.args"</span>&#125;,</div><div class="line">		&#123;dev_mode, false&#125;,</div><div class="line">		&#123;include_erts, true&#125;,</div><div class="line">		&#123;extended_start_script, true&#125;</div><div class="line">	]</div><div class="line">&#125;.</div></pre></td></tr></table></figure>
<p>你可能想知道这个“nine9s”应用将会做些什么？我的想法是先让这个应用做成一个hello world的web服务，然后再热更新它的代码。修改你的nine9s_app.erl文件以便让start/2看起来像下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line"> Dispatch = cowboy_router:compile(</div><div class="line">                                  [&#123;‘_’, [</div><div class="line">                                          &#123;“/”, default_handler, []&#125;</div><div class="line">                                         ]&#125;</div><div class="line">                                  ]),</div><div class="line"> &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line"> [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line"> ‘nine9s_sup’:start_link().</div></pre></td></tr></table></figure>
<p>现在我们创建一个模块，它叫做default_handler.erl。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-module(default_handler).</div><div class="line">-export([init/2]).</div><div class="line">init(Req, Opts) -&gt;</div><div class="line">    Req2 = cowboy_req:reply(200, [ &#123;&lt;&lt;”content-type"&gt;&gt;,</div><div class="line">                                    &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                            &lt;&lt;”Hello world!”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>接下来，我们编译并运行这个应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile &amp;&amp; rebar3 release</div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 console</div></pre></td></tr></table></figure>
<p>现在你已经运行了你的应用，你可以浏览<a href="http://localhost:9090" target="_blank" rel="external">http://localhost:9090</a>来验证一下。请保持这个应用一直运行，因为我们将创建这个应用的一个新版本并且尝试在线进行代码热更新。</p>
<p>上述代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0分支</a>里。</p>
<p>我们开始添加一些新的特性到我们的项目里，这样将形成我们项目的0.2.0版本，然后我们将尝试在运行着的0.1.0版本上在线进行代码热更新。版本0.2.0的代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0分支</a>。</p>
<p>我们想统计我们的default_handler已经响应的请求数。这个很好解决，我们创建一个模块<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/state_handler.erl" target="_blank" rel="external">state_handler.erl</a>，它是一个gen_server，它将存储default_handler.erl被调用的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(state_handler)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"><span class="comment">%% API functions</span></div><div class="line"><span class="keyword">-export</span><span class="params">([hello_world/<span class="number">0</span>,</span></div><div class="line">         get_hello_world_count/<span class="number">0</span>,</div><div class="line">         start_link/<span class="number">0</span>]).</div><div class="line"><span class="comment">%% gen_server callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>,</span></div><div class="line">         handle_call/<span class="number">3</span>,</div><div class="line">         handle_cast/<span class="number">2</span>,</div><div class="line">         handle_info/<span class="number">2</span>,</div><div class="line">         terminate/<span class="number">2</span>,</div><div class="line">         code_change/<span class="number">3</span>]).</div><div class="line"><span class="keyword">-record</span><span class="params">(state, &#123;count = <span class="number">0</span>&#125;)</span>.</div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="comment">%%% API functions</span></div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="function"><span class="title">hello_world</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:cast(?MODULE, hello_world).</div><div class="line"><span class="function"><span class="title">get_hello_world_count</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:call(?MODULE, hello_world_count).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:start_link(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="comment">%%% callback functions</span></div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    &#123;ok, #state&#123;&#125;&#125;.</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(hello_world_count, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, State#state.count, State&#125;;</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    Reply = ok,</div><div class="line">    &#123;reply, Reply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(hello_world, State)</span> -&gt;</span></div><div class="line">    Count = State#state.count,</div><div class="line">    &#123;noreply, State#state&#123;count = Count + <span class="number">1</span>&#125;&#125;;</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>我们修改我们的<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/default_handler.erl" target="_blank" rel="external">default_handler.erl</a>，以便每次它接收到请求的时候就通知state_handler。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(default_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    state_handler:hello_world(),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         &lt;&lt;”Hello world <span class="number">2</span> !”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>我们的state_handler将是<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_sup.erl" target="_blank" rel="external">nine9s_sup</a>监督者下的一个工作进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_sup’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(CHILD(Id, Mod, Args, Restart, Type)</span>, &#123;Id, &#123;Mod, start_link, Args&#125;, Restart, 60000, Type, [Mod]&#125;).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?SERVER&#125;, ?MODULE, []).</div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    State_Handler = ?CHILD(state_handler, state_handler, [], transient, worker),</div><div class="line">    &#123;ok, &#123; &#123;one_for_all, <span class="number">0</span>, <span class="number">1</span>&#125;, [State_Handler]&#125; &#125;.</div></pre></td></tr></table></figure>
<p>既然我们已经记录了default_handler的访问次数，我们就想有一个cowboy的路由来给出当前的访问次数，所以我们修改<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_app.erl" target="_blank" rel="external">nine9s_sup.erl</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_app’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(application)</span>.</div><div class="line"><span class="comment">%% Application callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">2</span></span></div><div class="line">         ,stop/<span class="number">1</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([set_routes_new/<span class="number">0</span></span></div><div class="line">        ,set_routes_old/<span class="number">0</span> ]).</div><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line">    Dispatch = cowboy_router:compile([&#123;‘_’, get_new_routes()&#125;]),</div><div class="line">    &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line">    [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line">    ‘nine9s_sup’:start_link().</div><div class="line"><span class="function"><span class="title">stop</span><span class="params">(_State)</span> -&gt;</span> ok.</div><div class="line"><span class="function"><span class="title">get_new_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/count”, count_handler, []&#125;] ++ get_old_routes().</div><div class="line"><span class="function"><span class="title">get_old_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/”, default_handler, []&#125;].</div><div class="line"><span class="function"><span class="title">set_routes_new</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_new_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div><div class="line"><span class="function"><span class="title">set_routes_old</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_old_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div></pre></td></tr></table></figure>
<p>请注意，我们把路由分成两部分，一部分是版本0.1.0里就有的，也就是老路由，还有一部分就是新路由。函数set_routes_new/0和set_routes_old/0我们将在后面解释。</p>
<p>下述代码是count_handler模块，就是处理路由 “/count”的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(count_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    Count = state_handler:get_hello_world_count(),</div><div class="line">    BCount = integer_to_binary(Count),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         BCount, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>最后，我们将修改在<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s.app.src#L3" target="_blank" rel="external">nine9s.app.src</a>和<a href="https://github.com/kansi/nine9s/blob/0.2.0/rebar.config#L7" target="_blank" rel="external">rebar.config</a>里的版本数字。版本0.2.0的特性就完成了。现在我们将尝试将正在运行的0.1.0版本升级到版本0.2.0。</p>
<p>为了升级到新的版本，我们需要创建一个appup文件，也就是nine9s.app.src文件，它描述了如何从版本0.1.0升级到0.2.0。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"vsn in app.src"</span>,</div><div class="line">    [ &#123;<span class="string">"upgrade from vsn"</span>, Instructions1&#125;],</div><div class="line">    [ &#123;<span class="string">"downgrade to vsn"</span>, Instructions2&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>appup文件是一个三元素组成的元组文件。第一个元素是和.app.src文件里一样的版本号（也就是当前版本）。第二个元素是一个元组列表，它的第一个元素是将要被升级的版本号，它的第二个元素是一些指令组成的列表，这些指令指示该如何从这个版本升级到新的版本。第三个元素也是一个元组列表，它的第一个元素是将要降级到的版本号，它的第二个元素是也是一些指令组成的列表，这些指令指示该如何降级到这个版本。</p>
<p>下面是应用nine9s的appup文件内容：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;“<span class="number">0.2</span>.<span class="number">0</span>”,</div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;add_module, state_handler&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, restart_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;add_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_new, [] &#125;&#125; ] &#125;],</div><div class="line"></div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, terminate_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, delete_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;delete_module, state_handler&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_old, [] &#125;&#125;</div><div class="line">             ,&#123;delete_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ]</div><div class="line">&#125;]&#125;.</div></pre></td></tr></table></figure></p>
<p>现在我们先来解释一下升级指令。注意：这些指令是按它们在文件中的先后顺序来执行的。</p>
<ul>
<li>{add_module, state_handler} : 指示增加state_handler模块到运行环境里。</li>
<li>{update, nine9s, supervisor} : 这条指令将修改监督者的内部状态，也就是改变重启策略和最大重启频率，同时也改变子进程规格说明。最终将增加state_handler这个模块到监督者的子进程规格说明里。</li>
<li>{apply, {supervisor, restart_child, [nine9s, state_handler]}} : “apply”指令接收{M,F,A}做为参数，然后执行 M:F(A1, … An)。所以我们实际上是执行supervisor:restart_child(nine9s, state_handler)，这将在nine9s_sup监督者下启动state_handler做为工作进程。请注意：上述三条指令的顺序。首先我们增加state_handler模块，然后改变监督者的状态，最后创建state_handler进程。</li>
<li>{load_module, default_handler} : 这条指令将重新装载default_handler模块，替换它的老版本代码。</li>
<li>{add_module, count_handler} : 增加count_handler模块。</li>
<li>{load_module, nine9s_app} : 我们重新装载nine9s_app，从而我们新增加的函数被装载进虚拟机。</li>
<li>{apply, {nine9s_app, set_routes_new, [ ] }} ] } ] : 既然我们装载了新的函数，我就执行 nine9s_app:set_routes_new() 增加新的路由到我们的服务器。</li>
</ul>
<p>接下来的元素是如何降级的指令，它的工作模式和前一个元素相似，但是是用老模块替换新模块。</p>
<ul>
<li>{load_module, default_handler} : 这个指令将装载老的default_handler模块。</li>
<li>{apply, {supervisor, terminate_child, [nine9s_sup, state_handler]}} : 终止state_handler进程。</li>
<li>{apply, {supervisor, delete_child, [nine9s_sup, state_handler]}} : 从nine9s_sup里删除state_handler这个子进程规格。</li>
<li>{update, nine9s_sup, supervisor} : 修改监督者nine9s_sup的内部状态。</li>
<li>{delete_module, state_handler} : 删除state_handler模块。</li>
<li>{apply, {nine9s_app, set_routes_old, [ ] }} : 设置路由为老版本路由。</li>
<li>{delete_module, count_handler} : 删除count_handler模块。</li>
<li>{load_module, nine9s_app} : 装载老的nine9s_app模块。</li>
</ul>
<p>既然我们的appup文件准备好了，我们就开始升级到最新的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先我们拷贝appup文件到lib目录下nine9s/ebin下</span></div><div class="line">$ cp apps/nine9s/src/nine9s.appup.src _build/default/lib/nine9s/ebin/nine9s.appup</div><div class="line"><span class="comment"># 接着我们编译和发布应用</span></div><div class="line">$ rebar3 compile</div><div class="line">$ rebar3 release</div><div class="line"><span class="comment"># 生成relup到前一个版本</span></div><div class="line">$ rebar3 relup -n nine9s -v <span class="string">"0.2.0"</span> -u <span class="string">"0.1.0"</span></div><div class="line"><span class="comment"># 生成新版本的tar文件</span></div><div class="line">$ rebar3 tar -n nine9s -v <span class="string">"0.2.0"</span></div><div class="line">$ mv _build/default/rel/nine9s/nine9s-0.2.0.tar.gz _build/default/rel/nine9s/releases/0.2.0/nine9s.tar.gz</div><div class="line"><span class="comment"># 升级到新的版本</span></div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 upgrade <span class="string">"0.2.0"</span></div></pre></td></tr></table></figure>
<p>搞定！如果所有执行都成功，那么我们就升级到0.2.0版本了。你可以浏览 <a href="http://localhost:9090和http://localhost:9090/count来验证一下。" target="_blank" rel="external">http://localhost:9090和http://localhost:9090/count来验证一下。</a></p>
<p>项目有两个分支<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0</a>和<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0</a>。你可以先编译和运行分支0.1.0，然后切换到0.2.0分支，使用python脚本<a href="https://github.com/kansi/nine9s/blob/0.2.0/upgrade.py" target="_blank" rel="external">upgrade.py</a>来升级到0.2.0版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4" target="_blank" rel="external">https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rebar3 shell]]></title>
      <url>http://szpzs.oschina.io/2016/12/07/rebar3-shell/</url>
      <content type="html"><![CDATA[<p>这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。</p>
<a id="more"></a>
<p>它有很多好的特性，不过在我的观点来看，这些是一个Erlang shell工具最少要支持的。因此，尝试展示这些特性听起来好像是吹嘘你该做的本分事情一样；多说无益，下面就进入正题。</p>
<p>不过，一些Erlang的东西的可用性一直很糟糕，我们（贡献者）已经在rebar3上做了很多工作来尝试解决这些糟糕的体验。我不得不说，很多社区已经有大量的非常好的工具，但是它们都是独立的，如何用好它们必须要读者自己去逐个尝试。这个时候，rebar3横空出世了。</p>
<p>当使用rebar3 shell命令的时候首先吸引人的是，它会自动编译项目（如果项目还没有被编译）并且将编译后的项目加入你的代码搜索路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; vegur:module_info().</div><div class="line">[&#123;module,vegur&#125;,</div><div class="line">&#123;exports,[&#123;start_http,3&#125;,</div><div class="line">&#123;start_proxy,3&#125;,</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个功能作用于所有项目。这至少摆脱很多需要你自己手写默认设置的许多烦恼。现在这些都由rebar3 shell来做。</p>
<p>对于一个编程语言来说，一个好的shell环境就是关于它的互动性。期望能够快速地重编译代码或者运行测试，并且重新装载代码而不需要任何中断或丢失状态。rebar3 shell有一个代理，隐藏在r3模块背后，它准备着所有需要重新编译代码或者运行任务的状态的管理。所以，例如任何存在的项目，我可以要求重新编译或者任何其他任务运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; r3:do(compile).</div><div class="line">===&gt; This feature is experimental <span class="keyword">and</span> may be modified or removed at any time.</div><div class="line">Verifying dependencies...</div><div class="line">Compiling vegur</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(ct).</div><div class="line">Verifying dependencies...</div><div class="line">Fetching websocket_client (&#123;git,<span class="string">"git@github.com:jeremyong/websocket_client.git"</span>,</div><div class="line">&#123;tag,<span class="string">"v0.7"</span>&#125;&#125;)</div><div class="line">Linking _build/default/lib/cowboyku to _build/test/lib/cowboyku</div><div class="line">Linking _build/default/lib/cowlib to _build/test/lib/cowlib</div><div class="line">Linking _build/default/lib/erequest_id to _build/test/lib/erequest_id</div><div class="line">...</div><div class="line">Running Common Test suites...</div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_callback: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_timeout: OK</span></div><div class="line">...</div><div class="line">All <span class="number">140</span> tests passed.</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(dialyzer).</div><div class="line">Verifying dependencies...</div><div class="line">...</div><div class="line">Analyzing <span class="number">19</span> files with <span class="string">"/home/ferd/code/self/vegur/_build/default/rebar3_18.1.5_plt"</span>...</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>如上述例子等等。所有这些任务都会用你的最新版本的rebar.config文件来运行它的任务和切换路径重装载模块等等。</p>
<p>rebar3的代理还有一个名字使得可以在外部调用它。你可以用一个名字来启动一个shell（rebar3 shell –name my_shell 或 rebar3 shell –sname my_shell）然后远程向它发送消息或者直接RPC调用当作指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --sname=my_shell</div><div class="line">erl -sname remote -eval <span class="string">'rpc:call(my_shell@localhost, r3, do, [ct]), halt(0).'</span> -noshell</div></pre></td></tr></table></figure>
<p>当作人们的工具的目的应该是可以被用来从你的IDE或编辑器里增加钩子到Erlang shell里。</p>
<p>被写出来的和rebar3代理一起工作的插件也是一种选择。例如，通过监控硬盘，<a href="https://www.rebar3.org/docs/using-available-plugins#auto-compile-and-load" target="_blank" rel="external">rebar3_atuo 能够被用来自动重新编译修改过的文件</a>，这样也省了这个的功能要和IDE或编辑器合成的需求。</p>
<p>这提供了一个非常好的改进，例如，在运行调试周期，在测试，代码分析和交互式调试都可以在同一个环境进行。</p>
<p>为了使得开发周期更加与你的项目成长无缝对接，rebar3 shell将在构建工具里自动侦测<a href="https://www.rebar3.org/docs/releases" target="_blank" rel="external">release配置</a>，并且以你的release遵循的的<a href="https://www.rebar3.org/docs/releases#section-application-configuration" target="_blank" rel="external">应用配置</a>【1】启动你的系统。</p>
<p>这意味着只要你的代码库配置成装配为一个可执行版本，你可以在它里面访问shell的代码重装载特性，使用的是同样的工具，而这些工具你可能以别的方式使用。</p>
<p>如果你不使用release呢？应用可以在你的rebar.config文件里被指定为{shell, [{apps, [myapp]}]}  或者在命令行里的参数里指定（–apps app1,app2）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --apps vegur</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">...</div><div class="line">===&gt; Booted midjan</div><div class="line">===&gt; Booted quickrand</div><div class="line">===&gt; Booted uuid</div><div class="line">===&gt; Booted erequest_id</div><div class="line">===&gt; Booted vegur</div></pre></td></tr></table></figure>
<p>万一你的开发环境和生产环境不匹配，任意的代码可以被运行来设置shell并且通过escript来设置它。这些设置指定的动态环境变量或启动外部依赖的模拟模块是特别有用的。为了进一步解释，下面的例子将展示我们如何不让shell启动，除非所有需要设置的环境变量都设置好了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env escript</div><div class="line"></div><div class="line"><span class="function"><span class="title">main</span><span class="params">(_)</span> -&gt;</span></div><div class="line">	OSVars = [<span class="string">"USER"</span>, <span class="string">"PASS"</span>],</div><div class="line">	[check_is_set(Var) || Var &lt;- OSVars].</div><div class="line"></div><div class="line"><span class="function"><span class="title">check_is_set</span><span class="params">(Var)</span> -&gt;</span></div><div class="line">	<span class="keyword">case</span> os:getenv(Var) <span class="keyword">of</span></div><div class="line">		<span class="literal">false</span> -&gt;</div><div class="line">			rebar_api:error(<span class="string">"Missing var ~s"</span>, [Var]),</div><div class="line">			halt(<span class="number">1</span>);</div><div class="line">		_ -&gt;</div><div class="line">			ok</div><div class="line">	<span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个escript文件可以通过增加{shell, [{script_file, “path/to/file”}]}到你的rebar.config文件配置成总是执行，或者通过在命令行被直接调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --script_file <span class="built_in">test</span>/check_env.escript</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; ===&gt; Missing var PASS</div></pre></td></tr></table></figure>
<p>希望这些工具比那些开箱即用的更可以让Erlang开发者的生活轻松些。</p>
<p>【1】这里有些警告：因为rebar3 shell是一个开发工具，诸如Erlang虚拟机配置的选项（例如，调度器的数量）已经在运行时里有了而且不能被修改。它不能复制所有release的配置，因此，你应该在生产环境保持使用release。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">http://ferd.ca/rebar3-shell.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Rebar3构建你的第一个Erlang应用]]></title>
      <url>http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/</url>
      <content type="html"><![CDATA[<p>Rebar3是Erlang的构建工具和包管理工具。归功于<a href="http://www.rebar3.org/" target="_blank" rel="external">Rebar3</a>以及它的插件<a href="https://hex.pm/" target="_blank" rel="external">Hex</a>，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。</p>
<a id="more"></a>
<h1 id="下载Rebar3"><a href="#下载Rebar3" class="headerlink" title="下载Rebar3"></a>下载Rebar3</h1><p>从Rebar3官方网站下载最新版本的Rebar3，网址：<a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -O https://s3.amazonaws.com/rebar3/rebar3</div></pre></td></tr></table></figure>
<p>用chmod赋予其可执行权限，并将它加入你的环境变量PATH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x rebar3</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:rebar3所在目录</div></pre></td></tr></table></figure>
<h1 id="你的第一个Erlang应用"><a href="#你的第一个Erlang应用" class="headerlink" title="你的第一个Erlang应用"></a>你的第一个Erlang应用</h1><p>使用rebar3 new命令采用内建模块app可以创建一个新的项目。在本例子里我们创建一个叫做myapp的项目。其他可用内建模版是：release、lib、plugin、escript、cmake。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new app myapp</div><div class="line">===&gt; Writing myapp/src/myapp_app.erl</div><div class="line">===&gt; Writing myapp/src/myapp_sup.erl</div><div class="line">===&gt; Writing myapp/src/myapp.app.src</div><div class="line">===&gt; Writing myapp/rebar.config</div><div class="line">===&gt; Writing myapp/.gitignore</div><div class="line">===&gt; Writing myapp/LICENSE</div><div class="line">===&gt; Writing myapp/README.md</div></pre></td></tr></table></figure>
<p>代码在src目录里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> myapp</div><div class="line">$ tree</div><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── rebar.config</div><div class="line">└── src</div><div class="line">    ├── myapp.app.src</div><div class="line">    ├── myapp_app.erl</div><div class="line">    └── myapp_sup.erl</div></pre></td></tr></table></figure>
<p>因为Rebar3只处理 <a href="http://www.erlang.org/doc/design_principles/applications.html" target="_blank" rel="external">OTP结构的项目</a> ，所以约定成俗用一个 .app.src 文件定义你的应用是一个OTP应用。看起来是不是很熟悉？这个文件也是Erlang文件。你可以阅读 <a href="http://www.erlang.org/doc/design_principles/applications.html#id73836" target="_blank" rel="external">详细的指引</a> 来看看它都能包括些什么元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp.app.src</div><div class="line">&#123;application, <span class="string">'myapp'</span>,</div><div class="line"> [&#123;description, <span class="string">"An OTP application"</span>&#125;,</div><div class="line">  &#123;vsn, <span class="string">"0.1.0"</span>&#125;,</div><div class="line">  &#123;registered, []&#125;,</div><div class="line">  &#123;mod, &#123;<span class="string">'myapp_app'</span>, []&#125;&#125;,</div><div class="line">  &#123;applications,</div><div class="line">   [kernel,</div><div class="line">    stdlib</div><div class="line">   ]&#125;,</div><div class="line">  &#123;env,[]&#125;,</div><div class="line">  &#123;modules, []&#125;</div><div class="line"> ]&#125;.</div></pre></td></tr></table></figure>
<p>src/myapp_app.erl是一个非常简单的代码框架。它只是让你可以启动和停止你的Erlang应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp_app.erl</div><div class="line">-module(<span class="string">'myapp_app'</span>).</div><div class="line">-behaviour(application).</div><div class="line">-export([start/2, stop/1]).</div><div class="line">start(_StartType, _StartArgs) -&gt;</div><div class="line">    <span class="string">'myapp_sup'</span>:start_link().</div><div class="line">stop(_State) -&gt;</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>Rebar3用rebar.config来指定一些额外的元数据，比如<a href="https://github.com/rebar/rebar/wiki/Dependency-management" target="_blank" rel="external">依赖</a>。rebar.config还可以包含很多配置项。你可以参考 <a href="https://github.com/rebar/rebar/blob/master/rebar.config.sample" target="_blank" rel="external">详细例子</a> 来学习各种配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat rebar.config</div><div class="line">&#123;erl_opts, [debug_info]&#125;.</div><div class="line">&#123;deps, []&#125;.</div></pre></td></tr></table></figure>
<p>现在我们用Rebar3启动一个Erlang shell，它包含了你的应用及依赖的路径。然后运行 application:start(myapp). 来确认你的应用被正确地装载了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling myapp</div><div class="line">Erlang R16B03-1 (erts-5.10.4) [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line">Eshell V5.10.4  (abort with ^G)</div><div class="line">1&gt; application:start(myapp).</div><div class="line">ok</div><div class="line">2&gt; application:stop(myapp).</div><div class="line">ok</div><div class="line">3&gt;</div><div class="line">=INFO REPORT==== 29-Jun-2015::16:14:10 ===</div><div class="line">    application: myapp</div><div class="line">    exited: stopped</div><div class="line">    <span class="built_in">type</span>: temporary</div></pre></td></tr></table></figure>
<p><a href="https://github.com/ferd" target="_blank" rel="external">Fred Hebert</a> （<a href="http://learnyousomeerlang.com/" target="_blank" rel="external">Learn You Some Erlang</a> 的作者）写了一篇很好的<a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">文章</a>介绍rebar3 shell的命令。</p>
<h1 id="Erlang的包"><a href="#Erlang的包" class="headerlink" title="Erlang的包"></a>Erlang的包</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要安装一个叫做<a href="https://github.com/hexpm/rebar3_hex" target="_blank" rel="external">rebar3_hex</a>的插件来从<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>（Erlang和Elixir的包管理者）获取和安装Erlang包。简单地把如下一行加入到rebar.config文件中（你需要Erlang/OTP17.4或以上版本）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;plugins, [rebar3_hex]&#125;.</div></pre></td></tr></table></figure>
<p>然后运行命令：rebar3 update 来启用这个插件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rebar3 update</div><div class="line">===&gt; Fetching jsx (&#123;pkg,&lt;&lt;<span class="string">"jsx"</span>&gt;&gt;,&lt;&lt;<span class="string">"2.6.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching ssl_verify_hostname (&#123;pkg,&lt;&lt;<span class="string">"ssl_verify_hostname"</span>&gt;&gt;,</div><div class="line">                                           &lt;&lt;<span class="string">"1.0.5"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching rebar3_hex (&#123;pkg,&lt;&lt;<span class="string">"rebar3_hex"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.6.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling ssl_verify_hostname</div><div class="line">===&gt; Compiling jsx</div><div class="line">===&gt; Compiling rebar3_hex</div><div class="line">===&gt; Updating package index…</div></pre></td></tr></table></figure>
<p>如果你想避免每次创建一个新Erlang应用都要做这个步骤，则将上述配置添加到全局的配置文件rebar.config中，并把这个配置文件放置在如下目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.config/rebar3/rebar.config</div></pre></td></tr></table></figure>
<h2 id="查找Erlang包"><a href="#查找Erlang包" class="headerlink" title="查找Erlang包"></a>查找Erlang包</h2><p>搜索命令让你远程查找在<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>上发布的Erlang包。你可以在查询语句里用正则表达式字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 hex search cowboy</div><div class="line">cloudi_service_http_cowboy</div><div class="line">cowboy</div></pre></td></tr></table></figure>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>Rebar3能下载和安装Erlang包以及任何必要的依赖。在你的rebar.config文件里增加应用名字到deps配置项，然后运行命令：rebar3 compile。下面的例子，我们尝试使用两个Erlang包，cowboy和meck。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [cowboy, meck]&#125;.</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Fetching ranch (&#123;pkg,&lt;&lt;<span class="string">"ranch"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching meck (&#123;pkg,&lt;&lt;<span class="string">"meck"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.8.2"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowlib (&#123;pkg,&lt;&lt;<span class="string">"cowlib"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowboy (&#123;pkg,&lt;&lt;<span class="string">"cowboy"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling cowlib</div><div class="line">===&gt; Compiling ranch</div><div class="line">===&gt; Compiling meck</div><div class="line">===&gt; Compiling cowboy</div><div class="line">===&gt; Compiling myapp</div></pre></td></tr></table></figure>
<p>想要安装一个Erlang包的指定版本？在配置中把应用名字和版本写在一个元组中。你可以在<a href="https://hex.pm/" target="_blank" rel="external">Hex主页</a>上查询Erlang包的可用版本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [&#123;cowboy, “<span class="number">1.0</span>.<span class="number">2</span>”&#125;, &#123;meck, <span class="string">"0.8.3"</span>&#125;]&#125;.</div></pre></td></tr></table></figure>
<h2 id="列出已安装的包"><a href="#列出已安装的包" class="headerlink" title="列出已安装的包"></a>列出已安装的包</h2><p>rebar3 deps 命令列出你本地已经安装的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div><div class="line">meck (locked package 0.8.2)</div></pre></td></tr></table></figure>
<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>要卸载一个包，你首先要在rebar.config文件中将它删除，然后使用命令：rebar unlock。现在我们卸载meck包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 unlock</div><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div></pre></td></tr></table></figure>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz" target="_blank" rel="external">https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红回调和绿回调]]></title>
      <url>http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/</url>
      <content type="html"><![CDATA[<p>有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。</p>
<p>为了解释这个问题，我必须先回过头来讲讲I/O。</p>
<a id="more"></a>
<h1 id="Erlang的并发I-O"><a href="#Erlang的并发I-O" class="headerlink" title="Erlang的并发I/O"></a>Erlang的并发I/O</h1><p>Erlang是如何处理并发I/O的？相当简单！假设我们有三个进程A、B和C，它们在并行执行。我用如下的方式描述这个场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A || B || C</div></pre></td></tr></table></figure>
<p>上述描述假设三个进程A、B、C正在进行I/O操作。</p>
<p>进程A如下所描述做一些事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A: --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>进程B则如下描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B: ---- write --- write --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>C进程也大致如此。虚线表示一些顺序的计算。进程A的Erlang代码框架如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">a</span><span class="params">()</span> -&gt;</span></div><div class="line">    ...</div><div class="line">    X = read(),</div><div class="line">    ...</div><div class="line">    Y = read(),</div><div class="line">    ...</div><div class="line">    write(...),</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>进程B和进程C的代码也和这个差不多。</p>
<p>Erlang里实际上是没有read()这个函数的。Erlang有  <a href="http://www.erlang.org/course/concurrent_programming.html#select" target="_blank" rel="external">select receive</a>  模式来处理消息，所以我们实际上定义的read()函数像如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        Pattern1 -&gt;</div><div class="line">           ...</div><div class="line">        Pattern2 -&gt;</div><div class="line">           ...</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>select receive 模式如何工作的细节不是本次讨论的重点，因此本文我将忽略这些细节。</p>
<p>重点是我在进程A的代码里如下所写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">X = read()</div><div class="line">...</div></pre></td></tr></table></figure>
<p>那么，我们的进程将在read函数处被挂起（或者叫做阻塞）直到read函数执行完毕。因此我们的代码“看起来像”是正在做一个同步阻塞的读动作。</p>
<p>看起来像是用双引号括起来的，因为它不是一个真正的阻塞读，而是一个真正的异步读，这个读操作不阻塞其他任何Erlang进程。</p>
<p>这真是棒极了，因为从一开始，程序就等待读请求完成，然后获得读取到的数据，程序继续运行。</p>
<h1 id="理解并发"><a href="#理解并发" class="headerlink" title="理解并发"></a>理解并发</h1><p>Erlang的I/O非常特别。当我们有两个并行的进程A和B，A进程里的一个读请求将明显地阻塞A进程，但是不会对其他任何并行的进程（这里指B）有影响。</p>
<p>所以A和B可以都同时执行写入操作就好像它们是连续的进程。</p>
<p>现在假设我们没有一个合适的基础并发模型。假设所有我们要做的事情都放入一个单独线程来执行。假设我们做一个读操作（它是阻塞的）而其他事情都在等待。啊！亲！我们的编程模型是更加清晰简单了，但是我们却浪费了CPU的宝贵资源。</p>
<p>现在在一些语言（正是我在研究的Javascript）没有多进程和多线程。不确切地说，它有一个线程，所有的事情都揉进这个线程里。在Javascript里要写与读相关操作的代码，你不得不用红回调，并且发明你自己的并发概念。</p>
<h1 id="红回调"><a href="#红回调" class="headerlink" title="红回调"></a>红回调</h1><p>在Javascript里你肯定不想在主线程里做一个阻塞同步读操作（记住它只有一个线程），那么你必需设置一个回调，当读操作完成的时候触发这个回调。我叫这样的回调为红回调。你写的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; ... do something <span class="keyword">with</span> x ..&#125;;</div><div class="line"><span class="keyword">var</span> error = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; .... x …&#125;</div><div class="line">read(Something, &#123;onSuccess:done, onError:error&#125;);</div><div class="line">... ... more code ...</div></pre></td></tr></table></figure>
<p>这样的代码搞得我脑袋一团浆糊。</p>
<p>当程序正在上述代码 more code 的某个地方执行的时候，读操作完成了，则必需立即回到done这个函数来执行，然后再回到前面 more code 中断的地方。我发现这个方式非常难以理解。</p>
<p>这的确很糟糕，每一个要解决并发问题的Javascript程序员必需要发明他自己的并发模型。问题就在于他们不知道他们正在做的是什么。每次一个Javascript程序员写下一行代码，说是“此处就该这么做”的时候，他实际上是在发明一个新的并发模型，并且在这些代码执行的时候他是没有任何线索知道这些代码是怎样交织在一起的。</p>
<p>（其实我对Javascript又爱又恨，它的大部分我都喜欢，但是就是恨它的并发模型。不过好笑的是，Javascript是没有并发模型的，所以对它也无从可恨了。:-）</p>
<p>更加难以理解的是错误。在共享内存的多线程回调代码里的错误更加是令我极度头痛！</p>
<h1 id="绿回调"><a href="#绿回调" class="headerlink" title="绿回调"></a>绿回调</h1><p>只是为了使得生活更加困惑，在Erlang里我们大量使用了回调。我把这些回调称为“绿回调”。因此回调并不一定是不好的。在Erlang里，我们可以在一个进程的上下文里更清晰地看到回调的执行，所以我们没有如何查看回调执行过程的问题。</p>
<p>如下是Erlang里一个绿回调的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">loop</span><span class="params">(F)</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;new_callback, F1&#125; -&gt;</div><div class="line">            loop(F1);</div><div class="line">        Msg -&gt;</div><div class="line">            F(Msg),</div><div class="line">            loop(F)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>当一个进程运行这段代码的时候收到一个消息Msg，它就执行函数F(Msg)。这里没有任何不确定的，当回调被触发的时候我们确切地知道。在收到消息Msg后，这个回调被立即触发。</p>
<p>这一小段代码却非常漂亮。如果你给进程发送一个消息{new_callbak, F1}，那么它将改变它的行为，在下一次调用的时候，它将执行新的回调。</p>
<p>我不知道你在Javascript里如何写出这样的代码。我写过大量的JQurey代码并且明白如何设置和删除回调。但是在删除一个事件处理并新增一个事件处理这期间里，这个事件被触发了，这会发生什么？我不知道。生命如此短暂如何花的起那么多时间来找这个答案。</p>
<h1 id="Erlang的I-O是如何工作的"><a href="#Erlang的I-O是如何工作的" class="headerlink" title="Erlang的I/O是如何工作的"></a>Erlang的I/O是如何工作的</h1><p>我们实际上并没有给进程发送消息。我们给进程的邮箱发送消息。每一个进程有一个邮箱，当我们给一个进程发送消息，这个消息被放入这个进程的邮箱（如果快递小子能找到这个进程的话）。</p>
<p>想像一下，Erlang的进程是有邮箱的房子。发送消息就好比你把你的消息给快递小子。快递小子的工作就是做两件事：把邮件放入目的邮箱并敲门说：“有新信到了”。</p>
<p>进程可能在忙着也可能在睡觉，就如一个房东一个样，他可能在干这活或者在睡觉。如果他在睡觉，那么当邮递员来了并敲响了房门，房东就会走到邮箱那里检查是否有令人感兴趣的邮件。</p>
<p>如果房东此时把手头的活干完后，正在做其他事情的时候，房东可能会走到邮箱那里检查是否有新的邮件到了，</p>
<p>这就是Erlang的消息工作机制。每一个房子（进程）有它自己的生命周期。邮递员投递邮件，房东根据自己的意愿决定什么时候去检查邮箱。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html" target="_blank" rel="external">http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang(和Elixir)无epmd之分布式]]></title>
      <url>http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/</url>
      <content type="html"><![CDATA[<p>当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：</p>
<ul>
<li>epmd（Erlang端口映射守护进程）端口4369，</li>
<li>Erlang节点自己的端口，一个不可预知的大数字端口。</li>
</ul>
<p>这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的<a href="http://erlang.org/doc/man/kernel_app.html" target="_blank" rel="external">kernel文档</a>里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。</p>
<a id="more"></a>
<p>但是如果我们限制了Erlang节点在一个单独的端口，那么我们还真的需要一个端口映射吗？运行epmd有以下几个潜在的缺点：</p>
<ul>
<li>我们可能想要以运行Erlang节点的用户来运行epmd，但是正如我们将见到的，这个很难得到保证。</li>
<li>我们可能想要配置epmd监听一个特定的端口，但是这依赖于在本机上我们如何第一次运行epmd。</li>
<li>任何人无需身份验证可以连接epmd并且可以列出本地的所有Erlang节点。</li>
<li>与epmd的连接都没有加密，即使你按 <a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">Erlang distribution over TLS</a> 这篇文章的方法去做，与epmd的连接也是不受保护的，并且有被中间人攻击的潜在风险。</li>
<li>虽然epmd很稳定，它也有发生崩溃的可能。一旦它崩溃了，任何已经存在的分布式Erlang节点将继续运行，即使epmd恢复了，这些节点也不会重新连接empd。这意味着存在的分布式连接继续工作着，但是与这些节点的新的连接将不起作用。阅读俄文博客 <a href="https://habrahabr.ru/post/49535/" target="_blank" rel="external">Экстренная реанимация epmd</a> 可能可以在不重启epmd的情况下解决这个问题。</li>
</ul>
<p>那么我们来研究一下epmd是如何工作的，然后我们如何做就可以在不用epmd的情况下运行一个Erlang集群。</p>
<h1 id="epmd是如何第一次启动的？"><a href="#epmd是如何第一次启动的？" class="headerlink" title="epmd是如何第一次启动的？"></a>epmd是如何第一次启动的？</h1><p>让我们来读读源码！epmd是在<a href="https://github.com/erlang/otp/blob/OTP-19.1.1/erts/etc/common/erlexec.c#L1234-L1279" target="_blank" rel="external">erlexec.c文件的start_epmd函数</a>里被启动的。实际上，每一次一个Erlang分布式节点启动epmd都无条件地被启动。如果一个epmd实例已经在运行，新的epmd在侦听端口4369的时候将失败，它将因此悄无声息地结束运行。</p>
<p>事实上，这就是即使由另一个用户启动的epmd实例存在系统将发生的事情。任何epmd实例都非常乐意为由任何用户启动的Erlang节点服务，因此这个通常不会引起任何问题。</p>
<h1 id="那么谁可以连接epmd？"><a href="#那么谁可以连接epmd？" class="headerlink" title="那么谁可以连接epmd？"></a>那么谁可以连接epmd？</h1><p>任何人都可以！默认情况下，epmd侦听在所有有效的接口上，并且响应关于当前有哪些节点以及这些节点所侦听的端口的查询。一听到这个场景，系统管理员应该有点紧张。</p>
<p>你可以在epmd启动前通过手工指定 -address 选项或设定ERL_EPMD_ADDRESS 环境变量启动epmd来改变上述情况。这个方法在<a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="external">官方文档</a>里有描述。这个方法需要在你第一次启动epmd的时候来做，否则，已经存在的epmd实例将不受影响地继续运行。</p>
<h1 id="为什么我们需要一个端口映射守护进程？"><a href="#为什么我们需要一个端口映射守护进程？" class="headerlink" title="为什么我们需要一个端口映射守护进程？"></a>为什么我们需要一个端口映射守护进程？</h1><p>很明显，epmd就是一个中间人。我们可以绕过这个中间人吗？</p>
<p>我们可以让每个Erlang节点侦听在一个大家熟知的端口–如果我们打算去除掉epmd的话，我们可以用empd默认保留的端口，4369。但是这就意味着我们只能够在每个主机上运行一个Erlang节点（当然，在某些场景下这就足够了）。</p>
<p>那么让我们指定一些其他端口。前面我们提到变量 inet_dist_listen_min 和 inet_dist_listen_max 。这两个变量定义一个端口范围，不过如果我们设置它们为相同的值，我们就把范围缩小到一个端口：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">erl -sname foo \</div><div class="line">    -kernel inet_dist_listen_min <span class="number">4370</span> \</div><div class="line">            inet_dist_listen_max <span class="number">4370</span></div></pre></td></tr></table></figure>
<p>这个方法不错，不过我们也需要告诉其他节点不要再去询问epmd来获取端口号，而是只用这个端口号来代替。如果我们在同一个主机上有几个节点，我们需要为这些节点配置不同的端口号。</p>
<h1 id="用别的方法"><a href="#用别的方法" class="headerlink" title="用别的方法"></a>用别的方法</h1><p>在Erlang/OTP 19.0里，有两个新的命令行选项：</p>
<ul>
<li>当我们指定 -start_epmd false，Erlang将不会在启动一个分布式节点的时候尝试去启动epmd；</li>
<li>选项 -epmd_module foo 让你指定一个不同的模块替代默认的模块erl_epmd，用来节点名字注册和查询。</li>
</ul>
<p>接下来我们来构建一些代码！</p>
<p>我想用一个无状态的方式来实现这个方法：既然发起连接的节点知道了它要连接的节点的名字，那么我就用这个名字作为资源来得到相应的端口号。我选择4370这个端口作为基准端口，它比epmd的端口大一。接着我从节点名称的“节点”部分抽取出数字，比如节点名称为 myapp3@foo.example.com 抽取的数字是3。最后我把这个数字和基准端口相加。由此得知，节点 myapp3@foo.example.com 侦听在端口4373。如果节点名字最后不是数字，我这种情况将处理为0。这意味着节点 myapp3 和 myotherapp3 不能运行在同一个主机上，但是我准备好了处理对这种场景。（感谢 Luca Favatella 的完美建议）</p>
<p>为此我们来写一个小模块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([dist_port/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% 返回被一个指定节点使用的端口号。</span></div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_atom</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    dist_port(atom_to_list(Name));</div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_list</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 获取基端口号。如果没有在 kernel 的环境变量</span></div><div class="line">    <span class="comment">%% inet_dist_base_port 里指定, 则默认为</span></div><div class="line">    <span class="comment">%% 4370, 比epmd端口大1。</span></div><div class="line">    BasePort = application:get_env(kernel, inet_dist_base_port, <span class="number">4370</span>),</div><div class="line"></div><div class="line">    <span class="comment">%% 现在，算出我们相对于基端口号的偏移值。</span></div><div class="line">    <span class="comment">%% 这个偏移值就是我们节点名的@符号左边的数字。</span></div><div class="line">    <span class="comment">%% 如果这个数字不存在，则偏移量设置为0。</span></div><div class="line">    <span class="comment">%%</span></div><div class="line">    <span class="comment">%% 同时我们也处理主机名没有指定的情况。</span></div><div class="line">    NodeName = re:replace(Name, <span class="string">"@.*$"</span>, <span class="string">""</span>),</div><div class="line">    Offset =</div><div class="line">        <span class="keyword">case</span> re:run(NodeName, <span class="string">"[0-9]+$"</span>, [&#123;capture, first, list&#125;]) <span class="keyword">of</span></div><div class="line">            nomatch -&gt;</div><div class="line">                <span class="number">0</span>;</div><div class="line">            &#123;match, [OffsetAsString]&#125; -&gt;</div><div class="line">                list_to_integer(OffsetAsString)</div><div class="line">        <span class="keyword">end</span>,</div><div class="line"></div><div class="line">    BasePort + Offset.</div></pre></td></tr></table></figure>
<p>同时我们还要写一个模块用作 -epmd_module。有一点小复杂就是因为OTP19.0期望这个模块导出 register_node/2 函数，而从OTP19.1开始则是期望导出 register_node/3 函数。我们把这两个函数都包含进去。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_epmd_client)</span>.</div><div class="line"></div><div class="line"><span class="comment">%% epmd_module 回调函数</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>,</span></div><div class="line">         register_node/<span class="number">2</span>,</div><div class="line">         register_node/<span class="number">3</span>,</div><div class="line">         port_please/<span class="number">2</span>,</div><div class="line">         names/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="comment">%% 监督者模块 erl_distribution 尝试着把我们当做一个被监督的子进程。</span></div><div class="line"><span class="comment">%% 我们不需要子进程，所以返回 ignore 。</span></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    ignore.</div><div class="line"></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(_Name, _Port)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 本函数是我们连接epmd并告诉它我们监听哪个端口，</span></div><div class="line">    <span class="comment">%% 不过因为我们是无epmd的，所以我们不需要做这些。</span></div><div class="line"></div><div class="line">    <span class="comment">%% 需要返回一个1到3的 ”creation” 数字。</span></div><div class="line">    Creation = rand:uniform(<span class="number">3</span>),</div><div class="line">    &#123;ok, Creation&#125;.</div><div class="line"></div><div class="line"><span class="comment">%% 从Erlang/OTP19.1开始，register_node/3函数替代register_node/2函数，</span></div><div class="line"><span class="comment">%% 该函数多了一个地址族的入参，取值为 ‘inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line"><span class="comment">%% 这一点对我们来说没有多大的改动。</span></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(Name, Port, _Family)</span> -&gt;</span></div><div class="line">    register_node(Name, Port).</div><div class="line"></div><div class="line"><span class="function"><span class="title">port_please</span><span class="params">(Name, _IP)</span> -&gt;</span></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line">    <span class="comment">%% 分布式协议版本从Erlang/OTP16开始就是5。</span></div><div class="line">    Version = <span class="number">5</span>,</div><div class="line">    &#123;port, Port, Version&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">names</span><span class="params">(_Hostname)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 因为我们没有epmd，所以我们真的不知道此处是否有其他节点。</span></div><div class="line">    &#123;error, address&#125;.</div></pre></td></tr></table></figure>
<p>正如你所见，大多数事情基本完成了。</p>
<p>当这个模块被加为 erl_distribution 监督者的子进程的时候，start_link/0 将被调用。我们并不需要在这个启动一个进程，因此我们只是返回 ignore。</p>
<p>register_node函数通常会连接epmd并告诉它我们使用哪一个端口。epmd将返回一个“creation”数字。“creation”数字上一个介于1和3的整数。epmd跟踪每一个节点名字的“creation”数字并且当一个确定名字的节点重连的时候增加这个数字。这意味着它可以区分先前某一个节点“存活期间”的进程id。</p>
<p>既然我们没有epmd，那么我们就没有获得它跟踪节点生命周期的好处。在这里我们返回一个随机数，它有三分之二的机会不同于前面的“creation”数字。</p>
<p>port_please/2 获取远程主机的IP地址以便连接它的epmd，但是我们不关心这些；我们用我们自己的算法来算出我们的端口号。</p>
<p>我们也需要返回一个分布式协议版本号。从Erlang/OTP 6开始它就是5（参阅 <a href="http://erlang.org/doc/apps/erts/erl_dist_protocol.html" target="_blank" rel="external">分布式协议官方文档</a> ），就这么简单。</p>
<p>最后，names/1 函数被调用来返回某个主机上的Erlang节点列表。我们没有办法知道这些信息，所以让我们假装我们连接不上这个主机。</p>
<p>目前为止，一起都顺利。但是我们需要一个方法来确认我们正侦听在合适的端口上。我认为最好的方法是写一个新的分布式协议模块，该模块仅是设置端口号而让真正的协议模块做它自己的事情：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_dist)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([listen/<span class="number">1</span>,</span></div><div class="line">         select/<span class="number">1</span>,</div><div class="line">         accept/<span class="number">1</span>,</div><div class="line">         accept_connection/<span class="number">5</span>,</div><div class="line">         setup/<span class="number">5</span>,</div><div class="line">         close/<span class="number">1</span>,</div><div class="line">         childspecs/<span class="number">0</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">listen</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 在此处我们算出我们想要侦听在什么端口。</span></div><div class="line"></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line"></div><div class="line">    <span class="comment">%% 设置 “最小” 和 “最大” 两个变量，强制侦听端口为一个值。</span></div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_min, Port),</div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_max, Port),</div><div class="line"></div><div class="line">    <span class="comment">%% 最后运行真正的函数！</span></div><div class="line">    inet_tcp_dist:listen(Name).</div><div class="line"></div><div class="line"><span class="function"><span class="title">select</span><span class="params">(Node)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:select(Node).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept_connection</span><span class="params">(AcceptPid, Socket, MyNode, Allowed, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">setup</span><span class="params">(Node, Type, MyNode, LongOrShortNames, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:setup(Node, Type, MyNode, LongOrShortNames, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">close</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:close(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">childspecs</span><span class="params">()</span> -&gt;</span></div><div class="line">    inet_tcp_dist:childspecs().</div></pre></td></tr></table></figure>
<p>几乎所有的代码都在这。listen/1函数在将控制权交给真正的处理模块inet_tcp_dist前，根据我们的节点名来设置inet_dist_listen_min和inet_dist_listen_max两个变量。</p>
<p>（请注意：虽然inet_tcp_dist是默认的处理模块，但是它仅提供基于IPv4上的未加密连接。如果你想用IPv6，你应该用inet6_tcp_dist，而如果你想用<a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">基于TLS上的Erlang分布式功能</a>，那就应该选择inet_tsl_dist或inet6_tsl_dist。增加这些弹性的尝试留给读者自己练习。）</p>
<p>我们准备好了！现在我们启动两个节点，foo1和foo2，并且使它们彼此互连：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo1</div><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo2</div></pre></td></tr></table></figure>
<p>系统能正常运行吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(foo2@poki-sona-sin)<span class="number">1</span>&gt; net_adm:ping('foo1@poki-sona-sin').</div><div class="line">pong</div></pre></td></tr></table></figure>
<p>看起来没问题！</p>
<h1 id="接着在Elixir下尝试"><a href="#接着在Elixir下尝试" class="headerlink" title="接着在Elixir下尝试"></a>接着在Elixir下尝试</h1><p>当然，因为Erlang和Elixir都运行在同样的虚拟机上，那么就没有什么可以阻止我们在Elixir里实现上述功能了。</p>
<p>在Elixir里，我们可以将所有代码放在一个单独文件里，编译器会将它编译成我们需要的不同的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个包含根据一个节点名来决定端口号的函数的模块。</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_atom(name) <span class="keyword">do</span></div><div class="line">    dist_port Atom.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_list(name) <span class="keyword">do</span></div><div class="line">    dist_port List.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_binary(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 算出基端口。如果没有指定则用</span></div><div class="line">    <span class="comment"># inet_dist_base_port 这个kernel的环境变量,</span></div><div class="line">    <span class="comment"># 默认值是4370, 比epmd的端口大1。</span></div><div class="line">    base_port = <span class="symbol">:application</span>.get_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_base_port</span>, <span class="number">4370</span></div><div class="line"></div><div class="line">    <span class="comment"># 现在，基于基端口算出我们的“偏移量”。</span></div><div class="line">    <span class="comment"># 偏移量就是一个我们节点名@符号左边的整数。</span></div><div class="line">    <span class="comment"># 如果这个整数不存在，则偏移量是0。</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># 也处理主机名没有指定的情况。</span></div><div class="line">    node_name = Regex.replace ~r/@.*<span class="variable">$/</span>, name, <span class="string">""</span></div><div class="line">    offset =</div><div class="line">      <span class="keyword">case</span> Regex.run ~r/[<span class="number">0</span>-<span class="number">9</span>]+<span class="variable">$/</span>, node_name <span class="keyword">do</span></div><div class="line">    <span class="keyword">nil</span> -&gt;</div><div class="line">      <span class="number">0</span></div><div class="line">    [offset_as_string] -&gt;</div><div class="line">      String.to_integer offset_as_string</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    base_port + offset</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_dist</span></span> <span class="keyword">do</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 此处我们算出我们想要侦听的端口。</span></div><div class="line"></div><div class="line">    port = Epmdless.dist_port name</div><div class="line"></div><div class="line">    <span class="comment"># 设置“min”和“max”变量，强制两个端口为一个值。</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_min</span>, port</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_max</span>, port</div><div class="line"></div><div class="line">    <span class="comment"># 最后运行真正的函数！</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.listen name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(node) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.select node</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept_connection</span></span>(accept_pid, socket, my_node, allowed, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept_connection accept_pid, socket, my_node, allowed, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>(node, type, my_node, long_or_short_names, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.setup node, type, my_node, long_or_short_names, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.close listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">childspecs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.childspecs</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_epmd_client</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># erl_distribution想要我们启动一个工作进程，然而我们并不需要。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ignore</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 因为Erlang/OTP 19.1用register_node/3来替换register_node/2，</span></div><div class="line">  <span class="comment"># 只是多传了一个参数：地址族，’inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line">  <span class="comment"># 这对于我们来说没什么问题。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(name, port, _family) <span class="keyword">do</span></div><div class="line">    register_node(name, port)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(_name, _port) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 在此处我们应该连接epmd并告诉它哪个是我们侦听的端口，</span></div><div class="line">    <span class="comment"># 但是因为我们是无epmd的，所以我们不需要这么做。</span></div><div class="line"></div><div class="line">    <span class="comment"># 需要返回一个介于1和3的"creation”数字。</span></div><div class="line">    creation = <span class="symbol">:rand</span>.uniform <span class="number">3</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, creation&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">port_please</span></span>(name, _ip) <span class="keyword">do</span></div><div class="line">    port = Epmdless.dist_port name</div><div class="line">    <span class="comment"># 分布式协议版本数字从Erlang/OTP R6开始就是5。</span></div><div class="line">    version = <span class="number">5</span></div><div class="line">    &#123;<span class="symbol">:port</span>, port, version&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">names</span></span>(_hostname) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 既然我们没有epmd，那么我们就不真正需要知道其他节点。</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:address</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们启动Elixir，我们需要用 - -erl 来传递一些参数来使得功能启用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --erl <span class="string">"-proto_dist Elixir.Epmdless -start_epmd false -epmd_module Elixir.Epmdless_epmd_client"</span> --sname foo3</div></pre></td></tr></table></figure>
<p>让我们ping我们前面已经启动的两个节点：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">1</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo1@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">2</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo2@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div></pre></td></tr></table></figure>
<p>它们都连通了并且没有epmd参与！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文描述的只是其中一种不需要epmd的Erlang分布式方式；我相信你可以用别的办法来更好地符合你的需求。我希望上述的示例代码是有用的指南！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang快速安装]]></title>
      <url>http://szpzs.oschina.io/2016/09/28/erlang-quick-install/</url>
      <content type="html"><![CDATA[<p><img src="/images/erlang-logo.png" style="border:0;"><br>在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的<a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank" rel="external">完全安装指引</a>。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。</p>
<ul>
<li><a href="#part1">在Mac OS X上安装Erlang</a></li>
<li><a href="#part2">在Linux上安装Erlang</a></li>
<li><a href="#part3">在Windows上安装Erlang</a></li>
<li><a href="#part4">用最新版本预编译包安装Erlang</a></li>
<li><a href="#part5">从源码编译安装Erlang</a></li>
</ul>
<a id="more"></a>
<h2 id="在Mac-OS-X上安装Erlang"><a href="#在Mac-OS-X上安装Erlang" class="headerlink" title="在Mac OS X上安装Erlang"></a><span id="part1">在Mac OS X上安装Erlang</span></h2><p><strong>使用HomeBrew来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install erlang</div></pre></td></tr></table></figure>
<p><strong>用MacPorts来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install erlang</div></pre></td></tr></table></figure>
<h2 id="在Linux上安装Erlang"><a href="#在Linux上安装Erlang" class="headerlink" title="在Linux上安装Erlang"></a><span id="part2">在Linux上安装Erlang</span></h2><p>大多数操作系统在它们的包管理系统里有预构建的Erlang发行版本。</p>
<p><strong>在Ubuntu和Debian下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install erlang</div></pre></td></tr></table></figure>
<p><strong>在Fedora下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<p><strong>在FreeBSD下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pkg update</div><div class="line">sudo pkg install erlang</div></pre></td></tr></table></figure>
<h2 id="在Windows上安装Erlang"><a href="#在Windows上安装Erlang" class="headerlink" title="在Windows上安装Erlang"></a><span id="part3">在Windows上安装Erlang</span></h2><p><a href="http://www.erlang.org/download.html" target="_blank" rel="external">直接下载安装程序来安装</a></p>
<h2 id="用最新版本预编译包安装Erlang"><a href="#用最新版本预编译包安装Erlang" class="headerlink" title="用最新版本预编译包安装Erlang"></a><span id="part4">用最新版本预编译包安装Erlang</span></h2><p>你在寻找最新的稳定Erlang版本或者前一个Erlang版本吗？<a href="https://www.erlang-solutions.com/" target="_blank" rel="external">Erlang Solutions</a> 给OS X，Windows，Ubuntu，Debian，Fedora，CentOS，Raspbian 以及其他平台都提供了一个<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp" target="_blank" rel="external">预编译安装包</a>。它们也提供了一个企业级Erlang发行版。</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="external">从Erlang Solutions下载</a></p>
<h2 id="从源码编译安装Erlang"><a href="#从源码编译安装Erlang" class="headerlink" title="从源码编译安装Erlang"></a><span id="part5">从源码编译安装Erlang</span></h2><p>你可以用Kerl脚本在你自己的机器上从源码来构建Erlang。Kerl是一个脚本，它使得你用几个命令就轻松地构建不同版本的Erlang。</p>
<p><strong>下载Kerl指令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O https://raw.githubusercontent.com/spawngrid/kerl/master/kerl</div><div class="line">chmod +x kerl</div></pre></td></tr></table></figure>
<p>选择一个可用的Erlang源码发行版本并且像如下指令一样来构建它（在这个例子里，我们选择18.0版本并且命名它为mybuild-18.0）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list releases</div><div class="line">./kerl build 18.0 mybuild-18.0</div></pre></td></tr></table></figure>
<p>选择一个目录来安装，例如 ~/erlang-r16b03</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list builds</div><div class="line">./kerl install mybuild-18.0 ~/erlang-18.0</div></pre></td></tr></table></figure>
<p>最后，把目录 ~/erlang-18.0/bin 加到你的环境变量 $PATH 里。</p>
<p><strong>搞定！</strong></p>
<p>在你的终端运行erl来启动一个Erlang shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 18 [erts-7.0] [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.0  (abort with ^G)</div><div class="line">1&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634" target="_blank" rel="external">https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[往Elixir里的Map塞东西]]></title>
      <url>http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/</url>
      <content type="html"><![CDATA[<p>Elixir的<a href="http://elixir-lang.org/docs/stable/elixir/Map.html" target="_blank" rel="external">Map</a>模块提供了一些不同的函数来操作map数据结构。其中一个函数就是<a href="http://elixir-lang.org/docs/stable/elixir/Map.html#put/3" target="_blank" rel="external">Map.put/3</a> 。这个函数允许你将一个健值对放入一个map中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">9</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">10</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果这个键对于此map来说是新的话，这个键值对就简单地加入map。如果这个键对于此map来说是已存在的，那么对应的老的值则被新的值替换。</p>
<p>同样的效果可以用Map.merge/2来实现。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">10</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">11</span>, <span class="symbol">bulbasaur:</span> <span class="number">14</span>&#125;)</div><div class="line">%&#123;<span class="symbol">bulbasaur:</span> <span class="number">14</span>, <span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">11</span>&#125;</div></pre></td></tr></table></figure>
<p>Map.merge/2的优势是它的灵活性。它能够更容易地在不同情况下使用。它甚至允许一次增加并且替换多个健值对。因为两个入参都是map，它让我们感觉到更容易阅读。</p>
<p>也有一个语法糖的方法，就是用map字面符号和一个管道来替换已经存在的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = %&#123;pokemon | <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>这个是最简洁的方法，但是，它仅仅是用来替换一个健值对。如果这个键不存在map中，则一个错误将发生。</p>
<p>除此之外当然还有其他函数来设置值到map中，包括 <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/3" target="_blank" rel="external">Kernel.put_in/3</a> 和 <a href="http://elixir-lang.org/docs/stable/elixir/Map.html#get_and_update/3" target="_blank" rel="external">Map.get_and_update/3</a> 。然而上述几个方法是我自己最经常接触到的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/" target="_blank" rel="external">http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[原子之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/eli5-atoms/</url>
      <content type="html"><![CDATA[<p><img alt="Atom Table" src="/images/eli5-atom-tab.png" style="border: 0;"><br><a id="more"></a><br>原子表是一个全局表，它将原子内部值（一个整数值）映射到一个字符串。同时也有一个反向的查询表，它将一个字符串映射到一个原子内部值。原子表有一个固定的记录条数上限：1048576。如果它一旦到达了这个上限，当前节点将崩溃 －－ 这就是为什么在运行时动态创建原子是很危险的做法。原子表的记录条数上限可以通过给erl命令指定 +t 标签来设置。</p>
<p>原子是在运行时不能改变它的值的一个符号。当一个新的原子被创建，它得到一个唯一的值来给当前节点来使用。原子在系统内部仅仅是指向原子表对应记录索引的整数值。这就是为什么原子的操作如此廉价的原因。</p>
<p>BEAM装载器例程读取原子值并且在原子表里查询它们。它将它们的整数值标记为原子<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>来替代原子名称。然后代码只是操作这些立即数而不是它们的名称。</p>
<p>这些内部值不能当做整数（通过网络或磁盘）离开节点。这是因为其他节点对于相通的原子有不同的内部值。因此当原子离开当前节点的时候都被转换为字符串。这会影响到BEAM文件，外部pid，外部port，Mnesia或DETS里的原子等等。这就是为什么一些开发者更喜欢给数据库字段名使用短原子名称的原因 －－ 它们将以字符串的形式出现在数据库数据中。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BEAM虚拟机之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/eli5-vm/</url>
      <content type="html"><![CDATA[<p>BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。</p>
<a id="more"></a>
<h2 id="寄存器和调用"><a href="#寄存器和调用" class="headerlink" title="寄存器和调用"></a>寄存器和调用</h2><p>作为一个寄存器虚拟机就意味着在函数调用的时候不是通过栈而是用寄存器来传递参数。它们与我们所理解的CPU架构中的寄存器不一样，而只是一个Erlang数据结构的值所组成的数组。这样的寄存器有1024个，但是有这么多入参的函数几乎不存在，所以通常虚拟机仅仅使用了前面3到10个寄存器。</p>
<p>例如，当调用一个有三个入参的函数的时候，寄存器x0，x1和x2分别被设置为三个入参值。如果我们需要进行递归调用，我们将不得不改写寄存器并丢失它们的原始值。在这种情况下，我们将需要保存旧的值到栈中。除了栈帧外没有动态栈分配，这是由编译器决定的。</p>
<p>每一个进程有自己的寄存器集。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>BEAM指令集包含大约158个基本指令，它们中的大部分可以通过调用 erlc -S yourfile.erl 生成汇编文件来查看到。每一个指令有零或多个参数。不同的技巧用来在便携方式和紧凑方式编码参数。例如，代码中的位置定位（也叫做标签）是用它们的索引来编码的，并且代码装载器后续会把它们翻译成内存地址。</p>
<p>在BEAM代码装载过程中，一些混合的操作码被更快的操作码替换。这个优化的技巧叫做超级指令。对于每一个操作码，在beam_emu.c文件中都有一个C标签对应的一段代码。一个C标签组成的数组存储在同一个虚拟机循环例程的尾部并且被当作查询表来使用。</p>
<p>请参见：<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-file.html" target="_blank" rel="external">BEAM文件格式</a>。<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-instructions.html" target="_blank" rel="external">BEAM指令代码</a>。</p>
<h2 id="线程虚拟机循环"><a href="#线程虚拟机循环" class="headerlink" title="线程虚拟机循环"></a>线程虚拟机循环</h2><p>虚拟机模拟器循环在 emulator/beam/beam_emu.s 里包含许多代码小片段，每一个代码小片段有一个标签和处理一个BEAM指令。它们都属于一个非常长的函数。一个标签表存储在此相同函数里，它被用来作为查询表。</p>
<p>装载操作码被标签地址替换后，紧跟着它们的是参数。例如，操作码 ＃1，一个来自标签数组第一索引元素被置于在代码内存。</p>
<p>这种方式很容易跳转到处理下一个操作码的 C 代码中的某个位置。只需要读一个 void* 指针并执行一个goto *p 的动作。此功能是C和C++编译器的一个扩展。这种类型的虚拟机循环称为直接线程调度虚拟机循环。</p>
<p>其他虚拟机循环的类型有：</p>
<ul>
<li>切换调度虚拟机（如果C编译器拒绝支持标签扩展，则这种类型被BEAM虚拟机源使用）。它也比直接线程调度虚拟机慢20%至30%；</li>
<li>直接调用线程</li>
<li><a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html" target="_blank" rel="external">其他</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-vm.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-vm.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我最喜欢的erlang程序]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/</url>
      <content type="html"><![CDATA[<p>前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。</p>
<p>他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。</p>
<a id="more"></a>
<h1 id="通用服务器"><a href="#通用服务器" class="headerlink" title="通用服务器"></a>通用服务器</h1><p>一般来说服务器都是做特定的事情的。一个HTTP服务器响应HTTP请求而一个FTP服务器响应FTP请求，等等。那么什么是通用服务器呢？我们肯定能归纳出一个服务器的概念，然后做出一个通用服务器，并且我们可以在晚些时候让它变成一个特定的服务器。</p>
<p>下面就是我的通用服务器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">universal_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;become, F&#125; -&gt;</div><div class="line">            F()</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个服务器相当简单。一旦我创建了一个通用服务器，它只是呆在那里等待一个 {become, F}消息，收到这样的消息后，他就变成了F服务器。</p>
<h1 id="阶乘服务器"><a href="#阶乘服务器" class="headerlink" title="阶乘服务器"></a>阶乘服务器</h1><p>一个阶乘服务器就是等待一个整数然后返回这个整数的阶乘。下面就是非常简单的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">factorial_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;From, N&#125; -&gt;</div><div class="line">            From ! factorial(N),</div><div class="line">            factorial_server()</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(N)</span> -&gt;</span> N * factorial(N-<span class="number">1</span>).</div></pre></td></tr></table></figure>
<p>现在我们已经准备好high起来了。</p>
<h1 id="把它们集成起来"><a href="#把它们集成起来" class="headerlink" title="把它们集成起来"></a>把它们集成起来</h1><p>我将写一个小函数来创建一个通用服务器，然后给它发送“变成阶乘服务器”消息，接着我将发送一个整数给它，等它返回结果并打印出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></div><div class="line">    Pid = spawn(fun universal_server/0), Pid ! &#123;become, fun factorial_server/0&#125;,</div><div class="line">    Pid ! &#123;self(), <span class="number">50</span>&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        X -&gt;</div><div class="line">            X</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这些函数都属于这个模块  <a href="http://joearms.github.io/code/fav1.erl" target="_blank" rel="external">/code/fav1.erl</a>.</p>
<p>现在我们需要做的就是启动一个Erlang shell并运行这个测试程序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line"><span class="number">1</span> &gt; c(fav1).</div><div class="line">&#123;ok, fav1&#125;</div><div class="line"><span class="number">2</span> &gt; fav1:test().</div><div class="line"><span class="number">30414093201713378043612608166064768844377641568960512000000000000</span></div></pre></td></tr></table></figure>
<h1 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h1><p>多年前当我在SICS的时候，我接触到 <a href="http://www.planet-lab.org/" target="_blank" rel="external">Planet 实验室</a>。Planet 实验室是一个有9000台计算机的研究网络。加入Planet实验室很容易，你所要做的是买一台标准PC，将它连接到网络并捐献它的使用给Planet实验室组织。你捐献你的机器给这个网络，相应的你可以使用Planet实验室里的所有其他机器。</p>
<p>Planet实验室是一个为分布式应用的真实世界的测试环境，它当前有1171个节点在562个站上。</p>
<p>当时我要用Planet实验室来做什么呢？我也不知道。最终我做的是写一些脚本在所有Planet实验的机器上安装了空转的通用服务器（和本文的代码很相似）。然后我设计了一套goosip算法来给这个网络发送 <strong>become</strong> 消息。这样我就有了一个空转的网络，我可以在数秒内将它变成我想要的任何服务器。</p>
<p>大概一年后，我必须要写一篇论文。作为一个研究者，最不划算的一个事情就是为了挣钱养家你必须要写关于这样或那样的论文，这样的论文所写的从来不是你当时感兴趣的，但是却一定是关于资助你研究的项目所期望读到的。</p>
<p>我已经在Planet实验室上建立了我的gossip网络，我可以让它成为任何服务器，因此我让它成为一个内容分发网络并且用一个gossip算法来将一个同样的文件拷贝到这个网络上的所有机器上。最后我把这件事写成一篇论文然后大家都哈皮了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html" target="_blank" rel="external">http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang的事件驱动应用]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/</url>
      <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://en.wikipedia.org/wiki/Event_%28computing%29" target="_blank" rel="external">事件</a> 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门<a href="http://www.erlang.org/doc/design_principles/events.html" target="_blank" rel="external">一章</a>是关于事件的，还有一种 <a href="http://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="external">事件驱动架构</a> 可以让你的代码和架构更牛X：</p>
<ul>
<li>它更易于将你的代码真正地解耦。</li>
<li>它打开了一扇门，通往令人感兴趣的新的架构模式，比如 <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="external">CQRS</a>（命令查询职责分离模式），<a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="external">event sourcing</a>（事件源模式），和<br><a href="http://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="external">event collaboration</a>（事件合作模式）。</li>
<li>应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。</li>
<li>事件和命令能够被非常小的事件处理器来处理。</li>
<li>如果你真的要用事件来开发系统，那么就可能像<a href="http://www.rabbitmq.com/" target="_blank" rel="external">rabbitmq</a>，<a href="http://www.zeromq.org/" target="_blank" rel="external">0mq</a>一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：</li>
<li>系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。</li>
<li>为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。</li>
<li>一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。</li>
</ul>
<a id="more"></a>
<p>Erlang已经提供了一种方式来实现事件驱动架构：gen_event 行为。<a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event</a> 是 Erlang/OTP 自带的<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id59741" target="_blank" rel="external">默认行为</a>之一。对我来说，它也是Erlang/OTP最酷的特性之一，因为你在许多语言或环境里都无法得到这样开箱即用（并且免费）的特性，因此这真的是非常棒。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>Gen_event 有一个或多个事件管理器、事件处理器，来派发和处理事件：</p>
<p><strong>事件管理器</strong>：一个事件管理器是一个 gen_event 进程。<br><strong>事件处理器</strong>：事件处理器是正真处理事件的回调模块，并且被注册到一个或多个事件管理器。<br><strong>事件</strong>：一个事件是任何erlang term，比如一个元组，一个原子，一个列表，等等。</p>
<p>在某些方面，gen_event 用起来像<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>里的<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external">EventEmitter</a>类，在概念上说也像<a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>。这个概念是有某种事件总线（事件管理器）负责接收来自系统的事件并且将它们路由到相应的监听者。其基本的工作流如下：</p>
<ul>
<li>创建一个或者多个实现 <a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event<br>行为</a><br>的回调模块。在本文末尾的<strong>附录B</strong>里有完整的例子。</li>
<li>启动一个事件管理器进程。</li>
<li>注册一个或者多个事件处理器到事件管理器上。</li>
<li>通过事件管理器派发事件。</li>
<li>在你的事件处理器里异步（同步）处理派发过来的事件。</li>
</ul>
<p>现在让我们按顺序研究上述每一步。</p>
<h1 id="启动一个事件管理器"><a href="#启动一个事件管理器" class="headerlink" title="启动一个事件管理器"></a>启动一个事件管理器</h1><p>这就是调用如下函数一样简单：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start().</div></pre></td></tr></table></figure>
<p>或者你计划把你的事件管理器包含在一个<a href="http://www.erlang.org/doc/design_principles/sup_princ.html" target="_blank" rel="external">监督树</a>里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link().</div></pre></td></tr></table></figure>
<h2 id="用一个给定的名字注册一个事件管理器"><a href="#用一个给定的名字注册一个事件管理器" class="headerlink" title="用一个给定的名字注册一个事件管理器"></a>用一个给定的名字注册一个事件管理器</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start(my_event_bus).</div></pre></td></tr></table></figure>
<p>或者也可以：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link(my_event_bus).</div></pre></td></tr></table></figure>
<p>这些函数与start/0以及start_link/0的目的一样，只是它们允许你用一个指定的名字注册一个新的事件管理器。引述<a href="http://www.erlang.org/doc/man/gen_event.html#start_link-1" target="_blank" rel="external">官方文档</a>如下：</p>
<p>如果 EventMgrName={local, Name}，这个事件管理器被以Name为名字用 register/2 本地注册。</p>
<p>如果 EventMgrName={global, GlobalName}，这个事件管理器被以GlobalName为名字用 global:register_name/2 全局注册。</p>
<p>如果没有名字提供，则这个事件管理器不能被注册。</p>
<p>如果 EventManager={via, Module, ViaName}，这个事件管理器将被Module注册到系统。这个回调模块Module应该导出如下函数 register_name/2 ，unregister_name/1 ，whereis_name/1 and send/2，这些函数和global模块里的相应函数的行为一样。因此，{via, global, GlobalName} 是一个有效的引用。</p>
<h1 id="注册事件处理器"><a href="#注册事件处理器" class="headerlink" title="注册事件处理器"></a>注册事件处理器</h1><p>一旦你已经有了你的事件管理器并且把它运行起来了，就该通过用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_handler/3</a> 来添加一些事件处理器了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>上述函数将添加一个新的事件处理器到指定的事件管理器（你传入的第一个入参所指的）。事件管理器可以用如下几种方式指定：</p>
<ul>
<li>进程PID。</li>
<li>Name，如果事件管理器是本地注册的。</li>
<li>{Name, Node}，如果事件管理器是在另一个节点本地注册的，或者 {global,<br>GlobalName}，如果事件管理器是全局注册的。</li>
<li>{via, Module, ViaName}，如果事件管理器的注册是通过一个替代进程注册的。</li>
</ul>
<p>第二个入参指定事件处理器的模块名，不过它也可以是{Module, Id}，Module是回调模块的名字，而当有多个事件处理器用同一个回调模块的时候，Id则用于识别指定的事件处理器。</p>
<p>紧接着my_event_handler里的回调函数 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:init-1" target="_blank" rel="external">init/1</a> 被调用，传给 add_handler/3 的第三个入参将原封不动地传给 init/1 做入参。init/1 可能返回：</p>
<p>如果成功，函数将返回{ok, State} 或 {ok, State, hibernate}，State是事件处理器内部初始状态。</p>
<p>如果返回{ok, State, hibernate}，事件管理器将通过调用 proc_lib:hibernate/3 进入冬眠状态，一直等到下一个事件发生。</p>
<h2 id="被监督的事件处理器"><a href="#被监督的事件处理器" class="headerlink" title="被监督的事件处理器"></a>被监督的事件处理器</h2><p>你可以用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_sup_handler/3</a> 在调用进程（也就是注册新事件处理器的进程）和事件处理器自己之间建立某种形式的监测（或监督）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_sup_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>正如官方文档描述：</p>
<p>如果调用进程后续因为原因Reason而终止，事件管理器将通过用 {stop, Reason} 作为入参调用 Module:terminate/2 来删除事件处理器。</p>
<p>如果事件处理器后来被删除，事件管理器给调用进程发送一个消息 {gen_event_EXIT, Handler, Reason}。Reaseon是下列之一：</p>
<pre><code>normal，如果事件处理器因为 delete_handler/3 的调用而被删除，或者被一个回调函数（见下面段落）返回 remove_handler 。

shutdown，如果事件处理器因为事件管理器结束而被删除。

{swapped, NewHandler, Pid}，如果进程Pid已经调用 swap_handler/3 或 swap_sup_handler/3 来用另一个事件处理器 NewHandler 替换了当前事件处理器。一个term，如果事件处理器因为一个错误而被删除。term的值是依据错误而来的。
</code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>事件处理器是按顺序执行的，所以要尽量保持它的代码短小。如果你需要有上千个事件处理器，那么实现某种<a href="https://gist.github.com/1230182" target="_blank" rel="external">转发器</a>是更好的选择。转发器的思路是有好几个子gen_event订阅一个主gen_event。这样将负载分发给所有感兴趣的监听者。</p>
<p>另一方面，如果你必需要在一个事件处理器里做费时的操作，你应该尝试用一个 <a href="https://gist.github.com/4474770" target="_blank" rel="external">gen_event caster</a>，他将监听事件并派发独特的（普通的）erlang消息。</p>
<p>我们也要注意，当一个被监督的事件处理器退出的时候，gen_event讲给所有的事件处理器<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L319" target="_blank" rel="external">发送消息</a>，因此要准备好如何处理这些消息。</p>
<h1 id="派发事件"><a href="#派发事件" class="headerlink" title="派发事件"></a>派发事件</h1><p>通过事件管理器派发一个事件实际上是相当简单的，仅仅需要调用 <a href="http://www.erlang.org/doc/man/gen_event.html#notify-2" target="_blank" rel="external">gen_event:notify/2</a> 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>你可以在本文的<strong>附录A</strong>里看到gen_event如何派发一个事件的具体细节。</p>
<p>这个函数将异步地派发这个事件。这意味着这个函数调用将不会阻塞而是立即返回。也有同步派发事件的方式，就是使用函数 <a href="http://www.erlang.org/doc/man/gen_event.html#sync_notify-2" target="_blank" rel="external">gen_event:sync_notify/2</a>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:sync_notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>同步在这里的意思是这个函数的调用将阻塞并仅在所有事件处理器已经被调用并且处理了这个事件后才返回。</p>
<h2 id="用消息替代-Notify-2"><a href="#用消息替代-Notify-2" class="headerlink" title="用消息替代 Notify/2"></a>用消息替代 Notify/2</h2><p>另一种方式来调用事件处理器是通过派发普通消息给事件管理器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pid ! &#123;new_user_created&#125;</div></pre></td></tr></table></figure>
<p>这将调用<strong>所有</strong>注册的事件处理器的 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数，gen_event官方文档说明如下：</p>
<p>当一个事件管理器接收到不是事件或者一个同步请求（或者一个系统消息）的任何其他消息时，每一个已经安装在这个事件管理器上的事件处理器的这个函数被调用。</p>
<h1 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h1><p>为了处理由notify/2派发的事件，你的回调模块需要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_event-2" target="_blank" rel="external">handle_event/2</a> 函数，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div></pre></td></tr></table></figure>
<p>另外，为了处理消息，要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(Info, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"Got message: ~p"</span>, [Info]),</div><div class="line">  &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>上面两个例子里的State是由 init/1 返回的数据。</p>
<p>上述两个函数返回值如下所述（当然我们还是引用官方文档）：</p>
<p>如果这个函数返回 {ok, NewState} 或者 {ok, NewState, hibernate} ，这个事件处理器将留在事件管理器里并且带着可能被修改过的内部状态NewState。</p>
<p>如果{ok, NewState, hibernate} 返回，事件管理器也将进入冬眠状态（通过调用 proc_lib:hibernate/3），并等待下一个事件的发生。只要一个事件处理器返回{ok, NewState, hibernate} 则整个事件管理器进程进入冬眠状态。</p>
<p>如果函数返回 {swap_handler, Args1, NewState, Handler2, Args2}，这个事件处理器将被 Handler2 替代，替换过程首先是调用 Module:terminate(Args1, NewState)，然后再调用 Module2:init({Args2, Term}) ，这里的Term是 Module:terminate/2 的返回值。更多信息可以查看 gen_event:swap_handler/3 。</p>
<p>如果函数返回 remove_handler ，这个事件处理器将通过调用 Module:terminate(remove_handler, State)来被删除。</p>
<h1 id="额外事项"><a href="#额外事项" class="headerlink" title="额外事项"></a>额外事项</h1><h2 id="停止事件管理器"><a href="#停止事件管理器" class="headerlink" title="停止事件管理器"></a>停止事件管理器</h2><p>停止事件管理器有时候是必须的并且通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#stop-1" target="_blank" rel="external">stop/1</a> 很容易就做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:stop(my_event_bus).</div></pre></td></tr></table></figure>
<p>这也会引起在所有已经注册的事件处理器上调用 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 。</p>
<h2 id="在一个事件处理器上调用函数"><a href="#在一个事件处理器上调用函数" class="headerlink" title="在一个事件处理器上调用函数"></a>在一个事件处理器上调用函数</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-3" target="_blank" rel="external">call/3</a> 来确切地调用一个事件处理器上指定的函数，就像你在 gen_server上做的一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;).</div></pre></td></tr></table></figure>
<p>和gen_server一样，你可以在调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-4" target="_blank" rel="external">call/4</a> 到时候指定一个超时时间：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;, <span class="number">5000</span>).</div></pre></td></tr></table></figure>
<p>gen_event将调用事件处理器模块的 handle_call/2 回调函数。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, this_is_my_reply, State&#125;.</div></pre></td></tr></table></figure>
<h2 id="删除事件处理器"><a href="#删除事件处理器" class="headerlink" title="删除事件处理器"></a>删除事件处理器</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#delete_handler-3" target="_blank" rel="external">delete_handler/3</a> 来删除你的事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:delete_handler(my_event_bus, my_event_handler, [arg1, arg2]).</div></pre></td></tr></table></figure>
<p>这个函数将从事件管理器删除这个事件处理器，而且也会将第三个参数传给 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 并调用它并将将调用结果返回。</p>
<p>列出所有已经注册的事件处理器</p>
<p>为了列出一个事件管理器当前注册的所有事件处理器，可以调用 <a href="http://www.erlang.org/doc/man/gen_event.html#which_handlers-1" target="_blank" rel="external">which_handlers/1</a> ：</p>
<p>gen_event:which_handlers(my_event_bus).</p>
<h2 id="替换-交换-事件处理器"><a href="#替换-交换-事件处理器" class="headerlink" title="替换 (交换) 事件处理器"></a>替换 (交换) 事件处理器</h2><p>通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_handler-3" target="_blank" rel="external">swap_handler/3</a> 也可以在运行时更换事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:swap_handler(my_event_bus, &#123;my_event_handler, [arg1]&#125;, &#123;my_new_event_handler, [arg2]&#125;).</div></pre></td></tr></table></figure>
<p>整个过程是：首先调用 my_event_handler:terminate([arg1], State) 然后调用 my_new_event_handler:init([arg2])，用一个新的事件处理器替换一个久的事件处理器。</p>
<p>如果老的事件处理器是被监督的，则新的事件处理器也被监督。你当然可以直接用同样的参数调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_sup_handler-3" target="_blank" rel="external">swap_sup_handler/3</a> 来做到。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>再一次我要感谢 <a href="https://github.com/elbrujohalcon" target="_blank" rel="external">Fernando “El Brujo” Benavides</a> 对本文的总体思考，关于gen_event缺陷的评论，以及他分享的gen_event转发器和caster。</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Marcelo Gornstein <a href="marcelo@inakanetworks.com">marcelo@inakanetworks.com</a></p>
<p>Github: <a href="https://github.com/marcelog" target="_blank" rel="external">marcelog</a></p>
<p>Homepage: <a href="http://marcelog.github.com/" target="_blank" rel="external">http://marcelog.github.com</a></p>
<h1 id="附录-A-gen-event实际上是如何派发一个事件的"><a href="#附录-A-gen-event实际上是如何派发一个事件的" class="headerlink" title="附录 A: gen_event实际上是如何派发一个事件的"></a>附录 A: gen_event实际上是如何派发一个事件的</h1><p>函数 notify/2 的实际调用最终在你的erlang/otp源码的 <a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl" target="_blank" rel="external">lib/stdlib/src/gen_event.erl</a> 文件的504行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="keyword">catch</span> Mod1:Func(Event, State) <span class="keyword">of</span></div></pre></td></tr></table></figure>
<p>Func是原子 handle_event 或 handle_info。所以如果你的事件处理器崩溃或不知何故失败了，事件管理器是不会崩溃的。</p>
<p>如果运行一个被监督的事件处理器（用add_sup_handler/3启动的），在同一个文件的<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L635" target="_blank" rel="external">635行</a>的 terminate/2 函数被调用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Res = (<span class="keyword">catch</span> Mod:terminate(Args, State)),</div></pre></td></tr></table></figure>
<p>另外，被监督的事件处理器，在<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L648" target="_blank" rel="external">648行</a>一个消息被发送给这个事件处理器注册到的进程</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Handler#handler.supervised <span class="keyword">of</span></div><div class="line">  <span class="literal">false</span> -&gt;</div><div class="line">      ok;</div><div class="line">  Pid -&gt;</div><div class="line">      Pid ! &#123;gen_event_EXIT,handler(Handler),Reason&#125;,</div><div class="line">      ok</div><div class="line">  <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="附录-B-回调模块样例"><a href="#附录-B-回调模块样例" class="headerlink" title="附录 B: 回调模块样例"></a>附录 B: 回调模块样例</h1><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_event_handler)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">  init/<span class="number">1</span>, terminate/<span class="number">2</span>, handle_info/<span class="number">2</span>,</div><div class="line">  handle_call/<span class="number">2</span>, code_change/<span class="number">3</span>, handle_event/<span class="number">2</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  &#123;ok, []&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, not_implemented, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(_Event, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Arg, _State)</span> -&gt;</span></div><div class="line">  ok.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://inaka.net/blog/2013/01/21/erlang-event-driven/" target="_blank" rel="external">http://inaka.net/blog/2013/01/21/erlang-event-driven/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS的查询、分页和并发的数据插入]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</url>
      <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">上星期的Erlang Thursday</a>的结尾，我说我们将继续研究ets模块的select函数的特性。</p>
<p>所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">TestOrderedSetTable = ets:new(ordered_set_table, [public, ordered_set]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line"><span class="comment">% 20499</span></div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:give_away(TestOrderedSetTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>接着我们给我们的测试ETS表装载一些测试数据，在数据的序列中留出一些空隙，为了后面我们填补这些空隙。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>然后我们从表里查询所有数据，我们可以看到不同类型的表的数据排序是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;]</span></div></pre></td></tr></table></figure>
<p>ets模块也有一个函数 <a href="http://erlang.org/doc/man/ets.html#select_reverse-2" target="_blank" rel="external">ets:select_reverse</a> ，我们停下来看一看它能做些什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select_reverse(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select_reverse(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;]</span></div></pre></td></tr></table></figure>
<p>我们比较 ets:select/2 和 ets:select_reverse/2 的结果，TestTable的结果是一样的，而TestOrderedSetTable的结果刚好是反序，这个结果和官方文档对 ets:select_reverse/2 描述一样。其实我们思考一下也就明白了。</p>
<p>结束了这个简单的小插曲，我们接着运行我们上面相同的匹配规则只是结果集限制在5个纪录，同时我们得到一个continuation。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;Result, Continuation&#125; = ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;19,19&#125;,&#123;29,29&#125;,&#123;27,27&#125;,&#123;17,17&#125;,&#123;5,5&#125;],</span></div><div class="line"><span class="comment">% &#123;20499,214,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">&#123;OrdSetResult, OrdSetContinuation&#125; = ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;3,3&#125;,&#123;5,5&#125;,&#123;7,7&#125;,&#123;9,9&#125;],&#123;16402,9,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>有了这些continuation，我们看看我们取回来的下一个结果集是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;23,23&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;9,9&#125;],&#123;20499,111,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;11,11&#125;,&#123;13,13&#125;,&#123;15,15&#125;,&#123;17,17&#125;,&#123;19,19&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,19,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>还记得我们用来创建元组的数字序列里留的那些间隙吗？</p>
<p>现在来看看我们填上那些序列间隙，同时我们用已经获取的continuation来查询数据会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>现在我们用前面获取到的continuation重新运行 ets:select/1 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;12,12&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;10,10&#125;,&#123;9,9&#125;],</span></div><div class="line"><span class="comment">%  &#123;20499,224,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;10,10&#125;,&#123;11,11&#125;,&#123;12,12&#125;,&#123;13,13&#125;,&#123;14,14&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,14,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们比较以前的结果，我们看到现在的结果里有了偶数元素在列表里。对于我们的 TestTable ，如果我们看上面的Continuation变量的值，它有一个continuation 的点，值是214，因为它是当前continuation和调用 ets:select(Countinuation) 后的结果continuation里唯一变化的值，所以通过这个值我们很难推断continuation的变化。</p>
<p>另一方面，OrdsetContinuation，它的第二个元素的值是9，也就是ETS表id 16402 后面的元素。而后面其它的continuation的这个值分别是19和14也碰巧和对应结果集的最后元素匹配上。因此在有序集合的情况下，我们能推断作为ordered_set类型的ETS表的continuation的一部分，这个continuation告诉我们返回结果集里最后纪录的键，我们可以不管任何同时插入动作发生而继续从这个纪录开始获取数据。</p>
<p>下次我们将看看 ets:is_compiled_ms/1 这个函数，并基于对官方文档的该函数的阅读，我们如何将匹配规则应用在continuation上。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - 限制返回结果的ETS查询]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-using-ets-select-with-a-limit/</url>
      <content type="html"><![CDATA[<p><a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">上星期的Erlang Thursday</a>我们继续研究 ets:select/2 并且用 ets:fun2ms/1生成匹配规则来和它配合使用。</p>
<p>这个星期我们将看看ets模块提供的select函数的其它版本。</p>
<a id="more"></a>
<p>还是老样子，我们将设置好我们新的ETS表的环境，以便我们的shell崩溃了我们的表不会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = fun() -&gt; receive after infinity -&gt; ok end end.</div><div class="line">% #Fun&lt;erl_eval.20.54118792&gt;</div><div class="line">SomeProcess = spawn(Fun).</div><div class="line">% &lt;0.52.0&gt;</div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line">% 16402</div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>接下来我们将装载我们的测试ETS表，它是一些测试“产品”。为了例子的简单，我们将仅用一个数字代表一个产品id，然后用一个100以内的随机整数加上0.99作为价格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;ProductId, random:uniform(100) + 0.99&#125;)</div><div class="line">  || ProductId &lt;- lists:seq(1, 10000) ]].</div><div class="line">% [[true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true|...]]</div></pre></td></tr></table></figure>
<p>我们将创建一个匹配规则（价格在19.99至30之间）来查找数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ProductsInTheTwenties = ets:fun2ms(fun(&#123;Product, Price&#125;)</div><div class="line">                                     when Price &gt;= 19.99 andalso Price &lt; 30</div><div class="line">                                     -&gt; &#123;Product, Price&#125;</div><div class="line">                                   end).</div><div class="line">% [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;,</div><div class="line">%   [&#123;&apos;andalso&apos;,&#123;&apos;&gt;=&apos;,&apos;$2&apos;,19.99&#125;,&#123;&apos;&lt;&apos;,&apos;$2&apos;,30&#125;&#125;],</div><div class="line">%   [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;&#125;]&#125;]</div></pre></td></tr></table></figure>
<p>如果我们用 ets:select/2 和上面这个匹配规则在我们的表上，我们在一个查询里得到所有结果就和前面我们看到的一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties).</div><div class="line">% [&#123;4351,29.99&#125;,</div><div class="line">%  &#123;635,19.99&#125;,</div><div class="line">%  &#123;6005,20.99&#125;,</div><div class="line">%  &#123;3742,27.99&#125;,</div><div class="line">%  &#123;5956,29.99&#125;,</div><div class="line">%  &#123;3753,28.99&#125;,</div><div class="line">%  &#123;6653,25.99&#125;,</div><div class="line">%  &#123;5151,28.99&#125;,</div><div class="line">%  &#123;2693,27.99&#125;,</div><div class="line">%  &#123;4253,21.99&#125;,</div><div class="line">%  &#123;7636,23.99&#125;,</div><div class="line">%  &#123;1935,19.99&#125;,</div><div class="line">%  &#123;9044,22.99&#125;,</div><div class="line">%  &#123;7797,22.99&#125;,</div><div class="line">%  &#123;2147,23.99&#125;,</div><div class="line">%  &#123;2574,26.99&#125;,</div><div class="line">%  &#123;7575,29.99&#125;,</div><div class="line">%  &#123;2130,28.99&#125;,</div><div class="line">%  &#123;4908,27.99&#125;,</div><div class="line">%  &#123;2218,22.99&#125;,</div><div class="line">%  &#123;9848,21.99&#125;,</div><div class="line">%  &#123;7632,26.99&#125;,</div><div class="line">%  &#123;3562,21.99&#125;,</div><div class="line">%  &#123;3130,27.99&#125;,</div><div class="line">%  &#123;575,26.99&#125;,</div><div class="line">%  &#123;4622,28.99&#125;,</div><div class="line">%  &#123;5678,25.99&#125;,</div><div class="line">%  &#123;4022,...&#125;,</div><div class="line">%  &#123;...&#125;|...]</div></pre></td></tr></table></figure>
<p>不过ets模块也给我们一个限制结果集的方式如果我们愿意的话，用 ets:select/3 并传入一个要一次返回结果数的限制。</p>
<p>那么我们来用 ets:select/3 并给它的限制是10，然后看看结果是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们的结果是一个元组而不是一个结果的列表。第一个元组元素是一个我们期望的10个结果组成的列表，第二个元素是一个奇怪的元组，我们查阅官方文档中 ets:select/3 的描述，这个奇怪的元组表示一个概念：continuation 。</p>
<p>所以我们再运行我们的查询，这次我们把结果绑定到变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;Results, Continuation&#125; = ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们有了这个continuation，不过它是什么？它对我们来说有什么用？</p>
<p>简而言之，它可以被认为是一个不可变的书签。它不仅表示我们在查询结果的哪一页，也表示我们正在读的内容（我们的查询）。</p>
<p>它允许我们把这个continuation传给 <a href="http://www.erlang.org/doc/man/ets.html#select-1" target="_blank" rel="external">ets:select/1</a> ，就能快速获取我们前面看过的结果内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>因为它是我们的特殊的不可变的书签，每次我们用这个书签它都带我们到这同样书的相同的地方，并且我们仅能读到我们原先设置的每页最大纪录数。</p>
<p>所以不管我们在我们同一个continuation上调用多少次 ets:select/1 ，每次我们都将获得相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>而如果我们仔细看结果的元组，我们看到得到一个不同的下一个continuation的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;SecondResults, SecondContinuation&#125; = ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们可以用这个新的continuation用在我们下一次调用 ets:select/1 上，来得到下一个结果集和另一个continuation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(SecondContinuation).</div><div class="line">% &#123;[&#123;8569,19.99&#125;,</div><div class="line">%   &#123;1805,28.99&#125;,</div><div class="line">%   &#123;6819,23.99&#125;,</div><div class="line">%   &#123;9313,28.99&#125;,</div><div class="line">%   &#123;9527,27.99&#125;,</div><div class="line">%   &#123;1737,29.99&#125;,</div><div class="line">%   &#123;700,26.99&#125;,</div><div class="line">%   &#123;142,25.99&#125;,</div><div class="line">%   &#123;6792,29.99&#125;,</div><div class="line">%   &#123;9295,29.99&#125;],</div><div class="line">%  &#123;16402,513,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果我们在获取完结果集后再执行一次查询，我们得到一个 ‘$end_of_table’ 原子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;&apos;$1&apos;, &apos;$2&apos;&#125;, [&#123;&apos;&lt;&apos;, &apos;$2&apos;, 0&#125;], [&apos;$$&apos;]&#125;], 10).</div><div class="line">% &apos;$end_of_table&apos;</div></pre></td></tr></table></figure>
<p>指定一个限制并有一个continuation的能力也可以用在 ets:match/3 和 ets:match/1 上，同时也可以用在 ets:match_object/3 和 ets:match_object/1 上。</p>
<p>下星期，我们将继续研究ets模块里的不同select函数，同时看看它们的行为方式和有序集合，将比较一下 select 函数和 select_reverse函数的不同，也研究一下如果我们当我们用一个continuation的时候在结果集里插入一些数据，continuation将会怎样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS，匹配规则和函数]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-match-specs-and-functions/</url>
      <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">上星期的Erlang Thursday</a>我展示了怎样通过使用ets:select带来的好处而且使我们的查询更丰富的优势来结束文章。</p>
<p>首先我们将需要一个新的ETS表，那么我们以一个新的public类型的“产品”表开始，并且按我们的标准来创建一个进程然后将表的所有权转移给它。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">Products = ets:new(products, [public]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">ets:give_away(Products, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>下一步我们将装载我们的“产品”进入表里。</p>
<p>在我们这个例子里，我们只是创建一个产品，用一个二进制数据当做产品的名字并用一个整数当做“共同世界货币里的价格”。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(Products, &#123;integer_to_binary(X), X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">100</span>) ]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>和我们在上星期一样，我们可以手工创建一个元组列表到匹配规则里去运行我们的查询，说是获取小于10CWC的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"8"&gt;&gt;,&lt;&lt;"6"&gt;&gt;,&lt;&lt;"5"&gt;&gt;,&lt;&lt;"3"&gt;&gt;,&lt;&lt;"7"&gt;&gt;,&lt;&lt;"1"&gt;&gt;,&lt;&lt;"4"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"9"&gt;&gt;,&lt;&lt;"2"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>我们也可以查询到那些大于10CWC并且小于25CWC的产品名称。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&gt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;, &#123;'&lt;', '$<span class="number">2</span>', <span class="number">25</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"11"&gt;&gt;,&lt;&lt;"15"&gt;&gt;,&lt;&lt;"23"&gt;&gt;,&lt;&lt;"20"&gt;&gt;,&lt;&lt;"21"&gt;&gt;,&lt;&lt;"14"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"12"&gt;&gt;,&lt;&lt;"13"&gt;&gt;,&lt;&lt;"16"&gt;&gt;,&lt;&lt;"19"&gt;&gt;,&lt;&lt;"17"&gt;&gt;,&lt;&lt;"18"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"22"&gt;&gt;,&lt;&lt;"24"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>但是这样并不一定清晰明了，因为我们正在使用元组里的元素的数值以及在它们里面元组列表的元组列表。</p>
<p>这个时候 <a href="http://www.erlang.org/doc/man/ets.html#fun2ms-1" target="_blank" rel="external">ets:fun2ms/1</a> 来解救我们。</p>
<p>ets:fun2ms/1 的入参是一个函数并且将把这个函数转换成一个匹配规则。</p>
<p>这就允许我们写一个函数，这个函数入参是一个产品和价格组成的元组，然后它返回价格小于10的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &lt; <span class="number">10</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&lt;','$2',10&#125;],['$1']&#125;]</span></div></pre></td></tr></table></figure>
<p>我们也能在传递给 ets:fun2ms/1 的这个函数的判断分支里用一个组合检查，相当于分支类型语句，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Between_25_And_35_CWC = ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">25</span>, Cost &lt; <span class="number">35</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&gt;','$2',25&#125;,&#123;'&lt;','$2',35&#125;],['$1']&#125;]</span></div><div class="line">ets:select(Products, Between_25_And_35_CWC).</div><div class="line"><span class="comment">% [&lt;&lt;"30"&gt;&gt;,&lt;&lt;"33"&gt;&gt;,&lt;&lt;"32"&gt;&gt;,&lt;&lt;"29"&gt;&gt;,&lt;&lt;"28"&gt;&gt;,&lt;&lt;"26"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"34"&gt;&gt;,&lt;&lt;"27"&gt;&gt;,&lt;&lt;"31"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>或者也可以是类型分支语句。</p>
<p>虽然这个函数有用，但是它还是有它的限制，因为这是在函数上解析转换，所以你不能像在普通函数上一样用任何东西。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">90</span> -&gt; lists:reverse(binary:bin_to_list(Product)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% Error: Unknown error code &#123;122,lists,reverse&#125;</span></div><div class="line"><span class="comment">% &#123;error,transform_error&#125;</span></div></pre></td></tr></table></figure>
<p>但是，匹配规则的结果部分也是不支持任何高级函数功能的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', <span class="number">90</span>, '$<span class="number">2</span>'&#125;], [binary:bin_to_list('$<span class="number">1</span>')]&#125;]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  binary:bin_to_list/1</span></div><div class="line"><span class="comment">%         called as binary:bin_to_list('$1')</span></div></pre></td></tr></table></figure>
<p>即使有这些限制，ets:fun2ms/1 依然帮助我们做了更富表现力的ETS查询。我们不仅能用有意义的变量名替代那些 $X 变量来引用一个函数，也用判断分支语句来替代判断元组，而且我们也可以在我们的结果里用这些变量名同时做基本的格式化作为函数的一部分。</p>
<p>请确认在下周回来，因为我们将继续研究 ets:select 的不同版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – 更多的ETS数据匹配和查询]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-more-ets-data-matching-and-querying/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续上周开始的从ETS获取数据研究。</p>
<p>我们已经有一个模块 markov_words ，本周我们将添加一个函数 markov_words:create_word_triples/1 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>,</span></div><div class="line">         create_word_triples/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_triples<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_triples(Words, []).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([_Word, _SecondWord | []], WordTriples)</span> -&gt;</span></div><div class="line">    WordTriples;</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([FirstWord | Words], WordTriples)</span> -&gt;</span></div><div class="line">    [SecondWord, Following | _] = Words,</div><div class="line">    UpdatedWordTriples = [&#123;FirstWord, SecondWord, Following&#125; | WordTriples],</div><div class="line">    create_word_triples(Words, UpdatedWordTriples).</div></pre></td></tr></table></figure>
<p>添加新函数的原因是它将允许我们得到更精确的马尔科夫链，这是通过能看到后续两个词的复合键的情形而提高获取下一个单词的概率。</p>
<p>修改和重新定义我们的模块后，我们回到Erlang shell，编译我们的模块并转载我们的介绍文本给一个变量，测试开始。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line"></div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>本周我们创建新的ETS表，创建一个新的进程并且把表转移给它（在例子中我们输入一些错误的东西来引起当前的shell进程崩溃）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MarkovWords = ets:new(markov_word_tuples, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div><div class="line">ets:give_away(MarkovWords, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这周，除了添加我们的词对元组到ETS，我们也将添加新的词三元组到ETS的同样的表里。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(MarkovWords, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"></div><div class="line">[[ ets:insert(MarkovWords, WordTriple) || WordTriple &lt;- markov_words:create_word_triples(ToTC)]].</div></pre></td></tr></table></figure>
<p>既然我们已经有词对和三词组在同一个ETS表中，我们可以用 ets:match_object/2 函数并指定一个匹配模式仅获得二元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者指定另一个匹配模式仅获得三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;]</span></div></pre></td></tr></table></figure>
<p>而如果我们用 ets:lookup/2 函数并传入键，那么我们得到这个键的所有数据而不管它是二元组还是三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:lookup(MarkovWords, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>和 ets:lookup/2 不一样，ets:match_object/2 可以匹配元组中的任何元素而不仅是键。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>和 ets:match_object/2 一样，ets:match/2 也可以如此匹配元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(MarkovWords, &#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>但有时候我们可能想要对如何返回结果给我们有更细粒度的控制能力，比如用一个元素单列表而不是一个字符串嵌套列表。或者我们甚至有一些标准是我们想要的真正作为我们选择的数据的一部分。</p>
<p>让我们开始研究 <a href="http://www.erlang.org/doc/man/ets.html#select-2" target="_blank" rel="external">ets:select/2</a> 。</p>
<p>ets:select/2 第一个入参是一个表，第二个入参是一个匹配规则。</p>
<p>这个匹配规则是一个三元组列表，元组的第一个元素是一个匹配模式，第二个元素是一个判断语句元组的列表，最后一个元素是一个表示每个匹配的结果。</p>
<p>如果我们想让调用 ets:select/2 结果和 ets:match/2 相似，就如像下面输出一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], [['$<span class="number">1</span>']]&#125;]).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>第二个入参是一个匹配规则列表，它只有一个元素，这个元素的组成是：<br>1）一个{“was”, “the”, ‘$1’}样式的匹配模式，它和我们传给 ets:match/2 的一样<br>2）一个空的条件判断元组列表3）一个返回结果的term： [[‘$1’]]，它是我们想要的结果格式列表，在本例子里我们想要每个结果都在它自己的列表里。</p>
<p>如果我们只是想得到一个词组成的列表，我们可以修改匹配规则的返回结果的term为[‘$1’]。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% ["winter","spring","season","season","epoch","epoch","age",</span></div><div class="line"><span class="comment">%  "age","worst","best"]</span></div></pre></td></tr></table></figure>
<p>如果我们想让返回结果看起来更像是一个 ets:match<em>object/2 返回的结果集，我们可以使用 ‘$</em>‘作为结果term，它表示整个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>如果你想要只是匹配某些元素并且提取元组中其它元素，我们可以用 ‘$$’ 作为结果term，它将返回所有匹配变量到一个列表里，返回列表里元素的顺序是按匹配模式里匹配变量的数值排序。</p>
<p>用 ets:select/2 我们也可以有指定多个匹配规则的能力。这样就允许我们查找到所有中间的词是 of 或 the 的三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;, &#123;&#123;'$<span class="number">1</span>', <span class="string">"of"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"some","of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"preserves","of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"worst","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"winter","of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"degree","of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"spring","of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"best","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>使用判断分支，我们可以找到在三元组数据里第一个元素是 was ，而且第二个词在字典排序上小于第三个词这样的第三个词。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;], ['$<span class="number">2</span>']&#125;]).</div><div class="line"><span class="comment">% ["than","winter","worst"]</span></div></pre></td></tr></table></figure>
<p>本周的文章我们已经学到使用 ets:match/2 和 ets:match_object/2 函数的其它方式，以及他们能克服使用 ets:lookup/2 的时候只能指定一个键的弱点，也可以能够通过使用 ets:select/2 来获得更强的查询能力。</p>
<p>下周，我们将研究 ets:select/2 的更多使用方式，以及我们怎样用ets模块的其它函数来帮助创建查询来更容易地快速解构数据。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS 数据匹配]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-data-matching/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday开始从介绍系列文章改为专门讲ETS，开始用ETS存储一些数据然后在ETS里做一些数据的检索。</p>
<p>首先我们需要在ETS有一些数据，所以我们回到马尔科夫链这个问题上。</p>
<a id="more"></a>
<p>马尔科夫链是一个状态机，它是基于概率而不是特定的输入来转换状态的。它的一个普通的例子就是人们熟悉的智能手机里的“日常使用”的预测输入功能，也就是下一个词或字母会被预测并提供给使用者，而被选择的预测单词是遵循预测它跟随当前单词的历史有关的可能性。</p>
<p>首先我们将创建一个模块，该模块有一个函数将接收一个文本字符串，它返回的是一个元组列表，而这个元组的元素是由一个词和该词的后续词组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div></pre></td></tr></table></figure>
<p>上述代码输入的是一个文本字符串，然后基于空格、tab和新行字符作为词的边界将文本分割成词列表。基于这个词列表，我们创建一个列表，该列表元素是由词和词的后续词组成的元组，而这些元组将被我们插入我们的ETS表中。</p>
<p>是时候打开Erlang shell开始我们的试验了。</p>
<p>首先我们需要编译我们的模块，然后我们将创建一个变量来持有我们的文本，这个文本是为我们的马尔科夫链准备的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>我们将创建一个新进程并把我们的ETS表转移给它，以防万一我们的Erlang shell崩溃。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.60.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个ETS表，它将用来存储数据，这些数据为我们用来作为我们的马尔科夫链生成器的一部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WordPairs = ets:new(word_pairs, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:give_away(WordPairs, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们设置表为 public，因为我们想让不再是表的所有者的shell进程可以添加数据到表里，同时我们设置表的类型为 duplicate bag。</p>
<p>设为 duplicate_bag 是为了演示的原因。我们希望能有相同键的多个数据，因为我们很可能会看到任何词多次，而且有些词对的词的集合很常见，所以我们希望能捕获（以及保留）那些重复的词。</p>
<p>为了方便从shell里生成数据，我们将用列表解析把我们从文本创建的每一个词对元组通过调用 ets:insert/2 函数来插入到我们的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(WordPairs, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>现在我们已经有了一些数据在我们的ETS表里，是时候看看我们怎样才能访问我们的数据。为访问数据，我们开始介绍函数 ets:match/2 ，它的入参是一个要查询的表以及一个模式。</p>
<p>模式是由一个Erlang term组成用来匹配：_ ，匹配任意数据而且不做绑定；或者模式变量，它的格式是$N，N是任意正整数。ets:match/2 的返回结果是一个列表，这个是由模式变量的值组成的，它们按照模式变量名的序列排序。</p>
<p>所以有了这些知识，我们可以尝试查询这些词对来找到所有跟在 of 后的词。如果我们写一个模式匹配，它可能看起来像 {“of”, Following}，但是使用ETS，我们需要用一个模式变量按规范来写成：{“of”, ‘$1’}.</p>
<p>让我们在shell里运行。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["loaves"],</span></div><div class="line"><span class="comment">%  ["the"],</span></div><div class="line"><span class="comment">%  ["France."],</span></div><div class="line"><span class="comment">%  ["England;"],</span></div><div class="line"><span class="comment">%  ["comparison"],</span></div><div class="line"><span class="comment">%  ["its"],</span></div><div class="line"><span class="comment">%  ["despair,"],</span></div><div class="line"><span class="comment">%  ["hope,"],</span></div><div class="line"><span class="comment">%  ["Darkness,"],</span></div><div class="line"><span class="comment">%  ["Light,"],</span></div><div class="line"><span class="comment">%  ["incredulity,"],</span></div><div class="line"><span class="comment">%  ["belief,"],</span></div><div class="line"><span class="comment">%  ["foolishness,"],</span></div><div class="line"><span class="comment">%  ["wisdom,"],</span></div><div class="line"><span class="comment">%  ["times,"],</span></div><div class="line"><span class="comment">%  ["times,"]]</span></div></pre></td></tr></table></figure>
<p>我们看到结果是一个由变量匹配数据的列表组成的列表，在本例子中，就是 ‘$1’ 匹配的。</p>
<p>为了好玩和探索，让我们确认一下在我们的双城记介绍文本里跟在 it 后面的词都有什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"it"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"]]</span></div></pre></td></tr></table></figure>
<p>就是一堆 was ，这刚好是这本书的头两段里的情况。</p>
<p>然后我们仔细检查看看跟在 Scrooge 后的词是什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"Scrooge"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>如果我们想得到整个元组，我们应该用 ets:match_object/2 ，它将返回满足匹配的整个对象。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者，在这个例子里，我们可以用 ets:lookup/2 ，它将返回所有键匹配的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>所以为了采取一个从马尔科夫链简短绕道的例子，为什么我们想要使用 ets:lookup/2 或 ets:match_object/2 而不是其它函数？为了回答这个问题我们用一个例子，让我们添加另一种数据到我们的马尔科夫链表里，它是一个三元素元组。</p>
<p>To start with, we will insert 100_000 items into our ETS tables and see what the resulting memory size becomes. We will insert a new tuple of {X, X}, for all numbers from 1 to 100_000.（译者注：这一段应该是作者手误，从另外一篇文章错误地拷贝粘贴过来的，这一段和本文无关。）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(WordPairs, &#123;<span class="string">"of"</span>, <span class="string">"times,"</span>, <span class="string">"it"</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>如果我们调用 ets:lookup/2 ，我们将得到指定键的所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>,<span class="string">"it"</span>&#125;]</div></pre></td></tr></table></figure>
<p>但是如果我们用 ets:match_object/2 ，并且用了一个两元组，因为我们只是想得到词对，我们在结果里将不会得到那个三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '_'&#125;).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;]</div></pre></td></tr></table></figure>
<p>回到马尔科夫链的场景，我们可以开始看看我们是怎样遵循马尔科夫链规则能够获得一些文本。</p>
<p>我们从一个给定的词得到匹配的潜在的词，并且我们从后续词列表里均匀随机抓取一个结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PotentialChoices = ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line">[NextWord] = lists:nth(random:uniform(length(PotentialChoices)), PotentialChoices).</div></pre></td></tr></table></figure>
<p>我们可以写一个函数，让它重复上面的这些步骤，直到终结为止。一些终结状态的例子应该是一个词而且没有后续词；我们得到一定数量的词来拼装我们的文本；或者我们得到一定的总长度，使得它符合社交网络和Tweet的要求。</p>
<p>本文里，我们已经开始将一些“真实”的数据加入ETS里，并且为一些给定的模式来匹配数据。下个星期我们将继续看看在这个例子里用其它方式从我们ETS表取出数据放到一些地方，在那里这些数据可能被更好的消费。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-data-matching/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-data-matching/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第五篇：keypos，compressed，read_conncurrency 和 write_concurren]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-5-keypos-compressed-read-conncurrency-and-write-concurrency/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且就<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">上星期我所预告的</a>，要研究ETS表的 keypos 设置以及其他一下设置。</p>
<p>首先我们来看看 keypos 设置。</p>
<a id="more"></a>
<p>keypos是被存储的元组的基于1的索引，并且将被作为表的数据项的键。如果你记得我们<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">第三篇介绍ETS的关于不同表类型的文章</a>所描述，表用这个索引作为它们的键进行比较来决定数据是否唯一。</p>
<p>如果我们创建一个新表而不指定它的 keypos 选项，则 keypos 默认是1。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>为了显示keypos的作用，我们将创建一些数据插入到我们的ETS表，这样我们就能看到keypos的作用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div><div class="line">Item4 = &#123;a, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;a,"a"&#125;</span></div><div class="line">Item5 = &#123;<span class="string">"a"</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;"a",a&#125;</span></div></pre></td></tr></table></figure>
<p>上述数据，我们在二元素元组里既有第一元素重复的也有第二元素重复的。</p>
<p>我们将继续依次把所有元素插入表中，我们要记住这个表是set类型的，所以任何新数据插入都会覆盖与它有相同键的前面插入的数据值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ets:insert(Table, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(Table, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;"a",a&#125;,&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们如上例子插入Item3，它覆盖表中的Item1，因为它们的元组第一个元素都是1。</p>
<p>我们现在创建一个kepos是2的新表，然后看看按上述例子同样的步骤来插入数据会有什么样的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">KeyPosTwo = ets:new(key_pos_2, [&#123;keypos, <span class="number">2</span>&#125;]).</div><div class="line"><span class="comment">% 24595</span></div><div class="line">ets:insert(KeyPosTwo, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;"a",a&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，当插入Item4时，就发生了覆盖，因为Item2和Item4的第二个元素都是“a”。然后插入Item5时，会覆盖Item1，因为它们的第二个元素都是原子a。</p>
<p>如果我们设置的keypos是其他值，比如说3，然后我们尝试插入一个元素小于3的元组，我们会得到一个bag argument异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">KeyPosThree = ets:new(key_pos_3, [&#123;keypos, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% 28692</span></div><div class="line">ets:insert(KeyPosThree, Item1).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(28692,&#123;1,a&#125;)</span></div></pre></td></tr></table></figure>
<p>现在我们来看看创建表的时候用compressed选项。</p>
<p>当创建一个新表，默认是不压缩的，因为我们可以从下面例子里看到表信息显示{compressed, false}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UncompressedTable = ets:new(uc, []).</div><div class="line"><span class="comment">% 32786</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新表，用了compressed选项，然后用ets:info/1查看表信息，我们看到{compressed, true}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CompressedTable = ets:new(uc, [compressed]).</div><div class="line"><span class="comment">% 45074</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>至少根据官方文档的说法，compressed选项会使得数据以更压缩的格式存储而减少内存的消耗。文档也警告这也会造成获取元素元组的操作更慢，并且键是不压缩存储的，至少在当前的版本里是这样。</p>
<p>让我们来看看compressed对内存的消耗有什么样的不同。</p>
<p>我们将给两种表分别插入100000条记录，然后看它们的内存大小。插入纪录的格式是{X, X}，X从1到100000。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,714643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,814643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>有意思！</p>
<p>压缩表的内存大小是814643，而非压缩表的内存大小却小一点，是714643。</p>
<p>可能是对整数值的压缩效果不好，所以我们再做一次，这次是用字符串替换元组的第二个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,914644&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,1692433&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>用字符串替换元素第二元素后，压缩表内存大小是914644，而非压缩表的内存大小是1692433。</p>
<p>所以当你要决定是否使用压缩表的时候除了要更仔细的考虑你将用何种方式如何匹配数据外，你还要考虑你将要放入ETS表的数据是什么样的类型。</p>
<p>最后两个要讨论的选项是 read_concurrency 和 write_concurrency。</p>
<p>read_concurrency 默认被设置为false，根据官方文档的说法这个选项在“读比写操作频繁很多，或者当并发读写的量非常巨大的时候”最适合设置为true。</p>
<p>因此如果你有一个表有大量的读操作，而写操作零零散散，这个时候你应该设置read_concurrency为true，因为官方文档的说法是在读和写之间切换是很昂贵的。</p>
<p>write_concurrency 默认被设置为false，这会使得当一个写操作正在进行的时候会造成其它并发的写操作阻塞。当把该选项设置为true，则同一个表的不同的元组可以通过并发进程写入，并且不影响任何ordered_set类型表。</p>
<p>ETS的一系列介绍文章到此告一段路。下星期我们将开始研究用ETS和ETS表进行不同的操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第四篇：ETS的访问保护]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-4-ets-access-protections/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并研究ETS支持的不同访问级别。</p>
<p>ETS支持的不同访问级别：public，protected和private。</p>
<a id="more"></a>
<p>在创建一个新ETS表的时候可以传入不同访问类型的任意一个，不过我们先看看当我们不指定访问级别的时候ETS表的访问级别是哪一个？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20501</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>从上面的输出可以看到不指定访问级别的话默认就是protected。</p>
<p>那么一个ETS表是被保护的意味着什么呢？官方文档说明被保护的表只可以被所有者进程写入，但是其他进程可以读取。</p>
<p>现在让我们一起看看它是如何工作的。</p>
<p>首先我们创建一个进程以便我们可以把ETS表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的ETS表并指定它是被保护的，同时也指定它是有名字的以方便后续操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ProtectedNamedETS = ets:new(protected_named_ets, [protected, named_table]).</div><div class="line"><span class="comment">% protected_named_ets</span></div></pre></td></tr></table></figure>
<p>函数的输出是 protected_name_ets 而不是像前面调用 ets:new/2 那样输出的是数字，这样一来我们能够用表的名字替代表标识码访问这个表。</p>
<p>我们将插入一条数据到这个ETS表里，并且我们将用这个ETS表的名字作为它的引用因为我们创建表的时候指定了 named_table 选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;foobar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>ets:insert/2 返回true，那么现在我们应该有一些数据在表里。让我们用ets:match/2把数据取出来，而且通过用一个$1的模式匹配出所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>那么作为这个ETS表的所有者进程，因为这个表是由这个进程创建的，所有我们能读写这个表。</p>
<p>现在我们把这个表转移给另外的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(protected_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>既然官方文档说表是可读的，我们在刚刚转移所有权后做同样的match操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>我们读取到我们的数据。<br>那么尝试写会发生什么？因为官方文档说只有所有者进程才能有写的权限，并且在调用 ets:insert/2 的时候总是返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;barbaz, foo&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(protected_named_ets,&#123;barbaz,foo&#125;)</span></div></pre></td></tr></table></figure>
<p>上面的例子返回了一个异常，异常的类型是 bag argument，也就是说它不允许非所有者进程写数据入表，但是这个异常没有确切地说明到底发生了什么。</p>
<p>如果我们尝试调用 ets:insert/2 往不存在的表插入数据将会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(no_such_table, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(no_such_table,&#123;foo,bar&#125;)</span></div></pre></td></tr></table></figure>
<p>一样的异常和一样的错误提示格式，仅仅是表名和元组不同。</p>
<p>仔细想想这些现象，这两种不同的情况有一样的错误是有意义的。当一个进程尝试去做一个插入而如果没有表存在或者如果表被设置为 protected，则就是要让正在调用插入动作的这个进程知道这样的表不存在。总之，就是调用者将一个错的ETS表的引用传给ets:insert/2 。</p>
<p>所以我们现在已经知道 protected 的行为，它是默认的访问级别，那么下面让我们看看 public 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PublicNamedETS = ets:new(public_named_ets, [public, named_table]).</div><div class="line"><span class="comment">% public_named_ets</span></div></pre></td></tr></table></figure>
<p>我们将从我们当前的进程，也就是表的所有者插入一条数据并且获取所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;]]</span></div></pre></td></tr></table></figure>
<p>一切正常。</p>
<p>官方文档说public的表允许任何进程读和写，所以让我们把这个public表转给进程 SomeProcess 并且尝试去读和写。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(public_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在我们已经将表转移出去，是时候来尝试添加一条新的数据到表里，同时来看看我们能否将写入的内容读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;bar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;],[&#123;bar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>完全没问题。我们已经插入新数据到那个表里，并且当我们调用 ets:match/2 获取所有数据的时候，我们看到新数据在结果集里。</p>
<p>现在让我们创建一个 private 表。官方文档说对于 private 的ETS表，只有表的所有者才被允许读写这个ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PrivateNamedETS = ets:new(private_named_ets, [private, named_table]).</div><div class="line">private_named_ets</div></pre></td></tr></table></figure>
<p>当进程还拥有这个表的时候，我们添加一条数据并读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;fizz, buzz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;fizz,buzz&#125;]]</span></div></pre></td></tr></table></figure>
<p>然后我们又把表转移给进程 SomeProcess。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(private_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在这个ETS表属于另一个进程了，我们再来尝试读取它的数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:match/2</span></div><div class="line"><span class="comment">%         called as ets:match(private_named_ets,'$1')</span></div></pre></td></tr></table></figure>
<p>又是 bad argument 异常，就像前面例子我们尝试在一个 protected ETS表上用 ets:insert/2 函数，而当时那个表属于另外一个进程。<br>再来看看写的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;buzz, fizz&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(private_named_ets,&#123;buzz,fizz&#125;)</span></div></pre></td></tr></table></figure>
<p>也是 bad argument 异常，现在这样的情况不会让人奇怪了，因为 protected 表的写以及这个 private 表的读都造成一样的异常。</p>
<p>总之，在所有到目前为止的ETS的介绍文章里，我们已经见过了ETS表的类型、访问级别、表命名、继承人和所有者这些属性的设置以及它们之间的关系。</p>
<p>下星期，我们将通过介绍ETS表的键位置的设置和其他一些设置来结束ETS介绍系列文章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第三篇：ETS表类型]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-3-ets-table-types/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且研究一下ETS支持的不同存储策略类型。</p>
<p>ETS支持的不同存储类型是：set，ordered_set，bag，和duplicate bag。</p>
<a id="more"></a>
<p>每种类型都可以在创建一个新ETS表的时候传给创建函数，不过我们来看看创建ETS表的时候不指定任何类型的话ETS表是什么类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ETS_Empty = ets:new(ets_empty, []).</div><div class="line"><span class="comment">% 36886</span></div><div class="line">ets:info(ETS_Empty).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,ets_empty&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>上面的输出中，type 标签元组显示类型是 set。</p>
<p>为了研究不同类型的ETS表如何工作的，我们将创建三个元组加入不同ETS表里来看看它们是如何存储的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div></pre></td></tr></table></figure>
<p>我们有两个第一元素都是1的元组，还有一个第一元素是1.0的元组，这是为了看看在相同的键情况下不同类型ETS表如何处理。</p>
<p>为什么有1和1.0两个键？因为根据使用的比较操作符的不同，它们可以被看作相同的也可以被看作不相同的，所以把它们当作一种相同键的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> == <span class="number">1.0</span>.</div><div class="line"><span class="comment">% true</span></div><div class="line"><span class="number">1</span> =:= <span class="number">1.0</span>.</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>首先我们看看一个set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Set = ets:new(ets_set, [set]).</div><div class="line"><span class="number">40978</span></div></pre></td></tr></table></figure>
<p>我们插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Set, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>set类型的ETS表把1和1.0当作不同的键。那么我们插入Item3也就是插入一个已经存在的键会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>原先1为键的元组已经被我们刚刚插入的Item3元组替换了。</p>
<p>我们再来看看ordered_set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_OrdSet = ets:new(ets_ordset, [ordered_set]).</div><div class="line"><span class="comment">% 45075</span></div></pre></td></tr></table></figure>
<p>我们还是插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_OrdSet, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，1.0被认为和先插入的1是相等的，所以它覆盖了第一个插入的元素。</p>
<p>我们再插入Iterm3，结果是它也覆盖了1.0那个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们来看看bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Bag = ets:new(ets_bag, [bag]).</div><div class="line"><span class="comment">% 49172</span></div></pre></td></tr></table></figure>
<p>我们还是给表里加入Item1和Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Bag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>从 ets:tab2list/1 的输出我们看到bag类型的ETS表把Item1和Item2当作两个不同的元素。</p>
<p>再将Item3加入表里看看会有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>在这个bag类型的ETS表中，我们有了Item2以及Item1和Item3三个元素，甚至Item1和Item3有相同当键。</p>
<p>最后我们来看看duplicate_bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_DupBag = ets:new(ets_dupbag, [duplicate_bag]).</div><div class="line"><span class="comment">% 53269</span></div></pre></td></tr></table></figure>
<p>像前面几种类型的ETS表一样，我们插入Item1再插入Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_DupBag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>也和前面的例子一样，我们接着插入Item3。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是我们在这个duplicate_bag表中有所有三个元素。</p>
<p>如果我们比较bag和duplicate_bag两种表，我们发现它们似乎有一样的行为。</p>
<p>那么它们两者之间有什么不同呢？</p>
<p>如果你深入挖掘官方文档，仔细阅读 ets:new/2 函数中关于表类型的描述，它说明一个bag表允许有重复键，但是只不允许两个一样的一个元素存在，而duplicate_bag允许相同元素存在即时它们的键值都相同。</p>
<p>为验证这个结论，我们往bag表和duplicate_bag表都加入Item1，看看结果是什么。</p>
<p>首先是bag表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果和原来没有不同，所以往bag里添加已经存在的元素不会改变表的内容。</p>
<p>那么duplicate_bag表呢？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是元组{1, a}有两份，因为我们调用 ets:insert/2 将这个元素插入了两次。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第二篇]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍 <a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 模块以及ETS的概况。</p>
<p>上次我们看到ETS表在其父进程崩溃的时候被删除了，那么问题来了，我们怎么能够在其父进程崩溃的时候依然保持ETS表活着呢？</p>
<a id="more"></a>
<p>为解决这个问题，我们将研究函数 ets:give_away/3 以及在创建表的时候指定的参数 heir 。</p>
<p>首先我们创建一个函数，它将代表一个进程，而我们可以将表的所有权赋予它的。这个函数只是等待消息而且永远不超时。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div></pre></td></tr></table></figure>
<p>现在我们创建一个运行该函数的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Process = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.53.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个新的ETS表，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(table, []).</div><div class="line"><span class="comment">% 20498</span></div></pre></td></tr></table></figure>
<p>并且将它赋予我们刚刚创建的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(Table, Process, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我查看表信息可以看到表的所有者是我们创建的进程，因为这个进程的PID和表消息里的所有者元组的PID一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.53.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们已经进行了所谓的所有权转移，那么是时候将原来的所有者进程也就是我们当前的shell进程崩溃掉。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.58.0&gt;</div></pre></td></tr></table></figure>
<p>我们检查我们创建的进程是否还活着，绝大多数情况下应该是活着的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">is_process_alive</span><span class="params">(Process)</span>.</span></div><div class="line">% <span class="title">true</span></div></pre></td></tr></table></figure>
<p>在检查表的信息，看看它是否还活着。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.53.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>它依然还活着！！！我们已经转移了所有权，所以如果我们自己的进程崩溃的话，ETS表依然是活着的。</p>
<p>是时候杀掉那个进程了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exit</span><span class="params">(Process, <span class="string">"Because"</span>)</span>.</span></div><div class="line">% <span class="title">true</span></div><div class="line"><span class="title">is_process_alive</span><span class="params">(Process)</span>.</div><div class="line">% <span class="title">false</span></div></pre></td></tr></table></figure>
<p>然后表就消失了…</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% undefined</span></div></pre></td></tr></table></figure>
<p>这一次，让我们在创建一个ETS表的时候用 heir 选项，来利用ETS表的所有权转移给一个继承人的魔法。</p>
<p>在这次场景里，当所有者进程死掉的时候shell将是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TableWithHeir = ets:new(table, [&#123;heir, self(), <span class="string">"something went wrong"</span>&#125;]).</div><div class="line"><span class="comment">% 24594</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的进程，然后将ETS表的所有权赋予这个新的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Process2 = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.71.0&gt;</span></div><div class="line">ets:give_away(TableWithHeir, Process2, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们检查表的信息，我们可以看到表的所有者是新的进程，而它的继承人是我们当前的shell进程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">self().</div><div class="line">% &lt;0.58.0&gt;</div><div class="line">ets:info(TableWithHeir).</div><div class="line">% [&#123;read_concurrency,false&#125;,</div><div class="line">%  &#123;write_concurrency,false&#125;,</div><div class="line">%  &#123;compressed,false&#125;,</div><div class="line">%  &#123;memory,349&#125;,</div><div class="line">%  &#123;owner,&lt;0.71.0&gt;&#125;,</div><div class="line">%  &#123;heir,&lt;0.58.0&gt;&#125;,</div><div class="line">%  &#123;name,table&#125;,</div><div class="line">%  &#123;size,0&#125;,</div><div class="line">%  &#123;node,nonode@nohost&#125;,</div><div class="line">%  &#123;named_table,false&#125;,</div><div class="line">%  &#123;type,set&#125;,</div><div class="line">%  &#123;keypos,1&#125;,</div><div class="line">%  &#123;protection,protected&#125;]</div></pre></td></tr></table></figure>
<p>现在再次杀掉所有者进程了……</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exit</span><span class="params">(Process2, <span class="string">"Because"</span>)</span>.</span></div><div class="line">% <span class="title">true</span></div><div class="line"><span class="title">is_process_alive</span><span class="params">(Process2)</span>.</div><div class="line">% <span class="title">false</span></div></pre></td></tr></table></figure>
<p>我们在检查表的信息，我们可以看到当前的shell进程既是所有者又是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableWithHeir).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,349&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的进程，然后我们把表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Process3 = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.78.0&gt;</span></div><div class="line">ets:give_away(TableWithHeir, Process3, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>所有者变成了新的进程，我们当前的shell进程依然是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableWithHeir).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,349&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.78.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>通过利用指定继承人的能力，同时用 ets:give_away/3 函数，我们可以帮助ETS表长生不死。</p>
<p>一种可能利用的方式是，我们有一个监督进程，它创建一个“继承人”进程，然后创建一个子进程，这个子进程拥有ETS表，如果这个子进程死掉，它将转移所有权给继承人进程。直到新的所有者进程被重新创建，然后继承人进程便可以将ETS表的所有权转移给这个新创建的进程。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第一篇]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday开始介绍 <a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 模块以及ETS的概况。</p>
<p>ETS是 Erlang Term Storage的缩写，是Erlang term（各种Erlang数据类型）的内存存储，它提供对存储的数据恒定的访问时间。</p>
<a id="more"></a>
<p>ETS可以被认为是一种键值对存储类型的存储，并且它用表的概念来组织数据。</p>
<p>第一个很有用的知识点是，ETS表是被一个进程创建的，这个表的创建者就是这个表的所有者，除非它把表转移给别的进程。</p>
<p>一旦所有者进程死掉，这个表也就被删除，而且再也不能被访问。</p>
<p>让我们看一下这会是什么样子。</p>
<p>首先，在启动了一个新的Erlang shell后，我们先看看我们所在shell的PID（进程标识符）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.34.0&gt;</div></pre></td></tr></table></figure>
<p>接着创建一个新的ETS表。我们在以后的文章里会专门详细介绍各种创建新表的方式，而今天我们只是仅仅指定一个名字和一个空的参数列表来创建一个新表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TableId = ets:new(table, []).</div><div class="line"><span class="comment">% 20496</span></div></pre></td></tr></table></figure>
<p>获得表的id后，我们用 ets:info/1 函数来看看表的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableId).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.34.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>是时候来让所有者进程崩溃了。在这个场景，我们用一个错误的模式匹配来引起一个错误匹配异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div></pre></td></tr></table></figure>
<p>现在我们检查PID变量和当前shell的进程是否匹配来证实Erlang真的启动了一个新的shell进程让我们使用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.40.0&gt;</div></pre></td></tr></table></figure>
<p>很明显，当前的shell的PID和我们第一次调用self()获得的PID不一样。</p>
<p>再来看看我们刚才创建的表的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:info(TableId).</div><div class="line"><span class="comment">% undefined</span></div></pre></td></tr></table></figure>
<p>结果是 undefined 。因此我们再也找不到那个表id所指的表了。</p>
<p>接下来我们用 ets:all/0 是否能看到虽然用 ets:info/1 找不到的表在某个地方藏着呢。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>还是没找到。让我们用和前面同样的名字创建另外一个表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Table2Id = ets:new(table, []).</div><div class="line"><span class="comment">% 24592</span></div></pre></td></tr></table></figure>
<p>创建成功而且没有报这个名字已经存在的错误。</p>
<p>我们再用 ets:all/0 来看看，这回能看到刚才 ets:new/2 返回的id。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [24592,8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>我们再让shell崩溃一次。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div></pre></td></tr></table></figure>
<p>我们注意到我们又有了新的shell进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.47.0&gt;</div></pre></td></tr></table></figure>
<p>如果我们再调用 ets:all/0 ，前面我们刚刚创建的表的id又没有了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>上述就是我们对ETS的初始印象，我们演示了所有者进程崩溃会删除表，我们也预览了ets模块的一些函数，特别是 ets:new/2 ，ets:info/1 和 ets:all/0 。</p>
<p>我们将继续在后面几篇文章里浏览ETS，并且在大概预览一些ets模块的函数后，我们会深入研究ets模块里与众不同的函数。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:del_path/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-del-path-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#del_path-3" target="_blank" rel="external">digraph:del_path/3</a>.</p>
<p>我们继续使用上次文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a>  一样的有向图。</p>
<a id="more"></a>
<p><img src="/images/digraph-del-path01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>digraph:del_path/3 有三个入参，一个有向图，一个源节点，一个目标节点，函数将删除有向图中从源节点到目标节点的每一条路径上的所有边，直到源节点和目标节点之间没有路径为止。</p>
<p>digraph:del_path/3 的返回值总是true。</p>
<p>我们将调用 digraph:del_path/3 传入上面例子的有向图，节点V1作为源节点，节点V4作为目标节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:del_path(Graph, V1, V4).</div><div class="line"><span class="comment">% true</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],['$v'|3]]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|4]]</span></div></pre></td></tr></table></figure>
<p>根据边的名字来看，从节点1到节点2点边已经被删除，从节点2到节点4点边也被删除。</p>
<p>那么Erlang是怎么得到这样的结果的？</p>
<p>它的结果一开始让我困惑，因为结果并不是我所预期的两种结果之一。我预期的结果是：除了从节点4到节点1的边其他边全部删除，或者仅删除从节点1到节点2的边。</p>
<p>为了解惑，我找到托管在Github上的Erlang源码来阅读 <a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/stdlib/src/digraph.erl" target="_blank" rel="external">digraph</a> 模块，在代码里我终于明白了其中缘由。</p>
<p>首先 digraph:del_path 调用 digraph:get_path/3 ，并且删除路径上所有的边，然后递归执行直到没有再找到路径。</p>
<p>这就是为什么Erlang只删除那些边对原因。</p>
<p>当我们在原始样例有向图上调用 digraph:get_path/3 ，我们得到的路径是 V1 -&gt; V2 -&gt; V4 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">digraph:get_path(Graph, V1, V4).</div><div class="line">[['$v'|<span class="number">0</span>],['$v'|<span class="number">1</span>],['$v'|<span class="number">3</span>]]</div></pre></td></tr></table></figure>
<p>Erlang将路径里的边都删除，然后再递归调用 digraph:del_path/3 ，而这个函数再一次调用 digraph:get_path/3 ，但是因为节点1和节点2之间的边已经被删除，所以没有找到路径，整个处理过程就此结束。</p>
<p>这就是为什么我们看到更多的边被删除，如果我们再次重置样例有向图（退出erlang shell，然后重新打开一个erlang shell，把初始化样例有向图的语句重新执行一遍），然后将节点2和节点4传给 digraph:del_path/3 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:del_path(Graph, V2, V4).</div><div class="line"><span class="comment">% true</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|0],['$e'|4]]</span></div></pre></td></tr></table></figure>
<p>这个场景有两个路径：V2 -&gt; V4 和 V2 -&gt; V3 -&gt; V4 ，如果我们删除路径V2 -&gt; V4路径，与这条路径的所有相关的边都被删除但是不会中断路径V2 -&gt; V3 -&gt; V4，所以函数也可以删除这条路径上的所有边。</p>
<p>所以在官方文档没有很清晰说明白函数内部机制的这个场景，我们可以通过开源的Erlang标准库来彻底了解其中奥妙，因为我们可以获取Erlang的源码来研究它底层的实现机制。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-del_path-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-del_path-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:get_cycle/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-get-cycle-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#get_cycle-2" target="_blank" rel="external">digraph:get_cycle/2</a>.</p>
<p>我们将继续在上一篇文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a> 用的有向图上讲解。</p>
<a id="more"></a>
<p><img src="/images/digraph-get-cycle01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>digraph:get_cycle/2 两个入参分别是一个有向图G，一个节点V，该函数尝试在有向图中找到一条路径使得节点V在其中并且形成一个环。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:get_cycle(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_cycle(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3],['$v'|0],['$v'|1]]</span></div></pre></td></tr></table></figure>
<p>接着我们增加一个新节点V5，并且新增一条从节点V4发出到节点V5的边。</p>
<p>然后我们调用 digraph:get_cycle/2 第二个入参是V5，我们会得到一个false，因为在图中没有一个环使得V5在其中。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">V5 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">E6 = digraph:add_edge(Graph, V4, V5).</div><div class="line"><span class="comment">% ['$e'|5]</span></div><div class="line">digraph:get_cycle(Graph, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>digraph模块还有一个函数 <a href="http://www.erlang.org/doc/man/digraph.html#get_short_cycle-2" target="_blank" rel="external">digraph:get_short_cycle/2</a> 。</p>
<p>digraph:get_short_cycle/2 尝试为节点V在图G中找到一条最短的环。</p>
<p>官方文档解释 digraph:get_short_cycle/2 的原话是：</p>
<p>尝试在有向图G上找到尽可能短的通过节点V的简单环。</p>
<p>因此这取决于你如何理解这句话，可能不能保证返回最短的环，而只是返回更短的一个环，这可能取决于有向图的整体大小和复杂度。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:get_short_cycle(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_short_cycle(Graph, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-get_cycle-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-get_cycle-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:in_neighbors/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-in-neighbors-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#in_neighbors-2" target="_blank" rel="external">digraph:in_neighbors/2</a>.</p>
<p>digraph:in_neighbors/2 第一个入参是一个有向图G，第二个入参是一个节点V，函数将返回一个由若干节点组成的列表，而且有从这些节点发出并进入节点V的边。</p>
<a id="more"></a>
<p>我们继续用上个星期的文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a> 里的例子基础上进行讲解。</p>
<p><img src="/images/digraph-in-neighbors01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>图和相关元素都设置好后，我们可以开始在我们的图里找不同节点的入站邻居节点 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:in_neighbours(Graph, V4).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|2]]</span></div><div class="line">digraph:in_neighbours(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|3]]</span></div><div class="line">digraph:in_neighbours(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|0]]</span></div></pre></td></tr></table></figure>
<p>上述输出我们可以看到对于节点4函数返回值是[[‘$v’ | 1],[[‘$v’ | 2]]]，也就是节点2和节点3。对于节点1，我们得到一个 inbound 邻居节点4，而对于节点2，我们得到inbound邻居节点1。</p>
<p><strong>digraph:out_neighbors/2</strong></p>
<p>digraph模块也包含函数 <a href="http://www.erlang.org/doc/man/digraph.html#out_neighbours-2" target="_blank" rel="external">digraph:out_neighbors/2</a> ，它的返回值是由从入参节点发出的边相应的所有节点组成的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:out_neighbours(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|3],['$v'|2]]</span></div><div class="line">digraph:out_neighbours(Graph, V4).</div><div class="line"><span class="comment">% [['$v'|0]]</span></div><div class="line">digraph:out_neighbours(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|1]]</span></div></pre></td></tr></table></figure>
<p>我们从上图看到节点2有“指向”节点3和节点4的边，而我们再看 digraph:out_neighbors/2 的输出，得到的结果就是节点3和节点4。</p>
<p>这个例子里我们得到的节点列表是节点4在节点3点前面，但是这个顺序是不确定的，正如官方文档所讲的，“边是没有特定的顺序的”，这个情况对于 digraph:in_neighbors/2 也一样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-in_neighbors-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-in_neighbors-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:get_path/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-get-path-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#get_path-3" target="_blank" rel="external">digraph:get_path/3</a>.</p>
<p>digraph:get_path/3 接收三个入参，一个有向图，一个开始节点和一个结束节点，该函数将尝试在图中找到一些大于0的路径，在路径里除了允许第一个节点和最后一个节点相同，其他所有的节点都不能相同。</p>
<a id="more"></a>
<p>如果找到一个路径，函数将返回一个在路径中按顺序被访问到的节点所组成的列表，如果找不到路径，函数将返回false。</p>
<p>首先我们创建一个新的有向图以便我们可以遍历它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>上述语句将给我们一个如下的有向图：</p>
<p><img src="/images/digraph-get-path01.png" alt="有向图"></p>
<p>现在我们可以使用 digraph:get_path/3 函数来看看图中任何两个节点间有什么路径。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">digraph:get_path(Graph, V2, V3).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|2]]</span></div><div class="line">digraph:get_path(Graph, V2, V4).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3]]</span></div><div class="line">digraph:get_path(Graph, V2, V1).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_path(Graph, V3, V1).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_path(Graph, V1, V4).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3]]</span></div><div class="line">digraph:get_path(Graph, V1, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div></pre></td></tr></table></figure>
<p>注意：上述结果中只是碰巧有最短的路径，但是该函数并不保证最短路径是第一个返回的路径。</p>
<p>如果我们新增加一个节点，但是没有将它和其他节点连接起来，然后我们就调用 digraph:get_path/3 来获取与它相关的路径，那么函数会返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">V5 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">digraph:get_path(Graph, V1, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-get_path-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-get_path-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:add_edge/4]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-add-edge-4/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#add_edge-4" target="_blank" rel="external">digraph:add_edge/4</a>.</p>
<p>digraph:add_edge/4 第一个入参是一个有向图，第二个入参是原节点（<a href="http://www.erlang.org/doc/man/digraph.html#emanate" target="_blank" rel="external">发出节点</a>），第三个入参是目标节点（<a href="http://www.erlang.org/doc/man/digraph.html#incident" target="_blank" rel="external">接收节点</a>），最后一个入参是一个标签。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">Vertex1 = digraph:add_vertex(Graph, foo).</div><div class="line"><span class="comment">% foo</span></div><div class="line">Vertex2 = digraph:add_vertex(Graph, bar).</div><div class="line"><span class="comment">% bar</span></div><div class="line">Edge1 = digraph:add_edge(Graph, Vertex1, Vertex2, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|0]]</span></div><div class="line">Edge2 = digraph:add_edge(Graph, Vertex2, Vertex1, &#123;bar, foo&#125;).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|0]]</span></div></pre></td></tr></table></figure>
<p>digraph模块也有 digraph:add_edge/5 函数，它允许你指定边的标识符，下面的例子我给一条边的标识符是 myEdge 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:add_edge(Graph, myEdge, Vertex2, Vertex1, myLabel).</div><div class="line"><span class="comment">% myEdge</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|3],myEdge,['$e'|0]]</span></div></pre></td></tr></table></figure>
<p>另外 digraph:add_edge/3 函数则允许你不指定边或者标签。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:add_edge(Graph, Vertex2, Vertex1).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">digraph:add_edge(Graph, Vertex2, Vertex1).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|3],['$e'|0]]</span></div></pre></td></tr></table></figure>
<p>如果你注意到上述的 digraph:add_edge/3 和 digraph:add_edge/5 函数的例子中，我们给同样的发出节点和接收节点增加几个边，函数都很乐意地为我们创建这些边。</p>
<p>我们也可以通过指定 acyclic 参数给 digraph:new/1 来创建一个无循环有向图。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Graph2 = digraph:new([acyclic]).</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,false&#125;</span></div><div class="line">VertexA = digraph:add_vertex(Graph2, foo).</div><div class="line"><span class="comment">% foo</span></div><div class="line">VertexB = digraph:add_vertex(Graph2, bar).</div><div class="line"><span class="comment">% bar</span></div><div class="line">EdgeAB = digraph:add_edge(Graph2, VertexA, VertexB, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">EdgeBA = digraph:add_edge(Graph2, VertexB, VertexA, &#123;bar, foo&#125;).</div><div class="line"><span class="comment">% &#123;error,&#123;bad_edge,[foo,bar]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>当我们想创建一条边从而在一个无循环有向图里创建一个环的时候，我们将得到一个带有指定边的 bad_edge 错误。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-add_edge-4/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-add_edge-4/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:add_vertex/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-add-vertex-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday如上星期保证的开始深入digraph模块，今天讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#add_vertex-1" target="_blank" rel="external">digraph:add_vertex/1</a>.</p>
<p>首先我们创建一个新的有向图以便我们可以往里加节点。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div></pre></td></tr></table></figure>
<p>我们用 digraph:add_vertex/1 往此有向图里加入一些节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div></pre></td></tr></table></figure>
<p>因为我们没有指定我们想要加入的节点的任何信息，Erlang将为我们创建一个 [‘$v’ | I]格式的节点，它有一个空列表做为标签，I是一个非负整数。</p>
<p>如果我们希望提供节点标识符，我们也可以用 digraph:add_vertex/2 来添加一个节点，或者用 digraph:add_vertext/3 来提供节点标识符和标签。正如 digraph:add_vertex/1 ，digraph:add_vertex/2 也用空列表来做为标签。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:add_vertex(Graph, vertex1).</div><div class="line"><span class="comment">% vertex1</span></div><div class="line">digraph:add_vertex(Graph, vertex2, <span class="string">"Vertex 2"</span>).</div><div class="line"><span class="comment">% vertex2</span></div></pre></td></tr></table></figure>
<p>我们现在添加了5个节点，可以用 <a href="http://www.erlang.org/doc/man/digraph.html#vertices-1" target="_blank" rel="external">digraph:vertices/1</a> 来检查在这个有向图里有哪些节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],vertex2,vertex1]</span></div></pre></td></tr></table></figure>
<p>如果我们决定以 [‘$v’ | I]格式自己尝试添加一个节点，然后接着调用 digraph:add_vertex/1 ，那么我们可能会有麻烦。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">digraph:add_vertex(Graph, ['$v' | <span class="number">3</span>]).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],['$v'|3],vertex2,vertex1]</span></div><div class="line">digraph:add_vertex(Graph, ['$v' | <span class="number">4</span>]).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|4],</span></div><div class="line"><span class="comment">%  ['$v'|2],</span></div><div class="line"><span class="comment">%  ['$v'|1],</span></div><div class="line"><span class="comment">%  ['$v'|0],</span></div><div class="line"><span class="comment">%  ['$v'|3],</span></div><div class="line"><span class="comment">%  vertex2,vertex1]</span></div></pre></td></tr></table></figure>
<p>我们自己通过制定格式来添加一个节点，然后又让Erlang帮我们添加一个新的节点，那么最终的结果就是“丢失”一个节点，因为当我们看这个有向图的状态的时候可以看到原来是发生了覆盖的情况。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-add_vertex-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-add_vertex-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – The digraph module]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-the-digraph-module/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们开始看 <a href="http://erlang.org/doc/man/digraph.html" target="_blank" rel="external">digraph</a> 模块。</p>
<p>当我研究这个模块的时候，发现这个模块并不和我预料的Erlang行为一样，所以我想在研究它的函数前仔细看看它那些与众不同的地方。</p>
<a id="more"></a>
<p>如果我们查看所有digraph模块的函数，我们只能找到两个函数 digraph:new/0 和 digraph:new/1 返回 digraph 类型数据。</p>
<p>我想看看这个Erlang API有什么奇怪的，我打开Erlang shell，添加一个节点到有向图然后检查这个操作的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">G = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,69651,73748,77845,true&#125;</span></div><div class="line">G2 = digraph:add_vertex(G, foo, bar).</div><div class="line"><span class="comment">% foo</span></div></pre></td></tr></table></figure>
<p>调用 digraph:add_vertex/3 返回的结果是foo，也就是传给它的第二个入参，这个结果并不像一个有向图的样子。<br>那么，再回过头来看看变量G是否有变化。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">G.</div><div class="line"><span class="comment">% &#123;digraph,69651,73748,77845,true&#125;</span></div></pre></td></tr></table></figure>
<p>元组形式的结果看起来和原来一样，那么我们看看那个节点是否在图里，因为我们获得返回值是foo。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [foo]</span></div><div class="line">digraph:vertex(G, foo).</div><div class="line"><span class="comment">% &#123;foo,bar&#125;</span></div></pre></td></tr></table></figure>
<p>看来那个节点的确在图中。</p>
<p>让我们再加入另一个节点到与变量G绑定到图中。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">V = digraph:add_vertex(G).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [['$v'|0],foo]</span></div></pre></td></tr></table></figure>
<p>这个节点也添加成功。</p>
<p><strong>困惑所在</strong></p>
<p>所以在研究这个模块的函数之前在本文中我要重点讲出来的这个行为模式是这些函数在图中显而易见地展现了可修改的行为模式。</p>
<p>我说它是显而易见的可修改的，因为如果它在底层的实现上是不可修改的，结构可以改变同时绑定的变量的引用保持不变。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [['$v'|0],foo]</span></div><div class="line">Copy = G.</div><div class="line"><span class="comment">% &#123;digraph,69651,73748,77845,true&#125;</span></div><div class="line">V2 = digraph:add_vertex(G, wat).</div><div class="line"><span class="comment">% wat</span></div><div class="line">digraph:vertices(Copy).</div><div class="line"><span class="comment">% [['$v'|0],foo,wat]</span></div><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [['$v'|0],foo,wat]</span></div></pre></td></tr></table></figure>
<p>甚至其他变量引用也改变，所以它颠覆了我见过的在Erlang生态圈里关于所有数据是不可变的任何常规。</p>
<p>我们将在后续的<a href="http://www.proctor-it.com/tag/erlang-thursday/" target="_blank" rel="external">Erlang Thursday</a>文章中研究digraph模块的函数，但是我想花点时间讲这个模块中的可变性的内在本质，所以当你需要使用这个模块的时候，你一定要认识到如果不谨慎的话你想在你的应用的并发部分使用它将很危险。</p>
<p><strong>修改 (10月18日)</strong></p>
<p>做为 <a href="http://blog.lfe.io/tags.html#lfe%20friday-ref" target="_blank" rel="external">LFE Fridays</a> 的 <a href="http://blog.lfe.io/tutorials/2015/10/18/1701-lfe-friday---the-digraph-module/" target="_blank" rel="external">translation into Lisp Flavored Erlang</a> 的一部分，Robert Virding 告诉我这个模块的可变性的原因，这个内容也包含在他翻译本文的文章里。</p>
<p><strong>屠龙（解惑）</strong></p>
<p>这背后的原因是这个模块是如何实现的。一个 有向图 底层的实现上有三个 <a href="http://erlang.org/doc/man/ets.html" target="_blank" rel="external">ETS</a> 表。在上述例子里，这些表的id是 8207，12304和16401。你可以调用 ets:i/0 来看到，这个函数列出所有当前ets表。你可以看到那3个表属于Erlang shell进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; self().</div><div class="line">&lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line">&gt; ets:i().</div><div class="line"> id              name              type  size   mem      owner</div><div class="line"> ----------------------------------------------------------------------------</div><div class="line"> <span class="number">1</span>               code              set   <span class="number">282</span>    <span class="number">10393</span>    code_server</div><div class="line"> <span class="number">4098</span>            code_names        set   <span class="number">64</span>     <span class="number">7713</span>     code_server</div><div class="line"> <span class="number">8207</span>            vertices          set   <span class="number">3</span>      <span class="number">328</span>      &lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line"> <span class="number">12304</span>           edges             set   <span class="number">0</span>      <span class="number">305</span>      &lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line"> <span class="number">16401</span>           neighbours        bag   <span class="number">2</span>      <span class="number">319</span>      &lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line"> ac_tab          ac_tab            set   <span class="number">6</span>      <span class="number">839</span>      application_controller</div><div class="line"> file_io_servers file_io_servers   set   <span class="number">0</span>      <span class="number">305</span>      file_server_2</div><div class="line"> global_locks    global_locks      set   <span class="number">0</span>      <span class="number">305</span>      global_name_server</div><div class="line"> global_names    global_names      set   <span class="number">0</span>      <span class="number">305</span>      global_name_server</div><div class="line">...</div><div class="line"></div><div class="line">ok</div></pre></td></tr></table></figure>
<p>有向图它自己的结构仅是一个标签元组，包含着ets表id。所有的改变都发上在ETS表里，图的结构本身从未改变。表的数据和内容可以用 <a href="http://erlang.org/doc/man/ets.html#info-1" target="_blank" rel="external">ets:info/1</a> 和 <a href="http://erlang.org/doc/man/ets.html#i-1" target="_blank" rel="external">ets:i/1</a> 来读取。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-the-digraph-module/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-the-digraph-module/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tar:table/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tar-table-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/erl_tar.html#table-1" target="_blank" rel="external">erl_tar:table/1</a> 。</p>
<p>erl_tar:table/1 返回一个tar文件包含的文件名列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">erl_tar:table(<span class="string">"animal_sounds.tar"</span>).</div><div class="line"><span class="comment">% &#123;ok,["dog.txt","cat.txt","pony.txt","bear.txt"]&#125;</span></div><div class="line">还有一个版本 erl_tar:table/<span class="number">2</span> 多了一个选项列表入参。</div><div class="line">erl_tar:table(<span class="string">"animal_sounds.tar.gz"</span>, [compressed]).</div><div class="line"><span class="comment">% &#123;ok,["dog.txt","cat.txt","pony.txt","bear.txt"]&#125;</span></div><div class="line">erl_tar:table(<span class="string">"animal_sounds.tar.gz"</span>, [compressed,verbose]).</div><div class="line"><span class="comment">% &#123;ok,[&#123;"dog.txt",regular,5,</span></div><div class="line"><span class="comment">%       &#123;&#123;2015,9,23&#125;,&#123;22,18,47&#125;&#125;,</span></div><div class="line"><span class="comment">%       420,501,20&#125;,</span></div><div class="line"><span class="comment">%      &#123;"cat.txt",regular,5,&#123;&#123;2015,9,23&#125;,&#123;22,18,56&#125;&#125;,420,501,20&#125;,</span></div><div class="line"><span class="comment">%      &#123;"pony.txt",regular,8,&#123;&#123;2015,9,23&#125;,&#123;22,19,10&#125;&#125;,420,501,20&#125;,</span></div><div class="line"><span class="comment">%      &#123;"bear.txt",regular,19,</span></div><div class="line"><span class="comment">%       &#123;&#123;2015,9,23&#125;,&#123;22,21,16&#125;&#125;,</span></div><div class="line"><span class="comment">%       420,501,20&#125;]&#125;</span></div></pre></td></tr></table></figure>
<p>用verbose选项，我们得到元组的列表而不仅是得到文件名列表。</p>
<p>这个元组包括：文件名，文件类型（标准文件／目录或者符号链接），文件的字节数，时间戳元组，访问权限（用十进制表示而不是用8进制），用户id，组id。</p>
<p>官方文档并没有指定任何返回类型的信息，另外澄清420，501，20这些元素代表的意思的荣誉是全部属于Robert Virding，属于他把本篇文章翻译成 <a href="http://blog.lfe.io/tags.html#lfe%20friday-ref" target="_blank" rel="external">LEF Fridays</a> 的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-table-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-table-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tar:extract/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tar-extract-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erl_tar.html#extract-1" target="_blank" rel="external">erl_tar:extract/1</a> 。</p>
<p>erl_tar:extract/1 有一个入参，这个入参可能是一个二进制元组、文件描述符元组或是文件名，函数把tar文件的内容解压到当前目录。</p>
<a id="more"></a>
<p>由于我们需要一个tar文件来演示解压它，那么我们来创建一些文件并将它们加入一个新的tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"woof"</span> &gt; dog.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"meow"</span> &gt; cat.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"sparkle"</span> &gt; pony.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">'Wocka Wocka Wocka!'</span> &gt; bear.txt</div><div class="line">$ tar -cvf animal_sounds.tar dog.txt cat.txt pony.txt bear.txt</div><div class="line">a dog.txt</div><div class="line">a cat.txt</div><div class="line">a pony.txt</div><div class="line">a bear.txt</div></pre></td></tr></table></figure>
<p>接着我们也创建一个压缩版本的tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ tar -cvzf animal_sounds.tar.gz dog.txt cat.txt pony.txt bear.txt</div><div class="line">a dog.txt</div><div class="line">a cat.txt</div><div class="line">a pony.txt</div><div class="line">a bear.txt</div></pre></td></tr></table></figure>
<p>为了测试解压这两个tar文件，我们清空当前目录的已经加入tar文件的相关文件。</p>
<p>`` bash<br>$ rm dog.txt cat.txt pony.txt bear.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">确保我们准备好了用来试验的tar文件后，我们打开Erlang shell，然后调用 erl_tar:extract/1 函数。</div><div class="line"></div><div class="line">``` erlang</div><div class="line">erl_tar:extract(&quot;animal_sounds.tar&quot;).</div><div class="line">% ok</div></pre></td></tr></table></figure></p>
<p>看起来直截了当，我们回到命令行看看我们解压出来的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls dog.txt cat.txt pony.txt bear.txt</div><div class="line">bear.txt cat.txt  dog.txt  pony.txt</div><div class="line">$ rm dog.txt cat.txt pony.txt bear.txt</div></pre></td></tr></table></figure>
<p>确认文件后，为了试验，我们把它们删除继续下面的试验。</p>
<p><strong>erl_tar:extract/2</strong></p>
<p>Erlang还有一个 <a href="http://www.erlang.org/doc/man/erl_tar.html#extract-2" target="_blank" rel="external">erl_tar:extract/2</a> 函数，它允许我们通过提供一个列表做为它第二个入参来做为解压的选项。</p>
<p>我们可以用 erl_tra:extract/2 解压文件并让它在控制台打印相关的信息，并且可以增加指定另外的选项，不仅打印相关信息而且解压动作不重写已经存在的任何对应的文件。</p>
<p>`` erlang<br>erl_tar:extract(“animal_sounds.tar”, [verbose]).<br>% x /Users/proctor/tmp/dog.txt<br>%<br>% x /Users/proctor/tmp/cat.txt<br>%<br>% x /Users/proctor/tmp/pony.txt<br>%<br>% x /Users/proctor/tmp/bear.txt<br>%<br>% ok<br>erl_tar:extract(“animal_sounds.tar”, [verbose, keep_old_files]).<br>% x /Users/proctor/tmp/dog.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/cat.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/pony.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/bear.txt - exists, not created<br>%<br>% ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">接着还是回到命令行把解压出来的文件删除继续试验。</div><div class="line"></div><div class="line">``` bash</div><div class="line">$ rm dog.txt cat.txt pony.txt bear.txt</div></pre></td></tr></table></figure></p>
<p>接下来我们通过传入有原子 compressed 组成的列表做为第二个参数来解压 animal_sounds.tar.gz。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, compressed, keep_old_files]).</div><div class="line"><span class="comment">% x /Users/proctor/tmp/dog.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/cat.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/pony.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/bear.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>有些时候在你的程序中处理tar文件的时候，你不想必需要在文件系统下操作所有tar里的文件而只是读取tar文件的内容，所以有一个选贤可以让tar文件内容保存在内存中</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, compressed, keep_old_files, memory]).</div><div class="line"><span class="comment">% &#123;ok,[&#123;"dog.txt",&lt;&lt;"woofn"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"cat.txt",&lt;&lt;"meown"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"pony.txt",&lt;&lt;"sparklen"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"bear.txt",&lt;&lt;"Wocka Wocka Wocka!n"&gt;&gt;&#125;]&#125;</span></div></pre></td></tr></table></figure>
<p>当传入 memory 这个选项，erl_tar:extract/2 的返回值变为一个状态元组，其中有一个包含了被解压tar文件内每一个文件的文件名和它们的二进制内容组成的元组形成的列表。<br>如果一个错误在解压文件到内存的时候发生，比如我们忘了传入 compressed 选项给一个压缩tar文件，函数将返回一个错误元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, memory]).</div><div class="line"><span class="comment">% &#123;error,eof&#125;</span></div></pre></td></tr></table></figure>
<p>erl_tar:extract/2 还可以接收跟多的选项，所以我强烈建议你仔细阅读官方文档获取全部可选项。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-extract-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-extract-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tar:create/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tar-create-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/erl_tar.html#create-2" target="_blank" rel="external">erl_tar:create/2</a> 。</p>
<p>erl_tar:create/2 根据传入的文件名来创建一个tar文件并将参提供的文件列表加入到tar文件里。</p>
<a id="more"></a>
<p>erl_tar:create/2 有两个入参，第一个入参是一个要写入内容到文件名，第二个入参是一个将要加入tar文件里的文件列表。</p>
<p>首先我们打开一个新的操作系统shell会话并且创建一些文件，这些文件将加入到一个新tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"foo"</span> &gt; foo.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"bar"</span> &gt; bar.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"baz"</span> &gt; baz.txt</div><div class="line">$ ls</div><div class="line">bar.txt  baz.txt  foo.txt  test.tar</div></pre></td></tr></table></figure>
<p>现在我们有了一些可以归档的文件，我们可以打开一个新的erl shell，并且创建一个新的tar文件，它的名字是test.tar。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"test.tar"</span>, [<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"baz.txt"</span>]).</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>看起来好像是有用的，所以我们回到OS shell，看看刚才我们给 erl_tar:create/2（译者注：作者手误写成了 erl_tar:create/3 ） 函数传的那个tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -tf test.tar</div><div class="line">foo.txt</div><div class="line">bar.txt</div><div class="line">baz.txt</div></pre></td></tr></table></figure>
<p>没错，tar可以读这个文件并且告诉我们，那三个我们传入的文件都真的在tar文件里。</p>
<p>erl_tar:create/3</p>
<p>Erlang也提供了 erl_tar:create/3 它最后一个入参是一个选项列表。</p>
<p>我们将创建一个新的tar文件，它里面的文件和上面的例子是一样的，第三个入参我们表明我们想要这个tar文件被压缩而且执行过程中在控制台输出执行过程的内容。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"options.tar.gz"</span>,</div><div class="line">               [<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"baz.txt"</span>],</div><div class="line">               [compressed, verbose]).</div><div class="line"><span class="comment">% a foo.txt</span></div><div class="line"><span class="comment">% a bar.txt</span></div><div class="line"><span class="comment">% a baz.txt</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>再次回到OS shell，来看看这个tar文件里包含的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -tf options.tar.gz</div><div class="line">foo.txt</div><div class="line">bar.txt</div><div class="line">baz.txt</div></pre></td></tr></table></figure>
<p>然后我们来测试一下，这个文件是否能被gzip解压缩。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gzip --test options.tar.gz</div><div class="line">$</div></pre></td></tr></table></figure>
<p>结果gzip认为这个文件压缩完整性很好。接着我们来看看我们创建的这两个tar文件在大小上的差异。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls <span class="_">-l</span> test.tar options.tar.gz</div><div class="line">-rw-r--r--  1 -------  -----    154 Sep XX HH:MM options.tar.gz</div><div class="line">-rw-r--r--  1 -------  -----  10240 Sep XX HH:MM test.tar</div></pre></td></tr></table></figure>
<p>从文件大小来看，options.tar.gz 的确是被压缩的，因为它比test.tar小了两个数量级。</p>
<p>创建一个已经存在的文件</p>
<p>我们刚刚创建了 test.tar 并且看了它内部的内容。现在我们来看看传入相同的文件名test.tar和一个空的文件列表来创建一个已经存在的文件，这样做会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"test.tar"</span>, []).</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>然后我们看看它的内容，发现它原来的内容被替换了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar -tf test.tar</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这说明，erl_tar:create/2 创建tar文件并且覆盖已经存在的文件，如果文件已经存在它不会输出错误（假设用户的shell有权限写该文件或目录）。</p>
<p>在一个不存在的路径上创建tar文件</p>
<p>如果我们给一个不存在的路径, 我们可以看到 erl_tar:create/2 将返回一个错误元组，包括了文件名以及错误原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create('/path/does/<span class="keyword">not</span>/exist.tar', []).</div><div class="line"><span class="comment">% &#123;error,&#123;'/path/does/not/exist.tar',enoent&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>其他潜在的陷阱</p>
<p>首先官方文档说该函数入参是文件名，但是它没有指明erl_tar模块中文件名的数据类型是什么。</p>
<p>如果你用原子来做文件名，你会像我第一次用字符串做文件名前一样得到下面例子的错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">erl_tar:create('test.tar', ['foo.txt', 'bar.txt', 'baz.txt']).</div><div class="line">** exception error: no function clause matching filename:join([]) (filename.erl, line <span class="number">392</span>)</div><div class="line">     in function  erl_tar:split_filename/<span class="number">4</span> (erl_tar.erl, line <span class="number">423</span>)</div><div class="line">     in call from erl_tar:create_header/<span class="number">3</span> (erl_tar.erl, line <span class="number">352</span>)</div><div class="line">     in call from erl_tar:add1/<span class="number">4</span> (erl_tar.erl, line <span class="number">305</span>)</div><div class="line">     in call from erl_tar:foreach_while_ok/<span class="number">2</span> (erl_tar.erl, line <span class="number">940</span>)</div><div class="line">     in call from erl_tar:create/<span class="number">3</span> (erl_tar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<p>其次，根据erl_tar官方文档的 <a href="http://erlang.org/doc/man/erl_tar.html#id180770" target="_blank" rel="external">限制</a> 这一节，为了最大的兼容性，在各种不同操作系统和tar程序版本中，文件名应该少于100个字符。</p>
<p>最后，当我们指定文件名的时候，包不包括扩展名由我们使用者决定，这和 erl_tar:compress/2 函数一样不为我们使用者管理文件扩展名。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-create-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-create-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tidy:file/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tidy-file-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们看看Erlang的 erl_tidy 模块，我们从 <a href="http://www.erlang.org/doc/man/erl_tidy.html#file-1" target="_blank" rel="external">erl_tidy:file/1</a> 开始。</p>
<p>erl_tidy:file/1 入参是一个文件名，它整理并简洁美观地输出入参指定的文件的源码。</p>
<a id="more"></a>
<p>在我的tmp目录里有我解决 FizzBuzz 的快速实现模块，我将看看 erl_tidy:file/1 如何处理这个文件，因为我确定它的处理不是那么的漂亮。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>我们打开一个新的Erlang shell，然后用入参 fizzbuzz.erl 来调用 erl_tidy:file/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erl_tidy:file(<span class="string">"fizzbuzz.erl"</span>).</div><div class="line"><span class="comment">% fizzbuzz.erl:6: replacing call to `lists:map/2' with a list comprehension.</span></div><div class="line"><span class="comment">% fizzbuzz.erl:6: changing application of implicit fun to direct local call.</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>看起来它不喜欢我在代码中用map而且它修改了我调用 translate/1 函数的方式。</p>
<p>关掉shell，我们来看看目录下多了什么。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls <span class="_">-l</span></div><div class="line">total 16</div><div class="line">-rw-r--r--  1 proctor  staff  402 Sep  9 22:06 fizzbuzz.erl</div><div class="line">-rw-r--r--  1 proctor  staff  405 Sep  9 22:05 fizzbuzz.erl.bak</div></pre></td></tr></table></figure>
<p>让我们来看看 fizzbuzz.erl.bak ，主要是确认它的内容是 fizzbuzz.erl 的原始内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>它的确是 fizzbuzz.erl 的原始内容。</p>
<p>现在我们来看看被 erl_tidy:file/1 修改后的 fizzbuzz.erl 文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = [translate(V1) || V1 &lt;- lists:seq(1, N)],</div><div class="line">    lists:foreach(fun (Item) -&gt; io:format("~s~n", [Item])</div><div class="line">		  end,</div><div class="line">		  Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">    'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt; 'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt; 'Buzz';</div><div class="line">translate(N) -&gt; integer_to_list(N).</div></pre></td></tr></table></figure>
<p>正如函数输出的两行消息所说的，我们现在用一个列表解析替代map，并且直接调用 translate/1 函数。</p>
<p>它还把传给 lists:foreach/2 的匿名函数的 end 放在新的一行，也把列表 Translations 放在新的一行。</p>
<p>最后，translate/1 三个分支被改成一行，而且文件最后的换行符也被删掉。</p>
<p>据官方文档所讲，如果 fizzbuzz.erl 有任何没使用的函数都会被删除，同时过时的结构和函数也会被修改。</p>
<p>总的来说，这个好用的Erlang应用小工具可以帮助你的代码保持稳定的风格并将代码保持整洁。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tidy-file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tidy-file-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:pid/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-c-pid-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们简单讲讲 <a href="http://erlang.org/doc/man/c.html#pid-3" target="_blank" rel="external">c:pid/3</a>.</p>
<p>c:pid/3 三个入参分别是一个pid的三个部分的整数值，返回值的类型是与入参值对应的Pid类型。</p>
<a id="more"></a>
<p>我们调用 self 函数来得到当前的pid，然后我们可以调用 c:pid/3 和 self 返回的值进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self().</div><div class="line">% &lt;0.42.0&gt;</div><div class="line">c:pid(0, 42, 0).</div><div class="line">% &lt;0.42.0&gt;</div><div class="line">self() =:= c:pid(0, 42, 0).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>这个函数有什么用呢？有时候当我们检测一个在线系统的时候，在Erlang里有些调用是需要Pid类型的入参而不只是pid的三个整数值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  128774    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163760    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                 448    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.27.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                17940    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div><div class="line">erlang:is_process_alive(c:pid(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>)).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>让我们以正常的方式给这个函数传入一些让其异常的值看看它会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">c:pid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% &lt;0.0.0&gt;</span></div><div class="line">c:pid(<span class="number">111110</span>, <span class="number">0</span>, <span class="number">1111110</span>).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  list_to_pid/1</span></div><div class="line"><span class="comment">%         called as list_to_pid("&lt;111110.0.1111110&gt;")</span></div><div class="line"><span class="comment">%      in call from c:pid/3 (c.erl, line 424)</span></div></pre></td></tr></table></figure>
<p>像<0.0.0>这样的pid是有效的pid，但是传入无效的pid，函数抛出异常，从异常信息里我们看到它尝试调用 list_to_pid 。</0.0.0></p>
<p>让我们快速看看 list_to_pid 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erlang:list_to_pid(<span class="string">"&lt;0.42.0&gt;"</span>).</div><div class="line"><span class="comment">% &lt;0.42.0&gt;</span></div><div class="line">c:pid(<span class="number">0</span>, <span class="number">42</span>, <span class="number">0</span>) =:= erlang:list_to_pid(<span class="string">"&lt;0.42.0&gt;"</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>看起来 c:pid/3 是一个 list_to_pid 的封装函数，它把pid的三个部分的整数值构建成一个字符串，然后调用 list_to_pid 来得到一个 Pid 类型的值。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-pid-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-pid-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – user_default]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-user-default/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们来看看user_default模块。</p>
<p>我是在想验证当我在erl shell中调用 c/1 和 l/1 的函数的版本的时候偶然发现这个模块的，然后研究 <a href="http://www.erlang.org/doc/man/shell_default.html" target="_blank" rel="external">shell_default</a> 的文档。</p>
<a id="more"></a>
<p>文档中提到，如果我们想让一些函数在shell里直接可用，我们可以生成一个名字为user_default的模块，然后在自己的 .erlang 文件里指定该模块的路径，这样的话user_default模块里的导出函数就可以直接在shell里可用了。</p>
<p>既然我手上有一个 fizzbuzz 的例子，那么让我们开始按文档的说明生成一个user_default模块证明我们可以让它正常工作。我们将把它放在我们home目录的tmp目录里。</p>
<p>~/tmp/user_default.erl</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(user_default).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>在我们的home目录下新建一个 .erlang 文件，添加如下内容，指明我们刚刚创建的user_default文件的路径。</p>
<p>～/.erlang<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code:load_abs(<span class="string">"tmp/user_default"</span>).</div></pre></td></tr></table></figure></p>
<p>如果你已经有一个 .erlang 文件，那么在这个文件的第一行必须是 <a href="http://www.erlang.org/doc/man/code.html#load_abs-1" target="_blank" rel="external">code:load_abs/1</a> 函数，其参数为 user_default 模块。</p>
<p>确定上述两个文件都保存好了，然后打开erlang shell来尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line">** exception error: undefined shell command fizzbuzz/<span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>然而并没有像文档里讲的那样起作用。我意识到，我们用的是 load_abs 函数，并且 user_default 是一个新模块，这个错误可能是因为没有文件可装载。让我们用erlc编译这个模块，然后再尝试。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd tmp/</div><div class="line">$ erlc user_default.erl</div><div class="line">$ ls user_default.*</div><div class="line">user_default.beam user_default.erl</div><div class="line">$ cd ..</div></pre></td></tr></table></figure>
<p>我们现在有一个BEAM文件在~/tmp目录里，所以让我们再次启动Erlang shell并尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">Fizz</div><div class="line"><span class="number">4</span></div><div class="line">Buzz</div><div class="line">Fizz</div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Fizz</div><div class="line">Buzz</div><div class="line"><span class="number">11</span></div><div class="line">Fizz</div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">14</span></div><div class="line">FizzBuzz</div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">17</span></div><div class="line">Fizz</div><div class="line"><span class="number">19</span></div><div class="line">Buzz</div><div class="line">ok</div><div class="line"><span class="number">2</span>&gt;</div></pre></td></tr></table></figure>
<p>终于正常工作了！我们现在可以在shell里不需要指定模块名而直接调用 fizzbuzz/1 。</p>
<p>更多的关于 .erlang 文件的信息可以阅读 <a href="http://www.erlang.org/documentation/doc-5.1/doc/getting_started/getting_started.html#1.7" target="_blank" rel="external">Erlang中关于配置部分的文档</a> 。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-user_default/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-user_default/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:i/0]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-c-i-0/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续讲c模块的另一个函数 <a href="http://erlang.org/doc/man/c.html#i-0" target="_blank" rel="external">c:i/0</a> 。</p>
<p>c:i/0 输出系统的信息，展示本节点的所有进程信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">c:i().</div><div class="line"><span class="comment">% Pid                   Initial Call                          Heap     Reds Msgs</span></div><div class="line"><span class="comment">% Registered            Current Function                     Stack</span></div><div class="line"><span class="comment">% &lt;0.0.0&gt;               otp_ring0:start/2                      987     4987    0</span></div><div class="line"><span class="comment">% init                  init:loop/1                              2</span></div><div class="line"><span class="comment">% &lt;0.3.0&gt;               erlang:apply/2                        6772   823443    0</span></div><div class="line"><span class="comment">% erl_prim_loader       erl_prim_loader:loop/3                   6</span></div><div class="line"><span class="comment">% &lt;0.6.0&gt;               gen_event:init_it/6                    376      220    0</span></div><div class="line"><span class="comment">% error_logger          gen_event:fetch_msg/5                    8</span></div><div class="line"><span class="comment">% &lt;0.7.0&gt;               erlang:apply/2                        1598      463    0</span></div><div class="line"><span class="comment">% application_controlle gen_server:loop/6                        7</span></div><div class="line"><span class="comment">% &lt;0.9.0&gt;               application_master:init/4              376       44    0</span></div><div class="line"><span class="comment">%                       application_master:main_loop/2           6</span></div><div class="line"><span class="comment">% &lt;0.10.0&gt;              application_master:start_it/4          233       69    0</span></div><div class="line"><span class="comment">%                       application_master:loop_it/4             5</span></div><div class="line"><span class="comment">% &lt;0.11.0&gt;              supervisor:kernel/1                   4185    49109    0</span></div><div class="line"><span class="comment">% kernel_sup            gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.12.0&gt;              rpc:init/1                             233       35    0</span></div><div class="line"><span class="comment">% rex                   gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.13.0&gt;              global:init/1                          233       51    0</span></div><div class="line"><span class="comment">% global_name_server    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.14.0&gt;              erlang:apply/2                         233       19    0</span></div><div class="line"><span class="comment">%                       global:loop_the_locker/1                 5</span></div><div class="line"><span class="comment">% &lt;0.15.0&gt;              erlang:apply/2                         233        3    0</span></div><div class="line"><span class="comment">%                       global:loop_the_registrar/0              2</span></div><div class="line"><span class="comment">% &lt;0.16.0&gt;              inet_db:init/1                         233      206    0</span></div><div class="line"><span class="comment">% inet_db               gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.17.0&gt;              global_group:init/1                    233       59    0</span></div><div class="line"><span class="comment">% global_group          gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.18.0&gt;              file_server:init/1                    2586     2562    0</span></div><div class="line"><span class="comment">% file_server_2         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.19.0&gt;              erlang:apply/2                        2586   155919    0</span></div><div class="line"><span class="comment">% code_server           code_server:loop/1                       3</span></div><div class="line"><span class="comment">% &lt;0.20.0&gt;              supervisor_bridge:standard_error/      233       41    0</span></div><div class="line"><span class="comment">% standard_error_sup    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.21.0&gt;              erlang:apply/2                         233        9    0</span></div><div class="line"><span class="comment">% standard_error        standard_error:server_loop/1             2</span></div><div class="line"><span class="comment">% &lt;0.22.0&gt;              supervisor_bridge:user_sup/1           610       87    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.23.0&gt;              erlang:apply/2                         233       24    0</span></div><div class="line"><span class="comment">% user                  user:server_loop/2                       5</span></div><div class="line"><span class="comment">% &lt;0.24.0&gt;              kernel_config:init/1                   233      286    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.25.0&gt;              supervisor:kernel/1                    233       58    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.29.0&gt;              kjell_profile:init/1                   987    27100    0</span></div><div class="line"><span class="comment">% kjell_profile         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.30.0&gt;              kjell_extension:init/1                2586     3903    0</span></div><div class="line"><span class="comment">% kjell_extension       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.45.0&gt;              k_user_drv:server/2                    987     2218    0</span></div><div class="line"><span class="comment">% user_drv              k_user_drv:server_loop/5                 8</span></div><div class="line"><span class="comment">% &lt;0.46.0&gt;              k_group:server/3                       987    14541    0</span></div><div class="line"><span class="comment">%                       k_group:server_loop/3                    4</span></div><div class="line"><span class="comment">% &lt;0.47.0&gt;              erlang:apply/2                       28690     4406    0</span></div><div class="line"><span class="comment">%                       kjell:shell_rep/4                       17</span></div><div class="line"><span class="comment">% &lt;0.48.0&gt;              erlang:apply/2                        1598    20585    0</span></div><div class="line"><span class="comment">%                       c:pinfo/1                               49</span></div><div class="line"><span class="comment">% Total                                                      58707  1110447    0</span></div><div class="line"><span class="comment">%                                                              237</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个函数返回进程的id，进程的初始化函数即启动进程的函数，进程堆的大小，进程的规约数，进程消息队列里的消息数，进程的注册名字，进程当前所处的函数，以及进程的栈大小。</p>
<p>c:i/0 的输出也包括堆大小、规约数，消息队列大小以及栈大小的各项数据的总和。</p>
<p>c模块也提供 c:ni/0 函数，它展示所有联通的节点的系统信息。</p>
<p>从该函数输出的进程信息来看，我们可以找到几个和 <a href="https://karlll.github.io/kjell/" target="_blank" rel="external">kjell</a> 相关的进程，kjell是我用来替换 erl shell的，它易于查找进程的信息。</p>
<p>查看一个kjell相关的进程，我们可以获得其pid，然后通过调用 <a href="http://erlang.org/doc/man/c.html#i-3" target="_blank" rel="external">c:i/3</a> 展示进程的信息来深入观察该进程，我们可以用pid的3个整数做为此函数的入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c:i(<span class="number">0</span>, <span class="number">47</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% [&#123;current_function,&#123;kjell,shell_rep,4&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;status,waiting&#125;,</span></div><div class="line"><span class="comment">%  &#123;message_queue_len,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;messages,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;links,[&lt;0.48.0&gt;,&lt;0.46.0&gt;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;dictionary,[&#123;&#123;result,1&#125;,ok&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;command,1&#125;,[&#123;call,1,&#123;remote,1,&#123;atom,1,c&#125;,&#123;atom,1,i&#125;&#125;,[]&#125;]&#125;,</span></div><div class="line"><span class="comment">%               &#123;evaluator,&lt;0.48.0&gt;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;trap_exit,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;error_handler,error_handler&#125;,</span></div><div class="line"><span class="comment">%  &#123;priority,normal&#125;,</span></div><div class="line"><span class="comment">%  &#123;group_leader,&lt;0.46.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;total_heap_size,46421&#125;,</span></div><div class="line"><span class="comment">%  &#123;heap_size,28690&#125;,</span></div><div class="line"><span class="comment">%  &#123;stack_size,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;reductions,4479&#125;,</span></div><div class="line"><span class="comment">%  &#123;garbage_collection,[&#123;min_bin_vheap_size,46422&#125;,</span></div><div class="line"><span class="comment">%                       &#123;min_heap_size,233&#125;,</span></div><div class="line"><span class="comment">%                       &#123;fullsweep_after,65535&#125;,</span></div><div class="line"><span class="comment">%                       &#123;minor_gcs,2&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;suspending,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们查看指定的进程的信息，我们可以看到它的链接进程，消息和消息队列长度，堆栈的信息，以及其他各种可能有用的相关设置。</p>
<p>同样，这几个函数也没有observer那样有漂亮的界面，不过它们在你无法直接通过一个终端来访问节点的时候可以派上用场，比如在一个跳板机上工作；它们能给你一个好的方式使得你能知道你的erlang节点的运行情况。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-i-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-i-0/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:regs/0]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-c-regs-0/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看看c模块并研究 <a href="http://erlang.org/doc/man/c.html#regs-0" target="_blank" rel="external">c:regs/0</a>.</p>
<p>c:regs/0 输出当前节点上注册的进程的信息，比如进程的名字，进程的id，执行规约数，以及其他信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  121202    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  156994    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                  92    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.28.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                 1219    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>尽管这个函数的输出没有observer函数提供的图形界面漂亮，但是它是一个有用的工具，在你无法运行observer函数来获得图形界面的时候能够帮助你得到这些进程是什么进程以及这些进程在做什么。</p>
<p>c模块还提供了一个 c:nregs/0 函数，它展示本节点以及与本节点联通的所有节点的所有注册进程的信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">node().</div><div class="line">% 'foo@127.0.0.1'</div><div class="line">nodes().</div><div class="line">% ['bar@127.0.0.1']</div><div class="line">c:nregs().</div><div class="line">%</div><div class="line">% ** Registered procs on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;0.19.0&gt;     auth:init/1                        880    0</div><div class="line">% code_server           &lt;0.25.0&gt;     erlang:apply/2                  122302    0</div><div class="line">% erl_epmd              &lt;0.18.0&gt;     erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163458    0</div><div class="line">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                264    0</div><div class="line">% file_server_2         &lt;0.24.0&gt;     file_server:init/1                  92    0</div><div class="line">% global_group          &lt;0.23.0&gt;     global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;0.13.0&gt;     global:init/1                      339    0</div><div class="line">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     255    0</div><div class="line">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 5405    0</div><div class="line">% kernel_safe_sup       &lt;0.34.0&gt;     supervisor:kernel/1                 58    0</div><div class="line">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;0.20.0&gt;     net_kernel:init/1                  792    0</div><div class="line">% net_sup               &lt;0.17.0&gt;     supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</div><div class="line">% standard_error        &lt;0.27.0&gt;     erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;0.26.0&gt;     supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;0.30.0&gt;     group:server/3                      36    0</div><div class="line">% user_drv              &lt;0.29.0&gt;     user_drv:server/2                 1661    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">%</div><div class="line">% ** Registered procs on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;6108.7.0&gt;   erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;6108.19.0&gt;  auth:init/1                        880    0</div><div class="line">% code_server           &lt;6108.25.0&gt;  erlang:apply/2                  124588    0</div><div class="line">% erl_epmd              &lt;6108.18.0&gt;  erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;6108.3.0&gt;   erlang:apply/2                  164400    0</div><div class="line">% error_logger          &lt;6108.6.0&gt;   gen_event:init_it/6                301    0</div><div class="line">% file_server_2         &lt;6108.24.0&gt;  file_server:init/1                  92    0</div><div class="line">% global_group          &lt;6108.23.0&gt;  global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;6108.13.0&gt;  global:init/1                      341    0</div><div class="line">% inet_db               &lt;6108.16.0&gt;  inet_db:init/1                     255    0</div><div class="line">% inet_gethost_native   &lt;6108.42.0&gt;  inet_gethost_native:serve           83    0</div><div class="line">% inet_gethost_native_s &lt;6108.41.0&gt;  supervisor_bridge:inet_ge           41    0</div><div class="line">% init                  &lt;6108.0.0&gt;   otp_ring0:start/2                 5515    0</div><div class="line">% kernel_safe_sup       &lt;6108.34.0&gt;  supervisor:kernel/1                127    0</div><div class="line">% kernel_sup            &lt;6108.11.0&gt;  supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;6108.20.0&gt;  net_kernel:init/1                  796    0</div><div class="line">% net_sup               &lt;6108.17.0&gt;  supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;6108.12.0&gt;  rpc:init/1                        1302    0</div><div class="line">% standard_error        &lt;6108.27.0&gt;  erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;6108.26.0&gt;  supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;6108.30.0&gt;  group:server/3                      36    0</div><div class="line">% user_drv              &lt;6108.29.0&gt;  user_drv:server/2                 2801    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">% ok</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-regs-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-regs-0/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday Bonus – Functional fizzbuzz]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-bonus-functional-fizzbuzz/</url>
      <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday红包。</p>
<p>过去的这个周末我读了文章  <a href="http://comp-phil.blogspot.com/2015/08/bro-do-you-even-fizzbuzz.html" target="_blank" rel="external">Bro, Do You Even FizzBuzz?!?</a> ，它阐述如何在Clojure里不用取模运算符来解决 FizzBuzz 问题。</p>
<a id="more"></a>
<p>在以同样的算法用Ruby来解决这个问题并发布<a href="http://www.proctor-it.com/ruby-tuesday-functional-fizzbuzz/" target="_blank" rel="external">博客</a>后，我想我应该将这个问题用Erlang也来解决，同时也看看有何不同。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(fizzbuzz)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([fizzbuzz/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Results = do_fizzbuzz(N),</div><div class="line">    lists:foreach(<span class="keyword">fun</span>(X) -&gt; io:format(<span class="string">"~p~n"</span>, [X]) <span class="keyword">end</span>, Results).</div><div class="line"></div><div class="line"><span class="function"><span class="title">do_fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Fizzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">"fizz"</span>], N),</div><div class="line">    Buzzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"buzz"</span>], N),</div><div class="line">    FizzBuzzes = lists:zipwith(<span class="keyword">fun</span> lists:append/<span class="number">2</span>, Fizzes, Buzzes),</div><div class="line">    Numbers = lists:seq(<span class="number">1</span>, N),</div><div class="line">    lists:zipwith(fun translate/2, Numbers, FizzBuzzes).</div><div class="line"></div><div class="line"><span class="function"><span class="title">cycle</span><span class="params">(List, N)</span> -&gt;</span></div><div class="line">    lists:sublist(lists:append(lists:duplicate(N, List)), N).</div><div class="line"></div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(Number, <span class="string">""</span>)</span> -&gt;</span></div><div class="line">    integer_to_list(Number);</div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(_, Translation)</span> -&gt;</span></div><div class="line">    Translation.</div></pre></td></tr></table></figure>
<p>在Erlang的解决方案里有几个点要注意。</p>
<p>首先，Erlang没有任何懒列表或序列的直接概念，也没有 cycle 函数，所以我只能临时凑合着调用 lists:duplicate, lists:append 和 lists:sublist 来处理一个列表，从而循环处理原列表来生成一个有N个元素的列表。虽然这个做法不是最高效的方式，但是它是可行的。</p>
<p>其次，lists:zipwith 的能力对于一些管道的想法有帮助，因为我们可以处理这些链在一起的元素，而不是必须在不同的步骤中去处理它们。</p>
<p>第三，我们不用case语句，而是用一个有guard分支的函数来决定一个翻译存在与否，如果是是否用这个翻译，如果不是是否用这个数字。</p>
<p>我希望这起到抛砖引玉的作用，也希望听到你怎样更高效的方案，或者除了用一般的有guard分支来检查剩余元素的模式匹配的其他方法来解决FizzBuzz问题。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:m/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-c-m-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续研究c模块，讲的函数是 <a href="http://erlang.org/doc/man/c.html#m-1" target="_blank" rel="external">c:m/1</a>.</p>
<p>c:m/1 入参是一个表示模块名字的原子，返回值是这个模块的信息。它打印出来的信息包括编译的日期、时间和编译选项，还有装载的目标（BEAM）文件以及这个模块中导出函数组成的列表。</p>
<a id="more"></a>
<p>我们来看看erlang中的string模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">c:m(string).</div><div class="line"><span class="comment">% Module string compiled: Date: November 28 2014, Time: 06.47</span></div><div class="line"><span class="comment">% Compiler options:  [&#123;outdir,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../ebin"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../include"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../../kernel/include"&#125;,</span></div><div class="line"><span class="comment">%                     warnings_as_errors,debug_info]</span></div><div class="line"><span class="comment">% Object file: /usr/local/Cellar/erlang/17.3.4/lib/erlang/lib/stdlib-2.2/ebin/string.beam</span></div><div class="line"><span class="comment">% Exports:</span></div><div class="line"><span class="comment">% centre/2                      rstr/2</span></div><div class="line"><span class="comment">% centre/3                      span/2</span></div><div class="line"><span class="comment">% chars/3                       str/2</span></div><div class="line"><span class="comment">% chars/2                       strip/1</span></div><div class="line"><span class="comment">% chr/2                         strip/2</span></div><div class="line"><span class="comment">% concat/2                      strip/3</span></div><div class="line"><span class="comment">% copies/2                      sub_string/2</span></div><div class="line"><span class="comment">% cspan/2                       sub_string/3</span></div><div class="line"><span class="comment">% equal/2                       sub_word/2</span></div><div class="line"><span class="comment">% join/2                        sub_word/3</span></div><div class="line"><span class="comment">% left/2                        substr/2</span></div><div class="line"><span class="comment">% left/3                        substr/3</span></div><div class="line"><span class="comment">% len/1                         to_float/1</span></div><div class="line"><span class="comment">% module_info/0                 to_integer/1</span></div><div class="line"><span class="comment">% module_info/1                 to_lower/1</span></div><div class="line"><span class="comment">% rchr/2                        to_upper/1</span></div><div class="line"><span class="comment">% right/2                       tokens/2</span></div><div class="line"><span class="comment">% right/3                       words/1</span></div><div class="line"><span class="comment">%                               words/2</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个模块是2014年11月28日在我的机器上编译的，还看到 warnings_as_errors 和 debug_info 这两个编译选项打开了，还有beam文件的路径以及string模块所有导出的不同函数。</p>
<p>接着我们看看在erlang shell里编译的模块。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">c(fizzbuzz).</div><div class="line">% &#123;ok,fizzbuzz&#125;</div><div class="line">c:m(fizzbuzz).</div><div class="line">% Module fizzbuzz compiled: Date: August 5 2015, Time: 22.14</div><div class="line">% Compiler options:  []</div><div class="line">% Object file: /Users/proctor/tmp/fizzbuzz.beam</div><div class="line">% Exports:</div><div class="line">%          fizzbuzz/1</div><div class="line">%          module_info/0</div><div class="line">%          module_info/1</div><div class="line">% ok</div></pre></td></tr></table></figure>
<p>c:m(fizzubzz)的输出显示fizzbuzz被编译了，并且是从我的用户目录下的tmp目录装载的，同时还有一个导出函数fizzbuzz/1 和在每个模块都有的两个版本导出函数module_info。</p>
<p>今天讲的这个函数不是你每天都可能用的函数，不过了解它对你调试和检查你的erlang应用很有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-m-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-m-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:xm/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-c-xm-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 <a href="http://erlang.org/doc/man/c.html#xm-1" target="_blank" rel="external">c:xm/1</a>.</p>
<p>c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。</p>
<a id="more"></a>
<p>首先让我们检查一下erlang模块，看看它是否有废弃的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c:xm(erlang).</div><div class="line"><span class="comment">% [&#123;deprecated,[]&#125;,&#123;undefined,[]&#125;,&#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是没有调用废弃的函数，没有未定义的函数，也没有未被使用的函数在erlang模块里。注：上述结果我是在Erlang 17.3.4 下得到的，根据你使用不同的erlang版本，你可能得到不一样的结果，因为 erlang:now/0 在18.0版本里已经是废弃的函数。（译者注：这句话有点费解，官网对 c:xm/1 对解析是：This function finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1. ）</p>
<p>为了找到符合这样标准的现存模块，我查看 Erlang 17.0 的 <a href="http://erlang.org/download/otp_src_17.0.readme" target="_blank" rel="external">README</a> 来搜索 deprecated 这个词。 找到如下这句：</p>
<p>pg 模块已经废弃，它将在Erlang/OTP 18中被删除。</p>
<p>那么让我们把这个模块名传给 c:xm/1 看看有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c:xm(pg).</div><div class="line"><span class="comment">% [&#123;deprecated,[&#123;&#123;pg,create,1&#125;,&#123;pg,master,1&#125;&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;pg,create,2&#125;,&#123;pg,master,1&#125;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;undefined,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>我们可以看到我们得到了pg模块里有关废弃的函数信息。</p>
<p>虽然你在日常工作中需要使用这个函数的几率很低，因为erlang相关的工具通常都非常注意这些方面，这足够引起人们的好奇，看起来调用这个函数似乎很值得，尤其如果那个时间Erlang代码的编译是Erlang内部完成的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-xm-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-xm-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:is_subset/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#is_subset-2" target="_blank" rel="external">ordsets:is_subset/2</a>.</p>
<p>ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">10</span>)).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">SetB = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)).</div><div class="line"><span class="comment">% [2,4,6,8,10]</span></div><div class="line">SetC = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>)).</div><div class="line"><span class="comment">% [1,4,7,10,13]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:is_subset(SetB, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetB).</div><div class="line"><span class="comment">% false</span></div><div class="line">ordsets:is_subset(SetC, SetA).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>有几个事实要跟不熟悉集合理论的同学讲讲。首先，空集合是所有集合的子集；其次，一个集合是它自己的子集；最后，如果集合B是集合A的超集，则集合A是集合B的子集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ordsets:is_subset(EmptySet, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetB).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetC).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, EmptySet).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetA).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:subtract/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-subtract-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#subtract-2" target="_blank" rel="external">ordsets:subtract/2</a>.</p>
<p>ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">OrderedSetA = ordsets:from_list([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">OrderedSetB = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">OrderedSetC = ordsets:from_list([<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">16</span>, -<span class="number">16</span>]).</div><div class="line"><span class="comment">% [-16,-4,-2,2,4,16]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetA, OrderedSetB).</div><div class="line"><span class="comment">% [4]</span></div><div class="line">ordsets:subtract(OrderedSetA, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">ordsets:subtract(OrderedSetB, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">ordsets:subtract(EmptySet, OrderedSetA).</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetB, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5,8,13]</span></div></pre></td></tr></table></figure>
<p>请注意，ordsets:subtract/2 的入参顺序是不可换的，这一点和 ordsets:union/2 或者 ordsets:intersection/2 不一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:subtract(OrderedSetA, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">ordsets:subtract(OrderedSetC, OrderedSetA).</div><div class="line"><span class="comment">% [-16,-4,-2,16]</span></div></pre></td></tr></table></figure>
<p>如果你不是一直跟读Erlang Thursday的话，我再次友情提醒你，虽然Erlang用列表来表示有序集合，但是并不意味着列表是有序集合。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday Bonus! Performace of erlang:length/1 on a list]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</url>
      <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday福利。</p>
<p>上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：</p>
<p>有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？</p>
<a id="more"></a>
<p>我可以百分之九九确定Erlang必须每次都要遍历列表来计算其长度，因为它用链接列表类的数据结构来构造它的列表，但是我不确定是否有一些聪明的实现方法是我没有意识到，这些方法能提高获取列表长度到速度。</p>
<p>在写今天的Erlang Thursday的时候，我意识到，我应该用 timer:tc 函数，通过它来展示需要多长时间来获取不同列表的长度来证明 erlang:length/1 函数的执行情况。</p>
<p>为了纪念这个问题，也为了在下一次会议的时候能回忆其它，我在这里记录相关内容。我们要明白，timer:tc 函数返回的结果里第一个元素是被测量函数执行的微秒时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10</span>)]).</div><div class="line">&#123;<span class="number">2</span>,<span class="number">10</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000</span>)]).</div><div class="line">&#123;<span class="number">5</span>,<span class="number">1000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000</span>)]).</div><div class="line">&#123;<span class="number">41</span>,<span class="number">10000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000</span>)]).</div><div class="line">&#123;<span class="number">134</span>,<span class="number">100000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>)]).</div><div class="line">&#123;<span class="number">1918</span>,<span class="number">1000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000000</span>)]).</div><div class="line">&#123;<span class="number">25139</span>,<span class="number">10000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000000</span>)]).</div><div class="line">&#123;<span class="number">1368691</span>,<span class="number">100000000</span>&#125;</div></pre></td></tr></table></figure>
<p>在链接列表有大概1000元素以后，我们可以看到计算其长度的时间线性增长，尽管不是真正对所有节点做遍历，但是在算法复杂度（大O）上看是相同复杂度级别。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:intersection/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-intersection-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看ordsets模块并且讲讲 <a href="http://erlang.org/doc/man/ordsets.html#intersection-2" target="_blank" rel="external">ordsets:intersection/2</a> 。</p>
<p>ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OrderedSet1 = ordsets:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>]</div><div class="line">OrderedSet2 = ordsets:from_list([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet1, OrderedSet2).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet2, OrderedSet1).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>因为 ordsets:intersection/2 在集合中找共同的元素，就向上面的例子一样，入参的顺序是可以交换的，不管两个入参的有序集合的参数顺序如何，我们得到的结果是一样的。</p>
<p>如果没有共同的元素，则结果是一个空的有序集合（其实就是一个空列表，上周的文章 <a href="http://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">ordsets:union/2</a> 里强调了用一个列表来当做一个有序集合是危险的）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Evens = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</div><div class="line">Odds = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>]</div><div class="line">ordsets:intersection(OrderedSet2, ordsets:new()).</div><div class="line">[]</div><div class="line">ordsets:intersection(Evens, Odds).</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>Erlang也提供了 <a href="http://erlang.org/doc/man/ordsets.html#intersection-1" target="_blank" rel="external">ordsets:intersection/1</a> 函数，它的入参是一个由多个有序集合为元素组成的列表，它返回的结果是列表里所有的有序集合的交集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">OrderedSet3 = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</div><div class="line">ordsets:intersection([Evens, Odds, OrderedSet1]).</div><div class="line">[]</div><div class="line">ordsets:intersection([Odds, OrderedSet2, OrderedSet1]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection([Evens, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">2</span>]</div><div class="line">ordsets:intersection([Odds, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:union/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-union-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#union-2" target="_blank" rel="external">ordsets:union/2</a> 。</p>
<p>ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">SetB = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">SetC = ordsets:from_list([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]).</div><div class="line"><span class="comment">% [1,3,4,5,9]</span></div><div class="line">SetD = ordsets:from_list([a, b, c, d, e]).</div><div class="line"><span class="comment">% [a,b,c,d,e]</span></div><div class="line">UnionAB = ordsets:union(SetA, SetB).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">UnionAC = ordsets:union(SetA, SetC).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div></pre></td></tr></table></figure>
<p>因为Erlang里的字符串实际上是字符列表，我们可以从字符串产生有序集合，然后通过这个函数得到两个字符串里不重复的字符并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:from_list(<span class="string">"Kermit"</span>).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list([<span class="number">75</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">116</span>]).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list(<span class="string">"Mississippi"</span>).</div><div class="line"><span class="comment">% "Mips"</span></div><div class="line">ordsets:union(ordsets:from_list(<span class="string">"Kermit"</span>), ordsets:from_list(<span class="string">"Mississippi"</span>)).</div><div class="line"><span class="comment">% "KMeimprst"</span></div></pre></td></tr></table></figure>
<p>ordsets模块也包含 <a href="http://erlang.org/doc/man/ordsets.html#union-1" target="_blank" rel="external">ordsets:union/1</a> ，它的入参是一个由有序集合组成的列表，它返回的是列表里所有有序集合的并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UnionAC = ordsets:union([SetA, SetC]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABC = ordsets:union([SetB, SetC, SetA]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABCD = ordsets:union([SetB, SetC, SetA, SetD]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9,a,b,c,d,e]</span></div><div class="line">UnionCD = ordsets:union([SetC, SetD]).</div><div class="line"><span class="comment">% [1,3,4,5,9,a,b,c,d,e]</span></div></pre></td></tr></table></figure>
<p>警告：有序集合的表现形式虽然只是一个列表，但是如果你传递一个普通列表给 ordsets:union/2 ，你将得不到你预期的结果，因为这个函数要求每个有序集合里的元素是真正的有序并且是一个集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c,1]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-union-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thrusday – queue:out/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thrusday-queue-out-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的的是queue模块原生API中的  <a href="http://erlang.org/doc/man/queue.html#out-1" target="_blank" rel="external">queue:out/1</a> 函数。</p>
<p>queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。</p>
<a id="more"></a>
<p>“是什么让这个函数这么厉害？”，你可能会这么问我。</p>
<p>这应该是这个函数由元组、标签元组组成，它的不可变性，它的宽容性，以及我们最终看到它返回结果的事实，所有这些使得我希望更多的队列实现都有像这样的一个API。</p>
<p>首先应该由很多次我自己或别人的过往经历中，在尝试弹出队列第一个元素的时候忘了检查这个队列是否是空的，从而造成一个很不友好的运行时错误。</p>
<p>queue:out/1 恰恰相反，当你给它的入参是一个空队列的时候，它并不触发一个错误，而是返回一个标签元组来告诉你，你传入的队列是空的，另外它还返回一个空队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:out(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们的入参是一个非空队列，queue:out/1 返回一个两元素元组。第一个元素是一个标签元组，它告诉我们，我们得到了一个值以及入参队列的头部元素，第二个元素，我们得到了入参队列移除头部元素后剩下的元素组成的队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([a, b, c, d]).</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">&#123;&#123;value, Head&#125;, NewQueue&#125; = queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">Head.</div><div class="line"><span class="comment">% a</span></div><div class="line">NewQueue.</div><div class="line"><span class="comment">% &#123;[d],[b,c]&#125;</span></div><div class="line">queue:head(NewQueue).</div><div class="line"><span class="comment">% b</span></div></pre></td></tr></table></figure>
<p>当我们在跨语言条件下谈论队列的理论上的概念时，“pop”这个概念做了两个事情，返回队列的头部元素，同时修改队列将其头部元素删除。</p>
<p>由于Erlang的队列是不可改变的，那么你仔细想想几分钟，你就会感觉到 queue:out/1 这个函数的妙处了，它也做了“pop”概念中的两件事情，就是返回队列头部，同时返回一个删除了头部元素的新的队列。</p>
<p>Erlang的queue模块也提供了函数 <a href="http://erlang.org/doc/man/queue.html#out_r-1" target="_blank" rel="external">queue:out_r/1</a> ，它的行为和 queue:out/1 基本一样，不一样的是它操作的是队列的尾部元素而不是队列的头部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:out_r(queue:from_list([a, b, c, d])).</div><div class="line"><span class="comment">% &#123;&#123;value,d&#125;,&#123;,[a,b]&#125;&#125;</span></div><div class="line">queue:out_r(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我希望你和我一样发现 queue:out/1 方便好用。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thrusday-queue-out-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thrusday-queue-out-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:split/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-queue-split-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲queue模块的原生API：<a href="http://erlang.org/doc/man/queue.html#split-2" target="_blank" rel="external">queue:split/2</a> 。</p>
<p>queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([a, <span class="number">1</span>, b, <span class="number">2</span>, c, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:split(<span class="number">4</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[2],[a,1,b]&#125;,&#123;[4,3],&#125;&#125;</span></div><div class="line">queue:split(<span class="number">0</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[]&#125;,&#123;[4,3,c],[a,1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">1</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[a]&#125;,&#123;[4,3,c],[1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">7</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[4,3,c],[a,1,b,2]&#125;,&#123;[],[]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">15</span>, QueueOne).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:split/2</span></div><div class="line"><span class="comment">%         called as queue:split(15,&#123;[4,3,c],[a,1,b,2]&#125;)</span></div><div class="line">&#123;SplitFirst, SplitSecond&#125; = queue:split(<span class="number">3</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[b,1],[a]&#125;,&#123;[4,3,c],[2]&#125;&#125;</span></div><div class="line">SplitFirst.</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">SplitSecond.</div><div class="line"><span class="comment">% &#123;[4,3,c],[2]&#125;</span></div><div class="line">queue:peek(SplitFirst).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(SplitSecond).</div><div class="line"><span class="comment">% &#123;value,2&#125;</span></div></pre></td></tr></table></figure>
<p>Erlang也提供一个 <a href="http://erlang.org/doc/man/queue.html#join-2" target="_blank" rel="external">queue:join/2</a> 函数，它有两个入参，入参类型都是队列，函数返回值是一个新的队列，新队列是由第二个入参队列添加到第一个入参队列后面形成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:join(SplitFirst, SplitSecond).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:join(SplitSecond, SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[2,c,3,4,a]&#125;</span></div><div class="line">queue:join(queue:new(), SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">queue:join(queue:new(), queue:new()).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-split-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-split-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:peek/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-queue-peek-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 <a href="http://erlang.org/doc/man/queue.html#peek-1" target="_blank" rel="external">queue:peek/1</a> 。</p>
<p>queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:peek(QueueOne).</div><div class="line"><span class="comment">% &#123;value,1&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>queue:peek/1 绝对不会修改入参队列，所以我们可以再一次调用上述例子，或者像下面例子一样多次调用，而我们的入参队列不会被修改。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueTwo = queue:from_list([a, b, c, d, e, f]).</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div></pre></td></tr></table></figure>
<p>不像上一篇文章里我们看到的 <a href="http://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">queue:head/1</a> ，我们可以安全地在入参队列为空的情况下调用 queue:peek/1 函数，而不是获得一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:head/1</span></div><div class="line"><span class="comment">%         called as queue:head(&#123;[],[]&#125;)</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>Erlang的 queue 模块也包含函数 <a href="http://erlang.org/doc/man/queue.html#peek_r-1" target="_blank" rel="external">queue:peek_r/1</a> ，它返回入参队列的尾部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">queue:peek_r(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,f&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue.</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-peek-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-peek-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:tail/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-queue-tail-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 <a href="http://erlang.org/doc/man/queue.html#tail-1" target="_blank" rel="external">queue:tail/1</a>.</p>
<p>queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">Tail = queue:tail(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Tail).</div><div class="line"><span class="comment">% 2</span></div><div class="line">queue:to_list(Tail).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>我们可以看到上述调用 queue:tail/1 的例子不像其它语言一样是一个破坏性操作，它完全保留了原始的入参队列的完整性。</p>
<p>做为将一个队列做为双端来处理的Okasaki API的一部分，queue:tail/1 有一个对应的函数 <a href="http://erlang.org/doc/man/queue.html#liat-1" target="_blank" rel="external">queue:liat/1</a> ，这个函数返回移除入参队列的最后一个元素后形成的新队列。queue:liat/1 也有一个别名函数，就是Okasaki API的 <a href="http://erlang.org/doc/man/queue.html#init-1" target="_blank" rel="external">queue:init/1</a>.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:liat(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">queue:init(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Erlang官方文档也指出有一个别名函数 queue:lait/1 ，大家最好不要用它，因为它的拼写是错误的。</p>
<p>因为我们是要深入细节然后看看我们能学到什么，那么让我们一起来到目前为止我们接触到的不同的tail函数在接收一个空队列为入参会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:tail(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop/1</span></div><div class="line"><span class="comment">%         called as queue:drop(&#123;[],[]&#125;)</span></div><div class="line">queue:liat(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div><div class="line">queue:init(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>当我们分别调用 <a href="http://erlang.org/doc/man/queue.html#drop-1" target="_blank" rel="external">queue:tail/1</a> 和 <a href="http://erlang.org/doc/man/queue.html#drop_r-1" target="_blank" rel="external">queue:liat/1</a> 的时候，看起来像我们在调用 queue:drop/1 和 queue:drop_r/1 得到的异常错误一样。</p>
<p>当我们用一个有若干元素的队列做为入参来调用 queue:drop/1 和 queue:drop_r/1 ，然后看看的执行情况，看起来 queue:tail/1 就是 queue:drop/1 的别名函数，而 queue:list/1 和 queue:init/1 就是 queue:drop_r/1 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:drop(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">queue:drop_r(Queue).</div><div class="line">&#123;[<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-tail-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-tail-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:head/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-queue-head-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看<a href="http://erlang.org/doc/man/queue.html#head-1" target="_blank" rel="external">queue:head/1</a>.</p>
<p>queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Queue).</div><div class="line"><span class="comment">% 1</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>上述例子显示，queue:head/1 函数没有修改原来的队列，而仅是返回它的第一个元素。</p>
<p>因为 queue:head/1 仅仅是返回队列头部能找到的值，而且不是一个标签元组，如果我们尝试从一个空的队列获取它的头部元素则会抛出一个错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">%** exception error: empty</span></div><div class="line"><span class="comment">%     in function  queue:head/1</span></div><div class="line"><span class="comment">%        called as queue:head(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>为了安全起见，让我们不在一个空队列上运行该函数而造成抛出异常，queue模块也定义了一个函数 queue:is_empty/1 ，你可以用它来检查一个队列是否为空。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:is_empty(EmptyQueue).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>像 queue:cons/2 和Okazaki API的其它函数一样，模块里也有一个函数<a href="http://erlang.org/doc/man/queue.html#daeh-1" target="_blank" rel="external">queue:dash</a> （head单词倒过来写），它从队列获取最后一个元素，它也是 <a href="http://erlang.org/doc/man/queue.html#last-1" target="_blank" rel="external">queue:last/1</a> 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:daeh(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:last(Queue).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>如果你调用 queue:dash/1 和 queue:last/1 的时候用空队列做入参也会引起错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:daeh(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:last(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>如果我们仔细看 queue:dash/1 和 queue:last/1 引起的错误，我们看到这个错误来自扩展API的 queue:get_r/1 。如果我们仔细看 queue:get_r/1 的执行情况，他看起来像 queue:tail/1 和 queue:dash/1 ，而这两个函数真的仅是 <a href="http://erlang.org/doc/man/queue.html#get_r-1" target="_blank" rel="external">queue:get_r/1</a> 别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:get_r(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-head-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:cons/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-queue-cons-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们稍微深入一下queue模块，我们讲讲来自Okazaki的API：<a href="http://www.erlang.org/doc/man/queue.html#cons-2" target="_blank" rel="external">queue:cons/2</a> 。</p>
<p>queue:cons/2 有两个入参，一个是元素，一个是队列，它执行后返回一个元素加在队列头部形成的新队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">7</span>, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[7]&#125;</span></div><div class="line">queue:cons(<span class="number">3</span>, queue:cons(<span class="number">7</span>, queue:new())).</div><div class="line"><span class="comment">% &#123;[7],[3]&#125;</span></div><div class="line">queue:cons(nil, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[nil]&#125;</span></div><div class="line">queue:cons(<span class="number">5</span>, queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>])).</div><div class="line"><span class="comment">% &#123;[21],[5,7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们传入一个列表给 queue:cons/2 ，我们看到它出错，表明它想要一个队列，而不会隐式地将一个列表转成一个队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:in_r/2</span></div><div class="line"><span class="comment">%         called as queue:in_r(5,[1,2,3,4])</span></div></pre></td></tr></table></figure>
<p>因为队列被设置成一个双端队列，Okasaki API 也提供了一个对应的函数 <a href="http://www.erlang.org/doc/man/queue.html#snoc-2" target="_blank" rel="external">queque:snoc/2</a> ，它将元素加在传入的队列的尾部。注意，queue:snoc/2 和 queue:cons/2 两个函数的两个入参的顺序也是相反的；queue:snoc/2 的第一个入参上一个队列，而要加在它尾部的元素做为第二个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:snoc(queue:new(), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:snoc(queue:new(), <span class="number">7</span>), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5,21],[7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-cons-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-cons-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – filelib:is_file/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-filelib-is-file-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/filelib.html#is_file-1" target="_blank" rel="external">filelib:is_file/1</a>.</p>
<p>filelib:is_file/1 入参是一个表示文件名的字符串，它根据这个文件名所指的是否是文件或目录而返回true或者false。</p>
<p>这个函数在你正在需要从一个配置文件读取内容并且在尝试处理前确认这个文件或目录是否存在的时候有用，以便你可以在退出前得到一个友好的错误信息而不仅是引起一个系统错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(<span class="string">"foo"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"junk"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tmp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tempmp"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"temp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/bin"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/var"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/vars"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"."</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">".."</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>filelib:is_file/1 的入参也可以是一个原子，或者甚至也可以是一个嵌套的列表来表示一个文件名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(foo).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(junk).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file([<span class="string">"/usr"</span>, ['/local', '/bin']]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:iso_week_number/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#iso_week_number-1" target="_blank" rel="external">calendar:iso_week_number/1</a>.</p>
<p>calendar:iso_week_number/1 接收一个日期元组做为入参，然后返回一个由年份和周数字组成的元组。年份是入参里的年份，而周数字是一个1到53的整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">04</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">19</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">03</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">18</span>&#125;</div></pre></td></tr></table></figure>
<p>如果我们拿本周做为一个例子，我们可以看到本周是从星期一（五月四日）开始，而前一个星期天（五月三日）是属于上一个星期的。</p>
<p>我们看到一月一日是这一年的第一周，这没什么奇怪，而2015年的十二月三十一日是这一年的第53周。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">1</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">53</span>&#125;</div></pre></td></tr></table></figure>
<p>一开始听到一年有53周我们会很惊讶，因为几乎每个人都认为一年只有52周，直到你意识到有些十二月三十一日有时候是处于一周的开始，所以造成了它处在第53周，而它仅仅是这周的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:is_leap_year/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#is_leap_year-1" target="_blank" rel="external">calendar:is_leap_year/1</a>.</p>
<p>calendar:is_leap_year/1 接收一个非负整数表示的年份，如果这个年份是闰年，则返回true，否则返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(<span class="number">2015</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2012</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">2017</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2000</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">1900</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">0</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>有了这个Erlang核心库的内置函数，意味着你不需要编写代码或者甚至不需要查找规则来记住如何判断某个年份到底是不是闰年。</p>
<p>如果你传递一个负数来表示年份，Erlang将抛出一个异常，因为没有一个函数分支能匹配用负数来表示的年份。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(-<span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-1) (calendar.erl, line 183)</span></div><div class="line">calendar:is_leap_year(-<span class="number">4</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-4) (calendar.erl, line 183)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:valid_date/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-valid-date-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#valid_date-3" target="_blank" rel="external">calendar:valid_date/3</a>.</p>
<p>本来这次我是想讲函数 calendar:time_difference/3 ，但是当我详细看了 <a href="http://www.erlang.org/doc/man/calendar.html" target="_blank" rel="external">calendar</a> 模块的官方文档后，发现文档里已经说这个函数被淘汰了，所以今天我讲 calendar:valid_date/3 。</p>
<a id="more"></a>
<p>calendar:valid_date/3 的入参分别是一个表示年份的整数、一个表示月份的整数以及一个表示日的整数。如果传入的日期是有效的，则 calendar:valid_date/3 返回原子true，如果传入的日期是无效的，则 calendar:valid_date/3 返回原子false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">30</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2012</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">17</span>, <span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>我们也可以快速地检查一下本篇文章发布的日期也是有效日期。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在让我们看看入参中有0或负整数情况会怎么样？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(-<span class="number">1</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, -<span class="number">7</span>, <span class="number">21</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">7</span>, -<span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>正如人们所希望的，除非你要经常处理公元前的日期，不然的话有一个负数的日期是无效的。</p>
<p>Erlang也提供了函数 calendar:valid_date/1 ，它的入参是由年、月、日三个整数组成的元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>&#125;).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:date_to_gregorian_days/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-date-to-gregorian-days-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#date_to_gregorian_days-3" target="_blank" rel="external">calendar:date_to_gregorian_days/3</a>.</p>
<p>正如我们上星期在 <a href="http://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">Erlang Thursday calendar:day_of_the_week/3</a> 中讲到的，当我们看到一些错误消息的时候，我们看到错误来自于 calendar:date_to_gregorian_days/3。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>在上星期那篇文章里我保证我们下次将深入了解 calendar:date_to_gregorian_days/3 ，所以现在让我们来完成这个任务。</p>
<p>calendar:date_to_gregorian_days/3 有三个入参，一个代表年份的非负整数，一个代表月份的从1到12的整数，一个代表某月第几日的从1到31的整数，该函数返回的值是从公元元年1月1日截止到入参日期的天数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 366</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 719528</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 730484</span></div></pre></td></tr></table></figure>
<p>还有一个只接收一个入参的版本 calendar:date_to_gregorian_days/1，它的入参是由年、月、日三个整数组成元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>&#125;).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 366</span></div></pre></td></tr></table></figure>
<p>如果我们传给 calendar:date_to_gregorian_days/1 无效的日期，我们就会在错误消息里看到它正在调用 calendar:date_to_gregorian_days/3 。所以它是一个不错的辅助函数，不破坏我们的模式匹配。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;).</div><div class="line">** exception error: no function clause matching calendar:date_to_gregorian_days(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>) (calendar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:day_of_the_week/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-day-of-the-week-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#day_of_the_week-3" target="_blank" rel="external">calendar:day_of_the_week/3</a>.</p>
<p>calendar:day_of_the_week/3 允许你传入年、月、日然后得到这个日子在一个星期里是第几天。</p>
<a id="more"></a>
<p>第一个入参表示年份而且必须是非负整数。第二个入参是月份而且必须是1到12的整数（包括1和12），它表示公历的12个月份，1表示1月份。最后一个入参是第几日，必须是1到31（包括1和31）的整数。</p>
<p>calendar:day_of_the_week/3 返回一个1到7（包括1和7）的整数值，1表示星期一，7表示星期日。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 1</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 5</span></div><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 6</span></div></pre></td></tr></table></figure>
<p>本篇文章的发布日期是2015年4月9日，把它传给 calendar:day_of_the_week/3 ，得到返回值是4，正好表示星期四，也就是本系列文章发布的日子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>).</div><div class="line"><span class="comment">% 4</span></div></pre></td></tr></table></figure>
<p>还有一个 calendar:day_of_the_week/1 函数，它和上面的函数功能和参数要求基本一样，只是它只接收一个入参，这个入参是由年、月、日组成的三元素元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>为了帮助大家认识 calendar:day_of_the_week/3 函数返回的错误消息，让我们看看，当我们给该函数传递无效日期，我们会得到什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>如果你仔细看这些错误消息，你会看到 calendar:day_of_the_week/3 调用了 calendar:date_to_gregorian_days/3 ，我们将在下个星期的Erlang Thursday来介绍它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thurday – lists:delete/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thurday-lists-delete-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#delete-2" target="_blank" rel="external">lists:delete/2</a> 。</p>
<p>lists:delete/2 接收一个Erlang term作为它的第一个入参，它将把该term从第二个入参－－一个列表里删除掉。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [8,7,6,5,4,3,2]</span></div><div class="line">lists:delete(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,5,8]</span></div><div class="line">lists:delete(<span class="number">72</span>, <span class="string">"Hello World!"</span>).</div><div class="line"><span class="comment">% "ello World!"</span></div><div class="line">lists:delete(d, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:delete(<span class="number">4</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:delete(&#123;b, <span class="number">2</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% [&#123;a,1&#125;,&#123;c,3&#125;]</span></div><div class="line">lists:delete([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]).</div><div class="line"><span class="comment">% [[4,5,6],[7,8,9]]</span></div></pre></td></tr></table></figure>
<p>注意：lists:delete/2 仅仅是将第一个在列表里发现的term删掉，而其他任何在列表里同样的term它不会删除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8]</span></div></pre></td></tr></table></figure>
<p>因为 lists:delete/2 是一个非常简单就能讲清楚用法的函数，这样这篇文章将可能非常短，所以我想在下面我们展示一下如何自己来写一个非常简单(1) 的 lists:delete/2 实现是非常值得的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>让我们一起看看我们的delete函数在被调用的时候是如何执行的？</p>
<p>my_lists:delete/2 是一个友好的API函数，它仅仅是调用一个“私有”函数（没有导出的函数）－－ delete/3，所以调用者不需要担心那个我们传递的已经检查了的一个空列表作为初始值的累加器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div></pre></td></tr></table></figure>
<p>delete/3函数的第一个分支用模式匹配来检查我们想要删除掉元素是否也是需要检查的列表的第一个元素。如果模式匹配成果，我们会看到第一个元素被删除！接着我们就能停止处理列表并返回的结果，而这个结果是由我们已经检查过的元素组成列表的反转列表和那些剩下的我们还没有检查的元素组成的列表一起构成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div></pre></td></tr></table></figure>
<p>第二个分支“知道”我们想删除掉元素和剩下的列表的第一个元素不匹配。它是怎么“知道”的？因为如果它们匹配，第一个分支将模式匹配成功而第二个分支将得不到执行的机会。因为我们找不到元素需要被删除，我们通过将元素加到被检查过的元素组成的列表头部，并且继续调用 delete/3 。我们通过在被检查过的元素组成的列表头部加上元素形成新的被检查过元素组成的列表的做法就是为什么我们在第一分支和第三分支需要反转被检查元素组成的列表的原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div></pre></td></tr></table></figure>
<p>第三个也是最后一个 delete/3 函数的分支已经搜索到列表的结尾并且没有发现相同的元素，所以我们只是将被检查过的元素组成的列表反转后返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>这就是你自己的简单(1)版 lists:delete/2 的实现。</p>
<p>1、简单的意思是因为这个版本没有进行性能优化，或者没有做彻底的是否完全符合 lists:delete/2 规范的测试。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-lists-delete-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-lists-delete-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erlang:list_to_atom/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-erlang-list-to-atom-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erlang.html#list_to_atom-1" target="_blank" rel="external">erlang:list_to_atom/1</a>.</p>
<p>erlang:list_to_atom/1 的入参是一个字符串，返回的是一个Erlang的原子。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>)</span>.</span></div><div class="line">% <span class="title">foo</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo"</span>)</span>.</div><div class="line">% <span class="title">'Foo'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo_bar"</span>)</span>.</div><div class="line">% <span class="title">'Foo_bar'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo_bar"</span>)</span>.</div><div class="line">% <span class="title">foo_bar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>++<span class="string">"bar"</span>)</span>.</div><div class="line">% <span class="title">foobar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Erlang"</span>)</span>.</div><div class="line">% <span class="title">'Erlang'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Elixir"</span>)</span>.</div><div class="line">% <span class="title">'Elixir'</span></div></pre></td></tr></table></figure>
<p>这个函数在你必须要基于从外部系统读到的字符串，比如解析一个CSV类型的头部，生成键或标识符的时候有用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> erlang:list_to_atom/<span class="number">1</span>,      	     string:tokens(<span class="string">"firstName,lastName,age,gender,preferredName,dateOfBirth"</span>, <span class="string">","</span>)).</div><div class="line"><span class="comment">% [firstName,lastName,age,gender,preferredName,dateOfBirth]</span></div></pre></td></tr></table></figure>
<p>当你用 erlang:list_to_atom/1 将从外部系统获取的字符串转换成原子的时候一定要小心，因为它只能处理值为256以下的字符。任何字符值在256（注1）以下的字符串都能正常地用该函数转成一个原子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">list_to_atom("Joe, Mike, and Robert").</div><div class="line">% 'Joe, Mike, and Robert'</div><div class="line">list_to_atom("it's").</div><div class="line">% 'it's'</div><div class="line">list_to_atom("heyn").</div><div class="line">% 'heyn'</div><div class="line">list_to_atom("with_supported_char"++[255]).</div><div class="line">% with_supported_charÿ</div><div class="line">list_to_atom("with_non_supported_char"++[256]).</div><div class="line">% ** exception error: bad argument</div><div class="line">%      in function  list_to_atom/1</div><div class="line">%         called as list_to_atom([119,105,116,104,95,110,111,110,95,115,117,112,112,111,114,</div><div class="line">%                                 116,101,100,95,99,104,97,114,256])</div></pre></td></tr></table></figure>
<p>1、字符值必须是非负整数，范围是0到255。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thurday – ordsets:is_disjoint/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thurday-ordsets-is-disjoint-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/ordsets.html#is_disjoint-2" target="_blank" rel="external">ordsets:is_disjoint/2</a>.</p>
<p>在日常的编码中，你应该会碰到这样的问题，如何判断一个给定的列表，它的元素不在另一个列表里出现。</p>
<a id="more"></a>
<p>你的第一个直觉可能写出的代码像如下这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">not</span><span class="params">( lists:any(<span class="keyword">fun</span>(Item) -&gt; lists:member(Item, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]) <span class="keyword">end</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span>.</span></div><div class="line">% <span class="title">true</span></div></pre></td></tr></table></figure>
<p>如果你更多地在数学的范畴里定义你的问题，你可以从集合方向上开始思考，那么这个问题会更清晰。当你开始在集合的方向上思考，你会意识到你可以检查两个集合的交集是否是空集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ordsets:intersection([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]) =:= [].</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这样不仅更加简洁，而且更加明确你需要检查的是什么。</p>
<p>实际上，当你通过判断两个列表是否是不相交的，你可以做的更好。下面我们开始看看 ordsets:is_disjoint/2 。</p>
<p>ordsets:is_disjoint/2 接收两个列表做为入参，当两个列表没有共同的元素的时候函数返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>因为 ordsets:is_disjoint/2 是对两个列表进行判断，所以我们没必要先调用所谓的 ordsets:disjoint/2 来确定列表元素是唯一的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>如果任何一个入参是空列表，则 ordsets:is_disjoint/2 返回的结果都是说这两个列表是不相交的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([], []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>另外，如果你很好奇，想看看用 timer:tc/3 来测量 ordsets:is_disjoint/2 的运行时间，那么我们可以看到，只要 Erlang 知道了两个列表是不相交的，它就立马返回false，如果你记得我们前面的文章 <a href="http://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">Erlang Thursday on timer:tc/3</a> ，你就知道它的返回值是一个元组，元组的第一个元素就是代表被测量函数运行时间，其单位是微秒。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(ordsets, is_disjoint, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>), lists:seq(<span class="number">2000000</span>, <span class="number">3000000</span>)]).</div><div class="line"><span class="comment">% &#123;19032,true&#125;</span></div><div class="line">timer:tc(ordsets, is_disjoint, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>), lists:seq(<span class="number">1</span>, <span class="number">3000000</span>)]).</div><div class="line"><span class="comment">% &#123;2,false&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-ordsets-is_disjoint-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-ordsets-is_disjoint-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:flatmap/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-lists-flatmap-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#flatmap-2" target="_blank" rel="external">lists:flatmap/2</a>.</p>
<p>选择这个函数来讲是因为这个星期早些时候我做的一些 <a href="http://elixir-lang.org/" target="_blank" rel="external">Elixir</a> 练习，在这些练习中我使用 Enum.flat_map/2 函数而它却不是像我期待的那样起作用，这个情况让我很困惑。</p>
<a id="more"></a>
<p>于是我回到Erlang来研究 lists:flatmap/2 的执行情况，然后在完全了解了该函数在Erlang里没有正确执行的原因后，我终于明白了这个函数的运行模式，同时我也意识到原来我对这个函数有错误的认识，所以是时候回来说清楚 lists:flatmap/2 实际上做了些什么。</p>
<p>不知何故，我曾误以为 lists:flatmap/2 就是接收一个任意嵌套深度的列表做为入参，并将他们的扁平化后每个元素都应用在map函数上，就相当于下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X * X <span class="keyword">end</span>, lists:flatten([<span class="number">1</span>, [[<span class="number">2</span>, [<span class="number">3</span>]], <span class="number">4</span>]])).</div><div class="line"><span class="comment">% [1,4,9,16]</span></div></pre></td></tr></table></figure>
<p>即使更近一步阅读 Ruby 文档，甚至在尝试 Ruby 的 flat_map 函数后，很显然我依然完全不理解它上如何工作的，所以是时候仔细阅读 Erlang 文档了。</p>
<p>Erlang文档说明 lists:flatmap/2 第一个入参是一个函数，这个入参函数接收一个类型A的元素然后返回一个由类型B的元素组成的列表；lists:flatmap/2 的第二个入参是一个由类型A的元素组成的列表。</p>
<p>我已经困惑于它到底是如何工作的，而且文档也没说明，直到我看到文档的一部分描述了 lists:flatmap/2 的工作原理入下面的定义一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">flatmap</span><span class="params">(Fun, List1)</span> -&gt;</span></div><div class="line">    append(map(Fun, List1)).</div></pre></td></tr></table></figure>
<p>这个定义一下子让我明白了 lists:flatmap/2 到底是如何执行的。以前在我的脑海里，我认为首先是扁平化列表，然后在将各个列表元素应用于map函数上，但是实际上，它首先将各个列表元素应用于map函数上，然后再简单地扁平化，而且仅仅是做了一个层级的扁平化。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lists:flatmap(<span class="keyword">fun</span>(&#123;Item, Count&#125;) -&gt;</div><div class="line">                  lists:duplicate(Count, Item)</div><div class="line">              <span class="keyword">end</span>,</div><div class="line">              [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;'C', <span class="number">3</span>&#125;, &#123;'_d_', <span class="number">4</span>&#125;]).</div><div class="line"><span class="comment">% [a,b,b,'C','C','C','_d_','_d_','_d_','_d_']</span></div></pre></td></tr></table></figure>
<p>而如果我们将相同的数据先传给map函数，然后再将其结果传给append函数，我们会得到相同的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:append(</div><div class="line">    lists:map(<span class="keyword">fun</span>(&#123;Item, Count&#125;) -&gt;</div><div class="line">                  lists:duplicate(Count, Item)</div><div class="line">              <span class="keyword">end</span>,</div><div class="line">              [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;'C', <span class="number">3</span>&#125;, &#123;'_d_', <span class="number">4</span>&#125;])).</div><div class="line"><span class="comment">% [a,b,b,'C','C','C','_d_','_d_','_d_','_d_']</span></div></pre></td></tr></table></figure>
<p>同时我们更进一步了解到，lists:flatmap/2 甚至不将列表扁平化，而只是简单地将map函数返回的列表链接起来。如下面的例子，最后的结果仍然是一个嵌套的列表结构，而不是只有一个层级的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatmap(<span class="keyword">fun</span>(X) -&gt; [X, [X]] <span class="keyword">end</span>, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,[a],b,[b],c,,d,[d]]</span></div></pre></td></tr></table></figure>
<p>希望本文能让你不要陷入我曾经的困惑。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-flatmap-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-flatmap-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:local_time_to_universal_time_dst/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-local-time-to-universal-time-dst-1/</url>
      <content type="html"><![CDATA[<p>（译者注：本文里的例子结果在中国时区是不同的）</p>
<p>为了纪念本周末的时间变化，今天的 Erlang Thursday 要讲的函数是  <a href="http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time_dst-1" target="_blank" rel="external">calendar:local_time_to_universal_time_dst/1</a>.</p>
<a id="more"></a>
<p>为了更好地理解 calendar:local_time_to_universal_time_dst/1 是做什么的，我们将用它和 <a href="http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time-1" target="_blank" rel="external">calendar:local_time_to_universal_time/1</a> 进行比较。</p>
<p>即将到来的星期日我们将在临晨两点把时钟拨快一个小时，那么让我们来看看在临晨一点五十九分的时候UTC时间是多少？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">1</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,3,8&#125;,&#123;7,59,59&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>现在让我们看看当日临晨两点的时候 calendar:local_time_to_universal_time/1 返回的UTC时间是多少，实际上当日临晨两点我们根本没有到达过，因为我们直接将时间向前拨快了到临晨三点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,3,8&#125;,&#123;8,0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>但是当我们深入函数库里，我们看到也有另外一个函数 calendar:local_time_to_universal_time_dst/1. calendar:local_time_to_universal_time_dst/1 返回值是一个由时间元组组成的列表，让我们开始看看为什么这很重要。</p>
<p>此时，让我调用 calendar:local_time_to_universal_time_dst/1 并传入当日临晨两点作为参数，然后我们看到的结果是什么呢。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>一个空列表！</p>
<p>如果你花一点时间来想一想，这是有道理的，因为临晨两点根本就没发生过，所以就没有UTC时间和它对应上。</p>
<p>那么当我们跳到临晨三点我们看到什么呢？我们将得到早上八点UTC时间，这仅仅是在临晨一点五十九分五十九秒的一秒之后的UTC时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,3,8&#125;,&#123;8,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>为了涵盖本周末的情况，让我们来看看在今年晚些时候也就是11月1日将时钟拨慢一小时会发生什么。</p>
<p>从一个基准时间开始，让我们看看零点五十九分五十九秒（译者注：原文是12:59:59AM，应该是作者手误）是多少UTC时间，我们知道这个时间我们将仅遇到一次。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,11,1&#125;,&#123;5,59,59&#125;&#125;</span></div><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;5,59,59&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>而且即使时间的变化发生在临晨两点，我们仍然只是遇到一次，因为我们第一次直接移动到临晨一点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;8,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>所以零点五十九分五十九秒，我们得到UTC时间五点五十九分五十九秒，而两点，我们得到UTC时间是八点。现在到了棘手的部分，凌晨一点。</p>
<p>临晨一点是一个奇怪的场景，当日晚上我们将度过两个临晨一点。那么让我们看看Erlang在这种情况下做了什么。</p>
<p>首先，我们看看在临晨一点的时候我们调用 calendar:local_time_to_universal_time 得到的UTC时间是多少。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,11,1&#125;,&#123;6,0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我们得到UTC时间是六点。我们从UTC时间五点五十九分五十九秒移动到UTC时间六点；这是合理的，直到我们开始怀疑我们第二次遇到临晨一点。</p>
<p>现在，让我们看看在临晨一点的时候我们调用 calendar:local_time_to_universal_time_dst/1 会得到什么UTC时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;6,0,0&#125;&#125;,&#123;&#123;2015,11,1&#125;,&#123;7,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>我们得到由两个UTC时间组成的列表，一个是我们第一次遇到临晨一点时的UTC时间六点，另一个是我们第二次遇到临晨一点的UTC时间七点。这个返回两个UTC时间的情况也在临晨一点内的每秒钟出现。（译者注：原文是every time，译者认为应该是every second）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;6,59,59&#125;&#125;,&#123;&#123;2015,11,1&#125;,&#123;7,59,59&#125;&#125;]</span></div></pre></td></tr></table></figure>
<p>通过返回没有元素、一个元素或者两个元素的列表，Erlang提供给你最精确的信息为你所用，同时让你做出希望如何处理时间的明智的决定，而不是为你做出一些决定即使它们不符合你的系统需要。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-local_time_to_universal_time_dst-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-local_time_to_universal_time_dst-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – dict:merge/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-dict-merge-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/dict.html#merge-3" target="_blank" rel="external">dict:merge/3</a>.</p>
<p>dict:merge/3 有三个入参，第一个入参是一个合并函数，它在发生键冲突的时候被调用，第二和第三个入参都是字典。</p>
<a id="more"></a>
<p>合并函数用键作为第一个入参，第一个字典对应的值作为第二个入参，第二个字典来对于的值作为第三个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, Value2) -&gt; [Value1, Value2] <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x,5,7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div><div class="line"></div><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, Value2) -&gt; Value1 * Value2 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|35]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>传给dict:merge/3的合并函数仅在发生冲突的时候才被调用。如下代码例子，合并函数体里有一个exit的调用，只要合并函数备调用就将导致进程的结束。（译者注：此处的代码并没有触发合并函数的调用，因为两个字典没有相同的键）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, _Value1, _Value2) -&gt; exit(merge_happened) <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果你想让合并函数将第二个字典覆盖第一个字典，那么合并函数在出现键冲突的时候只需要返回第二个字典里的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, _Value1, Value2) -&gt; Value2 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果你想保持第一个字典里的所有键和值，仅仅是将那些不在第一个字典里而在第二个字典里的键和值加进来，合并函数只需要返回第一个字典的相关值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, _Value2) -&gt; Value1 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|5]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>另外，大家可以关注Erlang 17.0中引入的新数据类型Maps。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-dict-merge-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-dict-merge-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – string:join/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-string-join-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/string.html#join-2" target="_blank" rel="external">string:join/2</a>.</p>
<p>string:join/2 有两个入参，第一个是由字符串为元素组成的列表，第二个是一个当作分隔符的字符串，输出是由分隔符将各个字符串串起来组成的字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">91</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">""</span>).</div><div class="line"><span class="string">"abc"</span></div><div class="line"><span class="number">92</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"-"</span>).</div><div class="line"><span class="string">"a-b-c"</span></div></pre></td></tr></table></figure>
<p>分隔符字符串可以是任意长度的字符串，也不必仅仅是单个字符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">93</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"___"</span>).</div><div class="line"><span class="string">"a___b___c"</span></div><div class="line"><span class="number">94</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">" "</span>).</div><div class="line"><span class="string">"a b c"</span></div></pre></td></tr></table></figure>
<p>而且任何字符串，字符列表，或者甚至是整数列表，都可以用作分隔符字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], [$A]).</div><div class="line"><span class="string">"aAbAc"</span></div><div class="line">string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], [<span class="number">52</span>]).</div><div class="line"><span class="string">"a4b4c"</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-string-join-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-string-join-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – string:tokens/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-string-tokens-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是  <a href="http://www.erlang.org/doc/man/string.html#tokens-2" target="_blank" rel="external">string:tokens/2</a>.</p>
<p>string:tokens/2 第一个入参是一个字符串，第二入参是一个分割字符列表，返回值是被分割后的字符串列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"foo"</span>, <span class="string">""</span>).</div><div class="line"><span class="comment">% ["foo"]</span></div><div class="line">string:tokens(<span class="string">"banana"</span>, <span class="string">"a"</span>).</div><div class="line"><span class="comment">% ["b","n","n"]</span></div><div class="line">string:tokens(<span class="string">"It was the best of times, it was the worst of times"</span>, <span class="string">" "</span>).</div><div class="line"><span class="comment">% ["It","was","the","best","of","times,","it","was","the",</span></div><div class="line"><span class="comment">%  "worst","of","times"]</span></div></pre></td></tr></table></figure>
<p>当连续的分割字符出现在字符串里，它们将被当做一个分割字符，并且没有空字符串返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"s"</span>).</div><div class="line"><span class="comment">% ["Mi","i","ippi"]</span></div><div class="line"><span class="number">65</span>&gt; string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"sp"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"is"</span>).</div><div class="line"><span class="comment">% ["M","pp"]</span></div></pre></td></tr></table></figure>
<p>传个 string:tokens/2 的分割字符列表的字符顺序无关紧要，可以按任意顺序指定。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"ps"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div><div class="line"><span class="number">65</span>&gt; string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"sp"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div></pre></td></tr></table></figure>
<p>同时由于分隔符列表只是简单的一个分割字符串列表，我们可以不是传递一个字符串，而是把字符的整数值组成的列表当做一个列表传给函数，因为一个整数值的列表和字符串是一样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$s.</div><div class="line"><span class="comment">% 115</span></div><div class="line">$p.</div><div class="line"><span class="comment">% 112</span></div><div class="line">[<span class="number">115</span>, <span class="number">112</span>].</div><div class="line"><span class="comment">% "sp"</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, [<span class="number">115</span>]).</div><div class="line"><span class="comment">% ["Mi","i","ippi"]</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, [<span class="number">115</span>, <span class="number">112</span>]).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-string-tokens-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-string-tokens-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:dropwhile/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-lists-dropwhile-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#dropwhile-2" target="_blank" rel="external">lists:dropwhile/2</a> 。</p>
<p>lists:dropwhile/2 接收一个断言函数和一个列表作为入参并且返回一个列表。从入参列表第一个元素开始逐个代入断言函数，如果断言函数返回值为true，则拿掉该元素，当遇到第一个使得判断函数返回值为false的元素，则停止继续判断。剩下的元素组成的列表作为结果返回。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:dropwhile(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,4]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [-1,0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [-2,-1,0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]).</div><div class="line"><span class="comment">% [0,-1,-2,-3,-4,-5]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; <span class="literal">true</span> <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; <span class="literal">false</span> <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [hello,'World',foo,1,3,bar,4]</span></div></pre></td></tr></table></figure>
<p>不像 <a href="http://www.proctor-it.com/erlang-thursday-lists-filter-2" target="_blank" rel="external">lists:filter/2</a>，lists:dropwhile/2 在断言函数返回false的时候就立即停止检查入参列表。这就意味着那些代入断言函数将返回true的元素仍然可以出现在返回列表里，只要它们排在那个使得断言函数返回false的元素之后。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:dropwhile(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,bar,4]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="keyword">not</span> is_atom(X) <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,4]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% [0,1,-5,3,7]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt;= <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% [0,1,3,7]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-dropwhile-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-dropwhile-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:filter/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-lists-filter-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是  <a href="http://www.erlang.org/doc/man/lists.html#filter-2" target="_blank" rel="external">lists:filter/2</a>.</p>
<p>lists:filter/2有两个入参：一个断言函数和一个被遍历的列表。它的返回值是是一个列表，其元素是入参列表的元素应用于断言函数返回值是true的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> =:= <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, a, <span class="number">3</span>, &#123;a, b&#125;, 'World', foo]).</div><div class="line"><span class="comment">% [a,'World',foo]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">3</span>, foo, -<span class="number">13</span>, <span class="number">43</span>]).</div><div class="line"><span class="comment">% [1,foo,43]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="literal">false</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="literal">true</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-filter-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-filter-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – httpc:request/1 and httpc:request/4]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-httpc-request-1-and-httpc-request-4/</url>
      <content type="html"><![CDATA[<p>今天的 Erlang Thursday 讲的是 <a href="http://www.erlang.org/doc/man/httpc.html#request-1" target="_blank" rel="external">httpc:request/1</a> 和 <a href="http://www.erlang.org/doc/man/httpc.html#request-4" target="_blank" rel="external">httpc:request/4</a> 。httpc模块是erlang的HTTP1.1 客户端，request函数是erlang的功能强大的web请求工具。</p>
<p>要使用httpc模块，我们必需先确保 inets 已经启动。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inets:start().</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>httpc:requst/1 接收一个入参，就是一个RUL，它是一个erlang字符串，也就是你需要访问的地址。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(<span class="string">"http://www.example.com"</span>).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 02:57:06 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 02:57:06 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>httpc:request/1 和 httpc:request/4 功能是一样的， 相当于 httpc:request(get, {Url, []}, [], []) 这样被调用一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], []).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:04:31 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 03:04:31 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我们可以指定我们请求的头部内容。比如，我们想得到在瑞典的DuckDuckGo主页来纪念Erlang由由爱立信创建。为了实现这个功能，我们增加一个元组{“Accept-Language”, “sv”}到请求的头部列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://duckduckgo.com/"</span>, [&#123;<span class="string">"Accept-Language"</span>, <span class="string">"sv"</span>&#125;]&#125;, [], []).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=1"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"connection","keep-alive"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:19:29 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""54bfe2a8-1488""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","nginx"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","5256"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html; charset=UTF-8"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 22 Jan 2015 03:19:30 GMT"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!DOCTYPE html&gt;n&lt;!--[if IEMobile 7 ]&gt; &lt;html lang="sv_SE" class="no-js iem7"&gt; ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>httpc:request/4 的第三个入参是一个HTTP选项元组组成的列表。比如，你必需设置一个返回超时来避免从一个不可靠的或者一个不能及时返回的慢网站等待结果，请求代码需要回撤并稍后再尝试从而避免触发服务拒绝的攻击后果。下面的例子，我指定一个超时时间为0，单位是毫秒，来确保上述描述的目的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://erlang.org/"</span>, []&#125;, [&#123;timeout, <span class="number">0</span>&#125;], []).</div><div class="line">&#123;error,&#123;failed_connect,[&#123;to_address,&#123;<span class="string">"erlang.org"</span>,<span class="number">80</span>&#125;&#125;,</div><div class="line">                        &#123;inet,[inet],timeout&#125;]&#125;&#125;</div></pre></td></tr></table></figure>
<p>httpc:request/4 的最后一个入参是一个选项列表，它们是Erlang这端如何工作的选项。比如，你想异步请求，并在它完成后收到一条消息，这样你需要指定元组{sync, false}作为选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;ok, RequestId&#125; = httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], [&#123;sync, false&#125;]).</div><div class="line"><span class="comment">% &#123;ok,#Ref&lt;0.0.0.179&gt;&#125;</span></div><div class="line"><span class="keyword">receive</span> &#123;http, &#123;RequestId, Result&#125;&#125; -&gt; Result <span class="keyword">after</span> <span class="number">500</span> -&gt; error <span class="keyword">end</span>.</div><div class="line"><span class="comment">% &#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%  [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"date","Thu, 22 Jan 2015 03:08:41 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%   &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"expires","Thu, 29 Jan 2015 03:08:41 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%  &lt;&lt;"&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta "...&gt;&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>或者如果你想返回结果用Erlang二进制而不是Erlang字符串，你可以这么指定选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], [&#123;body_format, binary&#125;]).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:58:55 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 03:58:55 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      &lt;&lt;"&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta "...&gt;&gt;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>这篇文章仅仅是描述了你可以用httpc:request/4 来做一些很简单的事情。我强烈建议你阅读Erlang官方文档的<a href="http://www.erlang.org/doc/man/httpc.html" target="_blank" rel="external">httpc模块</a>部分。更多的例子和信息也可以阅读 <a href="http://www.erlang.org/doc/apps/inets/inets_services.html" target="_blank" rel="external">Erlang inets User Guide</a>，和 <a href="http://www.erlang.org/doc/apps/inets/http_client.html" target="_blank" rel="external">HTTP Client</a> 章节。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-httpc-request-1-and-httpc-request-4/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-httpc-request-1-and-httpc-request-4/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erlang:apply/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-erlang-apply-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲 <a href="http://www.erlang.org/doc/man/erlang.html#apply-3" target="_blank" rel="external">erlang:apply/3</a>.</p>
<p>在函数式语言里，我们喜欢将函数当做第一等公民看待将它在程序中传递。但是有些时候，我们并不知道我们将要调用哪一个函数，从而导致我们不确定函数的参数是什么。如果我们知道要调用哪个函数，我们只需像这样 Fun(Arg1, Arg2, …, ArgN) 来调用，但是如果我们遇到有不同参数数量的场景就没法这么干了。怎么办？还是让我们进入今天的主题：erlang:apply/3 。</p>
<a id="more"></a>
<p>erlang:apply/3，三个入参分别是模块名、函数名、一个要传给函数的实参组成的列表。传给erlang:apply/3的函数必需也是被导出的，否则将有错误发生。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">erlang:apply(lists, max, [[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">1</span>]]).</div><div class="line"><span class="comment">% 11</span></div><div class="line">erlang:apply(lists, merge, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">erlang:apply(lists, merge, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div></pre></td></tr></table></figure>
<p>Erlang的官方文档特别指出，erlang:apply/3仅仅是在我们不完全清楚函数的参数数量的时候来使用。否则我们只需按平常的函数调用来做，即使以匿名函数的方式来传递。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">fun</span> lists:max/<span class="number">1</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>erlang模块也包括另一个版本 erlang:apply/2 ，第一个入参是一个函数，第二个人才是这个函数的实参的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erlang:apply(<span class="keyword">fun</span> lists:merge/<span class="number">2</span>, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div></pre></td></tr></table></figure>
<p>erlang:apply/2 和 erlang:apply/3 并不是我们的通常用法，它在一些特殊场合，它是必要的，比如上星期的 <a href="http://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">timer:tc</a> 。虽然我们将很少用到它，但是了解它对我们也有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-apply-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-apply-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - timer:tc/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-timer-tc-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday要讲的函数是 <a href="http://www.erlang.org/doc/man/timer.html#tc-3" target="_blank" rel="external">timer:tc/3</a>.</p>
<p>我相信我们所有人写测量目标代码执行耗时的代码都是先获取当前时间，接着执行目标代码，再获取当前时间，最后将前后两个时间的差作为目标代码的执行耗时。在Erlang里，按这种方式来写的话将像下面这样：</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Time1 = now().</div><div class="line"><span class="comment">% &#123;1420,519186,111375&#125;</span></div><div class="line">timer:sleep(<span class="number">4000</span>).  <span class="comment">% Do something</span></div><div class="line"><span class="comment">% ok</span></div><div class="line">Time2 = now().</div><div class="line"><span class="comment">% &#123;1420,519190,118280&#125;</span></div><div class="line">timer:now_diff(Time2, Time1).</div><div class="line"><span class="comment">% 4006905</span></div></pre></td></tr></table></figure>
<p>我们可以注意到这么一个现象：因为now()函数返回一个元组格式的时间戳，所以我们不能将两个元组相减来得到时间差，就像我们在其他语言里能够将两个时间相减；因此我们必需使用 <a href="http://www.erlang.org/doc/man/timer.html#now_diff-2" target="_blank" rel="external">timer:now_diff/2</a> 。</p>
<p>作为一个好的“工程师”，我们知道因为我们必需在应用的不同地方做一些事情，那么我们可以在一个地方创建我们自己的函数让这个函数去做这些事情。</p>
<p>难过的是（意思是我们不需要这么做了）：聪明的Erlang语言团队已经为我们做了这个事情并且以timer:tc/3这个函数的方式提供给我们用。</p>
<p>timer:tc/3接收模块名，函数名以及一个参数列表作为入参。因为我们通常要得到我们调用的函数的结果，另外还有时长，这个结果就是一个元组，其中第一个元素是时长，它的单位是微妙，另一个元素是传给timer:tc/3的第二个参数（它是一个函数）的执行结果。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(timer, sleep, [<span class="number">4000</span>]).</div><div class="line"><span class="comment">% &#123;4003097,ok&#125;</span></div><div class="line">timer:tc(lists, foldl, [<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)]).</div><div class="line"><span class="comment">% &#123;5099481,2000001000000&#125;</span></div></pre></td></tr></table></figure>
<p>另外还有timer:tc/1，它仅接收一个函数并执行它；还有timer:tc/2，它接收一个函数和一个入参列表，然后执行它。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(<span class="keyword">fun</span>() -&gt; lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% &#123;5709293,2000001000000&#125;</span></div><div class="line">timer:tc(<span class="keyword">fun</span> lists:foldl/<span class="number">3</span>, [<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)]).</div><div class="line"><span class="comment">% &#123;5766480,2000001000000&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-timer-tc-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:any/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-any-2/</url>
      <content type="html"><![CDATA[<p>今天的 Erlang Thursday 要讲的函数是 <a href="http://www.erlang.org/doc/man/lists.html#any-2" target="_blank" rel="external">lists:any/2</a>.</p>
<p>lists:any/2 接收一个断言函数作为第一个入参，一个将被遍历的列表作为第二个入参。如果这个断言函数对于任意一个给定列表的元素返回 true 的话lists:any/2 返回 true ，否则， lists:any/2 返回 false 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lists:any(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:any(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:any(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">3</span>, <span class="number">4</span>, a, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:any(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:any(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>lists:any/2 是个急性子，只要它发现某个元素使得断言函数返回true，它就立即返回true，并且忽略剩下的列表元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(lists, any, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;248410,false&#125;</span></div><div class="line">timer:tc(lists, any, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">0</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;13,true&#125;</span></div></pre></td></tr></table></figure>
<p>lists模块也包含 lists:all/2 函数，它和 lists:any/2 有点类似，不过它是通过断言函数检查每一个列表的元素，如果都返回true，则它就返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:all(<span class="keyword">fun</span> erlang:is_number/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:all(<span class="keyword">fun</span> erlang:is_number/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>lists:all/2 也是一个急性子，一旦某个列表元素使得断言函数返回false，它就立即返回false，并且忽略后续的列表元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(lists, all, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">0</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;235276,true&#125;</span></div><div class="line">timer:tc(lists, all, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;14,false&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-any-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-any-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:partition/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-partition-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#partition-2" target="_blank" rel="external">lists:partition/2</a>.</p>
<p>lists:partition/2 接收两个入参，第一个入参是一个断言函数，它将被调用对列表里的每个元素进行处理然后返回一个布尔值。第二个入参是一个将被分隔的列表。</p>
<p>lists:parition/2 返回一个两元素的元组，这个元组的第一个元素是一个列表，这个列表的元素是断言函数返回真值所对应的元素组成；元组第二个元素也是一个列表，它是断言函数返回false所对应的元素组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lists:partition(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% &#123;[1,3,5,7],[2,4,6]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">3</span> == <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% &#123;[3,6],[1,2,4,5,7]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [a, <span class="number">1</span>, [b, c], 'B', <span class="keyword">fun</span> lists:sum/<span class="number">1</span>]).</div><div class="line"><span class="comment">% &#123;[a,'B'],[1,[b,c],#Fun&lt;lists.sum.1&gt;]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [a, <span class="number">1</span>, &#123;b, [z]&#125;, 'B', <span class="keyword">fun</span> lists:sum/<span class="number">1</span>]).</div><div class="line"><span class="comment">% &#123;[a,'B'],[1,&#123;b,[z]&#125;,#Fun&lt;lists.sum.1&gt;]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, []).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-partition-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-partition-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:zip/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-zip-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的函数是 <a href="http://www.erlang.org/doc/man/lists.html#zip-2" target="_blank" rel="external">lists:zip/2</a>.</p>
<p>lists:zip/2 返回一个由两元素元组组成的列表，其中两元素元组是由两个入参列表位置相对应的元素组成。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:zip([a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [&#123;a,1&#125;,&#123;b,2&#125;,&#123;c,3&#125;,&#123;d,4&#125;]</span></div><div class="line">lists:zip([a, b, c, d], [&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">3</span>, <span class="number">7</span>&#125;, &#123;<span class="number">4</span>, <span class="number">11</span>&#125;]).</div><div class="line"><span class="comment">% [&#123;a,&#123;1,3&#125;&#125;,&#123;b,&#123;2,5&#125;&#125;,&#123;c,&#123;3,7&#125;&#125;,&#123;d,&#123;4,11&#125;&#125;]</span></div><div class="line">lists:zip([a, b], [<span class="keyword">fun</span> lists:map/<span class="number">3</span>, <span class="keyword">fun</span> lists:foldl/<span class="number">3</span>]).</div><div class="line"><span class="comment">% [&#123;a,#Fun&lt;lists.map.3&gt;&#125;,&#123;b,#Fun&lt;lists.foldl.3&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>如果两个入参列表的长度不同，将抛出一个函数子句不匹配（function clause match）的异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:zip([a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:zip([d],[]) (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in function  lists:zip/2 (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in call from lists:zip/2 (lists.erl, line 385)</span></div><div class="line">lists:zip([a, b, c], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:zip([],[4]) (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in function  lists:zip/2 (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in call from lists:zip/2 (lists.erl, line 385)</span></div></pre></td></tr></table></figure>
<p>也有接收3个入参版本的zip函数：lists:zip3/3，它的功能和 lists:zip/2 一样，只是入参为3个列表而不是2个列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:zip3([a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">"alpha"</span>, <span class="string">"bravo"</span>, <span class="string">"charlie"</span>, <span class="string">"delta"</span>]).</div><div class="line"><span class="comment">% [&#123;a,1,"alpha"&#125;,&#123;b,2,"bravo"&#125;,&#123;c,3,"charlie"&#125;,&#123;d,4,"delta"&#125;]</span></div></pre></td></tr></table></figure>
<p>如果你想用不同的方式来组合列表中的元素，你可以用 <a href="http://www.erlang.org/doc/man/lists.html#zipwith-3" target="_blank" rel="external">lists:zipwith/3</a> 或者 <a href="http://www.erlang.org/doc/man/lists.html#zipwith3-4" target="_blank" rel="external">lists:zipwith3/4</a>，它们的第一个入参是一个接收两个入参的组合函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lists:zipwith(<span class="keyword">fun</span>(X, Y) -&gt; X * Y <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [2,6,12,20]</span></div><div class="line">lists:zipwith(<span class="keyword">fun</span>(X, Y) -&gt; X + Y <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [3,5,7,9]</span></div><div class="line">lists:zipwith3(<span class="keyword">fun</span>(X, Y, Z) -&gt; X * Y * Z <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [8,18,24,20]</span></div><div class="line">lists:zipwith3(<span class="keyword">fun</span>(X, Y, Z) -&gt; &#123;&#123;X, Y&#125;, Z&#125; <span class="keyword">end</span>, [a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">"alpha"</span>, <span class="string">"bravo"</span>, <span class="string">"charlie"</span>, <span class="string">"delta"</span>]).</div><div class="line"><span class="comment">% [&#123;&#123;a,1&#125;,"alpha"&#125;,</span></div><div class="line"><span class="comment">%  &#123;&#123;b,2&#125;,"bravo"&#125;,</span></div><div class="line"><span class="comment">%  &#123;&#123;c,3&#125;,"charlie"&#125;,</span></div><div class="line"><span class="comment">%  &#123;&#123;d,4&#125;,"delta"&#125;]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-zip-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-zip-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:foldl/3 and lists:foldr/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-foldl-3-and-lists-foldr-3/</url>
      <content type="html"><![CDATA[<p>今天Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#foldl-3" target="_blank" rel="external">lists:foldl/3</a> 和 <a href="http://www.erlang.org/doc/man/lists.html#foldr-3" target="_blank" rel="external">lists:foldr/3</a> 。</p>
<p>lists:foldl/3 是Erlang版的 reduce 函数。 lists:foldl/3 接收三个入参：一个函数，一个初始的累加器，一个列表，输出一个单一的值。</p>
<a id="more"></a>
<p>foldl的第一个入参是一个接收两个参数的函数，一个是当前循环到的列表元素，另一个是积累的值。这个函数的输出值作为循环到下一个列表元素的时候的累加器，或者当循环结束的时候作为foldl函数的输出值。</p>
<p>foldl的第二个入参是一个累加器的初始值。与其他一些语言不同，在其他语言里这个累加器的初始值是可选的，而且常常是使用循环列表的第一个元素作为默认值，但是在Erlang里，累加器的初始值必需作为lists:foldl/3和lists:foldr/3两个函数的入参。</p>
<p>第三个入参，也就是最后一个入参是将被循环遍历的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Sum) -&gt; Sum + X <span class="keyword">end</span>, <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 15</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Product) -&gt; Product * X <span class="keyword">end</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 120</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]) <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 1 2 3 4 5 ok</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]), Accum <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 1 2 3 4 5 void</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; Accum + X <span class="keyword">end</span>, <span class="number">1</span>, []).</div><div class="line"><span class="comment">% 1</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Result) -&gt; lists:umerge(Result, X) <span class="keyword">end</span>, [], [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>], [<span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>]]).</div><div class="line"><span class="comment">% [1,2,3,5,8,11,13,17]</span></div></pre></td></tr></table></figure>
<p>在Erlang的lists模块里也包含foldr/3函数，它是从左到右（译者注：应该是从右到左，可能是作者手误）遍历列表或者说是从最后一个元素到第一个元素遍历列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:foldr(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]), Accum <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 5 4 3 2 1 void</span></div><div class="line">lists:foldr(<span class="keyword">fun</span>(X, Accum) -&gt; Accum + X <span class="keyword">end</span>, <span class="number">1</span>, []).</div><div class="line"><span class="comment">% 1</span></div></pre></td></tr></table></figure>
<p>Erlang文档里指出foldl/3通常比foldr/3更好，因为foldl/3是尾递归，而foldr/3不是。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:map/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-map-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是函数 <a href="http://www.erlang.org/doc/man/lists.html#map-2" target="_blank" rel="external">lists:map/2</a> 。</p>
<p>lists:map/2 接收两个入参，一个是接收一个入参的函数，我们称它为“mapping”函数，另一个是一个Erlang term组成的列表。lists:map/2 的结果是一个列表，这个列表是由入参的列表的每个元素应用于“mapping”函数得到结果组成的。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X + <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X * X <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,4,9,16]</span></div></pre></td></tr></table></figure>
<p>因为字符串在Erlang里就是整数列表，所以你也可以将map函数应用在字符串上。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X - <span class="number">1</span> <span class="keyword">end</span>, <span class="string">"IBM"</span>).</div><div class="line"><span class="comment">% "HAL"</span></div></pre></td></tr></table></figure>
<h1 id="Erlang里的函数"><a href="#Erlang里的函数" class="headerlink" title="Erlang里的函数"></a>Erlang里的函数</h1><p>如果你仔细观察上面第一个例子，你会发现第一个入参我们传递的是一个 fun(X) -&gt; X + 1 end. 这是Erlang的匿名函数的语法。 一个匿名函数的格式如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">fun</span><span class="params">(Args1)</span> O<span class="title">ptionalGuardClause1</span> -&gt;</span></div><div class="line">        Expression1, Expression2;</div><div class="line">   (Args2) OptionalGuardClause2 -&gt;</div><div class="line">        Expression3, Expression4;</div><div class="line">   (Args3) OptionalGuardClause3 -&gt;</div><div class="line">        Expression5, Expression6;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们可以像普通函数一样使用匿名函数，除了在17.0以前的版本不能递归调用一个匿名函数外，所以我们可以将一个有多个子句的匿名函数传给lists:map/2 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) <span class="keyword">when</span> is_atom(X) -&gt; atom; (X) -&gt; nil <span class="keyword">end</span>, [<span class="number">1</span>, x, &#123;x&#125;, [], 'B']).</div><div class="line">[nil,atom,nil,nil,atom]</div></pre></td></tr></table></figure>
<h1 id="传递命名函数给lists-map-2"><a href="#传递命名函数给lists-map-2" class="headerlink" title="传递命名函数给lists:map/2"></a>传递命名函数给lists:map/2</h1><p>虽然一些场合我们用匿名函数，但是更多时候为了清晰明了，我们还是想用命名函数。我们可以通过函数的限定名称方式来传递一个命名函数给lists:map/2，采用的格式是，在module:function_name/arity 前面加上 fun 。下面的例子用math:log10/1和erlang:is_atom/1两个函数来演示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> math:log10/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>]).</div><div class="line">[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>]</div><div class="line">lists:map(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, x, &#123;x&#125;, [], 'B']).</div><div class="line">[<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-map-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-map-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:flatten/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-flatten-1/</url>
      <content type="html"><![CDATA[<p>Erlang Thursday今天要讲的函数是 lists:flatten/1。</p>
<p>lists:flatten/1 函数将一个任意深度的由Erlang的term组成的列表展平为一个“扁平”的列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:flatten([]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:flatten([a, b, c]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:flatten([a, b, [<span class="number">1</span>, [x, y], <span class="number">3</span>], c]).</div><div class="line"><span class="comment">% [a,b,1,x,y,3,c]</span></div><div class="line">lists:flatten([a, b, [<span class="number">1</span>, [x, &#123;some, tuple&#125;], <span class="number">3</span>], c]).</div><div class="line"><span class="comment">% [a,b,1,x,&#123;some,tuple&#125;,3,c]</span></div></pre></td></tr></table></figure>
<p>注意！它会把所有的列表都展平，比如下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, <span class="string">"foo"</span>, b]).</div><div class="line"><span class="comment">% [a,102,111,111,b]</span></div></pre></td></tr></table></figure>
<p>上面的例子，你得到的结果有整数在列表里，因为字符串实际上在底层就是一个整数列表，所以你得到的是字符串“foo”里f和o的ASCII字符码。</p>
<p>如果你要保留字符串的格式，你必须使用二进制格式的字符串，如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, &lt;&lt;<span class="string">"foo"</span>&gt;&gt;, b]).</div><div class="line"><span class="comment">% [a,&lt;&lt;"foo"&gt;&gt;,b]</span></div></pre></td></tr></table></figure>
<p>作为一个奖励，还有一个lists:flatten/2 函数，它将一个列表展平，并且接收另外一个入参 Tail，这个入参将附加在展平列表的后面从而形成一个新的列表，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, [<span class="number">1</span>, [b, [<span class="number">2</span>]]]], [x, y, z]).</div><div class="line"><span class="comment">% [a,1,b,2,x,y,z]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-flatten-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-flatten-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:max/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-max-1/</url>
      <content type="html"><![CDATA[<p>今天我们来学习 lists:max/1。</p>
<p>lists:max/1 接收一个入参，这个入参是一个最少有一个元素的列表，并且它返回这个列表里最大值的元素。这个列表可以由任何Erlang term组成：</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="number">1</span>, <span class="number">39</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">27</span>, <span class="number">52</span>, <span class="number">16</span>]).</div><div class="line"><span class="comment">% 63</span></div><div class="line">lists:max([q, w, a, r, c, f, m, b]).</div><div class="line"><span class="comment">% w</span></div><div class="line">lists:max([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]]).</div><div class="line"><span class="comment">% [1,2,4]</span></div></pre></td></tr></table></figure>
<p>Erlang在不同类型的term之间有着截然不同的大小顺序，</p>
<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string<br>传给lists:max/1函数的列表可以由任意类型的term组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a]).</div><div class="line"><span class="comment">% a</span></div><div class="line">lists:max([<span class="number">1</span>, a, [foo, bar], &#123;baz&#125;]).</div><div class="line"><span class="comment">% [foo,bar]</span></div></pre></td></tr></table></figure>
<p>因为在Erlang中字符串实际上是数字列表，所以我们甚至可以比较字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"snafu"</span>]).</div><div class="line"><span class="string">"snafu"</span></div></pre></td></tr></table></figure>
<p>如果你传入一个空列表给lists:max/1函数，一个 “no function clause matching”的错误将产生，因为该函数需要一个至少有一个元素的列表作为入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:max([]).</div><div class="line">** exception error: no function clause matching lists:max([]) (lists.erl, line <span class="number">326</span>)</div></pre></td></tr></table></figure>
<p>请您告诉我在以后的Erlang Thursday系列文章里，哪些是您喜欢的Erlang函数，甚至只是你想看到的函数？</p>
<p>如果您想比较Erlang的max函数和Ruby的max方法，别忘了看看上周的Ruby Tuesday系列文章： <a href="http://www.proctor-it.com/ruby-tuesday-enumerable-max/" target="_blank" rel="external">Ruby Tuesday on Enumerable#max</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-max-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-max-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:seq]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-seq/</url>
      <content type="html"><![CDATA[<p>Erlang Thursday系列文章的下一个目标是详细描述那些与Ruby Tuesday系列文章里着重阐述的方法所相对应的Erlang函数。我希望通过每个星期与Ruby Tuesday配合的Erlang Thursday系列文章能使得读者渐渐不再对Erlang陌生；我也希望通过这种方式建立一个共同讨论的渠道来使得读者不再认为Erlang是令人生畏的一门语言。我很想知道您对我这个目标如何才能更好地让读者接受和理解的一些想法。<br><a id="more"></a><br>因为这周我在<a href="https://www.proctor-it.com/ruby-tuesday-ranges/" target="_blank" rel="external">Ruby Tuesday</a>里谈到了Ruby的Range方法，那么今天我要讲的Erlang函数就是lists:seq/2和lists:seq/3。</p>
<p>如果你还记得上周<a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">Erlang Thursday</a>里的Erlang扫盲小知识里讲到的，在函数名字后面的数字表示是这个函数的arity，也就是入参的个数。</p>
<p>函数 lists:seq/2 接受两个整数入参，一个表示起始整数，一个表示结束整数，它产生一个包括这两个入参的整数列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% [1]</span></div></pre></td></tr></table></figure>
<p>有三个入参的lists:seq函数引入一个增量作为第三个参数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).</div><div class="line"><span class="comment">% [1,4,7,10]</span></div></pre></td></tr></table></figure>
<p>这个增量值可以是负数，这样就允许从一个整数减少低至另一个整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">20</span>, <span class="number">10</span>, -<span class="number">1</span>).</div><div class="line"><span class="comment">% [20,19,18,17,16,15,14,13,12,11,10]</span></div><div class="line">lists:seq(<span class="number">20</span>, <span class="number">10</span>, -<span class="number">5</span>).</div><div class="line"><span class="comment">% [20,15,10]</span></div></pre></td></tr></table></figure>
<p>如果给了不合适的起始和结束入参，lists:seq 函数不像Rang Range那样返回一个空集合，它会抛出一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">10</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:seq(10,1) (lists.erl, line 241)</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div><div class="line">lists:seq(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-seq/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-seq/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:member/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-member-2/</url>
      <content type="html"><![CDATA[<p>为了和每周的 <a href="http://www.proctor-it.com/ruby-tuesday-enumerableinclude/" target="_blank" rel="external">Ruby Tuesday</a> 系列文章中关于Enumerable#include?函数来个跨界对比，我决定着重介绍 Erlang 中相同类型的函数，lists:member/2。</p>
<a id="more"></a>
<p>首先给不熟悉Erlang的同学们补充一下知识：lists:member/2 表达的意思是在lists模块里有个名字叫member的函数，它有两个参数。Arity这个词的意思表示这个函数接受的入参的个数。在Erlang中，模块很重要，因为它是所有函数赖以生存的容器－－另外也是因为模块在Erlang里是代码重新装载的单元－－为了重新载入某个方法的新版本，必需指定具体模块。</p>
<p>总而言之，模块lists的函数member接受两个入参：一个是被查找的元素，它是Erlang的一种由任意数据类型组成的数据，另一个是被检索的由Erlang的各种类型数据组成的列表；如果被查找的元素在列表里被找到，则返回true。一个Erlang的term是任意Erlang数据类型组成的数据。</p>
<p>为了方便大家运行，下面的表达式是通用的写法，返回值则加上了%符号，这个符号是Erlang注释符号，这样就方便大家直接拷贝下面的表达式然后复制到Erlang的shell上运行。</p>
<p>这个函数能够很方便地判断一个数字是否在一个由数字组成的列表里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:member(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:member(<span class="number">13</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>或者判断一个原子是否在一个由原子组成的列表里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:member(c, [a, b, c, d]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(q, [a, b, c, d]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>或者由更复杂的term组成的列表，比如元组，或者包含列表的元组：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:member(&#123;d, <span class="number">4</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;, &#123;d, <span class="number">4</span>&#125;]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(&#123;'Foo', [bar, baz]&#125;, [a, <span class="number">1</span>, &#123;'Foo', [bar, baz]&#125;]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(&#123;fu, [bar, baz]&#125;, [a, <span class="number">1</span>, &#123;'Foo', [bar, baz]&#125;]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>甚至是判断一个整数或字符是否在一个字符串里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:member($a, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(<span class="number">97</span>, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member($A, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>如果你仔细观察，你会发现，在Erlang里字符串实际上是由整数组成的列表。</p>
<p>希望这是一个有趣的Ruby和Erlang的比较；同时如果你对它不熟悉的话，能让你更了解Erlang。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-member/</a></p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
