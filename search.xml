<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用Spring Boot创建Web应用程序]]></title>
      <url>http://szpzs.oschina.io/2018/05/25/creating-a-web-application-with-spring-boot/</url>
      <content type="html"><![CDATA[<p>在这篇文章中，我们将探讨使用Spring Boot创建Web应用程序的细节。 我们将探索Spring Boot如何帮助你加速应用程序开发。我们将使用Spring Boot构建一个简单的Web应用程序，并为其添加一些有用的服务。</p>
<a id="more"></a>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>启动一个新项目的主要挑战之一是该项目的初始设置。 我们需要对不同的目录结构进行调用，并且需要确保我们遵循所有行业标准。对于使用Spring Boot创建Web应用程序，我们需要以下工具：</p>
<ul>
<li>我们自己喜欢的IDE (我将使用IntelliJ)</li>
<li>Maven</li>
<li>JDK 1.8+</li>
</ul>
<h1 id="2-创建项目结构"><a href="#2-创建项目结构" class="headerlink" title="2. 创建项目结构"></a>2. 创建项目结构</h1><p>有多种方式可以使用Spring Boot Initializr为你生成项目结构：</p>
<ol>
<li>使用<a href="https://start.spring.io/" target="_blank" rel="external">Spring Initializr</a> Web界面。</li>
<li>使用Spring Boot CLI工具。</li>
<li>使用你的IDE</li>
</ol>
<p>为了简化这篇文章，我们使用Spring Initializer的网页界面来生成项目结构。</p>
<p>用你的浏览器访问<a href="https://start.spring.io/" target="_blank" rel="external">Spring Initializr Web界面</a>，你将看到一个向导来开始你的配置。</p>
<p><img src="/images/spring-init-2.png" style="border:0;"></p>
<p>你需要填写网页界面中的一些信息才能开始。</p>
<ol>
<li>你想要生成什么类型的项目（Maven或Gradle）</li>
<li>你选择什么语言（除了Java，你还可以选择Kotlin或Groovy）？</li>
<li>Spring Boot版本</li>
<li>标准的项目组和工件细节。</li>
<li>依赖</li>
</ol>
<p>依赖是Web界面中的一个有趣功能，根据你选择的依赖，Web界面会自动在生成的pom.xml文件中添加Spring Boot Starter依赖。如果你希望对生成的项目结构进行更多控制，或者不确定所有你想要添加到项目中的依赖，请单击“Switch to the full version”按钮。</p>
<p>在本文中，我们将使用Web和Thymeleaf（用于用户界面）两个Starter。</p>
<h1 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h1><p>Spring Boot不需要任何特定的代码布局或结构。我们始终可以遵循Spring Boot团队提出的一些最佳实践，但最终结构将由你的项目需求驱动。</p>
<p>下图是我们例子应用的项目结构：</p>
<p><img src="/images/spring-boot-web-2.png" style="border:0;"></p>
<h1 id="4-pom-xml"><a href="#4-pom-xml" class="headerlink" title="4. pom.xml"></a>4. pom.xml</h1><p>我们来看看pom.xml文件，详细地了解Spring Boot配置。 我将仅涵盖pom.xml中与Spring Boot相关的更改。 以下是我们示例项目中的pom.xml文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javadevjournal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javadevspringboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>javadevspringboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Java Dev Journal project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot的主要特性之一是“Starter”，它们是在我们的类路径中添加所需依赖项（jar包）的简单方法。 当使用Spring Boot时，我们不必在我们的类路径中添加jar包或依赖项（如果starter不可用，你可能必须将这些依赖项添加到pom.xml中，或者可以创建自己的自定义starter）。 我们只需要在我们的pom.xml文件中添加正确的“Starter”，Spring Boot将确保自动添加这些依赖。</p>
<h1 id="5-主应用"><a href="#5-主应用" class="headerlink" title="5. 主应用"></a>5. 主应用</h1><p>如下所示是我们的Spring Boot应用程序主类，它也是一个Spring配置类。 注解@SpringBootApplication启用Spring上下文以及Spring Boot的所有启动魔法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      SpringApplication.run(WebApplication.class, args);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-1-SpringBootApplication-注解"><a href="#5-1-SpringBootApplication-注解" class="headerlink" title="5. 1 @SpringBootApplication 注解"></a>5. 1 @SpringBootApplication 注解</h2><p>@SpringBootApplication相当于使用@Configuration，@EnableAutoConfiguration和@ComponentScan以及它们的默认值。如果要开始项目，建议使用这个注解。</p>
<p>在主类中使用@SpringBootApplication相当于同时使用以下3个注解：</p>
<ul>
<li>@Configuration作为bean定义的来源。</li>
<li>@EnableAutoConfiguration，它为Spring Boot提供了如何配置应用程序。</li>
<li>@ComponentScan自动获取所有Spring组件，包括@Configuration类。</li>
</ul>
<h2 id="5-2-主方法"><a href="#5-2-主方法" class="headerlink" title="5. 2 主方法"></a>5. 2 主方法</h2><p>我们主类的另一个有趣特点是主方法。 这是遵循标准Java工作流程的标准方法。 我们的主类将把控制权交给Spring Boot SpringApplication类。</p>
<p>SpringApplication类的run方法将用于引导一个应用程序。</p>
<h1 id="6-Welcome-Controller"><a href="#6-Welcome-Controller" class="headerlink" title="6. Welcome Controller"></a>6. Welcome Controller</h1><p>我们设置的最后一部分，我们将创建一个welcome controller，负责通过返回View的名称（在本例中为“welcome”）处理/greeting的GET请求。 视图负责呈现HTML内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="string">"welcome"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的控制器，但在我们的设置中涵盖了很多要点。</p>
<ul>
<li>@Controller注解表示被注解的类是“控制器”（例如Web controller）。</li>
<li>@RequestMapping注解可确保将对/welcome的HTTP请求映射到welcome()方法。</li>
<li>我们没有为@RequestMapping注解指定任何HTTP方法，因此默认情况下，映射所有HTTP方法。</li>
<li>由于我们使用Thymeleaf进行视图技术并从welcome()方法返回“welcome”，因此Thymeleaf会解析模板welcome.html并生成输出。</li>
</ul>
<h2 id="6-1-UI-Template"><a href="#6-1-UI-Template" class="headerlink" title="6. 1 UI Template"></a>6. 1 UI Template</h2><p>如下我们简单的Thymeleaf HTML模板。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">Hello and Welcome to our Web Application</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当使用Thymeleaf作为我们的模板引擎时，Spring Boot将通过在视图名称前后加上前缀和后缀（配置参数分别是：spring.thymeleaf.prefix和spring.thymeleaf.suffix，它们的默认的值是：’classpath:/templates/‘和’html’）。</p>
<h1 id="7-运行程序"><a href="#7-运行程序" class="headerlink" title="7. 运行程序"></a>7. 运行程序</h1><p>我们完成了我们简单的Web应用程序，现在是时候运行我们的应用程序了。 尽管可以将此服务作为传统WAR文件打包以部署到外部应用程序服务器上，但更简单的方法是创建独立应用程序。 要从IDE运行我们的应用程序，我们需要将我们的Web应用程序作为独立的Java应用程序运行。</p>
<ul>
<li>如果使用Maven，我们可以使用mvn spring-boot:run命令运行应用程序。</li>
<li>我们可以使用mvn clean package命令构建Jar包，并使用java -jar target/demo-app-0.1.0.jar运行这个jar包。</li>
</ul>
<p>现在，该网站已启动并正在运行，请访问 <a href="http://localhost:8080/welcome" target="_blank" rel="external">http://localhost:8080/welcome</a> ，如果一切正常，则应在Web浏览器中输出以下内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello and Welcome to our Web Application</div></pre></td></tr></table></figure>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>在这篇文章中，我们学习了使用Spring Boot创建Web应用程序。 Spring Boot具有许多功能，可以更快，更轻松地创建和运行Web应用程序。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring/creating-a-web-application-with-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring/creating-a-web-application-with-spring-boot/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang私有函数的私有程度如何？]]></title>
      <url>http://szpzs.oschina.io/2018/05/25/how-private-are-erlang-private-functions/</url>
      <content type="html"><![CDATA[<p>今天我在推特上看到一条引起我注意的推文：</p>
<p><img src="/images/erlang-private-function.png" style="border:0;"></p>
<a id="more"></a>
<p>出于科学的考虑，Erlang的私有函数是私有的！这与Python中的情况不同，在Python中，<a href="https://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private" target="_blank" rel="external">你在各处添加了几个下划线</a>，突然之间，两秒钟前是私有的，现在已经公开了。在Erlang，我们的私有函数在保险箱里安全地呆了25年！没有人可以调用我们声明为私有的函数！或者……有办法吗？</p>
<p><img src="/images/erlang-private-function2.gif" style="border:0;"></p>
<center>我会告诉你</center>

<p>事实证明，在Erlang中调用私有函数的方式并不那么简单，即使假设代码已经在启用<a href="http://erlang.org/doc/man/compile.html" target="_blank" rel="external">debug_info</a>的情况下编译。 让我们看看事情是如何运作的。</p>
<p>我们首先定义一个名为test的模块。 该模块包含两个函数，其中只有一个被导出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(test)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([public/<span class="number">0</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">public</span><span class="params">()</span> -&gt;</span></div><div class="line"> i_am_public.</div><div class="line"></div><div class="line"><span class="function"><span class="title">private</span><span class="params">()</span> -&gt;</span></div><div class="line"> i_am_private.</div></pre></td></tr></table></figure>
<p>让我们编译模块，并确保包含调试信息。 注意在Erlang中如何包含调试信息是相当常见的，因为包括调试器，交叉引用工具和覆盖分析工具在内的许多工具都需要这些信息才能工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ erlc +debug_info test.erl</div><div class="line">test.erl:8: Warning: <span class="keyword">function</span> private/0 is unused</div></pre></td></tr></table></figure>
<p>编译器通知我们该私有函数不可访问，这是预期到会有的。 现在让我们打开一个shell并尝试调用这两个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">19</span> [erts-<span class="number">8.3</span>.<span class="number">5.3</span>] [...]</div><div class="line"></div><div class="line">Eshell V8.<span class="number">3.5</span>.<span class="number">3</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; l(test).</div><div class="line">&#123;module,test&#125;</div><div class="line"><span class="number">2</span>&gt; test:public.</div><div class="line">i_am_public</div><div class="line"><span class="number">3</span>&gt; test:private().</div><div class="line">** exception error: undefined function test:private/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>我们可以调用公共函数，但不能调用私有函数。没什么新鲜的。现在，让我们定义一个小的匿名函数(我马上将解释它的作用)，并将其绑定到变量Open：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; Open = <span class="keyword">fun</span>(Module) -&gt;</div><div class="line">    Which = code:which(Module),</div><div class="line">    &#123;ok,&#123;_,[&#123;_,&#123;_,A&#125;&#125;]&#125;&#125; = beam_lib:chunks(Module, [abstract_code]),</div><div class="line">    &#123;ok, Module, Binary&#125; = compile:forms(A, [export_all]),</div><div class="line">    code:load_binary(Module, Which, Binary)</div><div class="line">   <span class="keyword">end</span>.</div><div class="line">#Fun&lt;erl_eval.<span class="number">6.118419387</span>&gt;</div></pre></td></tr></table></figure>
<p>然后让我们调用Open函数，将test模块作为参数传递给它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span>&gt; Open(test).</div><div class="line">&#123;module, test&#125;</div></pre></td></tr></table></figure>
<p>现在让我们尝试访问私有函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span>&gt; test:private().</div><div class="line">i_am_private.</div></pre></td></tr></table></figure>
<p>保险箱现在大开着。</p>
<p><img src="/images/erlang-private-function3.gif" style="border:0;"></p>
<center>我的天哪。</center>

<p>那么，Open函数背后有什么样的黑魔法？ 实际上并不多。 让我们再看一遍：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">fun</span><span class="params">(Module)</span> -&gt;</span></div><div class="line">  Which = code:which(Module),</div><div class="line">  &#123;ok,&#123;_,[&#123;_,&#123;_,A&#125;&#125;]&#125;&#125; = beam_lib:chunks(Module, [abstract_code]),</div><div class="line">  &#123;ok, Module, Binary&#125; = compile:forms(A, [export_all]),</div><div class="line">  code:load_binary(Module, Which, Binary)</div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>在向code server请求test模块的绝对文件名路径之后，我们使用强大的beam_lib接口从test模块的beam文件中包含的调试信息中提取抽象语法形式（还记得我们使用debug_info选项编译它吗？)，然后我们从这些语法形式开始重新编译模块，并添加臭名昭著的export_all选项，这将导致导出模块中定义的所有函数。我们重新加载了模块的新版本。</p>
<p>为了简单起见，在上面的例子中有一些情况是Open函数没有考虑的，但你应该明白它的要点。</p>
<p>快乐黑客！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/about-erlang/how-private-are-erlang-private-functions-36382c6abfa4" target="_blank" rel="external">https://medium.com/about-erlang/how-private-are-erlang-private-functions-36382c6abfa4</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为gen_event辩护]]></title>
      <url>http://szpzs.oschina.io/2018/05/24/in-defense-of-gen-event/</url>
      <content type="html"><![CDATA[<p>gen_event曾一度引起Erlang和Elixir开发人员的不满。他们已经撰写了许多文章，并就gen_event的各种替代办法举行了一次以上的会议。在这篇文章中，我要说明的是，尽管gen_event存在缺陷，但它仍然是一个非常有用的模块。我也认为它的核心设计最终要比许多人认为的灵活得多。</p>
<a id="more"></a>
<p>某些设计决策会产生灵活的系统。例如，Erlang的异步消息发送和带有超时的同步消息接收为开发人员提供了全面的消息传递行为。如果要同步消息的发送，最好带上一个唯一(reference)引用来发送消息，然后执行receive语句，对这个引用进行接收模式匹配。这基本上就是使用gen_*:call这一类函数调用时内部的实际情况。如果要异步接收消息，则可以使用带有 after 0 的receive语句，在没有匹配的消息的情况下，立即超时。下面是示例代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sync_send</span><span class="params">(Pid, Msg)</span> -&gt;</span></div><div class="line">    Ref = make_ref(),</div><div class="line">    Pid ! &#123;Ref, Msg&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;Ref, Reply&#125; -&gt; Reply</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">async_recv</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        M -&gt; &#123;ok, M&#125;</div><div class="line">    <span class="keyword">after</span></div><div class="line">        <span class="number">0</span> -&gt; none</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>问题：如果Erlang给提供你同步发送和异步接收，你将如何去实现异步发送和同步接收？</p>
<p>Erlang消息传递的核心设计足够灵活，可以表达默认情况下未实现的消息传递语义。 当我们将注意力转向gen_event时，请记住这一点。</p>
<p>对于那些不熟悉gen_event的人来说，它的工作方式或多或少可能像这样：gen_event:start_link启动所谓的事件管理器进程。 当你编写一个实现gen_event行为的模块时，你正在编写所谓的事件处理程序。 事件管理器有一个已安装事件处理程序的列表，每个事件处理程序都有自己的状态。 当进程调用gen_event:notify时，事件管理器将一次调用一个其安装的处理程序（毕竟，事件管理器只是一个进程）。 我会重复重点：事件管理器进程一次执行一个所安装的事件处理程序。 这个设计引发了一些争议，特别是José Valim，他有一篇关于如何用监督者（作为事件管理器）和一堆gen_server（作为事件处理程序）替换gen_event的<a href="http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/" target="_blank" rel="external">博客文章</a>。</p>
<p>我知道我有点怪，但是我认为gen_event的默认行为非常好，并且最终比José建议的并发处理程序的解决方案灵活得多。如果希望并发处理事件，则可以通过安装事件处理程序(将消息转发到现有进程或派生进程以执行事件处理代码)来轻松实现事件的扇出。但是，如果事件的并发处理是默认行为，你将如何实现事件的顺序处理呢？我怀疑你最终会实现一个效率较低的gen_event版本；因为你将发送不必要的消息，这导致效率较低。</p>
<p>问题：如果gen_event在默认情况下并发运行事件处理程序，那么你将如何依次运行处理程序呢？</p>
<p>总之，gen_event很像Erlang的消息传递，它提供了一个灵活的基础，你可以轻松地实现不同的行为。 我很高兴gen_event的存在，并且它被设计为顺序处理事件是默认行为。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/" target="_blank" rel="external">http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot Starters简介]]></title>
      <url>http://szpzs.oschina.io/2018/05/24/spring-boot-starters/</url>
      <content type="html"><![CDATA[<p>在这篇文章中，我们将向你介绍Spring Boot Starters，并将讨论Spring Boot Starters的优点和优势。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在启动任何项目(无论是小型项目还是企业级应用程序)之前，其中关键的方面之一是依赖管理，手动为小型应用程序执行依赖管理并不是一项困难的工作，但对于复杂的应用程序，手动管理所有项目依赖并不理想，容易出现许多问题以及浪费时间，而这些时间可以用于项目的其他一些重要方面。</p>
<p>Spring Boot背后的基本原理之一就是解决类似的问题。Spring Boot Starter是一套方便的依赖描述符，可以很容易地包含在任何级别的应用程序中。这些Starters作为Spring相关技术的引导过程，我们 不再需要担心依赖关系，它们将由Spring Boot Starters自动管理。</p>
<p>Starters包含了许多你需要的依赖项，以使项目快速启动和运行，并且具有一致的、被支持的一组管理传递依赖项。</p>
<h1 id="1-为什么我们需要Starters？"><a href="#1-为什么我们需要Starters？" class="headerlink" title="1. 为什么我们需要Starters？"></a>1. 为什么我们需要Starters？</h1><p>当我们用Spring Boot开始开发应用时，我们想到的一个基本问题就是为什么我们需要Spring Boot Starters？ 或者这些Starters在我的应用中如何帮助到我？</p>
<p>如前所述，这些Starters用于引导应用程序，我们需要的只是在应用程序中包括正确的Starters，而Spring Boot将确保所选Starters所需的所有依赖项都在你的classpath中。</p>
<p>为了更清楚地理解它，我们举一个例子，我们想构建一个简单的Spring Web MVC应用程序，我们需要在开始编写我们的Web应用程序代码之前考虑以下几点。</p>
<ul>
<li>正确的Spring MVC依赖</li>
<li>Web技术所需的依赖（例如，我们想要使用Thymeleaf）</li>
<li>我们需要确保所有这些依赖是兼容的</li>
</ul>
<p>使用Spring Boot Starters来引导我们的Spring MVC Web应用程序非常简单，我们需要在我们的pom.xml中包含spring-boot-starter-web 这个starter：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上pom.xml中的条目将确保所有必需的依赖项都应位于classpath中，因此我们都准备好开始开发web应用程序了。</p>
<p>目前，Spring Boot提供的Starters约有50多个，这还不包括第三方的Starters。有关Starters的更新列表，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" title="Spring Boot Starter" target="_blank" rel="external">Spring Boot Starter</a></p>
<p>接下来，我将介绍一些常用的Starters。</p>
<h1 id="2-Web-Starter"><a href="#2-Web-Starter" class="headerlink" title="2. Web Starter"></a>2. Web Starter</h1><p>这是最常用的Spring Boot Starter之一，该Starter将确保创建Spring Web应用程序（包括REST）所需的所有依赖包括在你的calsspath中，它还将添加tomcat-starter作为默认服务器来运行我们的Web应用程序。 要在我们的应用程序中包含Web Starter，请在pom.xml中添加以下条目。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>现在我们可以创建我们的Spring MVC Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@RestController</span></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</div><div class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你运行应用程序并访问<a href="http://localhost:8080/greeting，你应该能够获得&quot;Hello" target="_blank" rel="external">http://localhost:8080/greeting，你应该能够获得&quot;Hello</a> Word”作为响应。我们使用最少的代码创建了一个REST控制器。</p>
<h1 id="3-Data-JPA-Starter"><a href="#3-Data-JPA-Starter" class="headerlink" title="3. Data JPA Starter"></a>3. Data JPA Starter</h1><p>大多数应用程序需要一些持久性机制，而JPA是持久性的标准，Spring Boot Starters带有JPA Starters，你不再需要手动配置这些JPA依赖，而是可以通过在应用程序中添加JPA Starter轻松实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring JPA Starter提供对H2，Derby和Hsqldb的自动支持。让我们看看使用JPA starter创建一个JPA样例应用程序是多么容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String firstName;</div><div class="line">    <span class="keyword">private</span> String lastName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">        <span class="comment">//this.id = id;</span></div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</div><div class="line">                <span class="string">"id="</span> + id +</div><div class="line">                <span class="string">", firstName='"</span> + firstName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", lastName='"</span> + lastName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下是我们的UserRepository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</div><div class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByLastName</span><span class="params">(String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们可以测试我们的代码了，如下是JUnit代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpademoApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Autowired</span></div><div class="line">   UserRepository userRepository;</div><div class="line"></div><div class="line">   <span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        User user = userRepository.save(<span class="keyword">new</span> User(<span class="string">"Demo"</span>,<span class="string">"User"</span>));</div><div class="line">        User searchUser= userRepository.findOne(user.getId());</div><div class="line"></div><div class="line">        assertNotNull(searchUser);</div><div class="line">        assertEquals(user.getFirstName(),searchUser.getFirstName());</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如我们在上面的代码中看到的那样，你不再需要指定那些数据库配置或额外的数据库配置，通过添加JPA starter，我们无需配置或编码即可获得许多开箱即用的功能。</p>
<p>如果需要，你始终可以修改或自定义这些配置。</p>
<h1 id="4-Mail-Starter"><a href="#4-Mail-Starter" class="headerlink" title="4. Mail Starter"></a>4. Mail Starter</h1><p>从应用程序发送电子邮件是非常常见的任务，现在每个应用程序都需要从系统发送电子邮件。Spring Boot Mail starter提供了一种隐藏所有复杂性的简单方法来处理此功能。</p>
<p>我们可以通过在应用程序中添加Mail starter来启用电子邮件支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我正在使用Mailgun作为我的SMTP服务器，以下是添加到我的application. properties文件中的SMTP详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">spring.mail.host=smtp.mailgun.org</div><div class="line">spring.mail.username=postmaster@domain.com</div><div class="line">spring.mail.password=mypassword</div><div class="line">spring.mail.properties.mail.transport.protocol=smtp</div><div class="line">spring.mail.properties.mail.smtp.port=587</div><div class="line">spring.mail.properties.mail.smtp.auth=true</div></pre></td></tr></table></figure>
<p>我们的EmailService类负责发送邮件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaEmailService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaEmailService</span><span class="params">(JavaMailSender mailSender)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mailSender = mailSender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line">        MimeMessagePreparator messagePreparator = mimeMessage -&gt; &#123;</div><div class="line"></div><div class="line">            MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</div><div class="line">            helper.setFrom(<span class="string">"noreply@javadevjournal.com"</span>);</div><div class="line">            helper.setTo(<span class="string">"xxx@gmail.com"</span>);</div><div class="line">            helper.setSubject(<span class="string">"Sample mail subject"</span>);</div><div class="line">            helper.setText(<span class="string">"Test Email"</span>);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        mailSender.send(messagePreparator);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用Spring提供的JavaMailSender来发送电子邮件。 JUnit测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    JavaEmailService javaEmailService;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        javaEmailService.sendEmail();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，只需简单的代码和配置即可发送一封简单的电子邮件，Spring Boot Mail Starter确保所有必需的工具已经到位，以快速开始解决实际问题。</p>
<p>请注意，我们在JavaEmailService bean中使用JavaMailSender - 该bean是由Spring Boot自动创建的。</p>
<h1 id="5-Test-Starter"><a href="#5-Test-Starter" class="headerlink" title="5. Test Starter"></a>5. Test Starter</h1><p>我们通常使用Junit、Mockito或Spring Test来测试我们的应用程序。我们可以通过添加Spring Boot Test starter轻松地将所有这些库包含在我们的应用程序中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot会自动找到我们正确的版本用于我们的应用程序测试。 这是一个JUnit示例测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    JavaEmailService javaEmailService;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        javaEmailService.sendEmail();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这些starter之外，下面还有其他常用的Spring Boot Starter</p>
<ul>
<li>spring-boot-starter-security</li>
<li>spring-boot-starter-web-services</li>
<li>spring-boot-starter-integration</li>
<li>spring-boot-starter-validation</li>
<li>spring-boot-starter-actuator</li>
</ul>
<p>如前所述，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" title="Spring Boot Starter" target="_blank" rel="external">Spring Boot Starter</a>获取Spring Boot提供的Starter的最新列表。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文提供了一个Spring Boot Starters简介，我们讨论了为什么我们需要这些Starter以及他们如何帮助我们快速引导我们的应用程序。 我们探索了一些最常用的Spring Boot Starter。</p>
<p>建议阅读：<br><a href="https://www.javadevjournal.com/spring/introduction-to-spring-boot/" title="Building an Application with Spring Boot" target="_blank" rel="external">使用Spring Boot构建应用程序</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">https://www.javadevjournal.com/spring/spring-boot-starters/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Spring Boot构建应用程序]]></title>
      <url>http://szpzs.oschina.io/2018/05/21/introduction-to-spring-boot/</url>
      <content type="html"><![CDATA[<p>在这篇文章中，我们将探讨使用Spring Boot构建应用程序。 我们将介绍Spring Boot的不同方面以及使用Spring Boot构建应用程序的不同选项。</p>
<a id="more"></a>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Spring Boot有自己一套的约定，而且约定优于配置。Spring Boot通过用Spring平台自有的约定来消除大部分项目设置，这样新用户和现有用户就可以快速到达他们需要的开发节点。Spring Boot使创建一个以Spring为动力的企业应用程序变得非常容易，而且操作简单。</p>
<h1 id="2-Spring-Boot特性"><a href="#2-Spring-Boot特性" class="headerlink" title="2. Spring Boot特性"></a>2. Spring Boot特性</h1><p>Spring Boot提供以下开箱即用的功能：</p>
<ol>
<li>它通过采用预定义的约定简化了Spring依赖关系（我们将会更详细地讨论它）。</li>
<li>Spring Boot提供了一组预先配置的技术/框架来减少容易出错的配置，因此我们作为开发人员专注于构建业务逻辑而不是考虑项目设置。</li>
<li>你真的不需要为你的项目配置那些大的XML配置。</li>
<li>直接内嵌Tomcat、Jetty 或 Undertow。</li>
<li>提供预定义的Maven POM来简化你的配置。</li>
</ol>
<h1 id="3-创建Spring-Boot项目"><a href="#3-创建Spring-Boot项目" class="headerlink" title="3. 创建Spring Boot项目"></a>3. 创建Spring Boot项目</h1><p>启动一个项目的最主要挑战之一是初始化该项目的配置。我们需要对不同的目录结构进行调用，并且需要确保我们遵循所有行业标准。如果你使用的是Maven，那么你可能已经在使用Maven启动工件，它可以帮助我们更快地完成初始设置。</p>
<p>Spring Initializr是另外一个非常棒的快速启动一个Spring Boot项目的工具。Spring Initializr是一个生成Spring Boo项目的web应用。请记住，它只会生成项目结构，而不会根据你的偏好为你生成任何代码( Maven或Gradle )。如果你正在启动你的项目，我的推荐是使用Spring Initializr。</p>
<p>有几种方式来使用Spring Boot Initializr为你生成项目结构：</p>
<ol>
<li>使用Spring Initializr Web界面</li>
<li>使用Spring Boot CLI工具</li>
<li>使用你的IDE</li>
</ol>
<h2 id="3-1-使用Spring-Initializr-Web界面"><a href="#3-1-使用Spring-Initializr-Web界面" class="headerlink" title="3.1 使用Spring Initializr Web界面"></a>3.1 使用Spring Initializr Web界面</h2><p>这是为你的应用生成项目结构的最简单方式。在你的浏览器打开Spring Initializr Web界面，你将看到一个向导来开始你的配置。</p>
<p><img src="/images/spring-init.png" style="border:0;"></p>
<p>你需要在这个web界面填写一些信息：</p>
<ol>
<li>你要生成哪一类项目（Maven还是Gradle）</li>
<li>你想用什么语言（除了Java，你还可以选择Kotlin或Groovy）</li>
<li>Spring Boot的版本</li>
<li>项目的 GroupID和ArtifactID</li>
<li>选择所需依赖</li>
</ol>
<p>在web界面里选择依赖是一个有趣的功能。基于你选择的依赖，web界面将自动在生成的pom.xml文件中增加 <a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">Spring Boot Starter</a> 依赖。如果你想要更多地控制生成的项目结构，或者不确定要添加到项目中的依赖，请单击“切换到完整版”。</p>
<p><img src="/images/Spring-Full.png" style="border:0;"></p>
<p>使用完整版本界面，你可以选择Java版本，打包模式（比如用于传统部署的war包）以及为项目选择依赖的选项。一旦你点击“生成项目”按钮，Spring Initializr将生成项目，你将下载得到一个zip文件。 你可以在IDE中将解压缩的项目作为基于Maven 或 Gradle的项目导入。</p>
<p>我将不会详细介绍如何在IDE中导入项目。 有关更多详细信息，请参阅相关的IDE文档。</p>
<h2 id="3-2-使用Spring-Boot-CLI"><a href="#3-2-使用Spring-Boot-CLI" class="headerlink" title="3.2 使用Spring Boot CLI"></a>3.2 使用Spring Boot CLI</h2><p>我们也可以使用Srping Boot CLI来生成项目的结构。只要你安装了CLI，就可以打开终端输入spring。如果你正确安装了CLI，输入spring，回车后将看到如下类似的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">localhost:~ javadevjournal$ spring</div><div class="line">usage: spring [--help] [--version]</div><div class="line">       [&lt;args&gt;]</div><div class="line"></div><div class="line">Available commands are:</div><div class="line"></div><div class="line">  run [options]  [--] [args]</div><div class="line">    Run a spring groovy script</div></pre></td></tr></table></figure>
<p>我们可以在spring命令后使用init作为额外的参数来创建一个新的项目。Spring Boot CLI将在其内部使用start.spring.io来为你创建项目结构。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">localhost:~ javadevjournal$ spring init --dependencies=web springboot-demo-project</div><div class="line">Using service at https://start.spring.io</div><div class="line">Project extracted to &apos;/Users/umesh/springboot-demo-project&apos;</div></pre></td></tr></table></figure>
<p>上述命令将创建一个基于Maven的使用spring-boot-starter-web的项目，目录名为springboot-demo-project。这和使用start.spring.io的web界面创建的项目是一样的效果。我们可以传递不同的参数来自定义项目的生成。</p>
<p>比如，我们想创建基于Java 1.7的项目，我们可以传递 --java-version=1.7 作为额外参数给Spring Boot CLI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring init --java-version=1.7  --dependencies=web springboot-demo-project</div></pre></td></tr></table></figure>
<p>当执行上面的命令后，在项目的pom.xml文件里自动增加了Java 1.7相关的信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你不确认Spring init的功能有什么，可以带上标志 --list ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring init --list</div></pre></td></tr></table></figure>
<h1 id="4-查看pom-xml的内容"><a href="#4-查看pom-xml的内容" class="headerlink" title="4. 查看pom.xml的内容"></a>4. 查看pom.xml的内容</h1><p>我们来看看pom.xml文件的内容，来更详细地了解Spring Boot的配置。我将只关注pox.xml里与Spring Boot有关的变化。如下是我们创建样例项目的pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.umeshawasthi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ems<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ems<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Employee Management System outline Spring Boot Features<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- project properties repository --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Spring boot test depedency --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot最主要的特色就是“<a href="https://www.javadevjournal.com/spring/spring-boot-starters/" title="Spring Boot Starters" target="_blank" rel="external">Starters</a>”，它们是增加依赖包到classpath的便捷方式。使用Spring Boot的时候，我们不需要增加jar包或依赖到classpath（如果一个starter不可用了，你可以自己增加所需依赖到classpath，或者创建你自己的starter）。我们仅需要增加正确的“Starters”到我们的pom.xml里，Spring Boot会确保自动增加那些依赖。</p>
<h1 id="5-应用程序入口"><a href="#5-应用程序入口" class="headerlink" title="5. 应用程序入口"></a>5. 应用程序入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmsApplication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">     SpringApplication.run(EmsApplication.class, args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-1-SpringBootApplication注解"><a href="#5-1-SpringBootApplication注解" class="headerlink" title="5.1 @SpringBootApplication注解"></a>5.1 @SpringBootApplication注解</h2><p>我们的主类用了@SpringBootApplication注解。@SpringBootApplication等同于同时使用@Configuration、@EnableAutoConfiguration和@ComponentScan。如果你启动你的项目，建议使用这个注解。使用@SpringBootApplication等同于同时使用如下三个注解：</p>
<ol>
<li><code>@Configuration</code>  作为bean定义的来源。</li>
<li><code>@EnableAutoConfiguration</code>  它使得Spring Boot自动配置应用程序。</li>
<li><code>@ComponentScan</code>  它会自动扫描所有的Spring组件，包括使用了<code>@Configuration</code>注解的类。</li>
</ol>
<h2 id="5-2-主方法"><a href="#5-2-主方法" class="headerlink" title="5.2 主方法"></a>5.2 主方法</h2><p>我们主类的另一个有趣的地方是主方法。它是遵循标准Java工作流程的标准方法。 我们的主类将把控制权交给Spring Boot的 SpringApplication类。 SpringApplication类的run方法将用于引导应用程序。 我们将在后面更深入地观察SpringApplication。</p>
<h1 id="6-Hello-World-控制器"><a href="#6-Hello-World-控制器" class="headerlink" title="6. Hello World 控制器"></a>6. Hello World 控制器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.javadevjournal.demo.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="string">"Hello World!!"</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制器非常简单。它是使用Spring MVC标准注解的Spring MVC控制器。</p>
<h1 id="7-运行应用"><a href="#7-运行应用" class="headerlink" title="7. 运行应用"></a>7. 运行应用</h1><p>是时候运行我们第一个Spring Boot程序了。我们有几种方式来运行我们的Spring Boot程序。</p>
<ol>
<li>如果我们使用IDE, 我们可以用IDE来运行我们Spring Boot程序。</li>
<li>我们可以在项目根目录下用  <code>mvn spring-boot:run</code>  命令来启动我们的第一个Spring Boot程序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> .   ____          _            __ _ _</div><div class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</div><div class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="line"> =========|_|==============|___/=/_/_/_/</div><div class="line"> :: Spring Boot ::        (v1.5.4.RELEASE)</div><div class="line"></div><div class="line">2017-07-08 15:49:50.319  INFO 1238 --- [           main] com.javadevjournal.demo.EmsApplication   : Starting EmsApplication on localhost with</div></pre></td></tr></table></figure>
<p>打开浏览器，输入 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> ，回车，我们将看到 Hello World 。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring Boot为基于Spring的应用程序提供了很好的推动力。在这篇文章中，我们学习了使用Spring Boot构建应用程序的不同选项。设置新项目始终是一项具有挑战性的任务，我们需要确保管理所有依赖，但是使用Spring Boot，这些都变得非常容易，我们能够只用几行代码就能运行第一个web应用程序，而无需过多考虑所需的依赖或程序的部署。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/introduction-to-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/introduction-to-spring-boot/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot是什么？]]></title>
      <url>http://szpzs.oschina.io/2018/05/18/spring-boot-what-is-spring-boot/</url>
      <content type="html"><![CDATA[<p>这将是更侧重于介绍Spring Boot的短文，我们将讨论“什么是Spring Boot”？ 以及Spring Boot如何帮助构建基于Java的企业应用程序。</p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作为一名Java开发人员，我们很可能已经直接或间接地在工作中使用基于Spring Framework的应用程序。<strong>Spring</strong>有许多方法来配置它的行为，它提供三种方式进行配置，基于XML的配置或基于注解的配置，以及基于Java的配置，而基于Java的配置正在成为新的Spring应用程序的事实标准。尽管这些选项看起来非常好，但大型企业应用程序涉及数百个模块和复杂的业务规则，但这些配置可能会变得非常复杂。 以下是大型应用程序可以带来的一些复杂情况。</p>
<ul>
<li>每个模块有它自己的配置</li>
<li>每个模块有它自己的依赖（第三方依赖）</li>
<li>升级应用（例如从Spring 4.x 升级到Spring 5.x）将会很复杂，因为我们需要确认所有的依赖都正确地升级</li>
<li>如果一些依赖不能正常工作，试图找出根本原因是一个大型应用程序非常复杂和具有挑战性。</li>
</ul>
<p>以上所有问题或多或少都与确保我们拥有一切，然后开发团队才能开始处理实际任务有关。 现在让我们来谈谈另一个情况，我们用它来处理任何基于Spring的应用程序。假设我们要创建一个基于Web的应用程序，下面是我们大多数人常用的常用步骤：</p>
<ul>
<li>使用我们选择的Maven或IDE创建一个Web应用程序。</li>
<li>复制标准的Web应用程序配置（Spring MVC应用程序的web.xml配置）。</li>
<li>根据我们的要求调整以上配置。</li>
<li>配置Spring MVC标准bean，如ViewResolver，MessageSource等。</li>
<li>配置要用于我们的应用程序的数据库属性。</li>
<li>建立数据库层并确保底层数据库连接已经就位，然后才能开始使用它（EntityManagerFactory，TransactionManager等）</li>
</ul>
<p>上面的列表可以根据我们的应用程序的类型显着增长。</p>
<h2 id="1-Spring-Boot是什么？"><a href="#1-Spring-Boot是什么？" class="headerlink" title="1. Spring Boot是什么？"></a>1. Spring Boot是什么？</h2><p>以上所有步骤对我们来说都很重要，但是它们给开发团队增加了很多开销，而不是专注于解决实际的业务问题，最初的时间将被消耗在确保一切都就位后才开始实际的工作。我们可以将Spring Boot视为可以自动完成这些初始任务的工具。Spring Boot对我们所使用的Spring平台有自己的视角，并确保团队可以快速开始解决实际业务问题，而不是花时间在初始配置和设置上。</p>
<p>Spring Boot提供以下开箱即用的功能：</p>
<ol>
<li>它通过采用自己的视角简化了Spring依赖关系（我们将会更详细地讨论它）。</li>
<li>Spring Boot提供了一组预先配置的技术/框架来减少容易出错的配置，因此我们作为开发人员专注于构建业务逻辑而不是考虑项目设置。</li>
<li>你真的不需要为你的项目配置那些大的XML配置。</li>
<li>直接内嵌Tomcat、Jetty 或 Undertow。</li>
<li>提供预定义的Maven POM来简化您的配置。</li>
</ol>
<p>使用Spring Boot，可以轻松管理和处理介绍部分突出显示的问题。在升级过程中，我们不需要手动搜索兼容的jar包，Spring Bug将确保我们的应用程序升级到正确的版本（这称为麻烦最小化开发应用程序）。</p>
<p>让我们来看看我们的Web应用程序的一个示例pom.xml，以了解Spring Boot例子程序的配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javadevjournal.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sample web application<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>rWeb Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hateoas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>请看&lt;packaging&gt;标签，Spring Boot可以灵活地将我们的应用程序作为jar包来运行，而不是强迫我们将war作为所需的打包类型。</p>
<h2 id="2-更好的依赖管理"><a href="#2-更好的依赖管理" class="headerlink" title="2. 更好的依赖管理"></a>2. 更好的依赖管理</h2><p>只要仔细检查配置，你不会找到所有这些Spring依赖项的条目（如web MVC，核心，AOP，ORM，验证API等等），你可能已经注意到类似的条目spring-boot-starter- *，这是Spring Boot依赖管理过程。 我们在我们的pom.xml中添加了spring-boot-starter-web，Spring Boot将拉取所有为Spring MVC应用程序必需的依赖（不再需要手动配置）。</p>
<h2 id="3-自动配置"><a href="#3-自动配置" class="headerlink" title="3.自动配置"></a>3.自动配置</h2><p>自动配置是Spring Boot的另一个有趣功能，这就是为什么Spring Boot团队认为它有意思的地方。以下是Spring Boot为你做的一些工作：</p>
<ol>
<li>它将添加所有依赖，如第2点中所述。</li>
<li>自动配置表明Spring Boot具有一些合理的默认设置，即基于配置的Spring Boot将猜测应用程序的类型，并提供运行应用程序所需的默认实现，以防我们未在应用程序中定义这些应用程序。 如果你定义了这些，Spring Boot将确保这些默认值将被取消，并让你的自定义配置将负责应用程序。</li>
<li>为了更清晰的理解，假设你已经为JPA定义了依赖，并且没有定义任何数据库配置，Spring Boot会自动为我们创建所需的配置。</li>
</ol>
<p>请阅读这篇<a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">文章</a>以更加深入地理解<strong>Spring boot的自动配置</strong></p>
<h2 id="3-Servlet容器"><a href="#3-Servlet容器" class="headerlink" title="3. Servlet容器"></a>3. Servlet容器</h2><p>每当我们做出那些小的改变，并且需要将你的应用程序部署到应用服务器来测试我们的改变时，你是否记得在Servlet容器（Tomcat等）上部署它们的过程？Spring Boot提供对嵌入式Servlet容器的支持，我们不再需要在应用服务器上部署我们的应用程序（这可以使用标准main方法轻松运行），同时我们可以使用http://\<host>:\<port>在浏览器上访问我们的应用程序。</port></host></p>
<p>我们的pom.xml中的Spring-boot-starter-web配置条目将为我们的Web应用程序提供嵌入式servlet容器，Apache Tomcat是Spring Boot提供的默认servlet容器，然而，Spring boot也提供了使用其他servlet容器的方法（我们所要做的就是将相应的 starter 添加到pom.xml中）。</p>
<p>请阅读我们的文章<a href="https://www.javadevjournal.com/spring/introduction-to-spring-boot/" target="_blank" rel="external">使用Spring Boot构建应用程序</a>来开始使用Spring Boot构建你的应用程序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们了解了Spring Boot，我们介绍了什么是Spring Boot？ Spring Boot有什么好处？ 我们讨论了Spring Boot的不同特性。 Spring Boot内部为我们做了很多事情，这对我们来说似乎很神奇。 在本系列文章中，我们将揭开Spring Boot的所有内部细节。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/what-is-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/what-is-spring-boot/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Rust的内存安全革命]]></title>
      <url>http://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/</url>
      <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的核心特性：内存管理。 该核心特性是Rust的主要创新之一，它的许多独特的特点是基于这种核心特性的。</p>
<p>本文是写给不知道Rust或刚刚开始学习它的程序员的。对于熟悉C、C++或其他使用手动管理内存以及使用垃圾回收器语言的读者来说会更容易理解Rust的特点。 本文是一个旨在介绍Rust核心概念并鼓励进一步学习的高层次介绍。本文不是教程，最后也没有Hello Wrold的Rust例子。</p>
<a id="more"></a>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>现代应用程序使用计算机的内存主要有两种方式：栈和堆。这可能不适用于使用汇编或编写嵌入式系统软件的情况，但让我们还是关注一般的应用程序的场景。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>随着程序进入和退出某些区域（通常是函数），以及循环和分支代码块，栈会自动扩展和缩小。所有现代的、高于汇编语言的语言都会自动执行此操作。它们的行为都是相似的，程序员声明变量，使用它，然后丢弃它。 编译器基于代码区域边界知道何时必须保留内存以及何时清除内存。 这是一个严格的流程，但它快速、安全且易于使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = 1       // 创建 A</div><div class="line">    loop &#123;</div><div class="line">        B = 2   // 创建 B</div><div class="line">                // 删除 B</div><div class="line">    &#125;</div><div class="line">                // 删除 A</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>对堆的处理更自由。 程序员可以从代码中的任何一点来请求它的一部分，然后在任何其他点释放它。 它并不明显与程序流程结合，编译器无法确定何时以及如何处理它。程序员有责任对其进行正确处理。</p>
<p>内存<strong>首先</strong>必须被获取到，<strong>然后</strong>被使用，<strong>最后</strong>被仅释放<strong>一次</strong>。这三个步骤似乎很简单，但将其与其他应用程序的流程混合会变得棘手，并且违反其中一个步骤都是灾难性的。 有时候一个错误可能没有任何后果，但是在其他时候，应用程序可能会被终止，甚至更糟糕的是，它的内存可能会悄无声息地被破坏。 这种行为不是确定性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">    release(A)      // 释放</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><p>当内存没有被正确释放当时候，泄露就发生了。内存泄漏成为一个致命的负担，使得应用程序比实际所需使用更多的资源。在极端情况下，如果所有的内存都被占用，并且仍然有更多的需求，它会使程序甚至整个系统崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">                    // &lt;运行时错误&gt; 从未释放</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="释放后使用"><a href="#释放后使用" class="headerlink" title="释放后使用"></a>释放后使用</h3><p>当内存被释放后程序还尝试去使用这块内存，这就是释放后使用。如果内存被还给了操作系统，而我们又尝试去访问它，这会导致致命的段错误，程序会立即被结束。另一个有趣的部分是当被释放的内存被分配器缓存并在下次获取时被重用，这使两个随机部分的代码使用相同位置的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    release(A)      // 释放</div><div class="line">    do_stuff(A)     // &lt;运行时错误&gt; 使用无效指针</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重复释放"><a href="#重复释放" class="headerlink" title="重复释放"></a>重复释放</h3><p>内存被释放两次就是重复释放。如果内存被还回操作系统，它就终止程序对它对访问。重复释放的后果很大程度上取决于分配器，释放内存在其他地方使用或只是崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">    release(A)      // 释放</div><div class="line">    release(A)      // &lt;运行时错误&gt; 释放无效指针</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="传统解决方法"><a href="#传统解决方法" class="headerlink" title="传统解决方法"></a>传统解决方法</h1><p>堆管理是个非常古老的问题，程序员发明了许多工具来减轻它。有两种主要的方法，都被证明是有用的，但每一种都有严重缺陷。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>这是一个简单的方法。程序获得特殊的机制检测到从某时刻开始给定的内存块将永远不会被使用，因此它可以安全释放。该方法防止了内存泄露、释放后使用、重复释放。证明内存永远不会被再次使用的最简单的方法是证明它是不可访问的。当程序将内存的地址存储在栈上、静态变量或堆上时，该内存是可到访问的，堆本身是可到达的，因此可以在不猜测的情况下获得。而内存本身是可访问的，因此可以毫无疑问地获得它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">   ...</div><div class="line">   A = &lt;pointer to&gt;──────┐</div><div class="line">   ...                   |</div><div class="line">&#125;                        │</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ AA = &quot;reachable&quot;         ║</div><div class="line">║ AB = &lt;pointer to&gt;──────┐ ║</div><div class="line">╚════════════════════════│═╝</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ ABA = &quot;also reachable&quot;   ║</div><div class="line">╚══════════════════════════╝</div><div class="line"></div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ BA = &quot;unreachable&quot;       ║</div><div class="line">║ BB = &lt;pointer to&gt;──────┐ ║</div><div class="line">╚════════════════════════│═╝</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ BBA = &quot;also unreachable&quot; ║</div><div class="line">╚══════════════════════════╝</div></pre></td></tr></table></figure>
<p>有许多智能的策略来检查可访问性，但它们都会产生显著的开销。例如，引用计数器会增加内存使用量并为每个堆访问增加开销。另一方面，追踪垃圾回收器允许自由访问，但引入了大量的内存可访问性分析，这些分析可以在后台不断运行，或者为了清理内存可以完全停止程序的执行。 无论如何，垃圾回收器都会为应用程序增加额外的工作量并增加内存使用量。</p>
<h2 id="严格的规则"><a href="#严格的规则" class="headerlink" title="严格的规则"></a>严格的规则</h2><p>因此垃圾回收器是一个很好但消耗大量资源的解决方案。但是，如果成本难以承受或者根本没有可能使用它，我们可以做些什么呢？ 程序员发明了一个特殊的规则，它使内存管理更容易。 它是基于所有权和生命周期的规则。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>所有权是这样的一个想法，可以有很多指向分配内存的指针，但只有其中一个被视为拥有该内存。当拥有所有权的指针被销毁时，应该使用它来释放分配给它的内存。非所有权的指针可以被创建和销毁任意个，但它们永远不应该用于释放内存。这使得内存管理更加清晰，因为只有一个重要指针要跟踪和释放。它还解决了前面提到的三个堆问题中的两个问题：泄漏和重复释放。所有权可能是API和程序流程中的一个软性协议，但某些语言和库提供的工具使得此策略的执行更加明确且不易出错。例如，现代C++提供了内置的智能指针，它明确表示有拥有权的指针并实现像销毁时释放的合适行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()      // 获取</div><div class="line">    do_stuff(A)         // 使用</div><div class="line">    release(A)          // 释放, 指针拥有内存</div><div class="line">                        // 删除指针</div><div class="line">&#125;</div><div class="line"></div><div class="line">do_stuff(B) &#123;</div><div class="line">    do_more_stuff(B)    // 使用</div><div class="line">                        // 不会释放，该指针不是所有权的指针</div><div class="line">                        // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期是程序执行过程中的一段时间，而这段时间内一段特定的数据被有效使用。处理堆分配的内存指针时，这是非常重要的属性，这些指针并不拥有内存。 只要拥有内存的指针不释放内存，它们就可以安全使用。而有所有权的指针释放内存之后，再使用它们就是错误，因为它们的生命周期结束了。值得注意的是，任何包含给定生命期周期的指针的结构都应该被认为具有不超过指针的生命期周期。这不是一个可以执行的简单的规则，但它可以防止前面提到的第三个堆内存问题：释放后使用。 这补充了所有权的保证，使得程序的完全内存安全，而无需垃圾回收器这样的开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // A&apos;s lifetime begins</div><div class="line">    do_stuff(A)     // use A</div><div class="line">    B = A           // B&apos;s lifetime begins</div><div class="line">    do_stuff(B)     // use B</div><div class="line">    release(A)      // release, A&apos;s and B&apos;s lifetimes end</div><div class="line">    do_stuff(A)     // &lt;RUN TIME FAIL&gt; use A after its lifetime ended</div><div class="line">    do_stuff(B)     // &lt;RUN TIME FAIL&gt; use B after its lifetime ended</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><p>有时Rust被描述为混合解决方案。 实际上，它所做的只是强化代码中的所有权和生命周期规则，然而结果是，用Rust写代码非常安全和无忧无虑，它类似于垃圾回收语言。编译器进行静态校验该程序是内存安全的，如果无法校验它是内存安全的，编译器会产生一个指出潜在风险的错误。 当编译通过后，代码保证不会导致内存损坏。 因为这些校验在构建输出二进制文件之前都发生了，所以这个过程对程序的执行没有任何影响，就像它是用纯C或C++编写的一样轻量。</p>
<h2 id="所有权-1"><a href="#所有权-1" class="headerlink" title="所有权"></a>所有权</h2><p>Rust有非常严格的所有权概念。每一块被分配的内存被一些结构的单独实例所拥有。这些结构可以是任何类型，但通常他们最终是某种来自标准库的集合或Box（Rust的智能指针）。这些包装器负责在自己被销毁的时候释放所拥有的内存。没有简单的方法来显式分配内存和获取原始指针，而不需要任何负责任的包装器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_fn</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(<span class="number">1234</span>);    <span class="comment">// 获取</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_box);         <span class="comment">// 使用</span></div><div class="line">                                    <span class="comment">// 删除 my_box,</span></div><div class="line">                                    <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归销毁"><a href="#递归销毁" class="headerlink" title="递归销毁"></a>递归销毁</h3><p>所有权是递归的，所以如果一个结构存储另一个结构的值，它将获得后者及其所有子结构的所有权。这也意味着，当容器被销毁时，它必须递归地销毁其所有内容。Rust处理这样的情况可以说是开箱即用一样轻松。所有结构都定义了析构器，它遍历所有字段并首先销毁它们。结构的作者可以在销毁期间添加自己的步骤，例如在编写客户端时关闭数据库连接，但是在此之后字段仍然会被逐一销毁。默认的处理行为在绝大多数情况下都是足够的，因此结构很少会定义析构函数，但是不管有没有定义析构函数，它们都不会泄漏内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;                       <span class="comment">// 结构定义</span></div><div class="line">    my_box: <span class="built_in">Box</span>&lt;<span class="keyword">u32</span>&gt;,                   <span class="comment">// 它只有一个字段,</span></div><div class="line">                                        <span class="comment">// 在堆上一个持有整数的Box类型数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_fn</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> my_struct = MyStruct &#123;          <span class="comment">// 创建结构实例</span></div><div class="line">        my_box: <span class="built_in">Box</span>::new(<span class="number">1234</span>),         <span class="comment">// 获取内存</span></div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_struct.my_box);   <span class="comment">// 使用</span></div><div class="line">                                        <span class="comment">// 删除 my_struct,</span></div><div class="line">                                        <span class="comment">// 同时删除 my_box,</span></div><div class="line">                                        <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="用栈替代堆"><a href="#用栈替代堆" class="headerlink" title="用栈替代堆"></a>用栈替代堆</h3><p>Rust的所有权模式带来了一个强大的特性：复杂的堆管理简化为简单的栈管理。程序员不需要担心如何分配和释放内存，这些工作都通过使用局部变量来处理。甚至即使结构里嵌套了许多堆内存的引用，在栈上也总是只有一个根结构，当程序不再需要它的时候，它会自动销毁。</p>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><p>不幸的是，编写那些访问数据需要拥有这些数据的程序并不方便。Rust提供普通的、非智能的、没有所有权的引用，这种引用使得没有所有权的访问成为可能。当这样的引用被创建时，它引用的值是借用的。借用会创建一个双向关系：引用必须具有不超过它引用的值的生命周期，但该值在引用的生命周期内不得移动。这两条规则任何一条被破坏的话，引用所指向的就是无效内存。Rust静态地跟踪并强制执行生命周期的正确性并拒绝危险的程序执行流程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">valid_flow</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value);          <span class="comment">// 使用值但是没有移动它</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, borrow);         <span class="comment">// 使用借用</span></div><div class="line">                                    <span class="comment">// 删除借用</span></div><div class="line">                                    <span class="comment">// 安全地删除值，</span></div><div class="line">                                    <span class="comment">// 因为它不再被借用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrow_outlives_value</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="keyword">return</span> borrow                   <span class="comment">// 借用没有被删除</span></div><div class="line">                                    <span class="comment">// &lt;编译时错误&gt; 删除值,</span></div><div class="line">                                    <span class="comment">// 但是它仍然被借用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_moved_during_borrow_lifetime</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(value);   <span class="comment">// &lt;编译时错误&gt; 值被移动了</span></div><div class="line">                                    <span class="comment">// 而它还被借用着</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归借用"><a href="#递归借用" class="headerlink" title="递归借用"></a>递归借用</h3><p>结构的生命周期永远不能超过它们的任何字段的生命周期。如果其中一个字段恰好是引用，则必须证明整个结构实例在引用值之前被销毁。如果存在对具有生命周期限制的结构的引用，则引用本身的生命周期不能超过结构。只要编译器可以证明它是安全的，这种关系就可以嵌套并绑定任意次数。当编译器无法猜测正确的关系时，可以用简单的语法明确定义它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">nested_borrow_outlives_value</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">                                    <span class="comment">// 使用的是值的生命周期</span></div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(borrow);  <span class="comment">// 创建 my_box</span></div><div class="line">                                    <span class="comment">// 用的是借用的生命周期,</span></div><div class="line">                                    <span class="comment">// 这是值的生命周期</span></div><div class="line">    <span class="keyword">return</span> my_box                   <span class="comment">// &lt;编译时错误&gt;</span></div><div class="line">                                    <span class="comment">// my_box 没有被删除,</span></div><div class="line">                                    <span class="comment">// 但是值被删除了,</span></div><div class="line">                                    <span class="comment">// 这造成借用的生命周期</span></div><div class="line">                                    <span class="comment">// 超过了值的生命周期</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="规则的妥协"><a href="#规则的妥协" class="headerlink" title="规则的妥协"></a>规则的妥协</h1><p>认为每一个系统都可以用限制性的、静态证明的安全性代码来表达是天真的想当然。在绝大多数的情况下，规则可以胜任，但有时规则也必须进行妥协，Rust提供工具来做这件事。</p>
<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><p>标准库提供一些包装器将所有权和借用的检查推迟到运行时。这就使有效性检查程序不那么繁忙，并提供了灵活性和很少的运行时开销。例如，Rc是一个没有所有者的Box（带有智能指针的内存）。 它是一个有引用计数器的可被垃圾回收的内存，它的最后一个引用消失的时候，它就被销毁。 Rust提供了更多的包装器，但它们稍微超出了本介绍的范围，它们适用于运行时规则，本文没有涉及。</p>
<h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>当在库和工具中进入足够低的层次时，Rust的安全保证变得无法应用。 例如，box和集合触及内存分配和指针，但没有安全保证，因为它们自己做安全保证。 它们可以写在Rust中，因为它们的代码明确标记为不安全。这使得完全忽略安全检查，但这非常危险。 所有外部C库包装器在某些层次也必须使用不安全的代码。 他们定义安全规则，使其与其余代码无缝集成。 不安全的代码是Rust强大能力的来源，但它带来了巨大的责任。 应尽可能避免使用它。</p>
<h1 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h1><p>Rust看起来不错，它是由聪明的人使用其他聪明人的学术研究设计的，但它真的有用吗？是的，的确有用。大多数情况下，它只会强制元素之间的明确关系，进行合理安全的设计。毕竟，Rust是与Firefox Web浏览器的未来引擎Servo并行设计的。从一开始，它不仅在理论上是好的，而且在实际的、复杂的软件开发中也被证明是可用的。经过一年使用Rust进行商业编程后，我可以确认，Rust的规则不是一种负担，而是在架构和稳定性保证方面提供了很大的帮助。 我真的相信，Rust这种语言是属于未来的，我强烈推荐大家使用它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://anixe.pl/content/news/rust_memory_safety_revolution" target="_blank" rel="external">https://anixe.pl/content/news/rust_memory_safety_revolution</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以NIF的方式在Elixir里使用C]]></title>
      <url>http://szpzs.oschina.io/2018/04/03/using-c-from-elixir-with-nifs/</url>
      <content type="html"><![CDATA[<p>Erlang支持一种方式，就是用C来实现函数，并在Erlang中透明地使用它们。这些函数被叫做NIFs（原生实现的函数）。在两种场景下，NIF被证明是完美的解决方案：当你需要原始的计算速度时；当你需要从Erlang调用已有的C接口时。在本文中，我们一起来看看这两种场景。</p>
<a id="more"></a>
<p>请注意，如果我们想要使用C程序（也就是我们想要与现有的C程序进行交互），那么NIF并不是我们唯一的选择。Erlang有其他方式处理外部函数接口来与其他语言交互。其中之一就是Port；如果你想深入了解，可以阅读 Sasa Juric 写的非常棒的<a href="http://theerlangelist.com/article/outside_elixir" target="_blank" rel="external">文章</a>。</p>
<p>我们将全面了解NIF。首先，我们将看看如何写简单的NIF来执行算术计算；接着，我们看看如何在Elixir里使用这些NIF。然后，我们了解如何从NIF里访问已有的C程序。最后，我们学习如何将C的编译合并到我们Elixir代码编译中。</p>
<p>我在本文中所讲的绝大部分内容都可以在Erlang官方文档中 <a href="http://www.erlang.org/doc/man/erl_nif.html" target="_blank" rel="external">erl_nif C 库</a> 中阅读到更多细节。</p>
<p>本文中讨论的内容适用于Erlang和Elixir，只需进行最小限度的调整。 我会在Elixir中展示我所有的例子，但我会随时提及Erlang和Elixir两者。</p>
<h1 id="严肃的NIF警告"><a href="#严肃的NIF警告" class="headerlink" title="严肃的NIF警告"></a>严肃的NIF警告</h1><p>NIF是危险的。我猜你肯定听说过Erlang（Elixir）如何可靠、容错，进程是如何隔离的，一个进程内部的崩溃只会影响到它自己，以及其他的很棒的特性。当你开始玩NIF的时候，你可以和所有Erlang好的东西说再见。一个NIF里的崩溃（比如可怕的段错误）将会使得整个Erlang虚拟机崩溃。没有监督者来恢复，没有容错，没有隔离。这意味着当你使用NIF的时候需要极度的小心谨慎，并且你应该总是确信你有一个好的理由来使用它。</p>
<p>另一个值得注意的是NIF不会被Erlang的调度器抢占：一个NIF做为一个单独的计算单元，它不会被中断。这意味着你的NIF应该尽可能地快; 正如Erlang的NIF文档所建议的那样，一个很好的经验法则是将NIF保持在毫秒级的执行时间内。查看Erlang文档，了解当你的NIF需要更多时间完成时应采取的措施。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>NIF的工作方式简单：你写一个C文件，然后在一些Erlang提供的设施下导出一些函数，然后编译这个文件。接着，你定义一个Erlang/Elixir文件，在里面调用 :erlang.load_nif/2 。这个函数将把C文件里的所有NIF定义为调用模块里的函数。</p>
<p>在实践中更容易明白这一点。</p>
<p>让我们从容易的开始：写一个没有副作用的NIF，它有一个入参和一个返回值。为完成这个例子，我们写一个 fast_compare 函数，它有两个整数入参，然后比较它们，如果相等就返回0，如果第一个比第二个小，就返回-1，否则就返回1。</p>
<h2 id="定义一个NIF"><a href="#定义一个NIF" class="headerlink" title="定义一个NIF"></a>定义一个NIF</h2><p>我们开始写 fast_compare.c 文件。首先我们必须包含 erl_nif.h 这个头文件，它包含了使用NIF的时候，我们需要的所有东西（类型、函数、宏）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div></pre></td></tr></table></figure>
<p>C编译器并不知道erl_nif.h在哪里，因此，当稍后我们编译我们的程序的时候，必须指出它的所在。</p>
<p>现在，定义NIF的所有C文件有相似的结构：C函数列表，接着是被导出到Erlang/Elixir的C函数列表（以及它们的名字），最后，调用 ERL_NIF_INIT 宏，它执行把所有这个一切串联起来的神秘的事情。</p>
<p>在我们的例子里，C函数列表就只有 fast_compare 函数。这个函数的签名如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="comment">// cool stuff here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个NIF的特定类型：ERL_NIF_TERM 和 ErlNifEnv。</p>
<p>ERL_NIF_TERM 是一个“包装”类型，它表示在C里所有的Erlang数据类型（像binary，list，tuple，等等）。我们必须使用 erl_nif.h 提供的函数来将一个 ERL_NIF_TERM 转换为一个C的值（或者多个C的值），反之亦然。</p>
<p>ErlNifEnv仅仅是NIF被执行所在的Erlang环境，我们绝大多数只是把它在函数中进行传递而不必实际对它进行操作。</p>
<p>我们来看看 fast_compare 的参数（所有的NIF参数都如此）：</p>
<ul>
<li>env 如上所述，仅是NIF被执行所在的Erlang环境，我们不比太关心它。</li>
<li>argc 当从Erlang调用NIF的时候，传递给它的参数个数。后面我们将详述。</li>
<li>argv 传递给NIF的参数的数组。</li>
</ul>
<h2 id="读取Erlang-Elixir类型的值为C类型的值"><a href="#读取Erlang-Elixir类型的值为C类型的值" class="headerlink" title="读取Erlang/Elixir类型的值为C类型的值"></a>读取Erlang/Elixir类型的值为C类型的值</h2><p>我们从Elixir调用 fast_compare ，如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fast_compare(<span class="number">99</span>, <span class="number">100</span>)</div><div class="line"><span class="comment">#=&gt; -1</span></div></pre></td></tr></table></figure>
<p>当执行 fast_compare ，argc为2，argv 是 99 和 100 组成的数组。然而，这些参数的类型是 ERL_NIF_TERM ，因此我们必须将它们“转换”为C的数据类型才能操作它们。erl_nif.h 提供了函数将Erlang的数据类型转换为C的数据类型。在本例子里，我们需要用enif_get_int这个函数。enif_get_int的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">enif_get_int</span><span class="params">(ErlNifEnv *env, ERL_NIF_TERM term, <span class="keyword">int</span> *ip)</span></span>;</div></pre></td></tr></table></figure>
<p>我们必须传入变量 env，我们需要转换的Erlang数据（从argv中取出的），以及转换得到的值所存储的地址。</p>
<h2 id="将C类型的值转换为Erlang类型的值"><a href="#将C类型的值转换为Erlang类型的值" class="headerlink" title="将C类型的值转换为Erlang类型的值"></a>将C类型的值转换为Erlang类型的值</h2><p>erl_nif.h 提供了几个 enif_make_* 类似的函数来将C类型的值转换为Erlang类型的值。它们都有相似的签名（只是根据被转换的数据类型不同而有差别），并且它们都返回 ERL_NIF_TERM类型的值。在本例子中，我们需要 enif_make_int 函数，它的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">ERL_NIF_TERM <span class="title">enif_make_int</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> i)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="编写NIF"><a href="#编写NIF" class="headerlink" title="编写NIF"></a>编写NIF</h2><p>我们已经知道如何在Erlang类型数据和C类型数据之间进行转换，那么编写NIF就很直观了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  <span class="comment">// Fill a and b with the values of the first two args</span></div><div class="line">  enif_get_int(env, argv[<span class="number">0</span>], &amp;a);</div><div class="line">  enif_get_int(env, argv[<span class="number">1</span>], &amp;b);</div><div class="line"></div><div class="line">  <span class="comment">// Usual C unreadable code because this way is more true</span></div><div class="line">  <span class="keyword">int</span> result = a == b ? <span class="number">0</span> : (a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> enif_make_int(env, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="连接我们的C"><a href="#连接我们的C" class="headerlink" title="连接我们的C"></a>连接我们的C</h2><p>我们现在必须将我们写的函数导出到Erlang。我们必须使用ERL_NIF_INIT这个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERL_NIF_INIT(erl_module, functions, load, upgrade, unload, reload)</div></pre></td></tr></table></figure>
<ul>
<li>erl_module 是Erlang模块，我们导出的函数将被定义在里面。它不需要被双引号括起来，因为它将被ERL_NIF_INIT字符串化（例如，用my_module而不是用”my_module”）；</li>
<li>functions 是ErlNifFunc结构类型数据的数组，它定义哪些NIF被导出，以及对应的Erlang函数和它的参数个数；</li>
<li>load，upgrade，unload，reload是函数指针，它们指向那些NIF被装载卸载等操作的回调函数；我们现在不太关心这些回调函数，把它们全部设置为NULL。</li>
</ul>
<p>我们所需的所有元素都准备好了。完整的C文件如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  enif_get_int(env, argv[<span class="number">0</span>], &amp;a);</div><div class="line">  enif_get_int(env, argv[<span class="number">1</span>], &amp;b);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> result = a == b ? <span class="number">0</span> : (a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> enif_make_int(env, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Let's define the array of ErlNifFunc beforehand:</span></div><div class="line"><span class="keyword">static</span> ErlNifFunc nif_funcs[] = &#123;</div><div class="line">  <span class="comment">// &#123;erl_function_name, erl_function_arity, c_function&#125;</span></div><div class="line">  &#123;<span class="string">"fast_compare"</span>, <span class="number">2</span>, fast_compare&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ERL_NIF_INIT(Elixir.FastCompare, nif_funcs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</div></pre></td></tr></table></figure>
<p>要记得我们必须要在ERL_NIF_INIT宏里使用Elixir模块的全名的原子（是Elixir.FastCompare而不是FastCompare）。</p>
<h2 id="编译我们的C代码"><a href="#编译我们的C代码" class="headerlink" title="编译我们的C代码"></a>编译我们的C代码</h2><p>NIF文件应该编译为 .so 共享库。编译标志在不同的系统和编译器中有所不同，但它们应该看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cc <span class="_">-f</span>PIC -I$(ERL_INCLUDE_PATH) \</div><div class="line">     -dynamiclib -undefined dynamic_lookup \</div><div class="line">     -o fast_compare.so fast_compare.c</div></pre></td></tr></table></figure>
<p>使用这个命令，我们用一些为了生产动态代码的标志把 fast_compare.c 编译为 fast_compare.so （-o fast_compare.so）。注意我们如何把 $(ERL_INCLUDE_PATH) 包含在搜索路径里：这个路径包含了erl_nif.h 头文件。这个路径通常在Erlang的安装目录里，即 lib/erts-VERSION/include。</p>
<h2 id="在Elixir中装载NIF"><a href="#在Elixir中装载NIF" class="headerlink" title="在Elixir中装载NIF"></a>在Elixir中装载NIF</h2><p>剩下的事情是装载在Elixir模块 FastCompare 里定义的NIF。如Erlang中关于NIF的文档所建议，钩子 @on_load 是做这件事的最适合的地方。</p>
<p>请注意，对于我们要定义的每个NIF，我们也需要在加载模块中定义相应的Erlang / Elixir函数。 这可以被利用来在NIF不可用的情况下定义例如回退代码。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># fast_compare.ex</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">FastCompare</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@on_load</span> <span class="symbol">:load_nifs</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load_nifs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:erlang</span>.load_nif(<span class="string">'./fast_compare'</span>, <span class="number">0</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fast_compare</span></span>(_a, _b) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"NIF fast_compare/2 not implemented"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:erlang.load_nif/2 的第二个参数可以是任何东西，它会被传递给我们上面提到的load回调函数。 你可以看看<a href="http://www.erlang.org/doc/man/erlang.html#load_nif-2" target="_blank" rel="external">erlang.load_nif/2</a>的文档以获取更多信息。</p>
<p>搞定！我们可以在IEx里测试一下我们的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; c <span class="string">"fast_compare.ex"</span></div><div class="line">iex&gt; FastCompare.fast_compare(<span class="number">99</span>, <span class="number">100</span>)</div><div class="line">-<span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>写“纯”的NIF（没有副作用，只是转换）非常有用。我非常喜欢的一个例子是 <a href="https://github.com/devinus/markdown" target="_blank" rel="external">devinus/markdown</a> 这个Elixir库：这个库用NIF封装了一个C的markdown解析器。这个用例是完美的，因为将Markdown转换为HTML可能是一项昂贵的任务，而通过将该工作委托给C来做可以获得更好的性能。</p>
<h1 id="有用的东西：资源"><a href="#有用的东西：资源" class="headerlink" title="有用的东西：资源"></a>有用的东西：资源</h1><p>正如我上面提到的，NIF的一个非常有用的地方是包装已有的C库。然而，这些库常常提供它们自己的数据抽象和数据结构。例如，一个C的数据库驱动导出一个 db_conn_t 类型来表示一条数据库链接，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// fields</span></div><div class="line">&#125; <span class="keyword">db_conn_t</span>;</div></pre></td></tr></table></figure>
<p>相应的函数初始化链接、发起查询、释放链接，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">db_conn_t</span> *db_init_conn();</div><div class="line"><span class="function">db_type <span class="title">db_query</span><span class="params">(<span class="keyword">db_conn_t</span> *conn, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_free_conn</span><span class="params">(<span class="keyword">db_conn_t</span> *conn)</span></span>;</div></pre></td></tr></table></figure>
<p>如果我们能够在Erlang/Elixir里处理db_conn_t数据类型并且在NIF调用之间传递它们的话，这将非常有用。NIF的API有一个叫做 <strong>resources</strong> 的概念。没有比用Erlang的官方文档更好的方式来快速解释什么是 <strong>resources</strong> 。</p>
<blockquote>
<p><strong>资源对象的使用是一种从NIF返回指向原生数据结构的指针的安全方法。 资源对象只是一块内存。 […].</strong></p>
</blockquote>
<p>资源是内存块，我们可以构建并返回指向该内存的安全指针作为Erlang的类型数据。</p>
<p>让我们来探讨一下如何在NIF内部包装上面简单的API。 我们将从这个骨架C文件开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// fields here</span></div><div class="line">&#125; <span class="keyword">db_conn_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">db_conn_t</span> *db_init_conn();</div><div class="line"><span class="function">db_type <span class="title">db_query</span><span class="params">(<span class="keyword">db_conn_t</span> *conn, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_free_conn</span><span class="params">(<span class="keyword">db_conn_t</span> *conn)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="资源的创建"><a href="#资源的创建" class="headerlink" title="资源的创建"></a>资源的创建</h2><p>要创建一个资源，我们必须要使用 enif_alloc_resource 函数的帮助来分配一些内存。从这个函数的签名你可以看出它和 malloc 函数相似（原则上）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">enif_alloc_resource</span><span class="params">(ErlNifResourceType *res_type, <span class="keyword">unsigned</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>enif_alloc_resource 的第一个参数是一个资源类型（这只是我们用来区分不同类型资源的东西），第二个参数是需要分配的内存大小，返回值是已分配内存的指针。</p>
<h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>资源类型是用 enif_open_resource_type 函数来创建的。我们可以在我们的C文件里声明资源类型作为全局变量。同时，利用传递给 ERL_NIF_INIT的load回调函数的便利性来创建资源类型并且把它们赋值给全局变量。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ErlNifResourceType *DB_RES_TYPE;</div><div class="line"></div><div class="line"><span class="comment">// 每次当一个资源被释放的时候这个函数被调用</span></div><div class="line"><span class="comment">// 资源被释放在enif_release_resource函数被调用</span></div><div class="line"><span class="comment">// 以及Erlang回收内存的时候发生</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">db_res_destructor</span><span class="params">(ErlNifEnv *env, <span class="keyword">void</span> *res)</span> &#123;</div><div class="line">  db_free_conn((<span class="keyword">db_conn_t</span> *) res);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">load</span><span class="params">(ErlNifEnv *env, <span class="keyword">void</span> **priv_data, ERL_NIF_TERM load_info)</span> &#123;</div><div class="line">  <span class="keyword">int</span> flags = ERL_NIF_RT_CREATE | ERL_NIF_RT_TAKEOVER;</div><div class="line">  DB_RES_TYPE =</div><div class="line">    enif_open_resource_type(env, <span class="literal">NULL</span>, <span class="string">"db"</span>, db_res_destructor, flags, <span class="literal">NULL</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h3><p>我们现在可以包装db_init_conn并且创建我们的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">db_init_conn_nif</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="comment">// 让我们给一个 db_conn_t 指针分配内存</span></div><div class="line">  <span class="keyword">db_conn_t</span> **conn_res = enif_alloc_memory(DB_RES_TYPE, <span class="keyword">sizeof</span>(<span class="keyword">db_conn_t</span> *));</div><div class="line"></div><div class="line">  <span class="comment">// 让我们创建一条链接并且把它拷贝到指针所指的内存</span></div><div class="line">  <span class="keyword">db_conn_t</span> *conn = db_init_conn();</div><div class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *) conn_res, (<span class="keyword">void</span> *) &amp;conn, <span class="keyword">sizeof</span>(<span class="keyword">db_conn_t</span> *));</div><div class="line"></div><div class="line">  <span class="comment">// 我们现在可以让Erlang类型数据持有这个资源...</span></div><div class="line">  ERL_NIF_TERM term = enif_make_resource(env, conn_res);</div><div class="line">  <span class="comment">// ...然后释放这个资源以便在Erlang垃圾回收的时候它将被释放</span></div><div class="line">  enif_release_resource(conn_res);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> term;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><p>为了包装db_query，我们需要获取 db_init_conn_nif 返回的资源。为实现这个功能，我们需要使用 enif_get_resource 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">db_query_nif</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">db_conn_t</span> **conn_res;</div><div class="line">  enif_get_resource(env, argv[<span class="number">0</span>], DB_RES_TYPE, (<span class="keyword">void</span> *) conn_res);</div><div class="line"></div><div class="line">  <span class="keyword">db_conn_t</span> *conn = *conn_res;</div><div class="line"></div><div class="line">  <span class="comment">// 我们现在可以运行我们的查询</span></div><div class="line">  db_query(conn, ...);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> argv[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在Elixir里使用资源"><a href="#在Elixir里使用资源" class="headerlink" title="在Elixir里使用资源"></a>在Elixir里使用资源</h3><p>让我们跳过在DB模块里导出我们创建的NIF，直接跳到IEx shell环节，而且假设C代码已经编译并被DB模块装载进虚拟机了。正如我前面所述，当资源返回给Erlang/Elixir的时候完全是一个不透明的数据。它们表现得就像是空的的二进制数据。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; conn_res = DB.db_conn_init()</div><div class="line"><span class="string">""</span></div><div class="line">iex&gt; DB.db_query(conn_res, ...)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>因为资源是不透明的数据，除了将它们回传给其他NIF，你无法在Erlang/Elixir里对它进行任何有意义的处理。它们的行为和看起来像二进制数据，这甚至可以导致问题，因为他们可以被误认为二进制数据。基于这个缘故，我建议将资源包装到结构当中。这样我们可以限制我们的公共API仅能处理结构并且在内部处理资源。我们也可以通过实现结构的 Inspect 协议来获得好处，这种方式使得我们可以安全地检测资源，而隐藏了它们看起来像是二进制数据的事实。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">DBConn</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:resource</span>]</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">defimpl</span> <span class="title">Inspect</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="用Mix编译"><a href="#用Mix编译" class="headerlink" title="用Mix编译"></a>用Mix编译</h1><p>Mix提供了一个特性，叫做<a href="http://elixir-lang.org/docs/stable/mix/Mix.html#compilers/0" target="_blank" rel="external">Mix 编译器</a>。每一个Mix项目在编译的时候可以指定一个编译器列表来运行。新的Mix编译器是自动编译C源代码的完美场所。对于本节的范围，假设我们正在构建一个叫做 :my_nifs 的Elixir应用程序，该应用程序将使用my_nifs.c C源文件中的NIF。</p>
<p>首先我们创建 Makefile 来编译C源码（反正我们可能会这么做）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ERL_INCLUDE_PATH=$(...)</div><div class="line"></div><div class="line">all: priv/my_nifs.so</div><div class="line"></div><div class="line">priv/my_nifs.so: my_nifs.c</div><div class="line">  cc <span class="_">-f</span>PIC -I$(ERL_INCLUDE_PATH) -dynamiclib -undefined dynamic_lookup -o my_nifs.so my_nifs.c</div></pre></td></tr></table></figure>
<p>这个 Makefile 文件假设 my_nifs.c 存储在我们的Mix项目的根目录。我们将把 .so 共享库存放在我们应用的 priv 目录中，以便在发布的时候它是可用的。现在，无论何时，只要我们修改了 my_nifs.c ，然后运行 make ，priv/my_nifs.so 都会被重新编译。</p>
<p>我们现在可以挂接一个只调用make的新的Mix编译器。在 mix.exs 中，我们来实现之：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Mix</span></span>.Tasks.Compile.MyNifs <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(_args) <span class="keyword">do</span></div><div class="line">    &#123;result, _errcode&#125; = System.cmd(<span class="string">"make"</span>, [], <span class="symbol">stdout_to_stderr:</span> <span class="keyword">true</span>)</div><div class="line">    IO.binwrite(result)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们调用 IO.binwrite/1 来将 make 的运行结果输出到终端。在一个真实的场景里，我们肯定要检查 make 的结果，同时也要确认 cc 和 make 已经安装到系统里，并且其路径可用；不过在这里，我们简单地忽略了这些步骤。</p>
<p>我们现在需要将 :my_nifs 编译器添加到 :my_nifs 应用的编译器列表。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in mix.exs</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyNifs</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:my_nifs</span>,</div><div class="line">     <span class="symbol">compilers:</span> [<span class="symbol">:my_nifs</span>] ++ Mix.compilers,</div><div class="line">     ...]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，任何时候我们运行 $ mix compiler ，我们的C代码就被自动重新编译（如果需要）。当其他库把 :my_nifs 作为依赖的话，这个过程也会一样地执行，因为现在运行 make 是 :my_nifs 项目编译的一个过程。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这是一个很长的帖子，但我希望我覆盖了NIF的大部分内容。如你所见，在Erlang/Elixir里使用NIF是相当方便的。正如本文开头提到的那样，由于NIF的脆弱性（记住NIF可能导致整个Erlang虚拟机崩溃）和速度要求，因此要谨慎使用NIF，而且它并不总是正确的工具。</p>
<p>感谢您的阅读！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/" target="_blank" rel="external">http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用“with”宏更好地控制执行流程]]></title>
      <url>http://szpzs.oschina.io/2018/04/02/better-control-flow-using-the-with-macro/</url>
      <content type="html"><![CDATA[<p>从Elixir1.2开始就可以用with宏来写出更有表现力的流程控制语句。与需要深度嵌套的 case 和 if/else 语句不同，你可以只使用一个 with 语句来表达一样的逻辑，而且方式上更加优雅可读性也更好。下面我将探索如何利用它们来改进你的代码。</p>
<h1 id="with-的基础"><a href="#with-的基础" class="headerlink" title="with 的基础"></a>with 的基础</h1><p>with 后跟一个句子列表，这些句子将按顺序执行。如果所有句子的结果都是正常，那么 do 后面的语句将被执行。当其中一个句子的结果有问题，则 do 后面的句子就不执行，而且相关错误值将返回给调用者。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"10"</span>) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">100</span></div><div class="line"></div><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"foo"</span>) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="symbol">:error</span></div><div class="line"></div><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>你也可以在那些句子中使用when子句。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; <span class="keyword">when</span> int != <span class="number">0</span> &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;   <span class="number">99</span> / int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">11.0</span></div></pre></td></tr></table></figure>
<p>另外，你可以使用else来捕获相关可能的异常。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="symbol">:error</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_an_int</span>&#125; <span class="comment"># error for bad parsing</span></div><div class="line">...&gt;   <span class="keyword">false</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_even</span>&#125; <span class="comment"># error for odd number</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:not_even</span>&#125;</div></pre></td></tr></table></figure>
<p>或者，你可以忽略所有错误值，只返回一个统一的错误。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="number">_</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:invalid_value</span>&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:invalid_value</span>&#125;</div></pre></td></tr></table></figure>
<p>你甚至可以在这些句子中赋值。不过要小心，如果你进行了错误的赋值，可能会得到 MatchError 错误。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      squared = int * int,</div><div class="line">...&gt;      <span class="keyword">false</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   squared + <span class="number">1</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">82</span></div><div class="line"></div><div class="line">iex&gt; with <span class="number">1</span> = <span class="string">"1"</span>, <span class="symbol">do:</span> <span class="symbol">:ok</span></div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"1"</span></div></pre></td></tr></table></figure>
<p>with的语法请看官方的<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">详细文档</a>。</p>
<h1 id="一个实际的例子"><a href="#一个实际的例子" class="headerlink" title="一个实际的例子"></a>一个实际的例子</h1><p>让我们来看看一个的例子。你可能遇到这样的情况，你需要在一个控制器里修改一个已经存在的记录并且发送一些通知消息出去。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> Documents.get(params[<span class="string">"id"</span>]) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, document&#125; -&gt;</div><div class="line">      <span class="keyword">case</span> Documents.update(document, params) <span class="keyword">do</span></div><div class="line">        &#123;<span class="symbol">:ok</span>, document&#125; -&gt;</div><div class="line">          Notifications.push_document_updated(document)</div><div class="line">          json(conn, document)</div><div class="line"></div><div class="line">        &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">          render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们很明显地看到我们用嵌套case语句来获得我们需要的执行路径。我们用 with 来重写的话，将会使代码简洁明了得多。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  with &#123;<span class="symbol">:ok</span>, document&#125; &lt;- Documents.get(params[<span class="string">"id"</span>]),</div><div class="line">       &#123;<span class="symbol">:ok</span>, updated_document&#125; &lt;- Documents.update(document, params) <span class="keyword">do</span></div><div class="line">    Notifications.push_document_updated(updated_document)</div><div class="line">    json(conn, document)</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>通过用 with 来重写代码，我们可以很清晰地看到我们期望的执行路径以及捕获的具体错误是什么。</p>
<h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>通常，你会发现自己需要在具有相似错误值的数据中进行匹配，这样会使得处理错误情况更加复杂。我喜欢用的一个小技巧是，使用像 {:my_atom, “expected_value”} 这样的有唯一标识的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  user = conn.assigns.user</div><div class="line">  with &#123;<span class="symbol">:ok</span>, document&#125; &lt;- Document.get(params[<span class="string">"id"</span>]),</div><div class="line">       &#123;<span class="symbol">:can_view?</span>, <span class="keyword">true</span>&#125; &lt;- &#123;<span class="symbol">:can_view?</span>, Authorizer.can_view?(document, user)&#125;,</div><div class="line">       &#123;<span class="symbol">:can_edit?</span>, <span class="keyword">true</span>&#125; &lt;- &#123;<span class="symbol">:can_edit?</span>, Authorizer.can_edit?(document, user)&#125;</div><div class="line">       &#123;<span class="symbol">:ok</span>, updated_document&#125; &lt;- Documents.update(document, params) <span class="keyword">do</span></div><div class="line">    Notifications.push_document_updated(updated_document)</div><div class="line">    json(conn, document)</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:can_view?</span>, <span class="keyword">false</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:can_edit?</span>, <span class="keyword">false</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"403"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>增加一个唯一原子使得更易于标识特定的错误然后返回适当的结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>with 帮助我们在不牺牲错误处理功能和可读性上写出更加整洁，更富表达性的代码。任何时候，当你需要处理复杂的逻辑流程的时候，都记得使用这个宏的优点。最后别忘了仔细阅读<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">官方关于 with 的文档</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://dockyard.com/blog/2018/03/30/better-control-flow-using-the-with-macro" target="_blank" rel="external">https://dockyard.com/blog/2018/03/30/better-control-flow-using-the-with-macro</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang的宏]]></title>
      <url>http://szpzs.oschina.io/2018/03/29/erlang-macro/</url>
      <content type="html"><![CDATA[<p>Erlang的宏的定义语法如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(Const, Replacement)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(Func(Var1,...,VarN)</span>, Replacement).</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>宏定义可以放在模块的属性和函数声明之间的任何地方，但是，宏使用前必须被定义。如果一个宏被几个模块使用，则建议将该宏的定义放置在一个包含文件里。</p>
<p>宏的使用语法如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?Const</div><div class="line">?Func(Arg1,...,ArgN)</div></pre></td></tr></table></figure>
<p>宏在编译期间被展开替换，如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(TIMEOUT, <span class="number">200</span>)</span>.</div><div class="line">...</div><div class="line"><span class="function"><span class="title">call</span><span class="params">(Request)</span> -&gt;</span></div><div class="line">    server:call(refserver, Request, ?TIMEOUT).</div></pre></td></tr></table></figure>
<p>编译期间被替换为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">call</span><span class="params">(Request)</span> -&gt;</span></div><div class="line">    server:call(refserver, Request, <span class="number">200</span>).</div></pre></td></tr></table></figure>
<p>有参数的宏在编译期间，其参数被实参替换，代码如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(MACRO1(X, Y)</span>, &#123;a, X, b, Y&#125;).</div><div class="line">...</div><div class="line"><span class="function"><span class="title">bar</span><span class="params">(X)</span> -&gt;</span></div><div class="line">    ?MACRO1(a, b),</div><div class="line">    ?MACRO1(X, <span class="number">123</span>)</div></pre></td></tr></table></figure>
<p>编译期间被替换为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">bar</span><span class="params">(X)</span> -&gt;</span></div><div class="line">    &#123;a,a,b,b&#125;,</div><div class="line">    &#123;a,X,b,<span class="number">123</span>&#125;.</div></pre></td></tr></table></figure>
<p>如果想看宏展开的效果，可以在编译模块的时候使用 ‘P’ 选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile:file(File, \['P'\]).</div></pre></td></tr></table></figure>
<p>这将产生宏展开后的文件：File.P 。</p>
<p>Erlang预定义了一些宏：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">?MODULE  <span class="comment">%%当前模块的名字</span></div><div class="line"></div><div class="line">?MODULE_STRING  <span class="comment">%%当前模块的名字的字符串</span></div><div class="line"></div><div class="line">?FILE  <span class="comment">%%当前模块的文件名</span></div><div class="line"></div><div class="line">?LINE  <span class="comment">%%当前行号</span></div><div class="line"></div><div class="line">?MACHINE  <span class="comment">%%虚拟机的名字，固定为'BEAM'</span></div></pre></td></tr></table></figure>
<p>除了预定义宏之外，宏是可以重载的。重载宏有多个定义，每个定义具有不同数量的参数。参数化宏在使用的时候，即使没有型参，也要加上括号。如果有型参数，则实参个数必须与型参一致。</p>
<p>宏可以应用于条件编译。如下指令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-undef</span><span class="params">(Macro)</span>. <span class="comment">%%取消宏Macro的定义。</span></div><div class="line"></div><div class="line"><span class="keyword">-ifdef</span><span class="params">(Macro)</span>. <span class="comment">%%如果宏Macro定义了，则编译其下面的语句。</span></div><div class="line"></div><div class="line"><span class="keyword">-ifndef</span><span class="params">(Macro)</span>. <span class="comment">%%如果宏Macro没有定义了，则编译其下面的语句。</span></div><div class="line"></div><div class="line"><span class="keyword">-else</span>. <span class="comment">%%这个指令只允许出现在 ifdef 或 ifndef 的后面。仅当它前面的ifdef 或 ifndef 为false时，它下面的语句才被编译。</span></div><div class="line"></div><div class="line"><span class="keyword">-endif</span>. <span class="comment">%%指示指令 ifdef  或  ifndef  的结束。</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong>上述指令不能出现在函数当中。</p>
<p>例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(m)</span>.</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">-ifdef</span><span class="params">(debug)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(LOG(X)</span>, io:format<span class="params">(<span class="string">"&#123;~p,~p&#125;: ~p~n"</span>, \[?MODULE,?LINE,X\])</span>).</div><div class="line"><span class="keyword">-else</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(LOG(X)</span>, true).</div><div class="line"><span class="keyword">-endif</span>.</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>如果想要LOG(X)宏真正输出内容，则在编译的时候要加上 debug 宏：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% erlc -Ddebug m.erl</span></div></pre></td></tr></table></figure>
<p>或<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(m, &#123;d, debug&#125;).</div><div class="line">&#123;ok,m&#125;</div></pre></td></tr></table></figure></p>
<p>这样?LOG(Arg)就会展开为对 io:format/2 的调用。</p>
<p>如果Arg是宏的参数，那么??Arg将展开为包含这个参数的字符串。这个和C语言中宏参数字符串化类似：#arg</p>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(TESTCALL(Call)</span>, io:format<span class="params">(<span class="string">"Call ~s: ~w~n"</span>, \[??Call, Call\])</span>).</div><div class="line"></div><div class="line">?TESTCALL(myfunction(<span class="number">1</span>,<span class="number">2</span>)),</div><div class="line">?TESTCALL(you:function(<span class="number">2</span>,<span class="number">1</span>)).</div></pre></td></tr></table></figure>
<p>它的结果是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io:format(<span class="string">"Call ~s: ~w~n"</span>,\[<span class="string">"myfunction ( 1 , 2 )"</span>,myfunction(<span class="number">1</span>,<span class="number">2</span>)\]),</div><div class="line">io:format(<span class="string">"Call ~s: ~w~n"</span>,\[<span class="string">"you : function ( 2 , 1 )"</span>,you:function(<span class="number">2</span>,<span class="number">1</span>)\]).</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang里的文件包含]]></title>
      <url>http://szpzs.oschina.io/2018/03/26/erlang-file-inclusion/</url>
      <content type="html"><![CDATA[<p>Erlang中包含文件的语法有两个：</p>
<ul>
<li>-include(File).</li>
<li>-include_lib(File).</li>
</ul>
<p>它们其实是预编译指令。其中File是一个字符串，表示被包含文件的文件名相对路径或绝对路径。</p>
<p>在Erlang中，一般需要被公用的记录和宏定义都放在被包含文件里，文件名后缀名为.hrl。</p>
<p>File可以使用操作系统的环境变量作为路径开头部分。比如：<br>-include(“\$PROJ_ROOT/my_records.hrl”).<br>Erlang将使用os:getenv(PROJ_ROOT)来获得操作系统的环境变量PROJ_ROOT的值，并替换”\$PROJ_ROOT/my_records.hrl”中的\$PROJ_ROOT。</p>
<p>如果File是绝对路径，则Erlang就按绝对路径来查找文件。如果File不是绝对路径，则Erlang按如下顺序来查找文件：</p>
<ul>
<li>当前工作目录</li>
<li>编译后的模块所在目录</li>
<li>通过include选项给出的目录</li>
</ul>
<p>include_lib不指定绝对路径。路径的第一部分被Erlang虚拟机认为是一个应用的名字。例如：</p>
<p>-include_lib(“kernel/include/file.hrl”).</p>
<p>Erlang使用code:lib_dir(kernel)来获得kernel应用的绝对路径，然后替换”kernel/include/file.hrl”里的kernel，最后得到绝对路径。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang的调度器如何绑定到CPU]]></title>
      <url>http://szpzs.oschina.io/2018/03/23/erlang-scheduler-binding-cpu/</url>
      <content type="html"><![CDATA[<h2 id="调度器绑定CPU"><a href="#调度器绑定CPU" class="headerlink" title="调度器绑定CPU"></a>调度器绑定CPU</h2><p>在启动Erlang虚拟机的时候可以通过参数来设置它的调度器以什么方式绑定CPU。这个参数是 +sbt，也可以用另一个参数 +stbt。它们的使用方法是：</p>
<p>+sbt 绑定类型</p>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl +sbt db</div></pre></td></tr></table></figure>
<p>这两个参数的差异表现在对如下错误的处理方式上：</p>
<ul>
<li>某些不支持绑定CPU功能的平台上尝试绑定调度器到CPU</li>
<li>没有可用的CPU拓扑。运行时系统无法自动侦测到CPU拓扑，并且我们也没有设置自定义的CPU拓扑。</li>
</ul>
<p>当发生上述两种情况的时候，如果使用的是 +sbt 参数，则运行时系统会打印错误消息并拒绝启动；而如果使用的是 +stbt 参数，则运行时系统会忽略错误，并且用调度器不绑定CPU的方式启动。</p>
<a id="more"></a>
<p>当前有效的绑定类型如下：<br>u、ns、ts、ps、s、nnts、nnps、tnnps、db。</p>
<p>下面对上述有效类型进行说明。我的机器CPU信息如下：</p>
<p>有两个NUMA节点，每个节点有一个物理处理器，两个物理处理器为：p1和p2，每个物理处理器有4个核，每个核有两个线程。p1上的线程标识符为：第一个核{0,8}，第二个核{1,9}，第三个核{2,10}，第四个核{3,11}；p2上的线程标识符为：第一个核{4,12}，第二个核{5,13}，第三个核{6,14}，第四个核{7,15}。</p>
<p>u：是 unbound 的首字母。调度器不绑定在某个CPU线程上，而是由操作系统决定调度器在那个CPU线程上执行以及什么时候迁移到别的cpu线程上。这是Erlang虚拟机的默认行为。</p>
<p>ns：代表 no_spread。标识符相近的调度器尽可能地绑定在相近的CPU线程上。调度器绑定到cpu线程的顺序是：{0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15}。</p>
<p>ts：代表 thread_spread。低标识符的调度器先绑定所有CPU核的第一个线程，然后再绑定所有CPU核的第二个线程，以此类推。调度器绑定到cpu线程的顺序是：{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}。</p>
<p>ps：代表 processor_spread。和ts方式一样，只是会跨物理处理器核间隔地绑定。调度器绑定到cpu线程的顺序是：{0,4,1,5,2,6,3,7,8,12,9,13,10,14,11,15}。</p>
<p>s：代表 spread。调度器尽可能地绑定到cpu线程上。与ns方式相似。调度器绑定到cpu线程的顺序是：{0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15}。</p>
<p>nnts：代表 no_node_thread_spread。与thread_spread方式相似。但是，如果有多个NUMA节点存在，则调度器会先把一个NUMA节点内的cpu线程全部绑定完，然后再去绑定下一个NUMA节点内的cpu线程。调度器绑定到cpu线程的顺序是：{0,1,2,3,8,9,10,11,4,5,6,7,12,13,14,15}。</p>
<p>nnps：代表 no_node_processor_spread。与processor_spread方式相似。但是，如果有多个NUMA节点存在，则调度器会先把一个NUMA节点内的cpu线程全部绑定完，然后再去绑定下一个NUMA节点内的cpu线程。调度器绑定到cpu线程的顺序是：{0,1,2,3,8,9,10,11,4,5,6,7,12,13,14,15}。</p>
<p>tnnps：代表 thread_no_node_processor_spread。是thread_spread和no_node_processor_spread方式的组合。调度器将在NUMA节点间顺序绑定cpu线程，但是会先在一个NUMA节点内的cpu核的同类线程都绑定完了再到下一个NUMA节点。调度器绑定到cpu线程的顺序是：{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}。</p>
<p>db：代表 default_bind。是调度器绑定cpu的默认方式。目前就是thread_no_node_processor_spread方式。将来可能会改变为别的方式。调度器绑定到cpu线程的顺序是：{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}。</p>
<h2 id="自定义CPU拓扑"><a href="#自定义CPU拓扑" class="headerlink" title="自定义CPU拓扑"></a>自定义CPU拓扑</h2><p>自定义CPU拓扑会覆盖任何自动监测到的CPU拓扑。将调度器绑定到逻辑处理器时会使用自定义的CPU拓扑。</p>
<p>自定义CPU拓扑的格式定义：</p>
<ul>
<li>&lt;Id&gt; = integer(); when 0 =&lt; &lt;Id&gt; =&lt; 65535</li>
<li>&lt;IdRange&gt; = &lt;Id&gt;-&lt;Id&gt;</li>
<li>&lt;IdOrIdRange&gt; = &lt;Id&gt; | &lt;IdRange&gt;</li>
<li>&lt;IdList&gt; = &lt;IdOrIdRange&gt;,&lt;IdOrIdRange&gt; | &lt;IdOrIdRange&gt;</li>
<li>&lt;LogicalIds&gt; = L&lt;IdList&gt;</li>
<li>&lt;ThreadIds&gt; = T&lt;IdList&gt; | t&lt;IdList&gt;</li>
<li>&lt;CoreIds&gt; = C&lt;IdList&gt; | c&lt;IdList&gt;</li>
<li>&lt;ProcessorIds&gt; = P&lt;IdList&gt; | p&lt;IdList&gt;</li>
<li>&lt;NodeIds&gt; = N&lt;IdList&gt; | n&lt;IdList&gt;</li>
<li>&lt;IdDefs&gt; = &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt; | &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;<ul>
<li>&lt;LogicalIds&gt;必须是一个标识符列表。</li>
<li>除&lt;LogicalIds&gt;之外至少还有一个其他的标识符类型也必须有一个标识符列表。</li>
<li>所有标识符列表必须产生相同数量的标识符。</li>
</ul>
</li>
<li>CpuTopology = &lt;IdDefs&gt;:&lt;IdDefs&gt; | &lt;IdDefs&gt;</li>
<li>&lt;IdRange&gt;可以递增也可以递减</li>
</ul>
<p>大写字母表示真实标识符，小写字母表示仅用于描述拓扑的伪标识符。作为实际标识符传递的标识符可能被运行时系统用于访问特定硬件，如果它们不正确，行为是未定义的。由于在没有真实的逻辑CPU标识符的情况下定义CPU拓扑没有意义，所以不接受假的逻辑CPU标识符。线程，核心，处理器和节点标识符可以省略。如果省略，线程ID默认为t0，核心ID默认为c0，处理器ID默认为p0，节点ID将为未定义。每个逻辑处理器必须属于一个且只有一个NUMA节点，或者没有逻辑处理器必须属于任何NUMA节点。NUMA节点标识符是系统范围的。 也就是说，系统上的每个NUMA节点都必须具有唯一的标识符。处理器标识符也是系统范围的。 核心标识符是处理器范围的。 线程标识符是核心范围。标识符类型的顺序意味着CPU拓扑的层次结构。</p>
<p>标识符类型的顺序：</p>
<ul>
<li>&lt;LogicalId&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt;</li>
<li>&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</li>
</ul>
<p>只要每个逻辑处理器属于一个且只有一个NUMA节点，则CPU拓扑可由NUMA节点外部处理器和NUMA节点内部处理器一起组成。</p>
<h2 id="linux-的CPU信息查询和NUMA工具"><a href="#linux-的CPU信息查询和NUMA工具" class="headerlink" title="linux 的CPU信息查询和NUMA工具"></a>linux 的CPU信息查询和NUMA工具</h2><ul>
<li>lscpu<ul>
<li>显示CPU架构信息</li>
</ul>
</li>
<li>mpstat -P ALL<ul>
<li>显示各个CPU负载情况</li>
</ul>
</li>
<li>numactl –hardware<ul>
<li>显示各个NUMA节点的内存以及distance情况</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[勉励自己]]></title>
      <url>http://szpzs.oschina.io/2017/12/31/2018-encourage-myself/</url>
      <content type="html"><![CDATA[<p><img src="/images/encourage-myself.jpg" style="border:0;"></p>
<h1 align="center">世界上任何书籍都不能带给你好运，</h1><br><h1 align="center">但是它们能让你悄悄成为你自己。</h1><br><h1 align="center">我继续和时间做朋友。</h1>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简说MQTT--第三部分：会话、服务质量和保留消息]]></title>
      <url>http://szpzs.oschina.io/2017/12/22/mqtt-in-a-nutshell-3/</url>
      <content type="html"><![CDATA[<p>有时候，我们希望MQTT代理会在客户端断开连接时存储客户端的订阅和队列消息，并在客户端稍后重新联机的时候将这些消息传递给它。在MQTT的世界中，存在保留消息，QoS级别和清除会话等技术，这些都对客户端存储消息有所影响。 我们将在这篇短文中讨论它们。</p>
<a id="more"></a>
<h1 id="清除会话"><a href="#清除会话" class="headerlink" title="清除会话"></a>清除会话</h1><p>您可以选择通过指定CONNECT数据包中的“clean_session”标志来告诉代理是否应该在连接时为您存储会话信息。</p>
<p>如果一条客户端链接仅仅是发布消息，它不会关心代理是否记得它。但是，如果客户端连接到代理是为了订阅消息，则通过将CONNECT数据包中的“clean_session”位设置为0来使连接“持久化”，这样是便利的或必要的。如果这么设置的话，这个客户端的订阅信息和未传送给它的消息将被代理存储下来。</p>
<p>要将clean_session设置为false，必须使用客户端ID。</p>
<p>当处于连接状态的时候，想修改“clean_session”设置是不可能的。要想修改它，你需要用新的设置来重连代理。</p>
<h1 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h1><p>不是所有“持久化”的连接上的消息都将被存储。QoS级别也会对其产生影响。</p>
<p>MQTT协议只保证具有QoS 1或QoS 2级别的消息确实传送给订阅者。对于那些QoS 0级别的消息，MQTT尝试发送它们一次，但是不保证一定送达。遵循这个原则，当用户断开连接时，即使这个连接是“持久化”的，也只有QoS 1和QoS 2级别的消息被存储。</p>
<p>值得注意的是，MQTT并不使用端到端的QoS，这意味着这些消息只有在用QoS != 0 发布并且用QoS != 0 订阅的情况下才被存储。</p>
<h1 id="保留消息"><a href="#保留消息" class="headerlink" title="保留消息"></a>保留消息</h1><p>如果您发布的MQTT消息的’retain’位设置为1，则它可以被保留在代理上，当订阅者连接到代理后，保留的消息会传递给它。</p>
<p>这是一个有用的特性，只有“保留”这个词有时令人困惑。它不保留相同主题的所有消息。 对于每个主题，只保留上次发布的消息，而较早的消息则由其后续消息替换掉。此外，’retain’标志设置为0的消息不会替换相同主题的保留消息，只有保留的消息替换保留的消息。</p>
<p>一个使用保留消息的场景：</p>
<p>一个传感器测量一个房间的温度并且每个小时将数据更新到系统中。如果温度数据用保留消息的方式发布到系统中，则无论什么时候，客户端连接到代理的时候只收到一份有用的数据，它不需要等待它不需要等待一段很长时间来等待新的数据发布，并且它也不会遭受大量无用而且过期数据的冲击。</p>
<blockquote>
<p>注意：保留的消息不属于任何会话。不管“clean_session”标志如何设置，保留消息都被保留。此外，它在会话结束时也被保留。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-2040b244aa4b" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-2040b244aa4b</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于变量绑定的棘手问题]]></title>
      <url>http://szpzs.oschina.io/2017/11/22/tricky-question/</url>
      <content type="html"><![CDATA[<p>在我的工作中，我有个任务是为Erlang程序员应聘者设计一套选择题考卷，我决定包含一个关于变量绑定的棘手问题。在加入这个问题之前，我决定自己先尝试一下（你懂的……我这是为了预防万一）并且我发现了一些可能让你第一眼看到觉得很惊讶的事情，尽管这在事后是很明显的。</p>
<a id="more"></a>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>不用说，这个问题最后没有列入考试，所以不要指望从这篇文章中得到一个简单的答案。这个问题是：</p>
<blockquote>
<p>假设一开始没有任何变量被绑定，那么下面的表达式计算结束后，哪些变量被绑定了？</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A = <span class="number">1</span>,</div><div class="line">B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">      C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">      D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">    <span class="keyword">end</span>,</div><div class="line">A + B.</div></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<ol>
<li>没有</li>
<li>A 和 B</li>
<li>A、B、C 和 D</li>
<li>不可能确切地知道</li>
</ol>
</blockquote>
<p>请不要先往下阅读，而是停在这里！你自己先思考答案是什么？而且不能启动一个Erlang shell来测试这条表达式。切接不要偷看下面的内容！</p>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>让我们先剔除那些显而易见的选项。</p>
<p>答案不可能是选项1，因为我们在表达式里明确地绑定了一个变量。选项1唯一能被选上的条件是表达式发生错误。毫无疑问，这不可能发生。</p>
<p>选项3也不正确，因为代码执行路径有两个分支，其中一个不会绑定C变量，另一个不会绑定D变量。</p>
<p>在我看来，答案是选项2。我认为，C 和 D只是case表达式里的临时变量。</p>
<p>但是，情况并非如此。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; A = <span class="number">1</span>,</div><div class="line"><span class="number">1</span>&gt; B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line"><span class="number">1</span>&gt;       C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line"><span class="number">1</span>&gt;       D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line"><span class="number">1</span>&gt;     <span class="keyword">end</span>,</div><div class="line"><span class="number">1</span>&gt; A + B.</div><div class="line"><span class="number">1.063499807059608</span></div><div class="line"><span class="number">2</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.063499807059608</span></div><div class="line">C = <span class="number">0.063499807059608</span></div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; f().</div><div class="line">ok</div><div class="line"><span class="number">4</span>&gt; e(<span class="number">1</span>).</div><div class="line"><span class="number">1.3765011035828076</span></div><div class="line"><span class="number">5</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.37650110358280764</span></div><div class="line">C = <span class="number">0.37650110358280764</span></div><div class="line">ok</div><div class="line"><span class="number">6</span>&gt; f().</div><div class="line">ok</div><div class="line"><span class="number">7</span>&gt; e(<span class="number">1</span>).</div><div class="line"><span class="number">1.0869922372383418</span></div><div class="line"><span class="number">8</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.08699223723834182</span></div><div class="line">D = <span class="number">0.9130077627616582</span></div><div class="line">ok</div><div class="line"><span class="number">9</span>&gt;</div></pre></td></tr></table></figure>
<p>如你所见，有时候C被绑定，有时候却是D被绑定，这依赖于case语句所执行的分支，即使被执行的case语句分支的表达式不需要这些变量，也会发生这样的情况：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>&gt; <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line"><span class="number">10</span>&gt;   C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; low;</div><div class="line"><span class="number">10</span>&gt;   D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; high</div><div class="line"><span class="number">10</span>&gt; <span class="keyword">end</span>.</div><div class="line">low</div><div class="line"><span class="number">11</span>&gt; b().</div><div class="line">C = <span class="number">0.3006547812129776</span></div><div class="line">ok</div><div class="line"><span class="number">12</span>&gt; f(), e(<span class="number">10</span>), b().</div><div class="line">C = <span class="number">0.12584026085863464</span></div><div class="line">ok</div><div class="line"><span class="number">13</span>&gt; f(), e(<span class="number">10</span>), b().</div><div class="line">D = <span class="number">0.9295007071083405</span></div><div class="line">ok</div><div class="line"><span class="number">14</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="到底是为什么呢？"><a href="#到底是为什么呢？" class="headerlink" title="到底是为什么呢？"></a>到底是为什么呢？</h1><p>正如我之前说过的，这个问题可能令人惊讶，但事实上，它是非常明显的，而且有据可查。case语句分支的头部匹配变量是完全有效的，它可以像下面这样使用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">      C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; low;</div><div class="line">      C <span class="keyword">when</span> C &gt;= <span class="number">0.5</span> -&gt; high</div><div class="line">    <span class="keyword">end</span>,</div><div class="line">&#123;B, C&#125;.</div></pre></td></tr></table></figure>
<p>这是一种非常复杂的编码方式，我根本不推荐这样做，你甚至可以把它弄得更糟糕：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">  C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; B = low;</div><div class="line">  C <span class="keyword">when</span> C &gt;= <span class="number">0.5</span> -&gt; B = high</div><div class="line"><span class="keyword">end</span>,</div><div class="line">&#123;B, C&#125;.</div></pre></td></tr></table></figure>
<p>但是，除了代码的样式和可维护性问题之外，这段代码是完全有效的，这意味着在case表达式的被计算之后，在case子句中（包括在头部和身体中）被绑定的变量都是绑定的。我知道有更学术的方式来表达这个问题，比如用像闭包或作用域等词汇，但是我将把这个解释权留给像iraunkortasuna这样的大牛们，他们比我能干的多。</p>
<p>考虑到这一点，在我们最初的例子中，无论是C还是D（但不是两者）都是在对整个表达式的计算之后绑定的，这是合理的。但是，你想知道，这样的代码是非常不安全的……难道Erlang不应该警告我吗？Erlang不应该阻止我写出这样一个非确定性的东西吗？</p>
<p>当然，Erlang会帮我们的！不过不是Erlang的shell，而是Erlang的编译器，它会对这类代码进行告警，而且它非常聪明。如下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(x)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>])</span>.</div><div class="line"><span class="function"><span class="title">bad</span><span class="params">(A)</span> -&gt;</span></div><div class="line">  B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">        C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">        D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">      <span class="keyword">end</span>,</div><div class="line">  A + B.</div></pre></td></tr></table></figure>
<p>这是我们的原始代码，在这种情况下，即使C或D在case语句之后是未绑定的，因为它们没有被使用，编译器什么也不说。</p>
<p>现在我们看看另一个版本的代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(x)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>])</span>.</div><div class="line"><span class="function"><span class="title">bad</span><span class="params">(A)</span> -&gt;</span></div><div class="line">  B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">        C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">        D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">      <span class="keyword">end</span>,</div><div class="line">  A + B - C.</div></pre></td></tr></table></figure>
<p>在这个例子里，编译器将不会编译这个模块，相反，它会报告如下错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x.erl:<span class="number">8</span>: variable 'C' unsafe in '<span class="keyword">case</span>' (line <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>我们可以对上述错误消息的可用性和可读性进行深入的讨论，但是这个模块不能编译的事实毫无疑问对Erlang开发者是有帮助的。</p>
<p><strong>小贴士：</strong>如果在编译Erlang模块时看到类似这样的错误，请注意警告：8（其中使用了不安全变量）和4（变量可能绑定的地方）中的两个行号。</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/erlang-battleground/tricky-question-25a956298b9d" target="_blank" rel="external">https://medium.com/erlang-battleground/tricky-question-25a956298b9d</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简说MQTT--第二部分：MQTT是如何运作的？]]></title>
      <url>http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-2/</url>
      <content type="html"><![CDATA[<p>与传统的客户端/服务器协议不同，MQTT不是端到端的。MQTT是一种发布订阅消息交换协议。另外，与消息队列不同，MQTT不维护任何队列。它使用主题来路由消息。</p>
<p>这次我们将向你展示MQTT是如何运作的。</p>
<a id="more"></a>
<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><p>MQTT是一种发布订阅消息交换协议，它的含义是：</p>
<ol>
<li>通信系统中有发布者和订阅者。发布者发布消息而订阅者接收消息。我们把发布者和订阅者统称为客户端。客户端可以同时是发布者和订阅者。</li>
<li>在系统中有另外一个角色，它接收发布者的消息并且将消息派发给订阅者。我们一般称这个角色为消息Broker。</li>
</ol>
<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>在MQTT中，另一个重要的概念是主题，每一条消息都有一个主题，它决定了消息将被谁接收。主题是MQTT的路由机制。</p>
<p>举个例子，如果一个天气预报服务正在更新各个城市的温度数据。这个服务并不知道谁将接收哪个城市的温度数据，它只是用主题来标识这些数据，比如，“temperature/newyork” 或 “temperature/frankfurt”，并且将它们发送给Broker。那些对城市天气有兴趣的人可以在Broker上订阅一个或多个这样的主题。一旦一条消息到达Broker，它就会检查消息里的主题，并且将消息派发给相应的订阅者。</p>
<p>主题由一个或多个层级组成，层级之间被斜杠（/）分隔。有时主题和分类和目录相似。</p>
<p>主题中的通配符(“#” 和 “+”)使得订阅者更易于一次订阅多个主题。“+”表示一个单独的层级，而“#”表示多个层级。多数情况下，你可以按你的意愿自由地命名主题，但是有一个列外：以“$”开头的主题是保留给系统使用的。</p>
<p>MQTT天然支持一对多（广播）的消息传递：一个发布者用一个主题发布一条消息到Broker，Broker派发这条消息给所有订阅这个主题的客户端。</p>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>一条消息就是我们想要在通信系统中与其他方交换的信息。交换消息是MQTT的目的。MQTT用控制数据包来传输消息和维护链接。</p>
<p>一个MQTT数据包包括一个固定的头部，一个可选的可变头部以及一个可选的有效负载数据部分：</p>
<ul>
<li>固定头部出现在所有MQTT控制包中。它包括包的类型、各种标志以及包的剩余长度。</li>
<li>可变头部出现在一些MQTT控制包中。它的内容根据包的类型不同而不同。</li>
<li>有效负载数据出现在一些MQTT控制包中。它是包的最后一部分。业务相关的数据都在这部分中。</li>
</ul>
<p>如你所猜测的一样，最小的MQTT包只有2字节。</p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>现在我们已经有了通信中的各种角色、路由消息的方式以及约定的消息格式，我们可以用这些基本元素来构建一个通信系统。</p>
<p>如下图所示，想象一下，我们在一所医院里：</p>
<p><img alt="MQTT communication, an example" src="/images/mqtt-communication.png" style="border: 0;"></p>
<p>住院病人的重要统计数据由可穿戴设备收集并发送到中心服务器，然后发送给相关人员（或设备）。</p>
<p>一个传感器，这里我们以温度计为例，测量患者的体温并将这个温度数据设置主题：“传感器/ 1 /温度话题”后发布到MQTT Broker。很明显，这个传感器的角色就是发布者。关心这个病人的任何数据的人（比如他的医生）可以订阅“sensor/1/#”这个主题；任何需要收集所有病人体温数据的人或设备可以订阅主题： “sensor/+/temperature”；只关心这个病人的体温的人可以精确地订阅主题：“sensor/1/temperature”，而不需要任何通配符。</p>
<h1 id="MQTT的特殊特点"><a href="#MQTT的特殊特点" class="headerlink" title="MQTT的特殊特点"></a>MQTT的特殊特点</h1><h2 id="QOS"><a href="#QOS" class="headerlink" title="QOS"></a>QOS</h2><p>MQTT实现了简单但是有效的3级服务质量系统：</p>
<ul>
<li>0：最多一次</li>
<li>1：最少一次</li>
<li>2：仅有一次</li>
</ul>
<h2 id="保留的消息"><a href="#保留的消息" class="headerlink" title="保留的消息"></a>保留的消息</h2><p>如果MQTT消息的保留标志被设置了，则消息可以被Broker保留。当一个客户端链接到Broker并订阅了一个主题，而Broker有这个主题的一条保留的消息，客户端将立刻收到这条消息。每一个主题最多只有一条保留的消息。</p>
<h2 id="遗愿消息"><a href="#遗愿消息" class="headerlink" title="遗愿消息"></a>遗愿消息</h2><p>MQTT经常被用于不可靠的网络环境。客户端可能没有正常关闭链接（DISCONNECT消息没有发送出去）的情况下丢失链接。在这种情况下，遗愿消息可以做客户端应该做的事情。</p>
<p>每个客户端当它链接到Broker的时候可以设置一条遗愿消息。遗愿消息和其他消息一样，它也有服务质量级别、保留属性以及主题。这条消息被存储在Broker上，当Broker检测到客户端丢失了链接，Broker把这条遗愿消息发送给所有订阅了遗愿消息的主题的所有在线客户端。如果客户端发送一个“DISCONNECT”包给Broker后断开链接，那么它的遗愿消息被丢弃。</p>
<h1 id="MQTT数据包"><a href="#MQTT数据包" class="headerlink" title="MQTT数据包"></a>MQTT数据包</h1><p>MQTT定义了14种消息类型。它们被用于创建链接、断开链接、发布消息、订阅主题、维护链接或保证服务质量。</p>
<p>消息类型如下表所示：</p>
<p><img alt="MQTT communication, an example" src="/images/mqtt-packet-type.png" style="border: 0;"></p>
<p>在本系列的下一篇文章中，我们将演示如何创建一个简单的MQTT应用并解释有关协议和数据包格式。</p>
<p>待续……</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-4e8dd6ef57c0" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-4e8dd6ef57c0</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简说MQTT--第一部分：MQTT是啥？]]></title>
      <url>http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-1/</url>
      <content type="html"><![CDATA[<p>MQTT是什么？这个问题的最贴切的答案是我在网站mqtt.org看到的：</p>
<blockquote>
<p>“MQTT是机器对机器(M2M)/物联网的链接协议。”</p>
</blockquote>
<p>它解释得十分清楚，MQTT是M2M和物联网（IoT）连接协议。要理解MQTT，我们需要首先去了解M2M或物联网。</p>
<a id="more"></a>
<h1 id="M2M和物联网"><a href="#M2M和物联网" class="headerlink" title="M2M和物联网"></a>M2M和物联网</h1><p>许多人已经在用物联网了，他们中有些人只是没有意识到。最近我去拜访我的一位朋友。他对他的新智能烤箱很兴奋，迫不及待地想告诉我他的烤箱是多么聪明：食谱下载到智能手机，然后通过WiFi发送到烤箱；可以通过智能手机的应用程序远程调控烘烤；当食物烤好了，烤箱就发出通知给智能手机。嗯，他已经进入物联网时代了。</p>
<p>物联网的基本概念并不新，它是设备之间的联网，让设备自己收集和交换数据。有时这种数据交换甚至在没有人工干预（机器对机器的连接）的情况下发生。各种设备通过网络彼此集成。现在，这种集成的规模可以是巨大的，它能够提高效率、精度和经济效益，减少人为干预。</p>
<p>在物联网的世界里，几乎所有的东西（包括人）都可以连接起来。事物互联有可能带来新的好处，我们要做的是利用我们的好奇心和想象力来释放这种潜力。高德纳说，到2020，将有超过260亿个连接设备。计算机，手机，平板电脑，台灯，咖啡机，汽车，光传感器，运动探测器，生物芯片，飞机和任何你能想象的东西。有人建议把“物”当做“硬件、软件、数据和服务不可分割的混合物”。</p>
<h1 id="为什么是MQTT"><a href="#为什么是MQTT" class="headerlink" title="为什么是MQTT"></a>为什么是MQTT</h1><p>物联网的一个关键要素是，“事物”具有连接的能力。他们需要一种大家都能理解的通用语言，一种连接协议。多年来，世界上已经有很多连接协议，像HTTP这样的协议被数以百万计的应用程序所使用。为什么不是只有一个广泛使用的协议？为什么MQTT是物联网的协议？</p>
<p>“什么事物都可以连接，也将被连接”。想想这样的场景：早上5点半，你的智能手机告诉客厅的暖气调节器调节室内温度，以适应日常活动。5点50，你的智能手机告诉咖啡机开始煮咖啡。当你在6点被你的智能手机叫醒，万事都准备妥当，甚至你喜欢的美剧已经被下载到你的平板电脑里了。当你享受宁静的早晨时，你可能会注意到一件事：所有连接的设备都是如此不同，而它们却一起工作得很好。</p>
<p>我们刚刚讨论的这个物联网场景，我们叫它做智能家居。我们来构建一个智慧城市或者甚至构建一个智慧世界如何？在这个世界里，一个超级计算机可以和一个芯片上的系统交换数据。例如，医疗中心监控病人植入的芯片，并向病人的医生发出警报。当任何设备被允许接入并且设备在地理上广泛分布时，应该使用什么样的通信协议呢？</p>
<p>它必须是一个轻量级的协议，占用的代码量很小，对于这个协议来说，非常有限的网络带宽就足够了。MQTT就是这种协议。</p>
<blockquote>
<p>“MQTT是一个客户端服务器的发布/订阅消息传输协议。它轻量、开放、简单，且设计为易于实现。这些特性使得它非常适合在许多情况下使用，包括受限的环境，例如用于机器对机器的通信（M2M）和物联网环境，在其中只需要占用少量的代码和/或网络带宽。”<br> – – 引用自MQTT规范</p>
</blockquote>
<h1 id="关于MQTT的历史"><a href="#关于MQTT的历史" class="headerlink" title="关于MQTT的历史"></a>关于MQTT的历史</h1><p>MQTT是MQ Telemetry Transport的缩写。它首先是Andy Stanford-Clark 和 Arlen Nipper在1999年发明的。他们当时在做一个管道的监控和数据采集系统（Telemetry这个词就来自这里），需要实时在卫星链路和拨号线路上传输数据，以连接远程管道。基于这些有限的资源，他们开始考虑做一个新的<strong>发布和订阅协议</strong>，就是MQTT协议。</p>
<blockquote>
<p>MQTT按下面5个目标来设计的：<br>它必须能简单地被实现；<br>它必须有数据传输的服务质量；<br>它必须轻量和带宽高效；<br>它必须可传输任意数据；<br>以及它必须可保持会话。</p>
</blockquote>
<p>今天，这五个目标依然被支持，它们本质上和物联网的需求是相等的。</p>
<p>IBM在2010年正式免费发布MQTT3.1，OASIS在2014年标准化了这个协议。写本文的时候，MQTT的版本是3.1.1。MQTT下一个版本是5.0，一个MQTT5.0的工作草稿正在被公示。</p>
<h1 id="MQTT-v-s-XMPP"><a href="#MQTT-v-s-XMPP" class="headerlink" title="MQTT v.s. XMPP"></a>MQTT v.s. XMPP</h1><p>将MQTT和其他协议进行比较可以使得我们更易于理解为什么MQTT适合物联网，在此我们将它和XMPP进行比较，XMPP是上世纪90年代后期诞生的消息协议。</p>
<ol>
<li>XMPP发明于1999年。它是eXtensible Messaging and Presence Protocol的缩写。</li>
<li>MQTT使用固定大小，即一个字节的头部，以及两个字节的KeepAlive包。它的包小，而且易于编解码。而XMPP用XML封装，它的包大并且交互复杂。</li>
<li>MQTT使用主题来路由消息，它比基于JID的点对点路由的XMPP更灵活。</li>
<li>MQTT不定义有效载荷数据的格式，因此它很容易携带不同的更高层协议的数据。而XMPP用XML来格式化有效载荷数据，它必须用Base64格式封装二进制数据。</li>
<li>MQTT支持消息确认和QoS机制，这些XMPP都没有，因此MQTT更加可靠。</li>
</ol>
<p>待续……</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-cc24370920c2" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-cc24370920c2</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang的乐趣犹如驾驭魅影]]></title>
      <url>http://szpzs.oschina.io/2017/08/01/joy-of-erlang/</url>
      <content type="html"><![CDATA[<p>在电影&lt;&lt;阿凡达&gt;&gt;里，有一条超级大的翼龙，它叫做魅影，男主角为了赢得蓝色族人的信任必须学会骑魅影。一般来说，魅影不喜欢被骑，但如果你和它打一架，而且把它制服，然后把你的蓝马尾辫连接到魅影的尾巴上，你就能拥有它的生命。这就像拥有一辆你能控制的飞车，在与强敌作战时，你可以很方便地用你的思想控制它，给未来的同事留下深刻印象。但是学会骑魅影是很危险的，很少有人能成功。</p>
<p>我喜欢把Erlang编程语言看作是一条魅影。大多数人都害怕Erlang。关于其能力的传说比比皆是。为了掌握它，你必须与它战斗，征服它，并(最后)把你的思想与它联系起来。但假设你能活下来，你就可以控制世界上最先进的服务器平台，让它做事情的时候通常无需再思考。现在让我来告诉你：驾驭魅影是很有趣的。</p>
<p>本指南旨在教会你Erlang的思想，这样你就不会害怕而离开，而是可以战胜你自己的魅影。我将只介绍一些Erlang语言特性，但是我们将使用它们来解决大量实际问题。它的目的是让你想要并且有信心去学习并掌握Erlang语言其他知识。</p>
<p>欢迎您将这些示例输入到自己的Erlang shell中，并执行它们，不过这些示例的设计是为了便于阅读而设计的。我建议你把这份文件打印出来，在舒适的椅子上仔细地阅读，并且远离电子邮件、编译器、3D电影以及其他干扰。</p>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><a href="#part-one">定义函数： 一个简单布尔逻辑库</a></li>
<li><a href="#part-two">递归地调用函数：一个简单算术运算库</a></li>
<li><a href="#part-three">整数列表：基本字符串处理</a></li>
<li><a href="#part-four">Erlang算法的乐趣</a></li>
<li><a href="#part-five">下一步</a></li>
<li><a href="#part-six">源代码</a></li>
</ol>
<h1 id="定义函数：-一个简单布尔逻辑库"><a href="#定义函数：-一个简单布尔逻辑库" class="headerlink" title="定义函数： 一个简单布尔逻辑库"></a><span id="part-one">定义函数： 一个简单布尔逻辑库</span></h1><p>在Erlang里，函数由一个或多个分支语句组成。最后一个分支语句必须用  .  号结束；而其他分支语句必须用  ;  号结束。当函数被调用的时候，第一个和入参匹配的分支语句被执行。你可能会思考，如果C语言的switch语句暴露在有毒污泥中并成为超级英雄，那么函数将会怎样。</p>
<p>最简单的例子，一个函数只有一个语句。如下所示，函数 noop 简单地返回它的参数，即变量A（变量总是大写开头的）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">noop</span><span class="params">(A)</span> -&gt;</span> A.</div></pre></td></tr></table></figure>
<p>注意，Erlang没有 return 语句。函数总是返回最后一个表达式的结果。因为每一个表达式都有一个结果，而且每一个函数分支语句至少有一个表达式，所以每一个函数总是有一个返回值。</p>
<p>现在假设我们希望实现一个布尔函数 not，它把true或false作为它的参数。not 函数需要两个子句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">not</span><span class="params">(true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">not</span><span class="params">(false)</span> -&gt;</span> <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<p>每次 not 函数被执行，Erlang首先测试入参是否是true（如果是，执行第一个子句），然后再测试入参是否是false（如果是，则执行第二个子句）。用入参和函数定义进行匹配被称为模式匹配。模式匹配使得在不使用内部控制结构的情况下很容易编写复杂的函数。</p>
<p>我们可以使用模式匹配来判断同一变量是否在参数列表中出现不止一次。比如，如下函数实现相等操作符：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, B)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>如果两个入参相同，则函数返回true；否则，函数返回false。</p>
<p>小心！在这个函数里子句的顺序很重要。如果像下面这样写，则是错误的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, B)</span> -&gt;</span> <span class="literal">false</span>; <span class="comment">% 错</span></div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<p>为什么会错呢？Erlang首先尝试匹配第一个子句。但是如果两个入参相同，第一个子句依然匹配，A和B被简单地绑定为相等的值。第二个子句永远不会被执行到。在形参列表里用不同名字到变量并不是说一定要给它们绑定不相等的值。</p>
<p>我们现在已经准备好实现更多的布尔逻辑。如下是 and 的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 与: 如果两个入参是true则是true, 否则是false</span></div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(false, true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, false)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>你可能认为所有这些真值表子句太啰嗦。它们的确是很啰嗦。我们可以用一个特别的匿名变量来将后面三个子句缩减到一个子句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 与: 如果两个入参是true则是true, 否则是false</span></div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>匿名变量(_)总是匹配任何数据。它没有被赋值，所以正如我们在上面的第二个子句中看到的，参数列表中的两个或多个下划线变量不需要匹配相同的项。匿名变量通常用来“丢弃”我们不关心的一部分模式。</p>
<p>现在我们有了常规变量和下划线变量，我们的布尔逻辑库的其余部分就容易写了。花点时间了解一下为什么下面的每一个功能都正好符合要求。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 或: 如果一个或两个参数是true则是true，否则为false。</span></div><div class="line"><span class="function"><span class="title">or</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">or</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 异或: 两个参数不同则是true，否则为false。</span></div><div class="line"><span class="function"><span class="title">xor</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">xor</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 非与: 两个参数是true则为false，否则为true。</span></div><div class="line"><span class="function"><span class="title">nand</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">nand</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 非或: 两个参数是false则为true，否则为false。</span></div><div class="line"><span class="function"><span class="title">nor</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">nor</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>如你所见，模式匹配给予Erlang函数极大的表达能力。在下一节中，我们将把模式匹配与递归相结合，建立一个新的算术运算库。在大多数语言中，递归通常是最后的手段，只用于实现复杂的算法。在Erlang，递归通常是最简单和最有效的方式来做一些平常的事情。</p>
<h1 id="递归地调用函数：一个简单算术运算库"><a href="#递归地调用函数：一个简单算术运算库" class="headerlink" title="递归地调用函数：一个简单算术运算库"></a><span id="part-two">递归地调用函数：一个简单算术运算库</span></h1><p>Erlang有一套丰富的算术运算符。不过在这一节里，我们不会使用它们。相反，我们将只使用我们目前为止学到的函数知识来构建我们自己的完整的算术运算库。</p>
<p>本节中的任务诚然是人为的，并且递归绝对不是在现实世界中解决这个问题的最简单的方法。然而，本节的练习将是好的方式来实践递归思维来为第3节做准备，在那里，递归是解决问题的最好方法。</p>
<p>回想一下递归函数至少有两部分：它们必须首先测试某种基本情况（算法终止），如果基本情况不满足，递归函数必须执行一些逻辑，然后发出对自身的调用。在Erlang，递归函数通常至少有两个子句：一个“基本情况”子句和“所有其他情况”子句。</p>
<p>事情将很快变得清晰。为解决问题，为将提供两个函数，算术运算库剩余的部分将以它们为基础来构建：incr 和 decr。假设incr增加入参，decr减少入参，如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">incr</span><span class="params">(A)</span> -&gt;</span> A + <span class="number">1</span>.</div><div class="line"><span class="function"><span class="title">decr</span><span class="params">(A)</span> -&gt;</span> A - <span class="number">1</span>.</div></pre></td></tr></table></figure>
<p>我们可以用这两个函数将任何两个正整数加到一起吗？</p>
<p>事实上我们可以！</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 两个正整数相加</span></div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A.</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span> add(incr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>有时从底层到顶部阅读递归函数是最容易的。所以先看第二个子句，它说将A和B相加与将(A+1)和(B-1)相加是相等的，这明显是正确的。因此，这个函数一直给A加一，给B减一，直到B为0。当B为0的时候，函数结束（第一个子句）。这时，add函数被递归调用了B次，也就是说A被增加了B次，因此最后的结果就是 A+B。</p>
<p>现在有点有趣，不是吗？让我们来实现减法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 从A减去B（B是正整数）</span></div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A.</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> -&gt;</span> sub(decr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>一样的思想。从第二个子句开始，我们看到(A - B)和((A - 1) - (B - 1))相等。这明显是对的。递归调用一直持续到B为0，这个时候，A被减少了B次，结果就是A - B。</p>
<p>当B是负整数的时候，这些函数都不无效。我们可以非常简单地修改add函数以适应负整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 任意两个整数相加</span></div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> add(decr(A), incr(B));</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span> add(incr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>请注意，在第二个子句中Erlang卫句的使用（when B &lt; 0）。我们可以在参数列表后用关键字 when 再加上表达式来指定条件判断。有许多种卫句，但是现在，我们只做整数的比较。</p>
<p>sub函数的修改也差不多：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 从整数A减去任意整数B。</span></div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> sub(incr(A), incr(B));</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> -&gt;</span> sub(decr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>完成了加、减函数，乘法就很容易实现了。正如我们把加法作为一系列加一一样来实现，我们将把乘法作为一系列的加法来实现，还是使用递归。我们使用这样的等式：A × B = A + A × (B - 1)。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% A乘以B（正整数）</span></div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> -&gt;</span> add(A, multiply(A, decr(B))).</div></pre></td></tr></table></figure>
<p>增加对负整数的支持也很容易，因为：A × (B + 1) - A = A × B：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 整数A乘以任意整数B</span></div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> sub(multiply(A, incr(B)), A);</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> -&gt;</span> add(A, multiply(A, decr(B))).</div></pre></td></tr></table></figure>
<p>除法呢？没问题。整数的除法，我们真正关心的是两个操作：求商和求余。这两个操作，我们都用被除数减去除数，直到我们接近0。求余操作更容易些：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求 A 除以 B 的余数</span></div><div class="line"><span class="function"><span class="title">remainder</span><span class="params">(A, B)</span> <span class="title">when</span> A &lt; B -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">remainder</span><span class="params">(A, B)</span> -&gt;</span> remainder(sub(A, B), B).</div></pre></td></tr></table></figure>
<p>至于求余函数，我们将使用Erlang里的通用模式，内部递归函数，以区别主接口。内部递归函数有一个额外参数，它跟踪我们已经减掉除数的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求A 除以 B 的余</span></div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B)</span> -&gt;</span> quotient(A, B, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="comment">% 包括累加器的内部函数</span></div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B, Answer)</span> <span class="title">when</span> A &lt; B -&gt;</span> Answer;</div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B, Answer)</span> -&gt;</span> quotient(sub(A, B), B, incr(Answer)).</div></pre></td></tr></table></figure>
<p>有了乘法和除法，我们就可以解决现实的一些问题。例如，让我们来实现一个幂函数。我们使用与前面完全相同的想法，认识求一个数的幂实际上只是一系列的乘法调用。也就是说，$$A^B = A × A^{B-1}$$</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求A的B次幂(正整数)</span></div><div class="line"><span class="function"><span class="title">pow</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">pow</span><span class="params">(A, B)</span> -&gt;</span> multiply(A, pow(A, decr(B))).</div></pre></td></tr></table></figure>
<p>在实践中，所有这些功能都是非常低效的，因为他们把所有的一切都转变为一系列递增或递减。但是这种递归的思想框架对于充分利用Erlang是绝对必要的，正如我们将要构建的字符串处理库中所看到的。</p>
<h1 id="整数列表：基本字符串处理"><a href="#整数列表：基本字符串处理" class="headerlink" title="整数列表：基本字符串处理"></a><span id="part-three">整数列表：基本字符串处理</span></h1><p>在Erlang里，字符串用整数列表来表示。这些整数是ASCII字符码或者是Unicode码点。例如，字符串”dog”就是表示为由100 (“d”), 111 (“o”), 103 (“g”)组成的列表。Erlang列表的字面量是由方括号括起来的，所以如果你愿意的话，”dog” 可以写为 [100, 111, 103]。要获得一个字符的编码，只要简单地在其前面加上美元符号\$。所以[\$d, \$o, \$g] 和 [100, 111, 103] 以及”dog”是相等的。</p>
<p>每一个列表都分为两部分：头部和尾部。头部是第一个元素，尾部则是除了头部外剩下的部分。列表是一个递归数据结构。列表的尾部是一个列表，它有自己的头部和尾部。以此类推。</p>
<p>空列表表示为[]，它没有头部，也没有尾部。</p>
<p>在Erlang里，添加一个元素到列表的头部使用 | 操作符（管道符号）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewList = [NewItem | OldList]</div></pre></td></tr></table></figure>
<p>| 也可以用在模式匹配中，从一个列表中抽取头部元素：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">some_function</span><span class="params">([FirstItem | RestOfList])</span> -&gt;</span></div><div class="line">   ... do something with FirstItem ...</div></pre></td></tr></table></figure>
<p>反转一个列表，使用函数lists:reverse()。反转一个列表可能看起来是一个不太常用的操作，但正如我们将看到的，它在Erlang实现列表算法时一直使用。</p>
<p>我们现在对字符串了解得足够多了，可以开始做一个例子。让我们写一个函数，将输入的第一字符转换为大写字符。</p>
<p>这个函数的基本思想是简单的。我们检查输入字符串的第一个字符（头部）是否是小写ASCII字符。如果是，我们把它转换成大写（通过增加大写ASCII字符和小写字母之间的差值），然后把它和尾部重写组合成一个字符串。如果不是，我们就简单地返回输入字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">capfirst</span><span class="params">([Head | Tail])</span> <span class="title">when</span> H<span class="title">ead</span> &gt;= $<span class="title">a</span>, H<span class="title">ead</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    [Head + ($A - $a) | Tail];</div><div class="line"><span class="function"><span class="title">capfirst</span><span class="params">(Other)</span> -&gt;</span></div><div class="line">    Other.</div></pre></td></tr></table></figure>
<p>在这里，我们使用了一些新的数学运算符，它们其中的含义你可能会明白。还要注意，逗号用于分隔同一子句中的多个判断条件。</p>
<p>如果你认为很好玩，那就等到你尝试将整个字符串转换为大写。在一个没有for循环的世界，一个进程如何处理字符串的每个元素？是时候重新审视我们的老朋友：递归。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 公共函数</span></div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">(String)</span> -&gt;</span></div><div class="line">   uppercase(String, []).</div><div class="line"></div><div class="line"><span class="comment">% 内部函数</span></div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>和我们在第二节写的函数 quotient 一样，这个函数有一个公共接口以及一个有额外参数的内部递归函数。额外的参数称为累加器，它的初始值为空列表。一般的策略是从输入的头部弹出一个元素，转换它，并将其加到累加器的头部。当我们处理完输入，我们要的结果将存储在累加器里，只不过它的顺序是反的。因此，我们调用 lists:reverse 并返回结果给公共接口函数。</p>
<p>让我们一句一句地检查一下内部函数子句，看看这个策略是如何实现的。</p>
<p>在基准情况下，没有更多的输入。因此，我们反转累加器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div></pre></td></tr></table></figure>
<p>如果还有输入，并且下一个字符是处于ASCII小写字母 a 和 z 之间的话，我们把它转换为大写字母，并把它加到累加器上，然后在剩下的输入上递归地调用 uppercase 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char + ($A - $a) | Output]);</div></pre></td></tr></table></figure>
<p>当下一个字符不是小写的ASCII字符的时候，最后一个子句匹配。在这种情况下，我们只需将字符从输入毫无更改地直接移动到累加器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>这个算法到此就结束了。写一个将所有字符转为小写的函数 lowercase ，这个作为一个练习由读者自己实现。</p>
<p>我们接着来实现一个有趣的函数。把每个单词的第一个字母转成大写，而不是把单词的里的所有字母转成大写。我们叫这个函数做 titlecase 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">(String)</span> -&gt;</span></div><div class="line">    titlecase(String, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], [] = Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], [$\  |_] = Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>titlecase 和 uppercase 的不同是，我们在决定处理每个字符之前用模式匹配检查一下累加器。如果累加器是空的（第二个子句），说明我们在输入的开始之处，并且要将接下来的字母大写化。如果累加器有一个空的字符在它的头部（第三个子句），说明我们在一个单词的开始之处，并且要将接下来的字母大写化。注意，空格字符的整数表示是用美元符号加上一个空格（”$\ “）。在这里我们也使用了匹配操作符（”=”），这使得在参数列表里可以很好地结合模式匹配和变量赋值。</p>
<p>如你所见，递归、累加器和模式匹配是一个强大的组合。我们可以编写无状态变量或正则表达式的上下文相关算法。更重要的是，我们可以清楚地表达问题的解决方案，并对我们的算法的正确性有信心。Erlang的乐趣在于编写代码而不必担心忘记某些东西。</p>
<h1 id="Erlang算法的乐趣"><a href="#Erlang算法的乐趣" class="headerlink" title="Erlang算法的乐趣"></a><span id="part-four">Erlang算法的乐趣</span></h1><p>现在我们可以开始好好玩耍了。既然你现在知道Erlang的基本知识，我就不会花太多时间来解释下面的算法了。它们对你来说只是让你思考和享受。</p>
<p>面试中一个经典的问题是，如何将一个字符串转换为整数（如：C语言中的atoi函数）。如下是Erlang的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([$- | String])</span> -&gt;</span> <span class="comment">% negative</span></div><div class="line">    -<span class="number">1</span> * atoi(String, <span class="number">0</span>);</div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">(String)</span> -&gt;</span> <span class="comment">% non-negative</span></div><div class="line">    atoi(String, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([], Acc)</span> -&gt;</span></div><div class="line">    Acc;</div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([C | Rest], Acc)</span> <span class="title">when</span> C &gt;= $0, C =&lt; $9 -&gt;</span></div><div class="line">    atoi(Rest, <span class="number">10</span> * Acc + (C - $<span class="number">0</span>)).</div></pre></td></tr></table></figure>
<p>注意，这里的累加器是一个整数，而不是我们前面例子里那样上一个字符串。当然，原则上，累加器可以是任何东西。</p>
<p>现在假设我们要做反向操作：将一个整数转换为字符串。代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    [$<span class="number">0</span>];</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer)</span> <span class="title">when</span> I<span class="title">nteger</span> &lt; 0 -&gt;</span> <span class="comment">% negative</span></div><div class="line">    [$-|to_string(-<span class="number">1</span> * Integer, [])];</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer)</span> -&gt;</span> <span class="comment">% positive</span></div><div class="line">    to_string(Integer, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(<span class="number">0</span>, Acc)</span> -&gt;</span></div><div class="line">    Acc;</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer, Acc)</span> -&gt;</span></div><div class="line">    to_string(Integer div <span class="number">10</span>, [(Integer rem <span class="number">10</span>) + $<span class="number">0</span> | Acc]).</div></pre></td></tr></table></figure>
<p>注意，在这里我用了两个整数操作符：div是整数除，rem是整数取模（在C风格语言里通常用%表示）。</p>
<p>让我们假设用Erlang来写一个工具套件，需要将正整数的列数字转换为大多数电子表格使用的字符串表示形式（“A”到“Z”，然后是“AA”到“ZZ”，以此类推）。代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(Number)</span> -&gt;</span></div><div class="line">    num2excel((Number-<span class="number">1</span>) <span class="keyword">div</span> <span class="number">26</span>, (Number-<span class="number">1</span>) <span class="keyword">rem</span> <span class="number">26</span>, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(<span class="number">0</span>, Remainder, Acc)</span> -&gt;</span></div><div class="line">    [(Remainder + $A)|Acc];</div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(Quotient, Remainder, Acc)</span> -&gt;</span></div><div class="line">    num2excel((Quotient-<span class="number">1</span>) <span class="keyword">div</span> <span class="number">26</span>, (Quotient-<span class="number">1</span>) <span class="keyword">rem</span> <span class="number">26</span>, [(Remainder + $A)|Acc]).</div></pre></td></tr></table></figure>
<p>或者在我们的工具套件里的单词处理器需要单词统计函数。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">% public</div><div class="line">wordcount(Input) -&gt;</div><div class="line">    wordcount(Input, 0).</div><div class="line"></div><div class="line">% internal</div><div class="line">wordcount([], Count) -&gt;</div><div class="line">    Count;</div><div class="line">% End of the input. Count the last word, if we didn't already</div><div class="line">wordcount([C1], Count) when C1 =/= $\  -&gt;</div><div class="line">    Count+1;</div><div class="line">% End of a word. Count it.</div><div class="line">wordcount([C1, C2|Rest], Count) when C1 =/= $\ , C2 =:= $\  -&gt;</div><div class="line">    wordcount([C2|Rest], Count + 1);</div><div class="line">% Not the end of a word. Don't count it.</div><div class="line">wordcount([_|Rest], Count) -&gt;</div><div class="line">    wordcount(Rest, Count).</div></pre></td></tr></table></figure>
<p>在这里我们用了两个新的操作符：=:= 是Erlang的相等操作符，=/=是Erlang的不等操作符。现在你明白了。</p>
<p>当然，如果我们计划构建一个产品来与Microsoft FrontPage竞争，那么我将需要一个方法来转义HTML特殊字符。这个功能实现起来不费吹灰之力，代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">escape</span><span class="params">(String)</span> -&gt;</span></div><div class="line">    escape(String, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([], Acc)</span> -&gt;</span></div><div class="line">    lists:reverse(Acc);</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&lt; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;lt;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&gt; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;gt;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&amp; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;amp;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([C | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, [C | Acc]).</div></pre></td></tr></table></figure>
<p>上述代码有一些新东西：有两个参数的lists:reverse()。它反转第一个参数，然后把第二个参数加在其后。这样的代码很方便，我们反向构建累加器（在字符串处理中经常如此）。</p>
<p>Outlook Express最好要小心了，因为我们现在有了编写杀手级电子邮件客户端的工具。让我们将即将发送出去的邮件用每行80个字符的方式来格式化。当我们扫描输入的时候，我们将有一个单词累加器，并且有一个输出累加器，我们要决定什么时候将累加的单词增加到输出累加器里，以及什么时候增加新行字符。在此你需要一个新的操作符：++ 将两个列表串起来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">% 公共接口</div><div class="line">wordwrap(Input) -&gt;</div><div class="line">    wordwrap(Input, [], [], 0, 80).</div><div class="line"></div><div class="line">% 内部函数</div><div class="line">% 没有输入了，我们结束处理，输出结果</div><div class="line">wordwrap([], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    lists:reverse(WordAcc ++ Acc);</div><div class="line"></div><div class="line">% 遇到输入里的换行符</div><div class="line">wordwrap([$\n | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\n | WordAcc ++ Acc], [], 0, WrapAt);</div><div class="line"></div><div class="line">% 当前行长度达到需要换行的长度，并且输入字符为空字符。新增一行</div><div class="line">wordwrap([$\  | Rest], Acc, WordAcc, WrapAt, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\n | WordAcc ++ Acc], [], 0, WrapAt);</div><div class="line"></div><div class="line">% 当前行长度未达到换行长度，输入字符为空字符。</div><div class="line">wordwrap([$\  | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\  | WordAcc ++ Acc], [], LineLength + 1 + length(WordAcc), WrapAt);</div><div class="line"></div><div class="line">% 在建立单词时其长度大于需要换行长度</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, 0, WrapAt) when erlang:length(WordAcc) &gt; WrapAt -&gt;</div><div class="line">    wordwrap(Rest, Acc, [C | WordAcc], 0, WrapAt);</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, LineLength, WrapAt)</div><div class="line">                        when erlang:length(WordAcc) + LineLength &gt; WrapAt -&gt;</div><div class="line">    wordwrap(Rest, [$\n | Acc], [C | WordAcc], 0, WrapAt);</div><div class="line"></div><div class="line">% 构建一个单词</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, Acc, [C | WordAcc], LineLength, WrapAt).</div></pre></td></tr></table></figure>
<p>上述就是我们实现的代码。</p>
<h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a><span id="part-five">下一步</span></h1><p>Erlang是一种丰富的语言，当你深入了解它时，你会更加欣赏它。为了直接讲解本文中的算法，我刻意避免覆盖Erlang的主要数据结构、库及其内置函数。但是如果你喜欢用Erlang的思维框架思考问题，我鼓励你阅读本文后去学习它其余的知识，并开始把Erlang用在工作中。Erlang拥有一个活跃的、不断增长的、友好的开发人员社区、令人兴奋的有潜力的应用程序以及许多有趣和有用的开源项目。</p>
<p>诚然，学习驾驭魅影是艰难的事情，但一旦你掌握了它，你一定会为你的付出而喜悦。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><span id="part-six">源代码</span></h1><p><a href="http://www.evanmiller.org/joy_of_erlang.erl" target="_blank" rel="external">下载本文中所示的源代码</a></p>
<blockquote>
<p>*原文链接<a href="http://www.evanmiller.org/joy-of-erlang.html" target="_blank" rel="external">http://www.evanmiller.org/joy-of-erlang.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么我经常从头开始实现某些功能]]></title>
      <url>http://szpzs.oschina.io/2017/06/14/why-i-often-implement-things-from-scratch/</url>
      <content type="html"><![CDATA[<p>从前有一个Erlang程序员，他需要一个FTP服务器，运行在一个私有网络上的一个主机上。实际上，他不需要一个FTP服务器，他只需要在中央服务器和他的客户端机器之间传输文件，但是他认为他需要一个FTP服务器来完成这个操作。</p>
<a id="more"></a>
<p>他在网上搜索了FTP服务器，确实找到了几个。他们当然是免费的，因为即使他工作的组织有很多钱，但是购买这样一种产品的行政程序是相当可观的。这个项目还必须有合适的许可证形式，这样法律部门才会高兴。</p>
<p>他下载了几个这样的服务器，其中一些是无法编译的，即使它们确实编译了，它们也必须正确配置才能运行，这并不容易。</p>
<p>突然，我们的程序员有了一种想法：他可能可以自己编写一个FTP服务器，而自己编写FTP服务器可能比查找和安装其他人编写的FTP服务器要快。</p>
<p>他问自己：“我想做什么呢?”。</p>
<p>“将远程目录的文件列出来，在本地和远程机器之间拷贝文件等等。”</p>
<p>然后他想起他正在做的项目使用了分布式Erlang。</p>
<p>他想：“这一定很容易”。他是对的。</p>
<p>然后…在服务器机器上，他输入了如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="variable">$erl</span> -name server -cookie ASDRTFERT</div><div class="line">1&gt; node().</div><div class="line"><span class="string">'server@host1.somenet.com'</span></div></pre></td></tr></table></figure>
<p>然后他在另一台机器上输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="variable">$erl</span> -name client1 -cookie ASDRTFERT</div><div class="line">1&gt; node().</div><div class="line"><span class="string">'client1@host23.somenet.com'</span></div></pre></td></tr></table></figure>
<p>现在他已经启动了两个Erlang节点。分布式Erlang的优点是你可以轻松地在任何节点上运行代码，因此要检查他是否能够从客户机节点访问服务器节点，程序员就会输入如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; rpc:call(server@host1.somenet.com',</div><div class="line">erlang, node, []).</div><div class="line">'server@host1.somenet.com'</div></pre></td></tr></table></figure>
<p>如果命令在第一台机器上发出，那将会发生什么。我们可以自己尝试一下。现在我们的程序员知道他可以就像在本地机器上一样调用远程机器上的任何功能。</p>
<p>例子如下：</p>
<p>如果本地命令是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; file:get_cwd()</div></pre></td></tr></table></figure>
<p>在服务器上执行这个命令时，他只需要调用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; rpc:call(server@host1.somenet.com',file, get_cwd, []).</div></pre></td></tr></table></figure>
<p>那么列出远程机器的文件，他输入如下命令即可：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; rpc:call(server@host1.somenet.com',</div><div class="line">     file, list_dir, [<span class="string">"."</span>]).</div><div class="line">&#123;ok, [<span class="string">"Makefile"</span>,</div><div class="line">  <span class="string">"readme"</span>,</div><div class="line"> ....</div></pre></td></tr></table></figure>
<p>然后他决定把远程机器的Makefile文件拷贝到他本地机器上，因此他写了如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; &#123;ok, Bin&#125; = rpc:call(server@host1.smenet.com',</div><div class="line">                file, read_file, [<span class="string">"Makefile"</span>]).</div><div class="line">&lt;&lt;<span class="string">".SUFFIXES: .erl .beam .yrl"</span> .....&gt;&gt;</div><div class="line"><span class="number">3</span>&gt; file:write_file(<span class="string">"Makefile"</span>, [Bin]).</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>此时，所有在shell中键入的内容变得冗长乏味，因此他启动了emacs并编写了如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(myftp)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([get_file/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">get_file</span><span class="params">(F)</span> -&gt;</span></div><div class="line">&#123;ok, B&#125; = rpc:call(server@host1.smenet.com',</div><div class="line">                  file, read_file, [F]),</div><div class="line">file:write_file(F ++ <span class="string">".copy"</span>, [B]).</div></pre></td></tr></table></figure>
<p>然后他编译并测试他的程序：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; c(myftp).</div><div class="line">&#123;ok,myftp&#125;</div><div class="line"><span class="number">5</span>&gt; myftp:get_file(<span class="string">"Makefile"</span>).</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>就这么简单，他搞定了。</p>
<h2 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h2><p>如果你有合适的工具，那么在从头开始实现一些东西比很麻烦地下载编译和安装别人写的东西更快。</p>
<p>这是一个真实的故事，只不过我刚刚写了这段代码。编写此代码和博客的时间与在我的机器上找到并安装一个FTP服务器差不多。</p>
<blockquote>
<p><em>原文链接：</em>  [<a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-often-implement-things-from.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com/2006/09/why-i-often-implement-things-from.html</a>]</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mnesia表分片]]></title>
      <url>http://szpzs.oschina.io/2017/05/30/Mnesia-Table-Fragmentation-erlangcentral/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">概述</a></li>
<li><a href="#part-two">要求</a></li>
<li><a href="#part-three">分片表的样例</a></li>
<li><a href="#part-four">启动一个Erlang节点</a></li>
<li><a href="#part-five">用20个表创建分片表</a></li>
<li><a href="#part-six">数据操作</a></li>
<li><a href="#part-seven">添加记录</a></li>
<li><a href="#part-eight">选择有限的记录</a></li>
<li><a href="#part-nine">分片表的列表</a></li>
</ol>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><span id="part-one">概述</span></h1><p>本文描述如何创建Mnesia分片表以及如何使用它们。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a><span id="part-two">要求</span></h1><p>假如我必须做一个图书索引应用程序。我有一张表用来记录所有可用的图书馆书籍。表的记录结构如下节所述。因为数据量巨大，所以我想把这个表在一个单独的Erlang节点里分片。如果你想分布式处理这个分片的表，你可以参考<a href="http://erlangcentral.org/wiki/index.php?title=Distributing_a_Mnesia_schema" target="_blank" rel="external">这篇文章</a>来分布式处理Mnesia的表。与表分片的其他相关工作都保持不变。</p>
<h1 id="分片表的样例"><a href="#分片表的样例" class="headerlink" title="分片表的样例"></a><span id="part-three">分片表的样例</span></h1><p>我需要这张表是disk_copies模式。其他模式也以相同的方式操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-record</span><span class="params">(book_info, &#123;isbn, name, author, keywords, category, description&#125;)</span>.</div></pre></td></tr></table></figure>
<h1 id="启动一个Erlang节点"><a href="#启动一个Erlang节点" class="headerlink" title="启动一个Erlang节点"></a><span id="part-four">启动一个Erlang节点</span></h1><p>我们的例子节点foo@example默认的磁盘存储路径被设置为在当前路径下的Mnesia.foo@example目录。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -sname foo</div></pre></td></tr></table></figure>
<p>这个路径可以在启动一个Erlang节点的时候通过用 -mnesia dir ‘“/path/of/your/preference”‘ ‘ 启动参数来改写。</p>
<p>让我们创建一个基于磁盘的schema，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnesia:create_schema([node()]).</div></pre></td></tr></table></figure>
<h1 id="用20个表创建分片表"><a href="#用20个表创建分片表" class="headerlink" title="用20个表创建分片表"></a><span id="part-five">用20个表创建分片表</span></h1><p>在本例中，所有20个分片在相同的Erlang/Mnesia节点里。另外这些分片是disc_copies类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mnesia:create_table(book_info,</div><div class="line">   [&#123;frag_properties, [&#123;node_pool, [node()]&#125;, &#123;n_fragments, <span class="number">20</span>&#125;, &#123;n_disc_copies, <span class="number">1</span>&#125;]&#125;,</div><div class="line">   &#123;index, [name, keywords, category]&#125;,</div><div class="line">   &#123;attributes, record_info(fields, book_info)&#125;]),</div></pre></td></tr></table></figure>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a><span id="part-six">数据操作</span></h1><p>为了能够访问在一个分片表的记录，Mnesia必须确定该真实记录属于那个分片。这通过mnesia_frag模块来做到，这个模块实现了mnesia_access回调行为。mnesia_frag封装标准Mnesia操作函数到其函数里，并将其作为参数传递给mnesia:activity/4。</p>
<h1 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a><span id="part-seven">添加记录</span></h1><p>创建一个调用mnesia:write/3的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AddFun = <span class="keyword">fun</span>() -&gt;</div><div class="line">           mnesia:write(book_info, Record, write)</div><div class="line">          <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在如下所示在mnesia:activity/4里调用这个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = mnesia:activity(transaction, AddFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>注意，我已将活动访问上下文用作“事务”。事务可以确保操作要么全部成功要么全部失败（即保证操作的原子性）。我可以使用如下几个访问上下文：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;transaction, Retries&#125;</div><div class="line">sync_transaction</div><div class="line">&#123;sync_transaction, Retries&#125;</div><div class="line">async_dirty</div><div class="line">sync_dirty</div><div class="line">ets</div></pre></td></tr></table></figure>
<p>例如，你想用脏模式做以上的操作，你可以这么写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = mnesia:activity(async_dirty, AddFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>你可以参考mnesia:activity/4文档来获得更多信息。</p>
<h1 id="选择有限的记录"><a href="#选择有限的记录" class="headerlink" title="选择有限的记录"></a><span id="part-eight">选择有限的记录</span></h1><p>做为一个例子，让我们选择作者是steve的10条记录。记住10不是硬性限制。用mnesia:select/4函数创建一个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MatchHead = #book_info&#123;author = <span class="string">"steve"</span>, _ = '_'&#125;,</div><div class="line">Guard = [],</div><div class="line">Result = ['$_'],</div><div class="line">MatchSpec = [&#123;MatchHead, Guard, Result&#125;],</div><div class="line">SelFun = <span class="keyword">fun</span>() -&gt;</div><div class="line">          mnesia:select(book_info, MatchSpec, <span class="number">10</span>, read)</div><div class="line">         <span class="keyword">end</span>,</div></pre></td></tr></table></figure>
<p>现在如下所示在mnesia:activity/4里调用这个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result = mnesia:activity(transaction, SelFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>Result的结果类型是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result -&gt; '$end_of_table' | &#123;[Objects], Cont&#125; | transaction abort</div></pre></td></tr></table></figure>
<p>在一个分片的表里，如果上述Result结果是{[Objects], Cont}，并且返回的对象数量少于我们期望的（10个），那么你需要递归地用Cont（continuation）来调用mnesia:select/1，直到你得到期望数量的结果或者’$end_of_table’。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SelFun2 = <span class="keyword">fun</span>() -&gt;</div><div class="line">             mnesia:select(Cont)</div><div class="line">           <span class="keyword">end</span>,</div><div class="line">Result2 = mnesia:activity(transaction, SelFun2, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>Result2的结果类型是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result2 -&gt; '$end_of_table' | &#123;[Objects], Cont&#125; | transaction abort</div></pre></td></tr></table></figure>
<h1 id="分片表的列表"><a href="#分片表的列表" class="headerlink" title="分片表的列表"></a><span id="part-nine">分片表的列表</span></h1><p>要获取分片表的列表，调用mnesia:table_info/2，并加上 frag_names 选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnesia:activity(async_dirty, mnesia:table_info/<span class="number">2</span>, [store, frag_names], mnesia_frag).</div></pre></td></tr></table></figure>
<p>本教程到此结束！现在你知道如何写一个基本的Mnesia分片表程序了。</p>
<blockquote>
<p><em>原文链接：</em>  [<a href="http://www2.erlangcentral.org/wiki/?title=Mnesia_Table_Fragmentation" target="_blank" rel="external">http://www2.erlangcentral.org/wiki/?title=Mnesia_Table_Fragmentation</a>]</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在运行时求值Erlang的代码字符串]]></title>
      <url>http://szpzs.oschina.io/2017/03/16/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/</url>
      <content type="html"><![CDATA[<p>Erlang有一种能力，在运行时读取一个代表一行代码的字符然后执行这行代码。</p>
<p>它可以解析这个字符串，执行它，然后返回结果。</p>
<ol>
<li><a href="#part-one">求值简单的表达式</a></li>
<li><a href="#part-two">安全注意事项</a><br> 2.1. <a href="#part-two-one">SQL注入攻击是什么？(请耐心看看)</a><br> 2.2 <a href="#part-two-two">与Erlang有关的安全问题是什么？！</a></li>
<li><a href="#part-three">拦截本地函数调用</a></li>
<li><a href="#part-four">拦截非本地函数调用</a></li>
<li><a href="#part-five">还有什么？</a></li>
</ol>
<a id="more"></a>
<h1 id="求值简单的表达式"><a href="#求值简单的表达式" class="headerlink" title="求值简单的表达式"></a><span id="part-one">求值简单的表达式</span></h1><p>最基本的，我们可以读取任何传入的表达式并执行它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),    <span class="comment">% 扫描代码为一些字符串标记</span></div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),     <span class="comment">% 解析这些字符串标记为一个抽象格式</span></div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, []),  <span class="comment">% 求值表达式，返回结果值</span></div><div class="line">    Result.</div></pre></td></tr></table></figure>
<p>尝试传递一些简单的算术表达式。很简单吧？</p>
<p>记住，语句用逗号结束，而函数用句号结束，所以你需要包括那些标点符号。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &gt; 2."</span>).</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4+2."</span>).</div><div class="line"><span class="number">6</span></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"A=7+2,A-4."</span>).</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>如果这就是你所需要的，真棒。</p>
<p>如果你有时间，你可能想要了解这开辟了潜在安全闸门。</p>
<h1 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a><span id="part-two">安全注意事项</span></h1><p>如果你只允许任何人执行任意一行代码，将会有一些很严重的问题，而且立刻就有更多的漏洞出现。</p>
<p>首先，要做一个比较…</p>
<h2 id="SQL注入攻击是什么？-请耐心看看"><a href="#SQL注入攻击是什么？-请耐心看看" class="headerlink" title="SQL注入攻击是什么？(请耐心看看)"></a><span id="part-two-one">SQL注入攻击是什么？(请耐心看看)</span></h2><p>我要转换一下话题，谈谈SQL注入攻击。</p>
<p>例如，我们已经一个web页面，用户可以在这个页面上只输入他们的用户名来查看关于他们自己的信息。在幕后，我们只是获取用户输入的用户名，然后将其插入一个查询语句中，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name = <span class="string">" + "</span>gwinney<span class="string">"</span></div></pre></td></tr></table></figure>
<p>只要用户规规矩矩地玩，一切都好。但是，如果他们输入的名字是 “gwinney; delete * from user_table” 呢？现在，这个查询语句变成如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name = <span class="string">" + "</span>gwinney; <span class="keyword">delete</span> * <span class="keyword">from</span> user_table<span class="string">"</span></div></pre></td></tr></table></figure>
<p>这个问题的解决方案（如果你把这样的代码提交到StackOverflow，至少一半的人会对你大吼大叫）是净化输入。我们应该检查一下以确保它做的是我们期望的，对于SQL来说，这通常意味着参数化查询。</p>
<p>我不想在此对这个问题进行太多的细述，但如果我们以正确的方式做的话，查询看起来更像下面这样，它这将查询失败，因为疯狂的用户名不存在。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="string">'gwinney; delete * from user_table'</span><span class="string">"</span></div></pre></td></tr></table></figure>
<h2 id="与Erlang有关的安全问题是什么？！"><a href="#与Erlang有关的安全问题是什么？！" class="headerlink" title="与Erlang有关的安全问题是什么？！"></a><span id="part-two-two">与Erlang有关的安全问题是什么？！</span></h2><p>相似地，我们可能会碰到表达式代码的安全问题。</p>
<p>我们被允许包含任何函数 – 本地函数、BIF（Erlang的内建函数）和在你创建的其他模块里暴露出来的函数 – 的调用，并且它将解析它们然后尝试执行它们。</p>
<p>如果我们让上述函数能被外界访问，即使是间接的，而且输入没有经过净化，那么我们就是给别人直接调用各种他们没有业务调用函数的能力。危险啊！</p>
<p>那么我们如何防止这样的危险呢？</p>
<h1 id="拦截本地函数调用"><a href="#拦截本地函数调用" class="headerlink" title="拦截本地函数调用"></a><span id="part-three">拦截本地函数调用</span></h1><p>我们可以给 erl_eval:exprs 提供一个函数，所有本地函数的调用都被传给它，我们就可以在这个函数里做一些额外的动作。</p>
<p>本地函数是那些在相同的模块里，它们可以不需要指定模块名而被调用。（虽然一些BIF，比如list_to_binary，不需要指定模块名，这是因为它们被系统自动导入了 – 它们仍然被认为是非本地的。）</p>
<p>在下面的代码里有一些新元素。一个叫做handle_local_function的函数和一个叫做get_random_number的本地函数（感谢<a href="https://xkcd.com/221/" target="_blank" rel="external">xkcd</a>）。这个处理函数输出一个相关信息然后处理传入给它的函数名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),</div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),</div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, [],</div><div class="line">                                        &#123;value, fun handle_local_function/2&#125;),</div><div class="line">    Result.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_local_function</span><span class="params">(FunctionName, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">        get_random_number -&gt; get_random_number();</div><div class="line">        what_time_is_it -&gt; calendar:universal_time();</div><div class="line">        are_we_there_yet -&gt; <span class="string">"no"</span>;</div><div class="line">        _ -&gt; <span class="string">"uh uh uh. you didn't say the magic word!"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> get_random_number<span class="params">()</span> -&gt; integer<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">get_random_number</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="number">4</span>.  <span class="comment">% 通过公平的骰子选择；保证是随机的</span></div></pre></td></tr></table></figure>
<p>现在再运行这个模块，传入一些新的表达式。</p>
<p>我们可以拦截这些本地函数（可能不是真的存在，但表达式求值器不知道），并且按照我们的要求重定向它们…或者如果用户试图做一些无效的事情，只会吐出一条消息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"get_random_number()."</span>).</div><div class="line">Local call to get_random_number with []</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"what_time_is_it()."</span>).</div><div class="line">Local call to what_time_is_it with []</div><div class="line">&#123;&#123;<span class="number">2017</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">15</span>,<span class="number">21</span>,<span class="number">53</span>&#125;&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"are_we_there_yet()."</span>).</div><div class="line">Local call to are_we_there_yet with []</div><div class="line"><span class="string">"no"</span></div><div class="line"></div><div class="line">parser:evaluate_expression(<span class="string">"break_the_system()."</span>).</div><div class="line">Local call to break_the_system with []</div><div class="line"><span class="string">"uh uh uh. you didn't say the magic word!"</span></div></pre></td></tr></table></figure>
<h1 id="拦截非本地函数调用"><a href="#拦截非本地函数调用" class="headerlink" title="拦截非本地函数调用"></a><span id="part-four">拦截非本地函数调用</span></h1><p>相似地，我们可以给 erl_eval:exprs 提供一个函数，所有非本地函数的调用都被传给它。（当前模块外的任何东西，包括BIF、甚至用于比较的运算符。）</p>
<p>如下代码被扩展来处理非本地函数。注意，我们如何必须显式处理属于Erlang模块的一部分的 &gt; 和 &lt; 比较运算符，我们如何能够把不存在的函数重导向到存在的函数，以及如果一个函数不被支持，我们如何能够输出一条消息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),</div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),</div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, [],</div><div class="line">                                        &#123;value, fun handle_local_function/2&#125;,</div><div class="line">                                        &#123;value, fun handle_non_local_function/2&#125;),</div><div class="line">    Result.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_local_function</span><span class="params">(FunctionName, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">        get_random_number -&gt; get_random_number();</div><div class="line">        what_time_is_it -&gt; calendar:universal_time();</div><div class="line">        are_we_there_yet -&gt; <span class="string">"no"</span>;</div><div class="line">        _ -&gt; <span class="string">"uh uh uh. you didn't say the magic word!"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_non_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_non_local_function</span><span class="params">(&#123;ModuleName,FunctionName&#125;, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Non-local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> ModuleName <span class="keyword">of</span></div><div class="line">        erlang -&gt;</div><div class="line">            <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">                '&gt;' -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                '&lt;' -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                list_to_binary -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                _ -&gt; <span class="string">"nope"</span></div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        calendar -&gt;</div><div class="line">            <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">                universal_time -&gt; calendar:universal_time();</div><div class="line">                lets_pretend_this_returns_four -&gt; <span class="number">4</span>;</div><div class="line">                something_ridiculous -&gt; <span class="string">"what calendar are you using??"</span>;</div><div class="line">                _ -&gt; <span class="string">"notgonnahappen"</span></div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        _ -&gt; <span class="string">"don't think about it"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> get_random_number<span class="params">()</span> -&gt; integer<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">get_random_number</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="number">4</span>.  <span class="comment">% chosen by fair dice roll; guaranteed to be random</span></div></pre></td></tr></table></figure>
<p>大于和小于比较是允许的，但是等于却不允许。一些函数被允许，一些函数不被允许，一些函数被重定向。在上一个例子中，一个邪恶的用户尝试用他们邪恶的计划搞垮系统。但他被挫败了。:p</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &lt; 2."</span>).</div><div class="line">Non-local call to '&lt;' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="literal">false</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &gt; 2."</span>).</div><div class="line">Non-local call to '&gt;' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 == 2."</span>).</div><div class="line">Non-local call to '==' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="string">"nope"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"list_to_binary(\"hi\")."</span>).</div><div class="line">Non-local call to list_to_binary with [<span class="string">"hi"</span>]</div><div class="line">&lt;&lt;<span class="string">"hi"</span>&gt;&gt;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"binary_to_list(&lt;&lt;\"hi\"&gt;&gt;)."</span>).</div><div class="line">Non-local call to binary_to_list with [&lt;&lt;<span class="string">"hi"</span>&gt;&gt;]</div><div class="line"><span class="string">"nope"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:universal_time()."</span>).</div><div class="line">Non-local call to universal_time with []</div><div class="line">&#123;&#123;<span class="number">2017</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">21</span>,<span class="number">4</span>,<span class="number">42</span>&#125;&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:local_time()."</span>).</div><div class="line">Non-local call to local_time with []</div><div class="line"><span class="string">"notgonnahappen"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:lets_pretend_this_returns_four()."</span>).</div><div class="line">Non-local call to lets_pretend_this_returns_four with []</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:something_ridiculous()."</span>).</div><div class="line">Non-local call to something_ridiculous with []</div><div class="line"><span class="string">"what calendar are you using??"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"sys:terminate(some_process, \"buahaha\")."</span>).</div><div class="line">Non-local call to terminate with [some_process,<span class="string">"buahaha"</span>]</div><div class="line"><span class="string">"don't think about it"</span></div></pre></td></tr></table></figure>
<h1 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a><span id="part-five">还有什么？</span></h1><p>Erlang里的好例子很难得到，你在这里看到的是一些试验和错误。如果你发现自己试图解析代码，并在运行时执行它，也许这会让你理解得更深。</p>
<p>其他资源：</p>
<ul>
<li><a href="http://www2.erlangcentral.org/wiki/?title=String_Eval" target="_blank" rel="external">执行存储在字符串里的Erlang代码</a>（涉及到绑定变量，这个我在本文没有介绍）</li>
<li>官方文档：<a href="http://erlang.org/doc/man/erl_scan.html" target="_blank" rel="external">erl_scan</a>、<a href="http://erlang.org/doc/man/erl_parse.html" target="_blank" rel="external">erl_parse</a>、<a href="http://erlang.org/doc/man/erl_eval.html" target="_blank" rel="external">erl_eval</a>（一切都在那里…一壶咖啡准备好了）</li>
<li><a href="http://people.apache.org/~dennisbyrne/infoq/DSLs_in_Erlang.ppt" target="_blank" rel="external">Erlang里的领域特定语言</a>（ppt文档，你可以下载来看）</li>
<li><a href="http://stackoverflow.com/q/6786034/301857" target="_blank" rel="external">参数化语句能阻止所有SQL注入吗？</a>（如果你感兴趣的话，这是一个在Stackoverflow上关于SQL注入更多细节的贴子。）</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://grantwinney.com/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/" target="_blank" rel="external">https://grantwinney.com/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir的多态性]]></title>
      <url>http://szpzs.oschina.io/2017/03/13/polymorphism-in-elixir/</url>
      <content type="html"><![CDATA[<p>多态性是向不同类型的实体提供单一接口。本质上，它允许不同的数据类型响应相同的函数。因此，相同的函数为不同的数据类型完成相同的行为。Elixir语言有‘协议’和简洁的方式实现多态性。</p>
<a id="more"></a>
<p>让我们实现一个基本的协议，它将开氏和华氏温度转换为摄氏温度。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Kelvin</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Kelvin"</span>, <span class="symbol">symbol:</span> <span class="string">"K"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Fahrenheit</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Fahrenheit"</span>, <span class="symbol">symbol:</span> <span class="string">"°F"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Celsius</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Temperature</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Convert Kelvin and Fahrenheit to Celsius degree</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(degree)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Temperature</span></span>, <span class="symbol">for:</span> Kelvin <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Deduct 273.15</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(kelvin) <span class="keyword">do</span></div><div class="line">    celsius_degree = kelvin.degree - <span class="number">273.15</span></div><div class="line">    %Celsius&#123;<span class="symbol">degree:</span> celsius_degree&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Temperature</span></span>, <span class="symbol">for:</span> Fahrenheit <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Deduct 32, then multiply by 5, then divide by 9</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(fahrenheit) <span class="keyword">do</span></div><div class="line">    celsius_degree = (fahrenheit.degree - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></div><div class="line">    %Celsius&#123;<span class="symbol">degree:</span> celsius_degree&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，我们实现了开氏和华氏温度的转换。</p>
<p>让我们尝试一些转换：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; fahrenheit = %Fahrenheit&#123;<span class="symbol">degree:</span> <span class="number">45</span>&#125;</div><div class="line">%Fahrenheit&#123;<span class="symbol">degree:</span> <span class="number">45</span>, <span class="symbol">name:</span> <span class="string">"Fahrenheit"</span>, <span class="symbol">symbol:</span> <span class="string">"°F"</span>&#125;</div><div class="line">iex&gt; celsius = Temperature.to_celsius(fahrenheit)</div><div class="line">%Celsius&#123;<span class="symbol">degree:</span> <span class="number">7.22</span>, <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>&#125;</div><div class="line"></div><div class="line">iex&gt; kelvin = %Kelvin&#123;<span class="symbol">degree:</span> <span class="number">300</span>&#125;</div><div class="line">%Kelvin&#123;<span class="symbol">degree:</span> <span class="number">300</span>, <span class="symbol">name:</span> <span class="string">"Kelvin"</span>, <span class="symbol">symbol:</span> <span class="string">"K"</span>&#125;</div><div class="line">iex&gt; celsius = Temperature.to_celsius(kelvin)</div><div class="line">%Celsius&#123;<span class="symbol">degree:</span> <span class="number">26.85</span>, <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>&#125;</div></pre></td></tr></table></figure>
<p>让我们试着转换没有实现to_celsius函数的任何其他数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Temperature.to_celsius(%&#123;degree: 12&#125;)</div><div class="line">** (Protocol.UndefinedError) protocol Temperature not implemented for %&#123;degree: 12&#125;</div><div class="line">    iex:11: Temperature.impl_for!/1</div><div class="line">    iex:15: Temperature.to_celsius/1</div></pre></td></tr></table></figure>
<p>如果你想要转换所有数据类型，你可以为<strong>Any</strong>这个数据类型定义一个实现。最后，如果你有时间，请阅读 <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/enum.ex#L3096" target="_blank" rel="external"><strong>Enum</strong></a> 和 <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/string/chars.ex#L3" target="_blank" rel="external"><strong>String.Char</strong></a> 的源码，它们是Elixir核心代码里多态性的好例子。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929#.d09i4bf56" target="_blank" rel="external">https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929#.d09i4bf56</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[减少固定大小缓冲区的最大延迟]]></title>
      <url>http://szpzs.oschina.io/2017/03/10/reducing-maximum-latency/</url>
      <content type="html"><![CDATA[<p>最近我在<a href="https://pusher.com/" target="_blank" rel="external">Pusher</a>的博客读到两篇很棒的文章：<a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/" target="_blank" rel="external">低延迟、大的工作集和GHC的垃圾收集器：三选二</a> 和 <a href="https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="external">Golang的实时GC的理论与实践</a> 。这两篇文章讲的是Pusher的工程师如何重新实现他们的消息总线的故事。第一篇是发生在Haskell里。在性能测试期间，他们发现在99%那个范围内有一些高延迟。在他们分析代码后，他们能够证明这些延时的尖峰是由GHC的 stop-the-world 垃圾收集器，再加上一个大的工作集（内存中的对象的数目）所造成的。该开发团队随后尝试了GO，得到好得多的结果，这得益于GO的并发垃圾收集器。</p>
<p>我强烈推荐这两篇文章。Pusher的测试是一个很棒的基准测试例子，因为它专注于解决一个真正的挑战，并且基于该项技术是否合适本工作来评估此技术。这是我喜欢的那种评估方式。我发现做一个简单的关键功能的实现非常有用，然后看看它在所需的负荷下的表现，而不是通过一些浅层的模拟基准测试来比较不同的技术，例如在环里传递令牌，或让一个Web服务器返回“200 OK”。这个方法应该能提供“我能用Y有效地解决X吗？”问题的答案。当我第一次评估Erlang的时候，我采用的就是这种方法。10 倍的预期负载模拟真实系统的12个小时测试让我相信这项技术比我所需要的绰绰有余。</p>
<a id="more"></a>
<h1 id="接受挑战"><a href="#接受挑战" class="headerlink" title="接受挑战"></a>接受挑战</h1><p>阅读Pusher的文章使得我很想知道这个问题的Elixir实现的性能如何。毕竟，底层的Erlang虚拟机（BEAM）一直是给我低的和可预测的延迟的印象，所以加上其他性质，如容错、大规模的并发性、可扩展性、分布式系统的支持，这似乎是一个为该工作令人信服的选择。</p>
<p>所以让我根据Pusher的文章来定义挑战。我将实现一个先进先出（FIFO）缓冲区，它可以处理两种操作：push 和 pull。这个缓冲区由最大尺寸来限定它的大小。如果这个缓冲区满了，push操作将覆盖队列里最老的元素。</p>
<p>目标是为了减少一个非常大的缓冲区（最大20万元素）的push和pull操作的最大延迟。把这最后的目标牢记在心是很重要的。我关心平滑缓冲区操作的延迟尖峰。我不在乎哪种语言给我更好的最坏情况的GC停顿。虽然Pusher的挑战的根本问题是由长GC停顿造成的，那并不意味着我仅仅是换其他的语言就能解决它。正如我将阐述的，依赖于Elixir/Erlang的一些技巧，我们可以完全旁路掉GC，并且将最大延迟带入到微秒区域。</p>
<h1 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h1><p>为了测量性能，我决定在一个独立的GenServer进程里运行缓冲区。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/server.ex" target="_blank" rel="external">这里</a>看到实现代码。</p>
<p>测量利用了Erlang的trace能力。一个独立的进程被启动，它设置了缓冲区进程的trace。它接收push和pull操作以及缓冲区垃圾回收的开始和结束时间。它收集那些时间，并且在被要求的时候生成最终结果。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer_tracer.ex" target="_blank" rel="external">这里</a>找到它的实现。</p>
<p>trace将导致一些性能损耗。当trace被使用的时候，整个基准测试将是平常花费的两倍时间。我不能说它对报告的时间有多大的影响，但我并不在意它。如果我能够在用trace的情况下获得好的结果，那么在不用trace的情况下，这样的实现足够满足要求了。:-)</p>
<p>如果你不熟悉Erlang，这里的进程指的是Erlang的进程 - 一个运行在同一个操作系统进程里的轻量并发程序，并且和其他Erlang进程没有共享数据。在操作系统层面，我们仍然还是只有一个进程，但是在Erlang虚拟机里，有很多Erlang进程独立地运行着。</p>
<p>这些进程没有共同点，没有共享内存，只能通过发送自己的消息进行通信。特别是，每个进程都有自己独立的堆，并且各自进行自己的垃圾回收。因此，不论tracer进程分配了什么数据都不会给缓冲区进程造成GC压力。只有那些我们确实压入到缓冲区的数据在缓冲区GC期间才被考虑，也因此会影响缓冲区操作的延时。这种方法展示了Erlang非常棒的好处。通过在隔离的进程里运行不同的程序，我们可以在系统中防止在一个进程里的GC压力影响其他进程。我不知道有任何其他轻量级的并发平台提供这样的保证。</p>
<p>测试首先从一个简短的“拉伸”热身开始。我创建了一个最大容量为20万元素（这个数字是Pusher的基准测试里使用的）的缓冲区。然后，我压入20万个元素，接着全部取出来，然后再压入20万个元素。热身结束之际，缓冲区内的数据达到了它的最大容量。</p>
<p>这个时候基准测试开始。我以15个push操作然后跟着5个pull操作为一个周期发起了两百万个请求。因此，缓冲区的大多数操作处于“溢出”模式下。总的来说，1百万个push操作执行在满的缓冲区上，而50万个push操作执行在几乎满的缓冲区上。被压入的元素是1024字节的Erlang二进制数据，而且每一个元素都互不相同，意思就是测试将产生1百50万个不同的元素。</p>
<p>基准测试代码在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/mix/tasks/buffer_prof.ex" target="_blank" rel="external">这里</a>。完整的项目文件在<a href="https://github.com/sasa1977/erlangelist/tree/master/examples/buffer" target="_blank" rel="external">这里</a>。我用 Erlang 19.1 和 Elixir 1.3.4 运行基准测试，我用 <a href="https://github.com/asdf-vm/asdf" target="_blank" rel="external">asdf</a> 版本管理器来安装它们。测试运行在我的2011年的iMac上（3.4 GHz Intel Core i7）。</p>
<h1 id="函数式实现"><a href="#函数式实现" class="headerlink" title="函数式实现"></a>函数式实现</h1><p>首先，我会尝试我所认为的符合Elixir和Erlang习惯的方法 - 基于 <a href="http://erlang.org/doc/man/queue.html" target="_blank" rel="external">:queue</a> 模块的纯函数实现。根据文档所说，这个模块以高效的方式实现双端先进先出（FIFO）队列，它的大多数操作有一个分摊的O(1)运行时间。这个模块的API提供了绝大多数我们所需要的函数。我可以用 :queue.in/2 和 :queue.out/2 来push和pull数据。它没有直接支持设置队列的最大尺寸，但是在 :queue 模块实现这个功能非常简单。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/queue.ex" target="_blank" rel="external">这里</a>找到我的实现。</p>
<p>当我最初读Pusher的文章的时候，我非常肯定，这样的实现会导致较大的延迟尖峰。虽然在Erlang里没有 stop-the-world 的GC，但是依然有 stop-the-process 的GC。一个Erlang进程启动的时候有一个相当小的堆（大约2Kb），如果它需要分配比这个更多的空间，那么进程被GC并且它的堆可能被扩展。要了解GC的更多细节，我推荐<a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html" target="_blank" rel="external">这篇文章</a>以及另<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">一篇文章</a>。</p>
<p>在我们的测试里，这意味着缓冲区进程将相当快扩展到很大的堆，因为它要容纳20万个元素。那么，当我们压入更多数据并产生更多垃圾，GC将有很多工作要做。因此，我们可以期待有一些显著的GC停顿发生，它们将导致延迟尖峰。让我们核实一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mix buffer.bench -m Buffer.Queue</div><div class="line"></div><div class="line">push/pull (2000000 <span class="built_in">times</span>, average: 6.9 μs)</div><div class="line">  99%: 17 μs</div><div class="line">  99.9%: 32 μs</div><div class="line">  99.99%: 74 μs</div><div class="line">  99.999%: 21695 μs</div><div class="line">  100%: 37381 μs</div><div class="line">  Longest 10 (μs): 27134 27154 27407 27440 27566 27928 28138 28899 33616 37381</div><div class="line"></div><div class="line">gc (274 <span class="built_in">times</span>, average: 8514.46 μs)</div><div class="line">  99%: 22780 μs</div><div class="line">  99.9%: 23612 μs</div><div class="line">  99.99%: 23612 μs</div><div class="line">  99.999%: 23612 μs</div><div class="line">  100%: 23612 μs</div><div class="line">  Longest 10 (μs): 21220 21384 21392 21516 21598 21634 21949 22233 22780 23612</div><div class="line"></div><div class="line">Buffer process memory: 35396 KB</div><div class="line">Total memory used: 330 MB</div></pre></td></tr></table></figure>
<p>这里有大量的数据，所以我将突出一些我发现的最有趣的数字。</p>
<p>我将从缓冲区操作的平均延迟开始。最近平均值这个概念得到一些坏名声，但我仍然觉得它们是有用的度量标准。观察到的平均延迟是6.9微秒，这告诉我，即使缓冲区完全满了，这个实现可以没有延迟地应付大约每秒145000次操作。如果我能容忍一些延迟的变化，而且也不期望更高的请求，那么 :queue 实现应该适合我的需求。</p>
<p>看一下延迟的分布，我们可以看到最大延迟大约37毫秒。这可能是不可接受的，又或者它可能是刚好合适的，这取决于特定的场景。武断地认为这个用 :queue 实现的缓冲区是糟糕的，或者断定它在所有场景下都是可行的，这两种看法都应该是错误的。如果我们知道手头上具体问题的规格和要求，我们就能解释这些数字。</p>
<p>如果你仔细观察push和pull操作的延迟分布，你可以看到在4个9和5个9之间延迟迅速增加，延迟从两位数的微秒区间过度到两位数的毫秒区间。在两百万操作里，意味着我们要经历小于200个延迟尖峰。同样，这是否可以被接受取决于特定问题的约束。</p>
<p>打印出来的GC状态只和缓冲区进程相关。我们可以看到274次GC发生在缓冲区进程里，而且有很高比例的延迟在两位数毫秒区间。不出所料，GC的次数和开始于4个9到5个9的延迟尖峰之间似乎有着很强的相关性。</p>
<p>最后，请注意缓冲区进程的堆大小为何是35MB。你可能期望它大约是200MB，因为缓冲区持有20万元素，每个元素是1024个字节。但是，在这个基准测试里，元素被叫做<a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#id67990" target="_blank" rel="external">引用计数二进制数据</a>，它的意思是它们被存储在单独的堆上。缓冲区进程只持有这些二进制数据的引用，而不是数据本身。</p>
<p>当然，缓冲区进程还是有20万引用在它自己的堆上，还和被删除的消息等任何垃圾一起，这些就是引起延迟尖峰的原因。因此如果我只看它和其他语言比较最坏的GC次数的话，Erlang就不够好，并且我可能错误地得到结论，它不适合这项工作。</p>
<h1 id="基于ETS的实现"><a href="#基于ETS的实现" class="headerlink" title="基于ETS的实现"></a>基于ETS的实现</h1><p>然而，我可以用ETS表来限制GC。ETS表有很多特色，但是本文我为了简单起见，只讲它们可以当做一个进程内的内存的键值存储来用。当涉及到语义，ETS表没有给表带来什么新的东西（没有双关语义）。你可以用普通的Erlang进程和数据结构来实现同样的功能。</p>
<p>然而，该表有几个有趣的特性，能使他们在某些情况下表现的很好。首先，ETS表的数据被存储在进程堆之外的独立内存空间里。因此，如果我们使用ETS表来存储数据，缓冲区进程就不再需要持有许多引用，这应该会减少它的GC次数。此外，ETS表里的数据在被删除后将立即被释放。这意味着我们可以完全避免在大集合数据上的GC。</p>
<p>我用ETS表来实现的缓冲区是根据Pusher的GO实现来做的。基本上，我用ETS表来模拟一个可变数组，存储 (index, value) 这样的键值对到表中。我维护着两个索引，一个决定我push下一个元素到哪个位置，另一个决定了我从哪个位置pull下一个元素。它们都是从零开始。然后，每次push存储一个(push_index, value)这样的键值对到表中，就将push的索引加一。如果push的索引达到缓冲区最大尺寸，它就被设置为零。同样地，当pull数据的时候，我根据 pull_index 键来读取值，并且增加pull索引的值。如果缓冲区已满，则pull操作将覆盖最老值并增加两个索引，从而确保下一个pull操作将从适当位置读取数据。全部实现代码在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/ets.ex" target="_blank" rel="external">这里</a>。</p>
<p>让我们看看它的性能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mix buffer.bench -m Buffer.Ets</div><div class="line"></div><div class="line">push/pull (2000000 <span class="built_in">times</span>, average: 6.53 μs)</div><div class="line">  99%: 27 μs</div><div class="line">  99.9%: 37 μs</div><div class="line">  99.99%: 50 μs</div><div class="line">  99.999%: 66 μs</div><div class="line">  100%: 308 μs</div><div class="line">  Longest 10 (μs): 76 80 83 86 86 96 106 186 233 308</div><div class="line"></div><div class="line">gc (97062 <span class="built_in">times</span>, average: 5.16 μs)</div><div class="line">  99%: 10 μs</div><div class="line">  99.9%: 20 μs</div><div class="line">  99.99%: 30 μs</div><div class="line">  99.999%: 44 μs</div><div class="line">  100%: 44 μs</div><div class="line">  Longest 10 (μs): 30 30 34 34 34 39 43 44 44 44</div><div class="line"></div><div class="line">Buffer process memory: 30 KB</div><div class="line">Total memory used: 312 MB</div></pre></td></tr></table></figure>
<p>6.53微秒的平均时间没有比用 :queue 模块实现的更好。不过，延迟尖峰现在小了很多。观测到的最长延迟是308微秒，同时，在5个9的区域，我们已经减到了两位数微秒区域。实际上，在两百万的操作里，只有4个操作的延迟时间大于100微秒。相当不错。:-)</p>
<p>充分披露：这个结果是我运行了几次测试中的最好一次结果。在我的机器上，最大延时有时候略大于1毫秒，而其他数字没有明显的变化。特别是，99.999%总是低于100微秒。</p>
<p>观察一下GC的状态，你可以看到缓冲区进程的GC次数大幅度增加。在用 :queue 模块的实现里，缓冲区进程触发了274次GC，但是这个实现里，我们观察到大约97000次GC。这是为什么呢？记住，缓冲区进程仍然在它自己的堆上管理着一些数据。其中包括了下一次push和pull操作的索引，以及对刚刚被push和pull的元素的临时引用。因此，大量请求到达缓冲区进程，它将产生大量垃圾。但是，给缓冲区的元素被存储在ETS表的单独堆上，缓冲区永远不会维护一个大的活跃的数据集。这与Pusher的结论相符。GC的延迟尖峰与产生的垃圾量无关，而是与活跃的工作数据集的数量有关。在这个实现里，我们减少工作的数据集，保持缓冲区进程的堆很小。因此，虽然我们将触发大量的GC，但是它们耗时都相当短。观察到的缓冲区进程的最长GC时间仅仅44微秒。</p>
<h1 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h1><p>因为Erlang的stop-the-process的GC特性，我们可能在一些进程里经历长时间停顿。但是我们有一些选项可以帮我们削减大的延迟尖峰。控制这些停顿的主要技巧就是保持进程的堆很小。一个大的活跃堆加上频繁的传入请求将对GC施加更多的压力，延迟将增加。</p>
<p>在这个特定的例子中，使用ETS帮我减少缓冲区进程的堆大小。虽然GC数量显著增加，但是GC停顿很短使得整体延迟稳定。虽然Erlang肯定不是最快的平台，但是它让我保持我的延迟是可预测的。我构建系统，调优它达到我想要的性能，并且我可以预测到在生产中较少的令人吃惊情况发生。</p>
<p>值得一提的另外两种技术可能会帮助您减少GC延迟尖峰。第一个是将管理一个大堆的进程分割成多个管理更小数据集的进程。这将导致碎片化的GC，并且可能削减GC延迟尖峰。</p>
<p>在某些情况下，你可以充分利用进程终止时立即释放进程内存的事实。如果你需要执行一个分配大量临时内存的一次性工作，你可以考虑使用<a href="https://hexdocs.pm/elixir/Process.html#spawn/2" target="_blank" rel="external">Process.spawn</a>，它允许你在启动进程时显式地预先分配一个大的堆给这个进程。这可能完全阻止GC在这个进程中发生。你做计算，输出结果，最后终止进程，因此它所有的内存被立即回收而从来没有被GC过。</p>
<p>最后，如果你不能在Erlang里使得你的系统的一些关键部分高效，那么你可以利用<a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/" target="_blank" rel="external">进程内的NIF的C编程</a>或者<a href="http://theerlangelist.com/article/outside_elixir" target="_blank" rel="external">进程外的端口机制</a>，而保持Erlang/Elixir作为你的系统的主平台和“控制面板”。许多选项都在桌面上，这给了我很大的信心，我将能够处理任何我遇到的挑战，无论它可能多么棘手。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://www.theerlangelist.com/article/reducing_maximum_latency" target="_blank" rel="external">http://www.theerlangelist.com/article/reducing_maximum_latency</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir中的元编程－领域特定语言]]></title>
      <url>http://szpzs.oschina.io/2017/02/27/elixir-getting-started-meta-domain-specific-languages/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">前言</a></li>
<li><a href="#part-two">构建我们自己的测试用例</a></li>
<li><a href="#part-three">test宏</a></li>
<li><a href="#part-four">用属性存储信息</a></li>
</ol>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><span id="part-one">前言</span></h1><p>域特定语言 (DSL) 允许开发人员剪裁它们的应用到特定领域。你不需要为了有一个DSL而需要宏：在你的模块里定义的每个数据结构和每个函数是你的领域特定语言的一部分。</p>
<p>例如，假设我们想实现一个校验器模块，它提供一个数据校验领域特定语言。我们可以使用数据结构、函数或宏来实现它。让我们看看这些不同的DSL的样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 数据结构</span></div><div class="line">import Validator</div><div class="line">validate user, <span class="symbol">name:</span> [<span class="symbol">length:</span> <span class="number">1</span>..<span class="number">100</span>],</div><div class="line">               <span class="symbol">email:</span> [<span class="symbol">matches:</span> ~r/@/]</div><div class="line"></div><div class="line"><span class="comment"># 2. 函数</span></div><div class="line">import Validator</div><div class="line">user</div><div class="line">|&gt; validate_length(<span class="symbol">:name</span>, <span class="number">1</span>..<span class="number">100</span>)</div><div class="line">|&gt; validate_matches(<span class="symbol">:email</span>, ~r/@/)</div><div class="line"></div><div class="line"><span class="comment"># 3. 宏 + 模块</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyValidator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Validator</div><div class="line">  validate_length <span class="symbol">:name</span>, <span class="number">1</span>..<span class="number">100</span></div><div class="line">  validate_matches <span class="symbol">:email</span>, ~r/@/</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyValidator.validate(user)</div></pre></td></tr></table></figure>
<p>在上面所有的方法中，第一个绝对是最灵活的。如果我们的领域规则可以用数据结构进行编码，则它们是迄今为止最容易的撰写和实施，因为Elixir的标准库中充满了操纵不同数据类型的函数。</p>
<p>第二种方法使用函数调用，它更适合更复杂的API（例如，如果你需要传递很多选项）和Elixir里用管道运算符来更好地读。</p>
<p>第三种方法，使用宏，是迄今为止最复杂的。它将花更多行代码来实现，也难于测试（是和测试简单函数相比），它限制用户肯能如何使用库，因为所有校验需要被定义在一个模块里。</p>
<p>若要驱动该点，请假设只有在给定条件满足时才要验证某个属性。我们可以很容易地用第一种方案实现，通过操作相应结构的数据，或用第二种方案在调用函数之前用条件句（if/else）。但是，用宏的方法是不可能的，除非它的DSL被增强。</p>
<p>换句话说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data &gt; <span class="built_in">functions</span> &gt; macros</div></pre></td></tr></table></figure>
<p>也就是说，仍然有场景使用宏和模块来构建特定于域的语言。既然我们在入门指南已经探讨了数据结构和函数定义，那么本章将探讨如何使用宏和模块的属性来处理更复杂的DSL。</p>
<h1 id="构建我们自己的测试用例"><a href="#构建我们自己的测试用例" class="headerlink" title="构建我们自己的测试用例"></a><span id="part-two">构建我们自己的测试用例</span></h1><p>本章的目标是构建一个名为 TestCase 的模块，它允许我们按如下内容来写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> TestCase</div><div class="line"></div><div class="line">  test <span class="string">"arithmetic operations"</span> <span class="keyword">do</span></div><div class="line">    <span class="number">4</span> = <span class="number">2</span> + <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"list operations"</span> <span class="keyword">do</span></div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>] ++ [<span class="number">3</span>]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyTest.run</div></pre></td></tr></table></figure>
<p>在上面的例子里，通过使用 TestCase ，我们可以用 test 宏写测试用例，它定义了一个名为 run 的函数来为我们自动运行所有测试用例。我们的原型将依赖匹配运算符（=）作为一个种机制来做断言。</p>
<h1 id="test宏"><a href="#test宏" class="headerlink" title="test宏"></a><span id="part-three">test宏</span></h1><p>让我们从创建一个定义和导入test宏的模块开始：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">TestCase</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Callback invoked by `use`.</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># For now it returns a quoted expression that</span></div><div class="line">  <span class="comment"># imports the module itself into the user code.</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__using__</span></span>(_opts) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      import TestCase</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Defines a test case with the given description.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      test "arithmetic operations<span class="string">" do</span></div><div class="line">        4 = 2 + 2</div><div class="line">      end</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">test</span></span>(description, <span class="symbol">do:</span> block) <span class="keyword">do</span></div><div class="line">    function_name = String.to_atom(<span class="string">"test "</span> &lt;&gt; description)</div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(function_name)(), <span class="symbol">do:</span> unquote(block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>假设我们在文件 tests.exs 里定义了 TestCase ，我们可以通过运行 iex tests.exs 打开它，并且定义我们第一个测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="keyword">use</span> TestCase</div><div class="line">...&gt;</div><div class="line">...&gt;   test <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;     <span class="string">"hello"</span> = <span class="string">"world"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在我们没有一种机制来运行测试，但是我们知道一个名为 “test hello” 的函数被定义在后台。当我们调用它，它应该失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; MyTest.<span class="string">"test hello"</span>()</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"world"</span></div></pre></td></tr></table></figure>
<h1 id="用属性存储信息"><a href="#用属性存储信息" class="headerlink" title="用属性存储信息"></a><span id="part-four">用属性存储信息</span></h1><p>为了完成我们的 TestCase 实现，我们需要能够访问所有被定义的测试用例。在运行时通过 __MODULE__.__info__(:functions) 获取测试用例来做到这点，这个函数将返回给定模块的所有函数组成的列表。但是，考虑到我们可能想要存储除了每一个测试用例名字外更多的信息，一个更灵活的方法是我们需要的。</p>
<p>在前面章节讨论模块属性时，我们提到了如何将它们用作临时存储。这正是我们将在本节中使用的属性。</p>
<p>在 __using__/1 的实现里，我们将初始化名为 @tests 的模块属性为一个空列表，然后存储每一个定义好的测试用例的名字到这个属性里，所以测试用例可以在run函数里被调用。</p>
<p>下面是 TestCase 模块修改后的代码：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">TestCase</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__using__</span></span>(_opts) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      import TestCase</div><div class="line"></div><div class="line">      <span class="comment"># 初始化 @tests 为一个空列表</span></div><div class="line">      <span class="variable">@tests</span> []</div><div class="line"></div><div class="line">      <span class="comment"># 模块被编译前调用 TestCase.__before_compile__/1</span></div><div class="line">      <span class="variable">@before_compile</span> TestCase</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Defines a test case with the given description.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      test "arithmetic operations<span class="string">" do</span></div><div class="line">        4 = 2 + 2</div><div class="line">      end</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">test</span></span>(description, <span class="symbol">do:</span> block) <span class="keyword">do</span></div><div class="line">    function_name = String.to_atom(<span class="string">"test "</span> &lt;&gt; description)</div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="comment"># 插入新定义的测试到测试列表</span></div><div class="line">      <span class="variable">@tests</span> [unquote(function_name) | <span class="variable">@tests</span>]</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(function_name)(), <span class="symbol">do:</span> unquote(block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 这将在目标模块被编译前被立即调用</span></div><div class="line">  <span class="comment"># 给我们完美的机会注入'run/0'函数</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__before_compile__</span></span>(env) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span> <span class="keyword">do</span></div><div class="line">        Enum.each <span class="variable">@tests</span>, <span class="keyword">fn</span> name -&gt;</div><div class="line">          IO.puts <span class="string">"Running <span class="subst">#&#123;name&#125;</span>"</span></div><div class="line">          apply(__MODULE_<span class="number">_</span>, name, [])</div><div class="line">        <span class="keyword">end</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>启动一个新的IEx，我们现在可以定义我们的测试用例并运行它们：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="keyword">use</span> TestCase</div><div class="line">...&gt;</div><div class="line">...&gt;   test <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;     <span class="string">"hello"</span> = <span class="string">"world"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; MyTest.run</div><div class="line">Running test hello</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>虽然我们忽略了一些细节，但是这是在Elixir里创建领域特定模块的主要思想。宏允许我们返回在调用者中执行的引用表达式，然后我们可以通过模块属性来用它转换代码并存储相关信息到目标模块中。最后，像 @before_compile 这样的回调，当它的定义完成的时候，允许我们注入代码到模块里。</p>
<p>除了 @before_compile ，还有其他有用的模块属性，像 @on_definition 和 @after_compile ，你可以在 <a href="https://hexdocs.pm/elixir/Module.html" target="_blank" rel="external">Module 模块的文档</a>里读到跟多关于它们的内容。你也可以在 Macro module 和 Macro.Env 文档里找到关于宏和编译环境的有用信息。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/domain-specific-languages.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/domain-specific-languages.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir中的元编程－宏]]></title>
      <url>http://szpzs.oschina.io/2017/02/26/elixir-getting-started-meta-macros/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">前言</a></li>
<li><a href="#part-two">我们第一个宏</a></li>
<li><a href="#part-three">宏的卫生</a></li>
<li><a href="#part-four">环境</a></li>
<li><a href="#part-five">私有宏</a></li>
<li><a href="#part-six">负责任地写宏</a></li>
</ol>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><span id="part-one">前言</span></h1><p>即使Elixir尽最大努力为宏提供一个安全的环境，但是用宏写干净的代码的主要责任落在开发者身上。宏比普通Elixir函数更难写，并且当它们不是必需的时候，使用它们被认为是一种坏的风格。所以要负责人地写宏。</p>
<p>Elixir已经通过使用它的数据结构和函数以一种简单和可读的方式提供了一种机制来写你每天的代码。宏只能作为最后的手段使用。记住，明确的优于暗示的。清晰代码优于简洁代码。</p>
<h1 id="我们第一个宏"><a href="#我们第一个宏" class="headerlink" title="我们第一个宏"></a><span id="part-two">我们第一个宏</span></h1><p>在Elixir里，宏通过 defmacro/2 定义。</p>
<blockquote>
<p>在本章，我们将使用文件来替代在IEx里运行代码样例。这是因为代码样例将跨多行而在IEx里输入它们将适得其反。你应该把代码样例保存在macros.exs文件里，用 elixir macros.exs 或 iex macros.exs 运行。</p>
</blockquote>
<p>为了更好地理解宏是如何工作的，让我们创建一个新模块分别用宏和函数来实现 unless ，也即 if 的相反功能：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Unless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun_unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">    if(!clause, <span class="symbol">do:</span> expression)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">macro_unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      if(!unquote(clause), <span class="symbol">do:</span> unquote(expression))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>函数接收入参然后传递给 if 。但是，如我们在<a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">前一章</a>所学，宏将接收引用表达式然后注入到引用，最后返回另一个引用表达式。</p>
<p>让我们用上面的模块来启动iex：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex macros.exs</div></pre></td></tr></table></figure>
<p>然后试一试那些定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; require Unless</div><div class="line">iex&gt; Unless.macro_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; Unless.fun_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div><div class="line"><span class="string">"this should never be printed"</span></div><div class="line"><span class="keyword">nil</span></div></pre></td></tr></table></figure>
<p>注意，在我们的宏实现了，句子没有被打印，而在我们的函数实现里，句子被打印了。那是因为传递给函数调用的入参在函数被调用前执行了。然而，宏不执行它们的入参。相反，它们接收入参作为引用表达式，然后转换为其他引用表达式。在本例子中，我们重写了 unless 宏，使得其实际上是一个 if 。</p>
<p>也就是说，当如下调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unless.macro_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div></pre></td></tr></table></figure>
<p>则我们的 macro_unless ，接收到如下所示内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macro_unless(<span class="keyword">true</span>, [<span class="symbol">do:</span> &#123;&#123;<span class="symbol">:</span>., [], [&#123;<span class="symbol">:__aliases__</span>, [<span class="symbol">alias:</span> <span class="keyword">false</span>], [<span class="symbol">:IO</span>]&#125;, <span class="symbol">:puts</span>]&#125;, [], [<span class="string">"this should never be printed"</span>]&#125;])</div></pre></td></tr></table></figure>
<p>然后它返回一个引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:if</span>, [],</div><div class="line"> [&#123;<span class="symbol">:</span>!, [], [<span class="keyword">true</span>]&#125;,</div><div class="line">  [<span class="symbol">do:</span> &#123;&#123;<span class="symbol">:</span>., [],</div><div class="line">     [&#123;<span class="symbol">:__aliases__</span>,</div><div class="line">       [], [<span class="symbol">:IO</span>]&#125;,</div><div class="line">      <span class="symbol">:puts</span>]&#125;, [], [<span class="string">"this should never be printed"</span>]&#125;]]&#125;</div></pre></td></tr></table></figure>
<p>我们可以用 Macro.expand_once/2 确认这个例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; expr = <span class="keyword">quote</span> <span class="symbol">do:</span> Unless.macro_unless(<span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span>)</div><div class="line">iex&gt; res  = Macro.expand_once(expr, __ENV_<span class="number">_</span>)</div><div class="line">iex&gt; IO.puts Macro.to_string(res)</div><div class="line">if(!<span class="keyword">true</span>) <span class="keyword">do</span></div><div class="line">  IO.puts(<span class="string">"this should never be printed"</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>Macro.expand_once/2 接收一个引用表达式然后依据当前环境扩展它。在本例子里，它扩展/调用 Unless.macro<em>unless/2 宏并且返回它的结果。我们然后继续转换返回的引用表达式为一个字符串并且打印它（我们将在这章后面讨论 \</em>_ENV__ ）。</p>
<p>这就是宏的所有内容。他们是关于接受引用表达式，并转化成其他东西。实际上，在Elixir里的 unless/2 就是用宏来实现的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defmacro</span> <span class="title">unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">  <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">    if(!unquote(clause), <span class="symbol">do:</span> unquote(expression))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>向 unless/2, defmacro/2, def/2, defprotocol/2 这样的结构，和在本教程中被使用的许多其他结构都是用纯Elixir实现的，经常是实现为一个宏。这意味着，用于构建语言的结构可以被开发人员用来将语言扩展到他们正在工作的领域。</p>
<p>我们可以定义一些函数和我们想要的宏，包括那些覆盖由Elixir提供的内置的定义。唯一的例外是Elixir的特殊形式，不用Elixir实现的，因此无法重写，<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary" target="_blank" rel="external">特殊形式的所有列表在Kernel.SpecialForms 里</a>。</p>
<h1 id="宏的卫生"><a href="#宏的卫生" class="headerlink" title="宏的卫生"></a><span id="part-three">宏的卫生</span></h1><p>Elixir宏有晚解决。它保证引用内定义的变量不会和宏展开的上下文里定义的变量冲突。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Hygiene</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">no_interference</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> a = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HygieneTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span></span> <span class="keyword">do</span></div><div class="line">    require Hygiene</div><div class="line">    a = <span class="number">13</span></div><div class="line">    Hygiene.no_interference</div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">HygieneTest.go</div><div class="line"><span class="comment"># =&gt; 13</span></div></pre></td></tr></table></figure>
<p>上述例子里，即使宏注入了 a = 1 ，它不会影响go函数里定义的变量 a。如果宏想明确地影响上下文，它可以用 var! ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Hygiene</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">interference</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> var!(a) = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HygieneTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span></span> <span class="keyword">do</span></div><div class="line">    require Hygiene</div><div class="line">    a = <span class="number">13</span></div><div class="line">    Hygiene.interference</div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">HygieneTest.go</div><div class="line"><span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>变量的卫生能运作只能是因为Elixir用上下文标注变量。例如，在一个模块的第三行定义的变量x将被表示成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:x</span>, [<span class="symbol">line:</span> <span class="number">3</span>], <span class="keyword">nil</span>&#125;</div></pre></td></tr></table></figure>
<p>但是，一个引用变量被表示成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">quoted</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Sample.quoted <span class="comment">#=&gt; &#123;:x, [line: 3], Sample&#125;</span></div></pre></td></tr></table></figure>
<p>注意，在引用变量里的第三个元素是原子 Sample ，而不是 nil ，这说明这个变量来自 Sample 模块。因此，Elixir认为这两个变量来自不同的模块和上下文，因此相应地分别处理它们。</p>
<p>Elixir为导入和别名也提供相似的机制。这保证了宏如它所在模块指定那样表现，而不会与它将被展开的所在模块发生冲突。Hygiene 可以在通过用像 var!/2 和 alias!/2 这样的宏特定的环境下被绕过，但是使用它们的时候必须要小心，因为它们直接修改用户环境。</p>
<p>有时候变量名字可以动态创建。在这种情况下，macro.var/2可以用来定义新的变量：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">initialize_to_char_count</span></span>(variables) <span class="keyword">do</span></div><div class="line">    Enum.map variables, <span class="keyword">fn</span>(name) -&gt;</div><div class="line">      var = Macro.var(name, <span class="keyword">nil</span>)</div><div class="line">      length = name |&gt; Atom.to_string |&gt; String.length</div><div class="line">      <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">        unquote(var) = unquote(length)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span> <span class="keyword">do</span></div><div class="line">    initialize_to_char_count [<span class="symbol">:red</span>, <span class="symbol">:green</span>, <span class="symbol">:yellow</span>]</div><div class="line">    [red, green, yellow]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">&gt; Sample.run <span class="comment">#=&gt; [3, 5, 6]</span></div></pre></td></tr></table></figure>
<p>注意 Macro.var/2 的第二个入参。这是正在使用的上下文，将决定在下一节描述的卫生。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><span id="part-four">环境</span></h1><p>在本章稍早前调用 Macro.expand<em>once/2 的时候，我们使用特别的形式 \</em>_ENV__。</p>
<p>__ENV__ 返回 Macro.Env 结构的一个实例，它含有有关编译环境的有用信息，包括当前模块、文件和行，所有在当前范围定义的变量，以及导入和需求等等：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; __ENV_<span class="number">_</span>.<span class="keyword">module</span></div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.file</div><div class="line"><span class="string">"iex"</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.requires</div><div class="line">[IEx.Helpers, Kernel, Kernel.Typespec]</div><div class="line">iex&gt; require Integer</div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.requires</div><div class="line">[IEx.Helpers, Integer, Kernel, Kernel.Typespec]</div></pre></td></tr></table></figure>
<p>Macro 模块里的许多函数期望有一个环境。你可以在 <a href="https://hexdocs.pm/elixir/Macro.html" target="_blank" rel="external">Macro 模块文档</a>里读到跟多有关这些函数的内容，也可以在 <a href="https://hexdocs.pm/elixir/Macro.Env.html" target="_blank" rel="external">Macro.Env 文档</a>里学到更多有关编译环境的知识。</p>
<h1 id="私有宏"><a href="#私有宏" class="headerlink" title="私有宏"></a><span id="part-five">私有宏</span></h1><p>Elixir用 defmacrop 也支持私有宏。像私有函数，这样的宏只能在定义它们的模块里有效，也只能在编译时有效。</p>
<p>宏在使用之前定义是很重要的。在调用之前不定义宏会在运行时引发错误，因为宏不会被扩展，将被转换为函数调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">...&gt;  <span class="function"><span class="keyword">def</span> <span class="title">four</span></span>, <span class="symbol">do:</span> two + two</div><div class="line">...&gt;  defmacrop two, <span class="symbol">do:</span> <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) <span class="symbol">iex:</span><span class="number">2</span>: function two/<span class="number">0</span> undefined</div></pre></td></tr></table></figure>
<h1 id="负责任地写宏"><a href="#负责任地写宏" class="headerlink" title="负责任地写宏"></a><span id="part-six">负责任地写宏</span></h1><p>宏是一个功能强大的结构并且Elixir提供了许多机制来确保他们被负责任地使用。</p>
<ul>
<li>宏是卫生的：默认情况下，宏中定义的变量不会影响用户代码。此外，函数调用和在宏观背景下可用的别名是不会泄漏到用户上下文。</li>
<li>宏是有词法范围的：在全局中注入代码或宏是不可能的。为了使用宏，你需要明确地需要或导入定义宏的模块。</li>
<li>宏是明确的：不明确调用宏是不可能运行宏的。例如，一些语言允许开发人员完全重写后台的功能，通常是通过解析变换或通过一些反射机制。在Elixir里，必须在编译时在调用者里明确地调用宏。</li>
<li>宏语言是清晰的：许多语言提供引用和非引用的语法快捷方式。在Elixir，为了清楚地划定一个宏的定义和引用表达式的界限，我们喜欢有明确的说明。</li>
</ul>
<p>即使有了这样的保证，开发者在负责编写宏时也扮演了重要角色。如果你有信心需要采用宏，请记住宏不是你的API。保持你的宏定义短，包括它们的引用内容。例如，不要像下面这样写宏：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyModule</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">my_macro</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      do_this(unquote(a))</div><div class="line">      ...</div><div class="line">      do_that(unquote(b))</div><div class="line">      ...</div><div class="line">      and_that(unquote(c))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>而是像下面这样写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyModule</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">my_macro</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="comment"># Keep what you need to do here to a minimum</span></div><div class="line">      <span class="comment"># and move everything else to a function</span></div><div class="line">      do_this_that_and_that(unquote(a), unquote(b), unquote(c))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">do_this_that_and_that</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    do_this(a)</div><div class="line">    ...</div><div class="line">    do_that(b)</div><div class="line">    ...</div><div class="line">    and_that(c)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这使你的代码更清晰，更容易测试和维，并且你可以直接调用和测试do_this_that_and_that / 3。它还有助于你为开发人员设计不想依赖宏的实际的API。</p>
<p>有了这些教程，我们完成了对宏的介绍。下一章讨论DSL，显示我们如何可以混合宏和模块属性来诠释和扩展模块和函数。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/macros.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/macros.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir中的元编程－Quote 和 Unquote]]></title>
      <url>http://szpzs.oschina.io/2017/02/25/elixir-getting-started-meta-quote-and-unquote/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Quoting</a></li>
<li><a href="#part-two">Unquoting</a></li>
<li><a href="#part-three">Escaping</a></li>
</ol>
<p>一个Elixir程序可以由Elixir自己的数据结构表示。在本章里，我们将学习那些数据结构看起来是什么样的，以及如何组成它们。在本章中学习的概念是宏的构建块，我们将在下一章中更深入地研究它。</p>
<a id="more"></a>
<h1 id="Quoting"><a href="#Quoting" class="headerlink" title="Quoting"></a><span id="part-one">Quoting</span></h1><p>一个Elixir程序的构建块上一个三元素的元组。例如，一个函数调用 sum(1, 2, 3) 被内部表示为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<p>你通过使用 quote 宏得到任何表达式的表示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<p>第一个元素是函数名，第二个元素是一个包含元数据的关键字列表，第三个元素是参数列表。</p>
<p>运算符也可以表示为这样的元组：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">1</span> + <span class="number">2</span></div><div class="line">&#123;<span class="symbol">:+</span>, [<span class="symbol">context:</span> Elixir, <span class="symbol">import:</span> Kernel], [<span class="number">1</span>, <span class="number">2</span>]&#125;</div></pre></td></tr></table></figure>
<p>甚至一个映射被表示为对 %{} 的调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> %&#123;<span class="number">1</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>变量也可以用这样的三元素的元组来表示，其最后一个元素不是一个列表而是一个原子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> x</div><div class="line">&#123;<span class="symbol">:x</span>, [], Elixir&#125;</div></pre></td></tr></table></figure>
<p>当引用更负责的表达式，我们可以看到代码用这样的元组来表示，这样的元组经常彼此嵌套为一个像一颗树的结构。许多语言叫这样的表示为抽象语法树（AST）。Elixir叫它们为被引用的表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, &#123;<span class="symbol">:+</span>, [<span class="symbol">context:</span> Elixir, <span class="symbol">import:</span> Kernel], [<span class="number">2</span>, <span class="number">3</span>]&#125;, <span class="number">4</span>]&#125;</div></pre></td></tr></table></figure>
<p>有时使用引用表达式时，返回代码的文本表示可能是有用的。这可以用 Macro.to_string/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span>, <span class="number">4</span>))</div><div class="line"><span class="string">"sum(1, 2 + 3, 4)"</span></div></pre></td></tr></table></figure>
<p>总的来说，以上元组按以下格式构造：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;atom | tuple, list, list | atom&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一个元素是一个原子或是相同表示格式的另一个元组。</li>
<li>第二个元素是一个包含元数据，比如数字和上下文，的关键字列表。</li>
<li>第三个元素是一个函数调用的参数列表或者一个原子。当这个元素是一个原子，则意味着这个元组表示一个变量。</li>
</ul>
<p>除了上述定义的元组，有五个Elixir字面量，当被引用的时候，返回的是它们自己（而不是一个元组）。它们是：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:sum</span>         <span class="comment">#=&gt; 原子</span></div><div class="line"><span class="number">1.0</span>          <span class="comment">#=&gt; 数字</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]       <span class="comment">#=&gt; 列表</span></div><div class="line"><span class="string">"strings"</span>    <span class="comment">#=&gt; 字符串</span></div><div class="line">&#123;key, value&#125; <span class="comment">#=&gt; 两个元素的元组</span></div></pre></td></tr></table></figure>
<p>大多数Elixir代码有一个它的底层引用表达式的直接翻译。我们建议你尝试不同的代码样例然后看看结果是怎么样的。例如，String.upcase(“foo”) 展开后是什么样子？我们也学到了 if(true, do: :this, else: :that) 和 if true do :this else :that end 是一样的。这个肯定是如何用引用表达式支持的？</p>
<h1 id="Unquoting"><a href="#Unquoting" class="headerlink" title="Unquoting"></a><span id="part-two">Unquoting</span></h1><p>quote是关于获取一些特指代码块的内部表示。但是，有时候可能必须注入一些其他特指代码块到我们想要获取的表示里。</p>
<p>例如，你有一个包含数字的变量number，你想要把它注入到一个引用表达式里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; number = <span class="number">13</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">11</span> + number)</div><div class="line"><span class="string">"11 + number"</span></div></pre></td></tr></table></figure>
<p>这不是我们想要的，因为number变量的值没有被注入并且number已经被引入表达式。为了注入number变量的值，unquote必须被使用在被引用的描述里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; number = <span class="number">13</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">11</span> + unquote(number))</div><div class="line"><span class="string">"11 + 13"</span></div></pre></td></tr></table></figure>
<p>unquote甚至可以被用于注入函数名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = <span class="symbol">:hello</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> unquote(fun)(<span class="symbol">:world</span>))</div><div class="line"><span class="string">"hello(:world)"</span></div></pre></td></tr></table></figure>
<p>在一些场景里，可能必须注入许多值在一个列表里。例如，假设你有一个列表 [1, 2, 6] 并且你想把 [3, 4, 5] 注入进去。使用 unquote 不会长生想要的结果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; inner = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> [<span class="number">1</span>, <span class="number">2</span>, unquote(inner), <span class="number">6</span>])</div><div class="line"><span class="string">"[1, 2, [3, 4, 5], 6]"</span></div></pre></td></tr></table></figure>
<p>这个时候就要使用 unquote_splicing ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; inner = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> [<span class="number">1</span>, <span class="number">2</span>, unquote_splicing(inner), <span class="number">6</span>])</div><div class="line"><span class="string">"[1, 2, 3, 4, 5, 6]"</span></div></pre></td></tr></table></figure>
<p>当使用宏的时候，Unquoting 非常有用。当写宏的时候，开发者能够接收代码块并且注入它们到其他代码块里，这能被用来转换代码或者写代码，在编译期间生成代码。</p>
<h1 id="Escaping"><a href="#Escaping" class="headerlink" title="Escaping"></a><span id="part-three">Escaping</span></h1><p>正如我们在本章开始的时候所见，在Elixir里只有一些值是有效引用表达式。例如，一个映射不是一个有效引用表达式。有四个元素的元组也不是。但是，这样的值可以被表达为一个引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> %&#123;<span class="number">1</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>在一些场景下，你可能需要注入这样的值到引用表达式里。为了这么做，我们需要首先用 Macro.escape/1 帮主来转义那些值为引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">hello:</span> <span class="symbol">:world</span>&#125;</div><div class="line">iex&gt; Macro.escape(map)</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [<span class="symbol">hello:</span> <span class="symbol">:world</span>]&#125;</div></pre></td></tr></table></figure>
<p>宏接收引用表达式并且必须返回引用表达式。然后，有些时候，在宏执行期间，你可能需要使用值并且使得值和将被需求的引用表达式之间有差别。</p>
<p>换句话说，使得一个普通Elixir值（像一个列表、一个映射、一个进程、一个引用等等）和一个引用表达式之间有差别是很重要的。一些值，比如，整数、原子和字符串，有一个引用表达式等于值的本身。其他值，像映射，需要被明确地转换。最后，像函数和引用这样的值完全不能被转换为引用表达式。</p>
<p>在 <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html" target="_blank" rel="external">Kernel.SpecialForms 模块</a>里，你可以阅读到跟多关于 quote 和 unquote 的内容。Macro.escape/1 和其他与引用表达式相关的函数的文档可以在 <a href="https://hexdocs.pm/elixir/Macro.html" target="_blank" rel="external">Macro 模块</a>里找到。</p>
<p>在这篇介绍文章里，我们已经为最终写我们的第一个宏奠定了基础，所以让我们开始下一章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/quote-and-unquote.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－分布式任务和配置]]></title>
      <url>http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个分布式代码</a></li>
<li><a href="#part-two">异步/等待</a></li>
<li><a href="#part-three">分布式任务</a></li>
<li><a href="#part-four">路由层</a></li>
<li><a href="#part-five">测试过滤器和标签</a></li>
<li><a href="#part-six">应用环境和配置</a></li>
<li><a href="#part-seven">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<a id="more"></a>
<p>在这最后一章，我们将回到 :kv 应用并增加一个路由层，这个路由层将允许我们基于bucket名字在节点间分布请求。</p>
<p>路由层将接收如下格式的一张路由表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line"> &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>路由器将根据表检查bucket名字的第一个字节然后据此来派发到合适的节点。例如，以字母“a”开头的一个bucket（?a表示字母“a”的Unicode代码点）将被派发到节点 foo@computer-name 。</p>
<p>如果匹配的条目指向处理请求的节点，那么我们就已经完成了路由，并且这个节点将执行请求的操作。如果匹配的条目指向一个不同的节点，我们将传递请求给这个节点，它将查询自己的路由表（可能与第一个节点的不同）并且做响应的动作。如果没有条目匹配，则一个错误将抛出。</p>
<p>你可能想知道为什么我们不告诉我们在我们的路由表找到的节点直接执行被请求的操作，而是传递路由请求给那个节点处理。尽管路由表和上面的那样简单，但在所有节点之间都可以合理地共享，这样当我们的应用程序增长时用这种方式传递路由请求使路由表变得更小。也许在某个时候，foo@computer-name 只是负责路由bucket的请求，而bucket被派发给不同的节点。用这种方式，bar@computer-name 不需要知道任何这些改变。</p>
<blockquote>
<p>注意：我们将在本章在同一个机器上使用两个节点。你可以自由地使用两台（或更多）不同的机器在同一网络，但你需要做一些准备工作。首先，你需要确认所有机器有一个有完全相同值的 ~/.erlang.cookie 文件。其次，你需要保证 <a href="http://www.erlang.org/doc/man/epmd.html" target="_blank" rel="external">epmd</a> 正运行在一个没有阻塞的端口（你可以运行 epmd -d 来输出调试信息）。最后，如果你想大体上学习更多分布式的知识，我们建议看 <a href="http://learnyousomeerlang.com/distribunomicon" target="_blank" rel="external">Learn You Some Erlang 里很棒的分布式章节</a>。</p>
</blockquote>
<h1 id="我们第一个分布式代码"><a href="#我们第一个分布式代码" class="headerlink" title="我们第一个分布式代码"></a><span id="part-one">我们第一个分布式代码</span></h1><p>Elixir自带了工具来链接节点以及在它们之间交换信息。实际上，当在一个分布式环境工作的时候，我们用进程、消息传递和接收消息相同的概念，因为Elixir进程是<em>位置透明的</em>。这就是说当发送一个消息的时候，不用关心接收进程是在同一个节点还是在另一个节点，虚拟机将能够在这两种情况下传递消息。</p>
<p>要运行分布式代码，我们需要用一个名字来启动虚拟机。名字可以是短的（当在同一个网络里）或长的（需要完整的计算机地址）。让我们启动一个新的IEx会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo</div></pre></td></tr></table></figure>
<p>你现在可以看到提示符有一点不同，显示了节点名字和计算机名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex(foo<span class="variable">@jv</span>)<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>
<p>我的机器名是 jv ，所以在上面的例子里我看到 foo@jv ，不过你将得到一个不同的结果。在后续的例子里我们将使用 foo@computer-name，当使用这些代码的时候，你应该相应地修改它们。</p>
<p>让我们在shell里定义一个叫Hello的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Hello</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">world</span></span>, <span class="symbol">do:</span> IO.puts <span class="string">"hello world"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你在同一个网络里的其他机器上已经装好了Erlang和Elixir，你可以在它上面启动另外一个IEx会话。否则，你可以在另一个终端启动另一个IEx会话。在这两种情况，给它一个短名叫做bar：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar</div></pre></td></tr></table></figure>
<p>注意，在这个新的IEx会话里，我们无法访问 Hello.world/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Hello.world</div><div class="line">** (UndefinedFunctionError) undefined <span class="symbol">function:</span> Hello.world/<span class="number">0</span></div><div class="line">    Hello.world()</div></pre></td></tr></table></figure>
<p>但是我们可以从 bar@computer-name 在 foo@computer-name 上创建一个新进程！让我们来试一试（@computer-name 是依据你自己的机器名字来写的）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt; Hello.world <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>Elixir在其他节点上启动一个进程并返回它的pid。代码在 Hello.world/0 函数所在的节点上被执行。注意：结果“hello world”打印在节点bar上而不是节点foo上。也就是说，被打印的消息从foo节点传回给bar节点。这是因为创建在其他节点（foo）上的进程仍然是有节点bar的组领导。我们已经简单地在<a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html#processes-and-group-leaders" target="_blank" rel="external">IO那一章</a>介绍了组领导的概念。</p>
<p>我们和往常一样可以与Node.spawn_link/2返回的pid进行消息的发送和接收操作。让我们尝试一个快速ping-pong例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   receive <span class="keyword">do</span></div><div class="line">...&gt;     &#123;<span class="symbol">:ping</span>, client&#125; -&gt; send client, <span class="symbol">:pong</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:ping</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:ping</span>, <span class="comment">#PID&lt;0.73.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:pong</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>从我们的快速探索，我们可以得出这样的结论：每一次我们需要做一个分布式计算的时候，我们应该用node.spawn_link/2在远程节点上创建进程。但是，我们已经从本教程学到，应该尽可能避免在监督树外创建进程，所以我们需要寻找其他方式。</p>
<p>有三种比 Node.spawn_link/2 更好的方式，我们在我们的实现里可以使用它们：</p>
<ol>
<li>我们可以使用Erlang的 <a href="http://www.erlang.org/doc/man/rpc.html" target="_blank" rel="external">:rpc模块</a>在远程节点上执行函数。在上面例子的bar@computer-name shell里，你可以调用 :rpc.call(:”foo@computer-name”, Hello, :world, []) ，它将打印“hello world”。</li>
<li>我们可以有一个运行在其他节点的服务，然后通过 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> API发送请求到那个节点。例如，你可以用 GenServer.call({name, node}, arg) 调用远程节点上的一个服务，或者传递远程进程的PID作为此函数的第一个入参。</li>
<li>我们可以使用我们在<a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">前一章</a>学到的<a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a>，因为它们可以在本地和远程节点被启动。</li>
</ol>
<p>上述三种选项有不同的特点。:rpc 和使用 GenServer 都是在一个单独服务器里顺序执行你的请求，而 Task 在远程节点上高效地异步运行，它唯一的顺序点是被监督者创建的时候。</p>
<p>对于我们的路由层，我们将使用Task，但是其他方式也可以去尝试。</p>
<h1 id="异步-等待"><a href="#异步-等待" class="headerlink" title="异步/等待"></a><span id="part-two">异步/等待</span></h1><p>到目前为止，我们已经探索了独立启动和运行的任务而不考虑它们的返回值。但是，有时候运行一个任务，然后在稍后读取它的值是有用的使用方式。为此，Task也提供了 async/await 模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task = Task.async(<span class="keyword">fn</span> -&gt; compute_something_expensive <span class="keyword">end</span>)</div><div class="line">res  = compute_something_else()</div><div class="line">res + Task.await(task)</div></pre></td></tr></table></figure>
<p>async/await 提供了一个种非常简单的机制并发地计算某些值。不仅如此，async/await 也可以被用于我们前面章节学到的 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 。我们只需要用 Task.Supervisor.async/2 替换 Task.Supervisor.start_child/2 然后稍后用 Task.await/2 读取结果。</p>
<h1 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a><span id="part-three">分布式任务</span></h1><p>分布式任务和被监督任务是一样的。唯一的区别是，我们在监督者上创建任务的时候传递的是节点名。打开 :kv 应用的 lib/kv/supervisor.ex 。让我们加入一个任务监督者作为监督树的最后一个孩子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KV.RouterTasks]]),</div></pre></td></tr></table></figure>
<p>现在，我们在 :kv 应用里启动两个命名的节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo -S mix</div><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>在 bar@computer-name 里，我们现在可以通过监督者在其他节点直接创建一个任务：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, node()&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.88.0&gt;, ref: #Reference&lt;0.0.0.400&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;</div></pre></td></tr></table></figure>
<p>我们的第一个分布式任务获取任务运行节点的名字。注意，我们给了一个匿名函数给 Task.Supervisor.async/2 ，但是， 在分布式场景里，最好是明确地指定模块、函数和函数的入参：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, Kernel, <span class="symbol">:node</span>, []</div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.89.0&gt;, ref: #Reference&lt;0.0.0.404&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line"><span class="symbol">:<span class="string">"foo@computer-name"</span></span></div></pre></td></tr></table></figure>
<p>这两者的区别是：匿名函数需要目标节点和调用者有一样的代码版本。使用模块、函数和函数入参更健壮，因为你只需要在给定的模块里找到匹配函数参数个数的函数。</p>
<p>有了这方面的知识，最后让我们来写路由代码。</p>
<h1 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a><span id="part-four">路由层</span></h1><p>创建一个有如下内容的文件 lib/kv/router.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Router <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Dispatch the given `mod`, `fun`, `args` request</div><div class="line">  to the appropriate node based on the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">route</span></span>(bucket, mod, fun, args) <span class="keyword">do</span></div><div class="line">    <span class="comment"># Get the first byte of the binary</span></div><div class="line">    first = <span class="symbol">:binary</span>.first(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># Try to find an entry in the table() or raise</span></div><div class="line">    entry =</div><div class="line">      Enum.find(table(), <span class="keyword">fn</span> &#123;enum, _node&#125; -&gt;</div><div class="line">        first <span class="keyword">in</span> enum</div><div class="line">      <span class="keyword">end</span>) || no_entry_error(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># If the entry node is the current node</span></div><div class="line">    if elem(entry, <span class="number">1</span>) == node() <span class="keyword">do</span></div><div class="line">      apply(mod, fun, args)</div><div class="line">    else</div><div class="line">      &#123;KV.RouterTasks, elem(entry, <span class="number">1</span>)&#125;</div><div class="line">      |&gt; Task.Supervisor.async(KV.Router, <span class="symbol">:route</span>, [bucket, mod, fun, args])</div><div class="line">      |&gt; Task.await()</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">no_entry_error</span></span>(bucket) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"could not find entry for <span class="subst">#&#123;inspect bucket&#125;</span> in table <span class="subst">#&#123;inspect table()&#125;</span>"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  The routing table.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># Replace computer-name with your local machine name.</span></div><div class="line">    [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">     &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>让我们写一个测试来验证我们的路由器是否正常。创建一个名为 test/kv/router_test.exs 文件，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RouterTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div><div class="line">    assert KV.Router.route(<span class="string">"hello"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"foo@computer-name"</span></span></div><div class="line">    assert KV.Router.route(<span class="string">"world"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"bar@computer-name"</span></span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"raises on unknown entries"</span> <span class="keyword">do</span></div><div class="line">    assert_raise RuntimeError, ~r/could <span class="keyword">not</span> find entry/, <span class="keyword">fn</span> -&gt;</div><div class="line">      KV.Router.route(&lt;&lt;<span class="number">0</span>&gt;&gt;, Kernel, <span class="symbol">:node</span>, [])</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个测试用例调用 Kernel.node/0 ，它将返回基于bucket的名字是 “hello” 和 “world”的当前节点的名字。根据我们目前的路由表，我们应该分别获得 foo@computer-name 和 bar@computer-name 作为响应。</p>
<p>第二个测试检查未知条目引起的代码异常。</p>
<p>为了运行第一个测试，我们需要两个节点来运行。来到 apps/kv 目录，启动一个名叫 bar 节点，它将被用来运行测试用例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>然后运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>测试将通过。</p>
<h1 id="测试过滤器和标签"><a href="#测试过滤器和标签" class="headerlink" title="测试过滤器和标签"></a><span id="part-five">测试过滤器和标签</span></h1><p>虽然我们的测试通过了，但是我们的测试结构变得越来越复杂。特别是，在我们的测试套件里只用 mix test 运行测试引起失败，因为我们的测试需要链接另一个节点。</p>
<p>幸运地，ExUnit有一个工具用来标签测试，允许我们运行指定的回调函数或者甚至完全基于那些标签过滤测试。我们已经在前面的章节里使用了 :capture_log 标签，它有被ExUnit指定的自己的语义。</p>
<p>这次让我们增加一个标签到 test/kv/router_test.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@tag</span> <span class="symbol">:distributed</span></div><div class="line">test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div></pre></td></tr></table></figure>
<p>写 @tag :distributed 等价于写 @tag distributed: true 。</p>
<p>测试被正确地标签，我们现在可以检查节点是否活在在网络里，如果没有节点没有在网络里活着，我们可以不考虑所有分布式测试。在 :kv 应用里打开 test/test_helper.exs ，然后加入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exclude =</div><div class="line">  if Node.alive?, <span class="symbol">do:</span> [], <span class="symbol">else:</span> [<span class="symbol">distributed:</span> <span class="keyword">true</span>]</div><div class="line"></div><div class="line">ExUnit.start(<span class="symbol">exclude:</span> exclude)</div></pre></td></tr></table></figure>
<p>现在用 mix test 运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div><div class="line">Excluding tags: [distributed: <span class="literal">true</span>]</div><div class="line"></div><div class="line">.......</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.1 seconds (0.1s on load, 0.01s on tests)</div><div class="line">7 tests, 0 failures, 1 skipped</div></pre></td></tr></table></figure>
<p>这一次所有测试都通过了并且ExUnit警告我们，分布式测试被忽略了。如果你用 $ elixir --sname foo -S mix test 运行测试，只要 bar@computer-name 这个节点可用，则刚才被忽略的那个测试将被运行并成功通过。</p>
<p>mix test 命令也允许我们动态包括和排除标签。例如，我们可以运行 $ mix test --include distributed 来运行分布式测试，而不管 test/test_helper.exs 里设置的值。我们也可以传递 --exclude 从命令行排除特定的标签。最后，--only 可以被用来运行只有特别标签的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case 模块文档</a>里阅读到更多的过滤器、标签和默认标签的内容。</p>
<h1 id="应用环境和配置"><a href="#应用环境和配置" class="headerlink" title="应用环境和配置"></a><span id="part-six">应用环境和配置</span></h1><p>目前我们硬编码路由表在 KV.Router 模块里。但是，我们想使得路由表是动态的。这不仅让我们配置开发/测试/生产环境，也允许不同节点在路由表里有不同内容。有一个OTP特性正好做这个事情：应用环境。</p>
<p>每一个应用有一个环境通过键来存储应用的特定配置。例如，我们可以存储路由表在 :kv 应用环境里，给它一个默认值，并且让其他应用在需要的时候修改这个表。</p>
<p>打开 apps/kv/mix.exs ，修改 application/0 函数返回如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">env:</span> [<span class="symbol">routing_table:</span> []],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们增加了一个新的键 :env 到应用里。它返回应用的默认环境，默认环境里有一个键为 :routing_table 的条目，其值为一个空的列表。应用程序环境与空表一起工作是有意义的，因为特定的路由表依赖于测试/部署结构。</p>
<p>为了在我们的代码里使用应用环境，我们需要用下面的内容来替换 KV.Router.table/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">The routing table.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">  Application.fetch_env!(<span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用 Application.fetch_env!/2 来读取 :kv 的环境的 :routing_table 条目。你可以在 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application 模块文档</a>里找到更多操作应用环境的信息和其他函数。</p>
<p>因为我们的路由表现在是空的，我们的分布式测试将会失败。重启应用并且重新运行测试来看它的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>应用环境有趣的是，它不仅被配置为当前应用，而是可以被配置为所有应用。这样的设置可以用 config/config.exs 文件来做到。例如，我们可以配置来修改IEx的默认提示符为其他值。只要打开 apps/kv/config/config.exs ，增加如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">config <span class="symbol">:iex</span>, <span class="symbol">default_prompt:</span> <span class="string">"&gt;&gt;&gt;"</span></div></pre></td></tr></table></figure>
<p>用 iex -S mix 启动IEx，你可以看到IEx的提示符已经改变。</p>
<p>这意味着，我们也可以在 apps/kv/config/config.exs 文件里直接配置我们的 :routing_table ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用你的本地节点替换 computer-name 。</span></div><div class="line">config <span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>,</div><div class="line">       [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">        &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>重启节点并再次运行分布式测试。现在它们应该全部通过。</p>
<p>从 Elixir v1.2 开始，所有伞型应用共享它们的配置，由于在伞型应用的根目录的 config/config.exs 文件里的如下一行，装载所有子应用的配置：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import_config <span class="string">"../apps/*/config/config.exs"</span></div></pre></td></tr></table></figure>
<p>mix run 命令也接收 --config 标签，允许配置文件按需提供。这个方法可以用来启动不同的节点，每个节点有它自己特定的配置（例如，不同的路由表）。</p>
<p>总体而言，内置配置应用的能力以及我们已经建立了我们的软件作为一个伞应用的事实，给我们在部署软件的时候提供了很多选择。</p>
<p>我们可以：</p>
<ul>
<li>部署伞型应用在一个节点将使得它既作为TCP服务器也作为键值存储。</li>
<li>部署 :kv_server 应用只作为TCP服务器只要路由表指向其他节点。</li>
<li>当我们想一个节点只作为一个存储（没有TCP访问）的时候，则只不是 :kv 应用。</li>
</ul>
<p>当我们在将来添加更多的应用程序时，我们可以继续使用粒度相同的级别来控制我们的部署，也可以继续选择用哪个配置给将要在生产上运行的应用。</p>
<p>我们也可以考虑用一个像<a href="https://github.com/bitwalker/distillery" target="_blank" rel="external">Distillery</a>的工具构建多发布版本，Distillery将打包被选择的应用和配置，包括当前安装的Erlang和Elixir安装，所以我们可以部署应用即使运行时没有预先在目标系统里被安装。</p>
<p>最后，我们在本章也学到一些新的东西，并且它也可以被应用到 :kv_server 。我们将留下一步作为一个练习：</p>
<ul>
<li>修改 :kv_server 应用从它的应用环境读取端口号而不是用硬编码值 4040 。</li>
<li>修改和配置 :kv_server 应用使用路由功能而不是直接派发给本地 KV.Registry 。为了 :kv_server 的测试，你可以使得路由表指向它自己的当前节点。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-seven">总结</span></h1><p>在本章，我们构建了一个简单的路由器作为一个方法来探索Elixir和Erlang虚拟机的分布式特性，也学会了如果配置它的路由表。这是我们的Mix和OTP教程的最后一章。</p>
<p>通过这个教程，我们已经构建一个简单的分布式键值存储当做一个机会来探索许多结构，像通用服务器、监督者、任务、agent、应用以及其他事物。不仅如此，我们为整个应用写了测试，熟悉 ExUnit ，并学习如何用 Mix 这个构建工具来完成很多任务。</p>
<p>如果你正在找用于生产的一个分布式键值存储，那么应该你一定去看看<a href="http://basho.com/riak/" target="_blank" rel="external">Riak</a>，它也运行在Erlang虚拟机里。在Riak里，bucket被复制，避免数据丢失；不是用路由表，它们而是使用 <a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="external">一致性哈希</a> 映射一个bucket到一个节点。当存储bucket的新的节点被加入到你的基础设施的时候，一致性哈希有助于减少需要被迁移的数据量。</p>
<p>这里有更多的课程可以学，希望目前为止你玩得开心！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－Docs、tests 和 with]]></title>
      <url>http://szpzs.oschina.io/2017/02/23/elixir-getting-started-mix-otp-docs-tests-and-with/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Doctests</a></li>
<li><a href="#part-two">with</a></li>
<li><a href="#part-three">运行命令</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将实现代码来分析我们在第一章描述的命令：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk <span class="number">1</span></div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs <span class="number">3</span></div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line"><span class="number">1</span></div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>分析做完后，我们将修改我们的服务器来派发被分析的命令给我们前面已经构建的 :kv 应用。</p>
<a id="more"></a>
<h1 id="Doctests"><a href="#Doctests" class="headerlink" title="Doctests"></a><span id="part-one">Doctests</span></h1><p>在Elixir语言首页，我们提到，Elixir使得文档在语言里作为第一类公民。我们已经在本指南探索这个概念多次，这些探索都是通过 mix help 或在IEx控制台上输入 h Enum 或 h 其他模块 来做到的。</p>
<p>在本节，我们将用 doctests 实现分析功能，它让我们直接在注释文档里写测试用例。这帮助我们提供有精确样例代码的注释文档。</p>
<p>让我们在 lib/kv_server/command.ex 创建我们的命令分析器，并用 doctest 启动：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Command <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">  Parses the given `line` into a command.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      iex&gt; KVServer.Command.parse "CREATE shopping\r\n<span class="string">"</span></div><div class="line">      &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:not_implemented</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Doctest通过在注释文档字符串里的缩进四个空格在紧跟 iex&gt; 提示符来指定。如果一个命令跨多行，你可以使用 …&gt; 作为在IEx里。期望的结果在 iex&gt; 或 …&gt; 行的下一行，用一个新行或新的 iex&gt; 前缀作为结束。</p>
<p>也要注意：我们用 @doc ~S””” 开始注释文档字符串。~S 阻止 \r\n 被转换为回车和换行，直到它们在测试里被计算。</p>
<p>为了运行我们的doctest，我们创建一个文件：test/kv_server/command_test.exs ，并且在测试用例里调用 doctest KVServer.Command ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.CommandTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line">  doctest KVServer.Command</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>运行这个测试，doctest将失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> doc at KVServer.Command.parse/1 (1) (KVServer.CommandTest)</div><div class="line">   <span class="built_in">test</span>/kv_server/command_test.exs:3</div><div class="line">   Doctest failed</div><div class="line">   code: KVServer.Command.parse <span class="string">"CREATE shopping\r\n"</span> === &#123;:ok, &#123;:create, <span class="string">"shopping"</span>&#125;&#125;</div><div class="line">   lhs:  :not_implemented</div><div class="line">   stacktrace:</div><div class="line">     lib/kv_server/command.ex:11: KVServer.Command (module)</div></pre></td></tr></table></figure>
<p>不错！</p>
<p>现在让我们使得 doctest 通过。让我们来实现 parse/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> String.split(line) <span class="keyword">do</span></div><div class="line">    [<span class="string">"CREATE"</span>, bucket] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:create</span>, bucket&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的实现用空格分割一行字符串，然后把命令和一个列表匹配起来。使用 String.split/1 意味着我们的命令将是空格不敏感的。前导和尾随空格无关紧要了，词与词之间的连续的空格也无关紧要。让我们加入一些新的doctest，用其他命令来测试这个行为模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">Parses the given `line` into a command.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "CREATE shopping\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "CREATE  shopping  \r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "PUT shopping milk <span class="number">1</span>\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:put, "shopping<span class="string">", "</span>milk<span class="string">", "</span><span class="number">1</span><span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "GET shopping milk\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:get, "shopping<span class="string">", "</span>milk<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "DELETE shopping eggs\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:delete, "shopping<span class="string">", "</span>eggs<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">Unknown commands or commands with the wrong number of</div><div class="line">arguments return an error:</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "UNKNOWN shopping eggs\r\n<span class="string">"</span></div><div class="line">    &#123;:error, :unknown_command&#125;</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "GET shopping\r\n<span class="string">"</span></div><div class="line">    &#123;:error, :unknown_command&#125;</div><div class="line"></div><div class="line">"<span class="string">""</span></div></pre></td></tr></table></figure>
<p>有了doctest，轮到你来使得测试通过了！一旦你准备好了，你可以比较你的实现和我们下面的解决方案：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> String.split(line) <span class="keyword">do</span></div><div class="line">    [<span class="string">"CREATE"</span>, bucket] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:create</span>, bucket&#125;&#125;</div><div class="line">    [<span class="string">"GET"</span>, bucket, key] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:get</span>, bucket, key&#125;&#125;</div><div class="line">    [<span class="string">"PUT"</span>, bucket, key, value] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:put</span>, bucket, key, value&#125;&#125;</div><div class="line">    [<span class="string">"DELETE"</span>, bucket, key] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:delete</span>, bucket, key&#125;&#125;</div><div class="line">    <span class="number">_</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：我们是如何能够优雅地分析命令，而不需要用大量的 if/else 分支来检查命令名字和参数个数！</p>
<p>最后，你可能已经观察到每一个doctest被认为是我们测试用例里的不同测试，因为我们的测试套件报告一共有7个测试。这是因为ExUnit认为如下所示是定义两个不同测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.Command.parse <span class="string">"UNKNOWN shopping eggs\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line"></div><div class="line">iex&gt; KVServer.Command.parse <span class="string">"GET shopping\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div></pre></td></tr></table></figure>
<p>而如下所示，中间没有新行，则ExUnit则编译它为一个单独的测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.Command.parse <span class="string">"UNKNOWN shopping eggs\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line">iex&gt; KVServer.Command.parse <span class="string">"GET shopping\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.DocTest.html" target="_blank" rel="external">ExUnit.DocTest 文档</a>里阅读更多关于doctest的内容。</p>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a><span id="part-two">with</span></h1><p>因为我们现在能够分析命令，我们终于可以开始实现逻辑来运行命令。现在让我们为这个函数添加一个存根（stub）定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Command <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Runs the given command.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(command) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在我们实现这个函数之前，让我们修改我们的服务器开始使用我们新的 parse/1 和 run/1 函数。记住：当客户端关闭套接字的时候，我们的 read_line/1 函数也崩溃，所以我们也找个机会修复它。打开 lib/kv_server.ex ，其内容如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  socket</div><div class="line">  |&gt; read_line()</div><div class="line">  |&gt; write_line(socket)</div><div class="line"></div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">  data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用如下内容替换它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  msg =</div><div class="line">    <span class="keyword">case</span> read_line(socket) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, data&#125; -&gt;</div><div class="line">        <span class="keyword">case</span> KVServer.Command.parse(data) <span class="keyword">do</span></div><div class="line">          &#123;<span class="symbol">:ok</span>, command&#125; -&gt;</div><div class="line">            KVServer.Command.run(command)</div><div class="line">          &#123;<span class="symbol">:error</span>, <span class="number">_</span>&#125; = err -&gt;</div><div class="line">            err</div><div class="line">        <span class="keyword">end</span></div><div class="line">      &#123;<span class="symbol">:error</span>, <span class="number">_</span>&#125; = err -&gt;</div><div class="line">        err</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">  write_line(socket, msg)</div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:ok</span>, text&#125;) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, text)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 已知错误。写到客户端。</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"UNKNOWN COMMAND\r\n"</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(_socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:closed</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 链接关闭，友好地退出。</span></div><div class="line">  exit(<span class="symbol">:shutdown</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, error&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 未知错误。写到客户端并退出。</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"ERROR\r\n"</span>)</div><div class="line">  exit(error)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果我们启动我们的服务器，我们现在可以发送命令给它。现在我们将得到两种不同的响应：当命令是已知的，是“OK”；否则，是“UNKNOWN COMMAND”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line">HELLO</div><div class="line">UNKNOWN COMMAND</div></pre></td></tr></table></figure>
<p>这意味着我们的实现在正确的方向上进行，不过它看起来不是很优雅，是吗？</p>
<p>以前的实现使用管道，使逻辑直截了当地前进。然而，现在我们需要处理不同的错误代码在前进的道路上，我们的服务器逻辑嵌套在许多case调用里。</p>
<p>幸运地是，Elixir v1.2 引入 with 结构，它允许你简化像上面的代码，有一个匹配分支链来替换嵌套的call调用。让我们用with重写serve/1：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  msg =</div><div class="line">    with &#123;<span class="symbol">:ok</span>, data&#125; &lt;- read_line(socket),</div><div class="line">         &#123;<span class="symbol">:ok</span>, command&#125; &lt;- KVServer.Command.parse(data),</div><div class="line">         <span class="symbol">do:</span> KVServer.Command.run(command)</div><div class="line"></div><div class="line">  write_line(socket, msg)</div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>好多了！with将获取 &lt;- 右边返回的值与 &lt;- 左边的模式进行匹配。如果值匹配上模式，则with继续移动到下一个表达式。如果没有匹配，则返回非匹配值。</p>
<p>也就是说，我们转换每一个给予 case/2 的表达式作为 with 里的一步。只要任何一步的返回值不能匹配 {:ok, x} ，则with终止，并且返回非匹配值。</p>
<p>你可以在<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">我们的文档</a>里读到更多关于with的内容。</p>
<h1 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a><span id="part-three">运行命令</span></h1><p>最后一步是实现 KVServer.Command.run/1 ，来运行分析好的对应于 :kv 应用的命令。它的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Runs the given command.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(command)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:create</span>, bucket&#125;) <span class="keyword">do</span></div><div class="line">  KV.Registry.create(KV.Registry, bucket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:get</span>, bucket, key&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    value = KV.Bucket.get(pid, key)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"<span class="subst">#&#123;value&#125;</span>\r\nOK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:put</span>, bucket, key, value&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    KV.Bucket.put(pid, key, value)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:delete</span>, bucket, key&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    KV.Bucket.delete(pid, key)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">lookup</span></span>(bucket, callback) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> KV.Registry.lookup(KV.Registry, bucket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt; callback.(pid)</div><div class="line">    <span class="symbol">:error</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>每一个函数分支派发合适的命令到 KV.Registry 服务器，这个服务器我们在 :kv 应用启动的时候注册了。由于我们的 :kv_server 取决于 :kv 应用，它是完全可以依靠它提供的服务。</p>
<p>注意：我们也提供了一个名为 lookup/2 的私有函数，它帮助查找一个bucket，如果此bucket存在则返回其pid，否则，返回 {:error, :not_found} 。</p>
<p>顺便说一句，既然我们现在将返回 {:error, :not_found} ，我们就应该修改 KVServer里的 write_line/2 函数，让它也打印这样的错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"NOT FOUND\r\n"</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的服务器功能几乎完成了。这剩下测试没完成。这次，我们最后剩下测试因为有一些重要考虑要做。</p>
<p>KVServer.Command.run/1的实现是直接发送命令给被 :kv 应用注册的名为 KV.Registry 的服务器。这意味着这个服务器是全局的，如果我们有两个测试用例同时发送消息给它，我们的测试用例将彼此冲突（并且可能失败）。我们需要在隔离和可以异步运行的单元测试之间做出决定，或者编写在全局状态之上工作的集成测试，但是在应用程序中执行我们的应用程序的完整堆栈，因为它意味着要在生产中进行操作。</p>
<p>到目前为止，我们只编写了单元测试，通常直接测试单个模块。然而，为了使kvserver.command.run/1作为一个可测试单元，我们需要改变它的实现，不能直接将命令发送到 KV.Registry 进程而是通过传递一个服务器作为参数。例如，我们将修改 run 函数的签名为 def run(command, pid) ，然后响应地修改所有分支：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:create</span>, bucket&#125;, pid) <span class="keyword">do</span></div><div class="line">  KV.Registry.create(pid, bucket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># ... 其他 run 函数分支 ...</span></div></pre></td></tr></table></figure>
<p>去做上面的修改，写一些单元测试。目的是你的测试用例将启动一个 KV.Registry 实例并且把它作为参数传递给 run/2 而不是依赖全局 KV.Registry 。这有利于保持我们的测试异步，因为没有共享状态。</p>
<p>由于这是我们迄今为止在测试中所做的方法，我们将尝试一些不同的方法。让我们来写集成测试，它依赖全局服务器名来运用从TCP服务器到bucket的整个栈。我们的集成测试将依赖全局状态并且必须是同步的。通过集成测试，我们得到了覆盖在我们应用中组件如何一起工作的测试性能的成本。它们通常用于测试应用程序中的主要流程。例如，我们应该避免使用集成测试来测试在我们的命令解析实现的边缘情况。</p>
<p>我们的集成测试将用一个TCP客户端发送命令给我们的服务器，然后断言我们将得到想要的响应。</p>
<p>让我们在 test/kv_server_test.exs 里实现集成测试，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServerTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    Application.stop(<span class="symbol">:kv</span>)</div><div class="line">    <span class="symbol">:ok</span> = Application.start(<span class="symbol">:kv</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    opts = [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>]</div><div class="line">    &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.connect(<span class="string">'localhost'</span>, <span class="number">4040</span>, opts)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">socket:</span> socket&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"server interaction"</span>, %&#123;<span class="symbol">socket:</span> socket&#125; <span class="keyword">do</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"UNKNOWN shopping\r\n"</span>) ==</div><div class="line">           <span class="string">"UNKNOWN COMMAND\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) ==</div><div class="line">           <span class="string">"NOT FOUND\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"CREATE shopping\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"PUT shopping eggs 3\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    <span class="comment"># GET 返回两行</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) == <span class="string">"3\r\n"</span></div><div class="line">    assert send_and_recv(socket, <span class="string">""</span>) == <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"DELETE shopping eggs\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    <span class="comment"># GET 返回两行</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) == <span class="string">"\r\n"</span></div><div class="line">    assert send_and_recv(socket, <span class="string">""</span>) == <span class="string">"OK\r\n"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">send_and_recv</span></span>(socket, command) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.send(socket, command)</div><div class="line">    &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>, <span class="number">1000</span>)</div><div class="line">    data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的集成测试检查所有服务器交互，包括未知命令和not found错误。值得注意的是，因为有ETS表和被链接进程，没有必要关闭套接字。一旦测试进程退出，套接字自动关闭。</p>
<p>这次因为我们的测试依赖全局数据，所有我们没有给 ExUnit.Case 设置 async: true 。另外，为了保证我们的测试总是在一个干净的状态中，在每一个测试用例前我们停止然后启动 :kv 应用。实际上，停止 :kv 应用甚至在终端打印一条警告信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">18:12:10.698 [info] Application kv exited: :stopped</div></pre></td></tr></table></figure>
<p>为了避免在测试期间打印日志消息，ExUnit提供了一个方便的特性，叫做 :capture_log 。通过在每一个测试用例前设置 @tag :capture_log 或为整个测试设置 @moduletag :capture_log ，ExUnit 将捕获在测试运行的时候记录的任何日志。如果我们的测试失败，被捕获的日志将和ExUnit报告一起被打印出来。</p>
<p>在 use ExUnit.Case 和 setup 之间增加如下调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@moduletag</span> <span class="symbol">:capture_log</span></div></pre></td></tr></table></figure>
<p>如果测试崩溃，你将看到如下的报告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>) test server interaction (KVServerTest)</div><div class="line">   test/kv_server_test.<span class="symbol">exs:</span><span class="number">17</span></div><div class="line">   ** (RuntimeError) oops</div><div class="line">   <span class="symbol">stacktrace:</span></div><div class="line">     test/kv_server_test.<span class="symbol">exs:</span><span class="number">29</span></div><div class="line"></div><div class="line">   The following output was <span class="symbol">logged:</span></div><div class="line"></div><div class="line">   <span class="number">13</span><span class="symbol">:</span><span class="number">44</span><span class="symbol">:</span><span class="number">10.035</span> [info]  Application kv <span class="symbol">exited:</span> <span class="symbol">:stopped</span></div></pre></td></tr></table></figure>
<p>通过这个简单的集成测试，我们开始明白为什么集成测试可能是缓慢的。 这个集成测试不仅不能异步运行，它还需要停止和启动 :kv 应用这样的耗时步骤。</p>
<p>最后，由你和你的团队为你们的应用制定出最好的测试策略。你需要平衡代码质量、信心和测试套件运行时。例如，我们可能一开始只有集成测试服务器的测试，但是如果服务器继续在将来的版本中成长，或它成为频繁的错误应用的一部分，重要的是要考虑分解集成测试，写更多的单元测试，无须集成测试这么重。</p>
<p>在下一章，我们通过增加一个bucket路由机制最终使得我们的系统成为分布式。我们也将学习应用配置。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－Task和gen_tcp]]></title>
      <url>http://szpzs.oschina.io/2017/02/22/elixir-getting-started-mix-otp-task-and-gen-tcp/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Echo服务器</a></li>
<li><a href="#part-two">Tasks</a></li>
<li><a href="#part-three">Tasks监督者</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将学习如何使用<a href="http://www.erlang.org/doc/man/gen_tcp.html" target="_blank" rel="external">Erlang的 :gen_tcp 模块</a>来处理请求。这提供一个很好的机会来探索Elixir的Task模块。在将来的章节我们将扩展我们的服务器以便使得它可以真正地处理命令。</p>
<a id="more"></a>
<h1 id="Echo服务器"><a href="#Echo服务器" class="headerlink" title="Echo服务器"></a><span id="part-one">Echo服务器</span></h1><p>我们将首先实现一个echo服务器来开始我们的TCP服务器。它将发送一个响应，响应内容是它接收到的请求的文本。我们将慢慢地改善我们的服务器，一直到它被监督并且准备好处理多链接。</p>
<p>从广义的角度来看，在一个 TCP 服务器执行以下步骤︰</p>
<ol>
<li>侦听一个端口，直到端口可用，并获取套接字</li>
<li>在那个端口等待客户端链接并接受它</li>
<li>读取客户端的请求并写响应回去</li>
</ol>
<p>让我们来实现这些步骤。来到 apps/kv_server 应用，打开 lib/kv_server.ex ，然后增加如下的函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">require Logger</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(port) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 下面的选项的意思：</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># 1. `:binary` - 以二进制数据方式接收数据（而不是列表）</span></div><div class="line">  <span class="comment"># 2. `packet: :line` - 一行行地接收数据</span></div><div class="line">  <span class="comment"># 3. `active: false` - 阻塞在 `:gen_tcp.recv/2` 一直到有数据可用</span></div><div class="line">  <span class="comment"># 4. `reuseaddr: true` - 如果侦听者崩溃，允许我们重用地址</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.listen(port,</div><div class="line">                    [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>, <span class="symbol">reuseaddr:</span> <span class="keyword">true</span>])</div><div class="line">  Logger.info <span class="string">"Accepting connections on port <span class="subst">#&#123;port&#125;</span>"</span></div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  serve(client)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  socket</div><div class="line">  |&gt; read_line()</div><div class="line">  |&gt; write_line(socket)</div><div class="line"></div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">  data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将通过调用 KVServer.accept(4040) 来启动我们的服务器，4040是一个端口。accept/1 里的第一步是侦听一个端口一直到套接字可用，接着调用 loop_acceptor/1 。loop_acceptor/1 是一个接收客户端链接的循环。对于每一个接收到的链接，我们调用 serve/1 。</p>
<p>serve/1 是另一个循环，它从套接字读取一行数据然后把这些数据写回给套接字。注意：serve/1 函数用了 <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" target="_blank" rel="external">管道运算符 |&gt;</a> 来表达操作的数据流。管道运算符计算其左边的表达式并将其结果作为第一个入参传递给其右边的函数。上述例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket |&gt; read_line() |&gt; write_line(socket)</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">write_line(read_line(socket), socket)</div></pre></td></tr></table></figure>
<p>read_line/1 用 :gen_tcp.recv/2 实现从套接字接收数据，而write_line/2 用 :gen_tcp.send/2 写数据到套接字。</p>
<p>注意：serve/1 在 loop_acceptor/1 里被顺序地无限循环地调用，所以对 loop_acceptor/1 的尾调用永远不会到达，因此应该被避免。但是，正如我们将看到的，我们将需要在一个隔离的进程里执行 serve/1 ，所以我们很快就需要这样的尾调用。</p>
<p>这几乎是实现我们echo服务器所有需要的内容。让我们来试一下！</p>
<p>在 kv_server 应用里用 iex -S mix 启动一个IEx会话。在IEx里运行：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.accept(<span class="number">4040</span>)</div></pre></td></tr></table></figure>
<p>服务器现在正在运行，你甚至会注意到控制台被阻塞。让我们用<a href="https://en.wikipedia.org/wiki/Telnet" target="_blank" rel="external">一个telnet客户端</a>来访问我们的服务器。大多数操作系统上都有客户端，它们的命令行大致相同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">hello</div><div class="line">hello</div><div class="line">is it me</div><div class="line">is it me</div><div class="line">you are looking <span class="keyword">for</span>?</div><div class="line">you are looking <span class="keyword">for</span>?</div></pre></td></tr></table></figure>
<p>输入“hello”，按下回车键，你将得到回复的“hello”。完美！</p>
<p>我的特别的telnet客户端可以通过输入 ctrl + ] ，接着输入 quit ，再按下回车键 来退出，但是你的客户端可能需要不同的步骤。</p>
<p>一旦你退出了telnet客户端，你将可能在IEx会话里看到一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> &#123;<span class="symbol">:error</span>, <span class="symbol">:closed</span>&#125;</div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">45</span>: KVServer.read_line/<span class="number">1</span></div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">37</span>: KVServer.serve/<span class="number">1</span></div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">30</span>: KVServer.loop_acceptor/<span class="number">1</span></div></pre></td></tr></table></figure>
<p>这是因为我们期望从 :gen_tcp.recv/2 获得数据，但是客户端关闭了链接。在我们服务器将来的修订版里我们需要更好地处理这样的情况。</p>
<p>现在我们有一个更重要的bug需要去修复：如果我们的TCP接收者崩溃会发生什么？因为没有监督，服务器死掉而我们将不能服务更多请求，因为服务器不能被重启。这就是为什么我们必须把我们的服务器移到一颗监督树里的原因。</p>
<h1 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a><span id="part-two">Tasks</span></h1><p>我们已经学习了agent，通用服务器和监督者。它们都可以处理多消息或者管理状态。当我们只是需要执行一些任务的时候我们用哪个而它又是什么？</p>
<p><a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task模块</a>提供了这个功能。例如，它有一个 start_link/3 函数，此函数接收一个模块、函数和函数的参数作为入参，让我们运行一个给定的函数作为一个监督树的一部分。</p>
<p>让我们试试它。打开 lib/kv_server/application.ex ，让我们修改 start/2 函数里的监督者，修改如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">  import Supervisor.Spec</div><div class="line"></div><div class="line">  children = [</div><div class="line">    worker(Task, [KVServer, <span class="symbol">:accept</span>, [<span class="number">4040</span>]])</div><div class="line">  ]</div><div class="line"></div><div class="line">  opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">  Supervisor.start_link(children, opts)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>经过这个修改，我们说我们想运行 KVServer.accept(4040) 作为一个工作者。现在我们硬编码端口号，不过稍后我们将讨论修改这种方式。</p>
<p>现在服务器是监督树的一部分，当我们启动应用的时候它将自动启动。在终端里输入 mix run –no-halt ，然后再次使用 telnet 客户端来确认所有事情都依然运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">say you</div><div class="line">say you</div><div class="line">say me</div><div class="line">say me</div></pre></td></tr></table></figure>
<p>对的，它运行着！如果你杀掉客户端，整个服务器也崩溃。但是你将看到另一个服务器马上起来。但是，它的扩展性如何？</p>
<p>尝试同时链接两个telnet客户端。当你这么做的时候，你将注意到第二个客户端没有回声消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">hello</div><div class="line">hello?</div><div class="line">HELLOOOOOO?</div></pre></td></tr></table></figure>
<p>它好像没有完全正确运行。这是因为我们在接收链接的进程里处理请求。当一个客户端被链接了，我们就不能再接收另一个客户端。</p>
<h1 id="Tasks监督者"><a href="#Tasks监督者" class="headerlink" title="Tasks监督者"></a><span id="part-three">Tasks监督者</span></h1><p>为了使得我们的服务器处理同时发生的链接，我们需要有一个作为接收者的进程创建其他进程来处理请求。一个解决方案是将如下所示内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  serve(client)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>改为用 Task.start_link/1 ，它和 Task.start_link/3  相似，不过它接收一个匿名函数而不是模块、函数和函数的参数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  Task.start_link(<span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们从接收者进程直接启动一个被链接的任务。但是我们已经犯了一次错。你还记得吗？</p>
<p>这个错与当我们从registry直接调用 KV.Bucket.start_link/0 造成的错误相似。这意味着在任何一个bucket的错误将把整个registry搞垮。</p>
<p>上面的代码有同样的瑕疵：如果我们链接 serve(client) 这个任务到接收者，当它处理请求的时候崩溃，则会导致接收者乃至其他所有链接崩溃。</p>
<p>我们通过用 :simple_one_for_one 这种监督者来为registry修复这个问题。我们将使用相同的策略，除了这个模式是如此常见，Task已经有一个解决方案：一个 :simple_one_for_one 监督者启动临时任务作为我们的监督树的一部分。</p>
<p>让我们再次修改 start/2 ，增加一个监督者到我们的监督树：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">  import Supervisor.Spec</div><div class="line"></div><div class="line">  children = [</div><div class="line">    supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KVServer.TaskSupervisor]]),</div><div class="line">    worker(Task, [KVServer, <span class="symbol">:accept</span>, [<span class="number">4040</span>]])</div><div class="line">  ]</div><div class="line"></div><div class="line">  opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">  Supervisor.start_link(children, opts)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们现在将用 KVServer.TaskSupervisor 这个名字启动一个 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 进程。记住：因为接收者任务依赖这个监督者，因此这个监督者必须先启动。</p>
<p>现在我们需要修改 loop_acceptor/1 使用 Task.Supervisor 来处理每一个请求：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, pid&#125; = Task.Supervisor.start_child(KVServer.TaskSupervisor, <span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">  <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.controlling_process(client, pid)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你可能注意到我们增加了一行，:ok = :gen_tcp.controlling_process(client, pid) 。这使得子进程成为 client 这个套接字进程的“控制进程”。如果我们不这么做，如果接收者崩溃，它将把所有客户端都搞崩溃，因为套接字被绑定到接收它们的进程（这是默认的行为）。</p>
<p>用 mix run –no-halt 启动一个新的服务器，然后我们现在可以打开许多并发的telnet客户端。你也将注意到，退出一个客户端，不会把接收者搞崩溃。非常好！</p>
<p>下面是整个echo服务器的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span> <span class="keyword">do</span></div><div class="line">  require Logger</div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts accepting connections on the given `port`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(port) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.listen(port,</div><div class="line">                      [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>, <span class="symbol">reuseaddr:</span> <span class="keyword">true</span>])</div><div class="line">    Logger.info <span class="string">"Accepting connections on port <span class="subst">#&#123;port&#125;</span>"</span></div><div class="line">    loop_acceptor(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = Task.Supervisor.start_child(KVServer.TaskSupervisor, <span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.controlling_process(client, pid)</div><div class="line">    loop_acceptor(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">    socket</div><div class="line">    |&gt; read_line()</div><div class="line">    |&gt; write_line(socket)</div><div class="line"></div><div class="line">    serve(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">    data</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们已经修改了监督者规格说明，我们要问：我们的监督策略还正确吗？</p>
<p>在现在的情况下，答案是：正确。如果接收者崩溃，无需崩溃已经存在的链接。在另一方面，如果任务监督者崩溃，也不需要崩溃接收者。</p>
<p>在下一章，我们将开始分析客户端请求和发送响应，并结束我们的服务器。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－依赖和伞型项目]]></title>
      <url>http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">外部依赖</a></li>
<li><a href="#part-two">内部依赖</a></li>
<li><a href="#part-three">伞型项目</a></li>
<li><a href="#part-four">伞型项目里的依赖</a></li>
<li><a href="#part-five">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将讨论用Mix如何管理依赖。</p>
<p>我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。</p>
<p>构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。</p>
<a id="more"></a>
<h1 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a><span id="part-one">外部依赖</span></h1><p>外包依赖是没有绑定到你的业务领域的。例如，如果你需要为你的分布式 kv 应用提供HTTP API，你可以用 <a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a> 项目作为一个外包依赖。</p>
<p>安装外部依赖是简单的。最常见的，我们通过在我们的mix.exs文件里的deps函数内列出依赖来使用 <a href="https://hex.pm/" target="_blank" rel="external">Hex包管理器</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="string">"~&gt; 1.0"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个依赖指向已经发布到Hex的Plug的1.x.x版本系列的最新版本。这由版本号数字前的 ~&gt; 符号表示。有关指定版本要求的更多信息，请参见<a href="https://hexdocs.pm/elixir/Version.html" target="_blank" rel="external">版本模块的文档</a>。</p>
<p>通常，稳定版本被发布到Hex。如果你想依赖一个还处于开发中的外部依赖，Mix也能够管理git依赖：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="symbol">git:</span> <span class="string">"git://github.com/elixir-lang/plug.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你将注意到，当你增加一个依赖到你的项目，Mix生成一个mix.lock文件来保证<em>可重复构建</em>。这个lock文件必需被提交到你的版本控制系统，以便保证所有使用这个项目的人将使用和你一样的依赖版本。</p>
<p>Mix提供很多任务来处理依赖，这些任务可以用 mix help 来列出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">help</span></div><div class="line">mix deps              <span class="comment"># 列出依赖和它们的状态</span></div><div class="line">mix deps.clean        <span class="comment"># 删除给定的依赖文件</span></div><div class="line">mix deps.compile      <span class="comment"># 编译依赖</span></div><div class="line">mix deps.get          <span class="comment"># 获取所有过时的依赖</span></div><div class="line">mix deps.tree         <span class="comment"># 打印依赖树</span></div><div class="line">mix deps.unlock       <span class="comment"># 解锁给定的依赖</span></div><div class="line">mix deps.update       <span class="comment"># 更新给定的依赖</span></div></pre></td></tr></table></figure>
<p>最常用的任务是 mix deps.get 和 mix deps.update 。一旦被获取到，依赖被自动编译。你可以通过输入 mix help deps 和在 <a href="https://hexdocs.pm/mix/Mix.Tasks.Deps.html" target="_blank" rel="external">Mix.Tasks.Deps 模块文档</a>里读到更多关于依赖的内容。</p>
<h1 id="内部依赖"><a href="#内部依赖" class="headerlink" title="内部依赖"></a><span id="part-two">内部依赖</span></h1><p>内部依赖项是特定于你的项目的依赖。它们通常在你的项目/公司/组织范围之外是没有意义的。大多数时候，你想让他们私有化，无论是由于技术，经济或商业原因。</p>
<p>如果你有一个内部依赖，Mix支持两种方法与它一起工作：git仓库和伞型项目。</p>
<p>例如，如果你推送 kv 应用到一个git仓库，你将需要在你的依赖代码里列出它以便使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">git:</span> <span class="string">"https://github.com/YOUR_ACCOUNT/kv.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果仓库是私有的，您可能需要指定私有URL git@github.com:YOUR_ACCOUNT/kv.git 。在任何情况下，Mix将能够把它拿来给你，只要你有适当的凭据。</p>
<p>在Elixir里不鼓励使用git依赖作为内部依赖。记住：运行时和Elixir生态已经提供了应用这个概念。因此，我们希望你经常将你的代码分解成可以被逻辑地组织的应用，即使在单个项目中也是如此。</p>
<p>然而，如果你把每个应用作为一个独立的项目放入一个git仓库，那么你的项目可能非常难以维护，因为你将花费大量时间来管理那些git仓库而不是写你代码。</p>
<p>因为这个原因，Mix支持“伞型项目”。伞型项目允许你创建一个项目，它拥有许多项目，而且保持它们在一个单独源码仓库里。这正是下一节我们将要探索的风格。</p>
<p>让我们创建一个新的Mix项目。我们将创造性地命名它为 kv_umbrella ，这个新项目里面将拥有已经存在的 kv 应用和新的 kv_server 应用。目录结构将如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>关于这个方法令人感兴趣的事情是，Mix有许多遍历措施来处理这样的项目，诸如用一个命令将apps里的所有应用都编译和测试的能力。但是，尽管它们都在apps目录里，它们依然是彼此解耦的，所以，如果你想的话，你就可以独立地构建、测试和部署每一个应用。</p>
<p>所以让我们开始吧！</p>
<h1 id="伞型项目"><a href="#伞型项目" class="headerlink" title="伞型项目"></a><span id="part-three">伞型项目</span></h1><p>让我们用 mix new 开始一个新项目。这个新项目将被命名为 kv_umbrella ，并且在创建它的时候，我们需要传递 --umbrella 参数。不要在已经存在的 kv 项目里创建这个新项目！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix new kv_umbrella --umbrella</div><div class="line">* creating .gitignore</div><div class="line">* creating README.md</div><div class="line">* creating mix.exs</div><div class="line">* creating apps</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div></pre></td></tr></table></figure>
<p>从打印出来的信息我们可以看到生成的文件少了很多。生成的mix.exs文件也不同。让我们看一看这个文件（注释已经被删除）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KvUmbrella</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">apps_path:</span> <span class="string">"apps"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>使得这个项目与前面的项目不同的是在项目定义里有一个 apps_path: “apps” 条目。它的意思是这个项目将表现得像一把伞。这样的项目既没有源码文件也没有测试用例，但是它们可以有它们自己的依赖。每一个子应用必须定义在apps目录里。</p>
<p>让我们进入apps目录里开始构建 kv_server 。这一次，我们将传递 --sup 标志，它将告诉Mix自动为我们生成一颗监督树，替代在前面章节里如我们所做的手工构建监督树：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv_umbrella/apps</div><div class="line">$ mix new kv_server --module KVServer --sup</div></pre></td></tr></table></figure>
<p>生成的文件与我们第一次为 kv 所生成的相似，有一些不同。让我们打开 mix.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv_server</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line">     <span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line">     <span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line">     <span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.4"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">     <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>首先，因为我们在kv_umbrella/apps里创建这个项目，Mix自动监测到伞型结构并且增加四行到项目定义里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>这些选项的意思是，所有选项将被放置到 kv_umbrella/deps ，并且它们将共享同样的构建、配置和锁文件。这确保为整个伞型结构，依赖将被获取并被编译一次，而不是每一个伞型应用一次。</p>
<p>第二个改变是在 mix.exs 里的 application 函数中：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们传递了 --sup 标志，Mix自动增加了 mod: {KVServer.Application, []} ，指明 KVServer.Application 是我们的应用回调模块。KVServer.Application 将启动我们的应用监督树。</p>
<p>事实上，让我们打开 lib/kv_server/application.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Application <span class="keyword">do</span></div><div class="line">  <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Application.html</span></div><div class="line">  <span class="comment"># for more information on OTP Applications</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    import Supervisor.Spec, <span class="symbol">warn:</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">    <span class="comment"># Define workers and child supervisors to be supervised</span></div><div class="line">    children = [</div><div class="line">      <span class="comment"># Starts a worker by calling: KVServer.Worker.start_link(arg1, arg2, arg3)</span></div><div class="line">      <span class="comment"># worker(KVServer.Worker, [arg1, arg2, arg3]),</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Supervisor.html</span></div><div class="line">    <span class="comment"># for other strategies and supported options</span></div><div class="line">    opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">    Supervisor.start_link(children, opts)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：它定义了应用回调函数，start/2，而不是使用 Supervisor 模块定义一个名为 KVServer.Supervisor 的监督者，它便捷地在行内定义了监督者！你可以通过阅读<a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor模块文档</a>获得更多这样的监督者的内容。</p>
<p>我们已经可以试试我们第一个伞型子应用。我们可以在 apps/kv_server 里运行测试，但是那样不好玩。相反，到伞型项目的根目录，运行 mix test ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>它正常运行！</p>
<p>因为我们想让 kv_server 最终使用我们在 kv 里定义的功能，因此我们需要将 kv 作为一个依赖加入我们的应用。</p>
<h1 id="伞型项目里的依赖"><a href="#伞型项目里的依赖" class="headerlink" title="伞型项目里的依赖"></a><span id="part-four">伞型项目里的依赖</span></h1><p>Mix支持一种简单的机制使得一个伞型子应用依赖于另一个伞型子应用。打开 apps/kv_server/mix.exs 并且按如下所示修改 deps/0 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">in_umbrella:</span> <span class="keyword">true</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述代码使得 :kv作为 :kv_server 里的一个可用依赖并且在启动 :kv_server 前自动启动 :kv 应用。</p>
<p>最后，拷贝我们已经构建好的 kv 应用到我们新的伞型项目的 apps 目录里。最终的目录结构和我们前面提到的结构匹配上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>我们现在需要修改 apps/kv/mix.exs 让其包含我们已经在 apps/kv_server/mix.exs 所见到的伞型相关条目。打开 apps/kv/mix.exs 并将如下内容加入 project 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>现在你可以从伞型项目根目录用 mix test 运行两个应用的测试。太棒了！</p>
<p>请记住，伞型项目是一个方便工具用来帮助你组织和管理你的应用。apps 目录里的应用仍然是彼此解耦的。它们之间的依赖必须明确地列出来。这允许它们被一起开发，但是如果需要的话，独立地编译、测试和部署。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-five">总结</span></h1><p>在这一章，我们学到了更多关于Mix依赖和伞型项目的内容。我们决定构建一个伞型项目，因为我们认为 kv 和 kv_server 是内部依赖的，其重要性只存在于这个项目的上下文里。</p>
<p>在将来，你将写应用并且你将注意到它们可以被提取到一个简洁的单元，这个单元能被不同的项目使用。在这种情况下，使用Git或Hex依赖是要走的路。</p>
<p>这里有几个问题，当你使用依赖的时候你可以问自己。问题是：这个应用在这个项目之外有意义吗？</p>
<ul>
<li>如果没有，则使用一个有伞型子应用的伞型项目。</li>
<li>如果有，则这个项目在你的公司或组织外部可以被共享吗？<ul>
<li>不可以， 则使用一个私有git仓库。</li>
<li>如果可以，则推送你的代码到一个git仓库并且用Hex做频繁的发布。</li>
</ul>
</li>
</ul>
<p>我们的伞型项目构建好并运行了，是时候开始写我们的服务器了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－ETS]]></title>
      <url>http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">ETS作为缓存</a></li>
<li><a href="#part-two">竞争条件</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！</p>
<p>在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。</p>
<blockquote>
<p>警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。</p>
</blockquote>
<a id="more"></a>
<h1 id="ETS作为缓存"><a href="#ETS作为缓存" class="headerlink" title="ETS作为缓存"></a><span id="part-one">ETS作为缓存</span></h1><p>ETS允许我们存储任何Elixir数据到一个内存表里。与ETS表交互是通过Erlang :ets 模块做到的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:set</span>, <span class="symbol">:protected</span>])</div><div class="line"><span class="number">8207</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(table, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>当创建一个ETS表的时候，需要两个入参：一个表名字和一个选项集合。从可用选项中，我们选择传递表类型和它的访问规则。我们选择了 :set 类型，这意味着键不能是重复的。我们也设置表的访问规则为 :protected ，这意味着只有创建表的进程能写这个表，不过其他进程可以从表里读取数据。这两个选项实际上是默认值，所以从现在开始我们将忽略它们。</p>
<p>ETS表可以被命名，允许我们通过给定的名字访问它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:named_table</span>])</div><div class="line"><span class="symbol">:buckets_registry</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(<span class="symbol">:buckets_registry</span>, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(<span class="symbol">:buckets_registry</span>, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>让我们修改 KV.Registry 来使用ETS表。因为我们的registry需要一个名字作为入参，我们计划用与registry相同的名字来命名ETS表。ETS的名字和进程的名字存储在不同的地方，因此没有冲突的可能。</p>
<p>打开 lib/kv/registry.ex ，让我们修改它的实现。我们增加注释到源码中来强调我们所做的修改：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry with the given `name`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 1. 传递名字给GenServer的init回调函数</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, name, <span class="symbol">name:</span> name)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">when</span> is_atom(server) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 2. 查询现在直接在ETS里做，没有访问服务器</span></div><div class="line">    <span class="keyword">case</span> <span class="symbol">:ets</span>.lookup(server, name) <span class="keyword">do</span></div><div class="line">      [&#123;^name, pid&#125;] -&gt; &#123;<span class="symbol">:ok</span>, pid&#125;</div><div class="line">      [] -&gt; <span class="symbol">:error</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Stops the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">    GenServer.stop(server)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(table) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 3. 我们已经用ETS表替换名字映射</span></div><div class="line">    names = <span class="symbol">:ets</span>.new(table, [<span class="symbol">:named_table</span>, <span class="symbol">read_concurrency:</span> <span class="keyword">true</span>])</div><div class="line">    refs  = %&#123;&#125;</div><div class="line">    &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 4. 原来为查询服务的handle_call回调函数被删除</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 5. 读写ETS表而不是映射</span></div><div class="line">    <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, _pid&#125; -&gt;</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">      <span class="symbol">:error</span> -&gt;</div><div class="line">        &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">        ref = Process.monitor(pid)</div><div class="line">        refs = Map.put(refs, ref, name)</div><div class="line">        <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 6. 从ETS表而不是从映射删除</span></div><div class="line">    &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">    <span class="symbol">:ets</span>.delete(names, name)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：在我们修改前， KV.Registry.lookup/2 发送请求给服务器，但是现在它直接从ETS表里读取，ETS表被所有进程共享。这是我们实现的缓存机制背后的主要思想。</p>
<p>为了让缓存机制工作，被创建的ETS表需要有 :protected 访问规则（访问规则的默认值），因此所有客户端可以从它读取数据，而只有 KV.Registry 进程可以写数据到这个表里。当表启动的时候，我们已经设置 read_concurrency: true ，这样就优化了表的并发读取操作的通用场景。</p>
<p>我们上面的修改已经使得我们的测试失败，因为我们原来是用registry进程的pid来做所有操作，而现在registry查询需要ETS表的名字。但是，ETS表的名字和registry进程的名字相同，这个问题就很容易修复。如下所示修改 test/kv/registry_test.exs 的setup函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> context.test&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们修改 setup ，一些测试用例将继续失败。你可能甚至注意到，在不同的运行之间，测试的通过和失败也不是一致的。例如：“spawns buckets”测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">  assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>可能在这一行失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div></pre></td></tr></table></figure>
<p>如果我们刚刚在上一行创建了bucket，这一行为何会失败？</p>
<p>那些发生的失败的原因是因为为了教学目的，我们已经犯两个错误：</p>
<ol>
<li>我们过早地优化（通过增加这个缓存层）</li>
<li>我们使用 cast/2 （但是我们应该使用 call/2 ）</li>
</ol>
<h1 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a><span id="part-two">竞争条件</span></h1><p>在Elixir里做开发不会使得你的代码免于竞争条件。然而，Elixir的简单抽象，默认情况下不共享数据，更容易发现竞争条件的根本原因。</p>
<p>在我们测试里所发生的是，在一个操作和我们可以观察到在ETS表里这个改变的时间之间有一个延迟。下面是我们所期望的事件发生步骤：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>registry创建bucket并修改缓存表</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 {:ok, bucket}</li>
</ol>
<p>但是，因为 KV.Registry.create/2 是一个 cast 操作，这个命令在我们实际写表前返回。换句话说，实际发生的步骤如下：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 :error</li>
<li>registry创建bucket并修改缓存表</li>
</ol>
<p>要修复这个错误，我们需要通过用 call/2 替代 cast/2 来使得 KV.Registry.create/2 成为同步操作。这将保证在修改被写入表后客户端才继续执行。让我们如下所示修改这个函数和它的回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">  GenServer.call(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, _from, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt;</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="symbol">:error</span> -&gt;</div><div class="line">      &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">      ref = Process.monitor(pid)</div><div class="line">      refs = Map.put(refs, ref, name)</div><div class="line">      <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将回调函数从 handle_cast/2 改为 handle_call/3，并且修改它用被创建的bucket的pid作为返回结果。总的来说，Elixir开发者喜欢用 call/2 而不是 cast/2 ，因为 call/2 也提供反压（你被阻塞一直到你获得响应）。在不必要的时候使用 cast/2 也可以被认为是一种过早优化。</p>
<p>让我们再次运行测试，这次，我们将传递 --trace 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> --trace</div></pre></td></tr></table></figure>
<p>当你的测试有死锁或有竞争条件的时候 --trace 选项有用，因为它同步地运行所有测试（async: true 无效了）并且显示每一个测试详细信息。这次我们将减少到一到两个不连续的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes buckets on <span class="built_in">exit</span> (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:19</div><div class="line">   Assertion with == failed</div><div class="line">   code: KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == :error</div><div class="line">   lhs:  &#123;:ok, <span class="comment">#PID&lt;0.109.0&gt;&#125;</span></div><div class="line">   rhs:  :error</div><div class="line">   stacktrace:</div><div class="line">     <span class="built_in">test</span>/kv/registry_test.exs:23</div></pre></td></tr></table></figure>
<p>根据失败消息，我们期望bucket不再存在表里，但是它依然还在！这个问题和我们刚才解决的问题相反：已经解决的问题是在创建bucket的命令和修改表之间有延迟，现在的这个问题是bucket进程死亡和它的信息从表里删除之间存在延迟。</p>
<p>不幸的是，这次我们不能简单地修改负责清理ETS表的 handle_info/2 函数 为同步操作。相反，我们要找到一个方法保证registry已经处理了当bucket崩溃的时候发送给它的 :DOWN 通知。</p>
<p>一个简单的方法来做到这点，就是通过发送一个同步请求给registry：因为消息按顺序被处理，如果registry响应了一个在Agent.stop调用后发送的请求，这就说明 :DOWN 消息已经被处理了。让我们通过创建一个“假的”bucket来做到这点，它是一个在Agent.stop后的同步请求，在两个测试用例里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Kill the bucket and wait for the notification</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Wait until the bucket is dead</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试用例现在应该（一直）通过！</p>
<p>到此我们的优化章节结束。我们用ETS作为一个缓存机制，读取可以从任何进程发起，但是写入依然只能通过一个单独的进程顺序执行。更重要的是，我们也学到，一旦数据可以被异步读取，我们需要明白它可能引入竞争条件。</p>
<p>下一章我们将讨论外部和内部的依赖以及Mix如何帮助我们管理大型代码库。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/ets.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/ets.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－监督者和应用]]></title>
      <url>http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个监督者</a></li>
<li><a href="#part-two">理解应用</a><br> 2.1. <a href="#part-two-one">启动应用</a><br> 2.2. <a href="#part-two-two">应用的回调函数</a><br> 2.3. <a href="#part-two-three">项目或者应用？</a></li>
<li><a href="#part-three">简单的一对一监督者</a></li>
<li><a href="#part-four">监督树</a></li>
<li><a href="#part-five">Observer</a></li>
<li><a href="#part-six">测试里的共享状态</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。</p>
<p>当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。</p>
<p>在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。</p>
<a id="more"></a>
<h1 id="我们第一个监督者"><a href="#我们第一个监督者" class="headerlink" title="我们第一个监督者"></a><span id="part-one">我们第一个监督者</span></h1><p>创建一个监督者和创建一个GenServer没有太大的不同。我们将在文件 lib/kv/supervisor.ex 里定义一个名为 KV.Supervisor 的模块，它将使用 Supervisor 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Registry, [KV.Registry])</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的监督者目前只有一个孩子：registry。如下格式的一个工作者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker(KV.Registry, [KV.Registry])</div></pre></td></tr></table></figure>
<p>将用下面的调用启动一个进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KV.Registry.start_link(KV.Registry)</div></pre></td></tr></table></figure>
<p>我们传递给start_link的入参是这个进程的名字。给在监督树下的进程命名是通用的做法，这样使得其他进程不需要知道它们的pid就可以通过名字来访问它们。这是有用的，因为一个被监督的进程可能崩溃，这样的话，当监督者重启它时，它的pid将改变。通过使用一个名字，我们可以保证新的被重启的进程将注册到同样的名字下，而不用一定获取最新的pid。注意，用定义它的相同的模块的名字来注册进程也是通用的做法，这使得在调试或监测一个运行的系统时更方便直接。</p>
<p>最后，我们用孩子列表和策略 :one_for_one 作为入参调用 supervise/2 。</p>
<p>监督策略规定，当一个孩子进程发生崩溃的时候会发生什么。:one_for_one 的意思是，如果一个孩子进程死了，只有它一个将被重启。因为我们只有一个孩子进程，所有这些就是我们所需的。Supervisor行为支持许多不同的策略，我们将在本章中讨论它们。</p>
<p>因为现在KV.Registry.start_link/1期望有一个入参，我们需要改变我们的实现来接收这样的入参。打开 lib/kv/registry.ex 并替换 start_link/0 的实现如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Starts the registry with the given `name`.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">  GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> name)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们也需要修改我们的测试用例，当启动一个registry的时候给它一个名字。用下面的内容替换 test/kv/registry_test.exs 里的setup回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>setup/2也可以接收测试上下文，和test/3相似。除了我们在设置块中添加的任何值外，上下文还包含一些默认键，例如：:case， :test，:file 和 :line。我们用当前运行的测试的相同名字作为快捷方式来启动一个registry。</p>
<p>现在我们的测试通过，我们可以带我们的监督者兜兜风。如果我们在我们的项目目录里用 iex -S mix 启动一个控制台，我们可以手工启动一个监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Registry.create(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>当我们启动监督者，registry工作者自动被启动，允许我们创建bucket而不需要手工去启动它。</p>
<p>在实践中，我们很少手动启动应用的监督者。相反，它被作为应用的回调的一部分启动。</p>
<h1 id="理解应用"><a href="#理解应用" class="headerlink" title="理解应用"></a><span id="part-two">理解应用</span></h1><p>在这整个时间里我们一直在一个应用里工作。每次我们修改完一个文件并运行 mix compile ，我们会看到在编译输出里有一个 Generated kv app 的消息。</p>
<p>我们可以找到这个被创建的 .app 文件，它在 _build/dev/lib/kv/ebin/kv.app 。让我们看看它的内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;application,kv,</div><div class="line">             [&#123;registered,[]&#125;,</div><div class="line">              &#123;description,<span class="string">"kv"</span>&#125;,</div><div class="line">              &#123;applications,[kernel,stdlib,elixir,logger]&#125;,</div><div class="line">              &#123;vsn,<span class="string">"0.0.1"</span>&#125;,</div><div class="line">              &#123;modules,[<span class="string">'Elixir.KV'</span>,<span class="string">'Elixir.KV.Bucket'</span>,</div><div class="line">                        <span class="string">'Elixir.KV.Registry'</span>,<span class="string">'Elixir.KV.Supervisor'</span>]&#125;]&#125;.</div></pre></td></tr></table></figure>
<p>这个文件包含Erlang数据（用Erlang语法写的）。即使我们不熟悉Erlang，也很容易猜出这个文件有我们应用的定义。它包含我们应用的版本，由它定义的所有模块，以及我们依赖的应用的列表，比如：Erlang的kernel、elixir它自己和在mix.exs文件里的应用列表里指定的logger。</p>
<p>每次我们增加一个新的模块到我们的应用都要手工修改这个文件将会是非常麻烦的。这就是为什么Mix帮我们生成并维护它的原因。</p>
<p>我们也可以通过在我们mix.exs项目文件里自定义 application/0 的返回值来配置被创建的 .app 文件。我们马上将做我们第一个自定义的应用。</p>
<h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a><span id="part-two-one">启动应用</span></h2><p>当我们定义了一个应用规格说明文件：.app 文件，我们就能把应用当做一个整体来启动和停止。目前我们不需要关注这个文件是因为有两个原因：</p>
<ol>
<li>Mix自动为我们启动我们当前的应用。</li>
<li>即使Mix没有启动我们的应用程序，我们的应用程序还没有做任何事情当它启动的时候。</li>
</ol>
<p>不管怎样，让我们看看Mix如何为我们启动应用。让我们用 iex -S mix 启动一个项目的控制台并且进行如下操作：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:already_started</span>, <span class="symbol">:kv</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>哇！它已经启动了。Mix通常启动在我们项目的 mix.exs 文件所定义的整个应用层级的应用；如果这些应用依赖其他应用，它也会同样地为这些所依赖的应用做相同的事情。</p>
<p>我们可以传递一个选项给Mix要求它不要启动我们的应用。让我们运行 iex -S mix run --no-start 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们可以停止我们的 :kv 应用和 :logger应用，:logger应用是由Elixir默认启动的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.stop(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Application.stop(<span class="symbol">:logger</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然后让我们再次启动我们的应用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:not_started</span>, <span class="symbol">:logger</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们得到了一个错误因为 :kv 应用依赖的 :logger 应用没有启动。我们需要按正确顺序手工启动每一个应用或如下所示调用 Application.ensure_all_started ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.ensure_all_started(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, [<span class="symbol">:logger</span>, <span class="symbol">:kv</span>]&#125;</div></pre></td></tr></table></figure>
<p>没有什么真正值得兴奋的，不过它展现了我们如何能控制我们的应用。</p>
<blockquote>
<p>当你运行 iex -S mix 的时候，它相当于运行 iex -S mix run 。所以当你启动IEx无论何时你需要传递更多选项给Mix，一定运行 iex -S mix run ，然后传递任何选项给run命令接收。你可以在你的shell里运行mix help run找到更多关于run的信息。</p>
</blockquote>
<h2 id="应用的回调函数"><a href="#应用的回调函数" class="headerlink" title="应用的回调函数"></a><span id="part-two-two">应用的回调函数</span></h2><p>既然我们花了所有时间来谈论应用如何启动和停止，则必定有方法在应用启动的时候做一些有用的事情。而事实上，有！</p>
<p>我们可以指定一个应用的回调函数。这个函数将在应用启动的时候被调用。这个函数必须返回格式为 {:ok, pid} 的结果，pid是监督者进程的进程标识符。</p>
<p>我们可以用两个步骤来设置应用的回调函数。首先，打开 mix.exs 文件，然后，按如下所示改变 def application ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:mod 选项指定了“应用回调模块”，它后面的参数将在应用启动的时候被传递。应用回调模块可以是任何实现了 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application</a> 行为的模块。</p>
<p>现在我们已经指定了 KV 作为模块回调，我们需要修改定义在 lib/kv.ex 的 KV 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    KV.Supervisor.start_link</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们 use Application 时，我们需要定义一些函数，和当我们使用 Supervisor 或 GenServer 时相似。这次我们只是需要定义一个 start/2 函数。如果我们想在应用结束时指定自定义的行为，我们可以定义一个 stop/1 函数。</p>
<p>让我们再次用 iex -S mix 来启动我们项目的控制台。我们将看到一个名为 KV.Registry 的进程已经在运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create(KV.Registry, &quot;shopping&quot;)</div><div class="line">:ok</div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, &quot;shopping&quot;)</div><div class="line">&#123;:ok, #PID&lt;0.88.0&gt;&#125;</div></pre></td></tr></table></figure>
<p>我们如何知道它是正常运行的？毕竟，我们创建了一个bucket然后查询它；当然，它应该正常运行，对吗？好的，记得 KV.Registry.create/2 使用 GenServer.cast/2 ，因此将返回 :ok ，而不管消息是否找到它的目标。在这个时候，我们不知道监督者和服务器是否起来了，以及bucket是否被创建了。但是， KV.Registry.lookup/2 使用 GenServer.call/3 ，而且将阻塞并等待从服务器返回的结果。我的确得到了正确的响应，所以我们知道所有事情都起来并运行着。</p>
<p>做一个实验，尝试用 GenServer.call/3 替代来重新实现 KV.Registry.create/2 ，并且短暂地使得应用回调不可用。在控制台再次运行上面的代码，你会立即看到创建步骤失败。</p>
<p>记得在继续教程前恢复代码。</p>
<h2 id="项目或者应用？"><a href="#项目或者应用？" class="headerlink" title="项目或者应用？"></a><span id="part-two-three">项目或者应用？</span></h2><p>Mix区分项目和应用。基于我们的mix.exs文件内容，我们可以说我们有一个Mix项目，它定义了一个 :kv 应用。正如我们将在后面章节所看到的，有的项目没有定义任何应用。</p>
<p>当我们说“项目”的时候，你应该考虑Mix。Mix是一种工具，它管理你的项目。它知道如何编译你的项目，测试你的项目等等。它也知道如何编译和启动与你的项目相关的应用程序。</p>
<p>当我们谈论应用的时候，我们谈论的是OTP。应用程序是由运行时作为一个整体来启动和停止的实体。你可以从<a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application的官方文档</a>里学到更多关于应用的内容，也可以通过运行 mix help compile.app 来学到更多在 def application 里被支持的选项。</p>
<h1 id="简单的一对一监督者"><a href="#简单的一对一监督者" class="headerlink" title="简单的一对一监督者"></a><span id="part-three">简单的一对一监督者</span></h1><p>我们现在已经成功地定义了我们的监督者，它作为我们应用生命周期的一部分被自动地启动（和结束）。</p>
<p>然而我们记得在 handle_cast/2 回调函数里，我们的 KV.Registry 同时链接和监测着bucket进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>链接是双向的，这暗示着bucket的崩溃会导致registry的崩溃。虽然我们现在有监督者，它保证registry将被恢复并运行，但是崩溃registry意味着我们丢失所有bucket名字与它们相应进程的关联数据。</p>
<p>换句话说，我们希望registy继续运行，即使一个bucket溃。让我们写一个新的registry测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 用非正常原因停止bucket</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 等待一直到bucket死亡</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个测试用例和“removes bucket on exit”测试用例相似，不同点是我们有点苛刻地发送 :shutdown 作为退出原因替代 :normal 。和 Agent.stop/1 相反，Process.exit/2 是一个异步操作，因此我们不能简单地在发送退出信号后立即调用 KV.Registry.lookup/2 来查询，因为那时还无法保证bucket已死。为解决这个问题，我们在测试期间也监测bucket，一旦我们确认它死掉了，我们才查询registry，这样就避免了条件竞争。</p>
<p>因为bucket被链接到registry，而registry被链接到测试进程，那么杀掉bucket导致registry崩溃，从而导致测试进程也崩溃：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes bucket on crash (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:52</div><div class="line">   ** (EXIT from <span class="comment">#PID&lt;0.94.0&gt;) shutdown</span></div></pre></td></tr></table></figure>
<p>这个问题有一个解决办法，提供一个调用 Agent.start/1 的 KV.Bucket.start/0  ，然后在registry里使用它，删除bucket和registry之间的链接。但是，这是一个坏主意，因为这么修改了后，bucket将不会和任何一个进程链接。这就意味着，如果有人停止 :kv 应用，所有的bucket因为无法被访问而继续存活。不仅如此，如果一个进程是不可被访问的，它们就更难被监测。</p>
<p>我们将通过定义一个新的创建和监督所有bucket的监督者来解决这个问题。有一个监督者策略，叫做 :simple_one_for_one ，它特别适合这样的场景：它允许我们指定一个工作者模板并监督许多基于这个模板的子进程。使用这个策略，没有一个工作者在监督者初始化的时候被启动，而每次通过调用 start_child/2 启动一个新的工作者。</p>
<p>让我们在 lib/kv/bucket/supervisor.ex 文件里定义我们的 KV.Bucket.Supervisor ，内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="comment"># 一个存储监督者名字的简单模块属性</span></div><div class="line">  <span class="variable">@name</span> KV.Bucket.Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> <span class="variable">@name</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_bucket</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_child(<span class="variable">@name</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Bucket, [], <span class="symbol">restart:</span> <span class="symbol">:temporary</span>)</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:simple_one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>和第一个监督者相比这个监督者有三处改变。</p>
<p>首先，我们决定给这个监督者一个本地名字 KV.Bucket.Supervisor 。我们也定义了一个 start_bucket/0 函数，它将启动一个bucket作为叫做 KV.Bucket.Supervisor 监督者的子进程。我们将在registry里直接调用 start_bucket/0 来替换对 KV.Bucket.start_link 的调用。</p>
<p>最后，在 init/1 回调函数里，我们标注工作者是 :temporary 。这意味着，如果一个bucket死了，它不会被重启。这是因为我们只是想用监督者作为一种聚集bucket的机制。</p>
<p>运行 iex -S mix  ，我们来试试我们新的监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Bucket.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(bucket, <span class="string">"eggs"</span>, <span class="number">3</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(bucket, <span class="string">"eggs"</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>让我们修改registry，用KV.Bucket.Supervisor 来重写bucket如何被重启：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们按上述所示进行了修改，我们的测试用例将失败，因为没有bucket监督者。让我们来自动启动bucket监督者作为我们主监督树的一部分来替代每次测试都直接地启动bucket监督者。</p>
<h1 id="监督树"><a href="#监督树" class="headerlink" title="监督树"></a><span id="part-four">监督树</span></h1><p>为了在我们的应用里使用bucket监督者，我们需要把它加进 KV.Supervisor 的子进程了。注意：我们开始有监督其他监督者的监督者，形成所谓的“监督树”。</p>
<p>打开 lib/kv/supervisor.ex ，按如下所示修改 init/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这次我们增加一个监督者作为一个子进程，没有用参数来启动它。重新运行测试套件，现在所有测试用例都将通过。</p>
<p>因为我们增加了更多的子进程给监督者，所以评估 :one_for_one 监督策略是否依然正确也很重要。有一个瑕疵马上显现出来，就是 KV.Registry 工作者进程和 KV.Bucket.Supervisor 监督者进程之间的关系。如果 KV.Registry 死了，所有链接 KV.Bucket 名字到 KV.Bucket 进程的信息丢失，而且因此 KV.Bucket.Supervisor 也必须死，否则，它管理的 KV.Bucket 进程将成为孤儿。</p>
<p>根据这一观察，我们应该考虑转移到另一个监督策略。另外两个候选者是：:one_for_all 和 :rest_for_one 。一个监督者使用 :one_for_all 策略，则无论何时它任何一个子进程死亡，它将杀掉和重启它所有的子进程。乍一看，这似乎适合我们的使用情况，但它似乎也有点霸道，因为如果 KV.Bucket.Supervisor 死了，KV.Registry 是完全能够清理它自己的。在这种情况下，:rest_for_one 策略就派上用场了：当一个进程崩溃了，监督者将只是杀掉和重启在崩溃子进程后启动的子进程。让我们重写我们的监督树，用这个策略来替代原来的策略：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:rest_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，如果 KV.Registry 工作者崩溃，则 KV.Registry 和 KV.Supervisor 的“剩余”子进程（即 KV.Bucket.Supervisor ）将被重启。但是，如果 KV.Bucket.Supervisor 崩溃了，KV.Registry 将不会被重启，因为它先于 KV.Bucket.Supervisor 启动。</p>
<p>还有其他的策略和其他的选项可以给 worker/2，supervisor/2 和 supervise/2 函数，所以不要忘了仔细阅读 <a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor</a> 和 <a href="https://hexdocs.pm/elixir/Supervisor.Spec.html" target="_blank" rel="external">Supervisor.Spec</a> 模块的文档。</p>
<p>为了帮助开发者记住如何使用 Supervisor 和它方便的函数，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a> 已经创建了 <a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/Supervisor_CheatSheet.pdf" target="_blank" rel="external">Supervisor备忘录</a> 。</p>
<p>在我们转到下一章前还剩下两个话题。</p>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><span id="part-five">Observer</span></h1><p>现在我们已经定义了我们的监督树，这是一个很好的机会介绍Erlang自带的Observer工具。用 iex -S mix 启动你的应用，然后在里面输入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:observer</span>.start</div></pre></td></tr></table></figure>
<p>一个包含我们系统的所有各类信息的图形界面弹出来，信息包括从总的统计到负载图，也有所有运行的进程和应用的列表。</p>
<p>在应用标签卡里，你将看到你的系统里的所有当前运行的应用以及它们的监督树。你可以选择 kv 应用来进一步浏览它：</p>
<p><img src="/images/getting-started-mix-otp-supervisor-and-application-kv-observer.png" style="border:0;"></p>
<p>不仅如此，当你在终端创建一个新的bucket的时候，你将在Observer里看到被新创建的进程在监督树里展示出来。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create KV.Registry, <span class="string">"shopping"</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们将留给你进一步探索Observer提供了什么。记住，你可以双击监督树里的任何进程来获取这个进程的更多信息，也可以右击一个进程来发送“一个杀死信号”，这是一个完美的方式来模拟失败并看看你的监督者是否如预期地响应。</p>
<p>在一天结束之际，像Observer这样的工具是你想要总是在监督树内启动进程，即使他们是暂时的，以确保它们总是可以到达和监测的主要原因之一。</p>
<h1 id="测试里的共享状态"><a href="#测试里的共享状态" class="headerlink" title="测试里的共享状态"></a><span id="part-six">测试里的共享状态</span></h1><p>到目前为止，我们已经为每一个测试用例启动一个registry来确保它们是被隔离的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>既然我们现在已经改变了我们的registry来使用 KV.Bucket.Supervisor ，它被全局注册，我们的测试现在依靠这个共享、全局的监督者，尽管每个测试用例都有自己的registry。问题是：我们应该这样做吗？</p>
<p>这取决于只要我们只依赖于这个状态的非共享部分，就可以依赖共享的全局状态。例如，每次我们用给定的名字注册一个进程，我们就是正在对应于一个共享了名字的registry来注册一个进程。然而，只要我们通过使用像 context.test 这样的结构来保证这个名字对于每一个测试用例都是特定的，我们就不会在测试用例之间有并发或者数据依赖的问题。</p>
<p>类似的推理应适用于我们的bucket监督者。虽然在共享的bucket监督者上多个registry可能启动bucket，但是那些bucket和registry是彼此隔离的。如果我们使用像 Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数，我们只会遇到并发问题；Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数从所有registry统计所有的bucket数量，当测试用例并发地运行的时候，潜在获得不同结果的问题。</p>
<p>因为我们目前只依赖bucket监督者的非共享部分，因此在我们的测试套件里我们不需要担心并发问题。万一它成为一个问题，我们可以每一个测试用例启动一个监督者并且把它作为入参传递给registry的start_link函数。</p>
<p>现在，我们的应用得到适当的监督和测试，让我们看看如何可以加快速度。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－GenServer]]></title>
      <url>http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个GenServer</a></li>
<li><a href="#part-two">测试一个GenServer</a></li>
<li><a href="#part-three">监测的必要性</a></li>
<li><a href="#part-four">call、cast还是info？</a></li>
<li><a href="#part-five">监测还是链接？</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在<a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">上一章</a>我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>, <span class="symbol">name:</span> <span class="symbol">:shopping</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而<strong>我们不应该将用户输入转换为原子</strong>。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！</p>
<p>在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。</p>
<p>我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。</p>
<p>注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。</p>
<p>我们将使用一个 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。</p>
<a id="more"></a>
<h1 id="我们第一个GenServer"><a href="#我们第一个GenServer" class="headerlink" title="我们第一个GenServer"></a><span id="part-one">我们第一个GenServer</span></h1><p>一个GenServer被实现为两部分：客户端API和服务端回调函数。你既可以把这两部分合并到一个单独的模块里，也可以把它们分拆到一个客户端模块和一个服务端模块。客户端和服务端分别运行在隔离的进程里，客户端和服务端来回传递消息，而服务器在内部基于收到的消息而调用相关的函数。本文我们将用一个单独的模块来容纳客户端API和服务端回调函数。</p>
<p>创建一个文件 lib/kv/registry.ex ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## Client API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.call(server, &#123;<span class="symbol">:lookup</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server Callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, %&#123;&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, names) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), names&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, names) <span class="keyword">do</span></div><div class="line">    if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:noreply</span>, names&#125;</div><div class="line">    else</div><div class="line">      &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">      &#123;<span class="symbol">:noreply</span>, Map.put(names, name, bucket)&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个函数是 start_link/3 ，它接收三个入参来启动一个新的GenServer：</p>
<ol>
<li>服务端回调函数被实现所在模块，本例子里是 __MODULE__ ，意思就是当前模块。</li>
<li>初始化参数，本例子里是原子 :ok 。</li>
<li>一个选项列表，它可以被用来指定一些事项，比如服务器名字。本例子里我们传递了一个空列表。</li>
</ol>
<p>有两种类型请求你可以发送给一个GenServer：call 和 cast。call是同步的，服务端<strong>必须</strong>发送一个响应给这一个的请求。cast是异步的，服务端不需要返回响应。</p>
<p>接下来的两个函数，lookup/2 和 create/2 负责发送这些请求给服务端。在本例子中，我们分别用 {:lookup, name} 和 {:create, name} 作为请求消息。请求消息常常被指定为元组，就像本例一样，是为了在第一个参数位置提供多于一个“参数”。通常指定请求的动作作为元组的第一个元素，而剩下的元素作为该动作的参数。注意：请求必需匹配 handle_call/3 或 handle_cast/2 的第一个入参。</p>
<p>上面讲的就是客户端API。在服务器这边，我们可以实现各种各样的回调函数来保证服务器的初始化、终止和处理请求。那些回调函数是可选的，目前我们只实现我们所关心的。</p>
<p>第一个是 init/1 回调函数，它接收传给 GenServer.start_link/3 的参数并且返回 {:ok, state} ，此处的状态是一个新的映射。我们可能已经注意到GenServer的API是如何使得客户端和服务端隔离的更明显的。start_link/3 在客户端，而它所对应的回调函数 init/1 运行在服务端。</p>
<p>对应于 call/2 的请求，我们实现一个 handle_call/3 回调函数来接收它的请求、请求的来源进程（_from），以及当前服务器状态（state）。handle_call/3 回调函数返回一个格式为 {:reply, reply, new_state} 的元组。这个元组的第一个元素，:reply ，表明服务器将发送一个应答给客户端。第二个元素，reply，就是发送给客户端的应答。而第三个元素，new_state，是一个新的服务器状态。</p>
<p>对应于 cast/2 的请求，我们实现了一个 handle_cast/2 回调函数来接收它的请求和当前服务器状态（state）。handle_cast/2  回调函数返回一个格式为 {:noreply, new_state} 的元组。注意：在一个真实的应用里，可能应该用同步调用的方式为 :create 实现回调函数来替换异步的cast函数。我们在本例里这么做是为了说明如何实现一个cast函数的回调。</p>
<p>handle_call/3 和 handle_cast/2 函数还有其他格式的返回元组。也有其他的回调函数我们可以实现，比如：terminate/2 和 code_change/3 。欢迎你探索<a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">整个GenServer文档</a>以了解关于这方面的更多内容。</p>
<p>现在，让我们写一些测试来保证我们的GenServer如我们所期望地工作。</p>
<h1 id="测试一个GenServer"><a href="#测试一个GenServer" class="headerlink" title="测试一个GenServer"></a><span id="part-two">测试一个GenServer</span></h1><p>测试一个GenServer和测试一个Agent没有太大的不同。我们将在测试的setup回调函数里创建一个服务器，并在我们整个测试中使用它。创建一个文件：test/kv/registry_test.exs ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RegistryTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">    KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">    assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试应该毫无阻碍地通过！</p>
<p>你不需要明确地停掉registry，因为当我们的测试结束的时候，它将收到一个 :shutdown 信号。虽然这么处理相应的测试来说没问题。但是如果需要将停止一个GenServer作为一个应用里逻辑的一部分，那么你可以使用 GenServer.stop/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Stops the registry.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">  GenServer.stop(server)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="监测的必要性"><a href="#监测的必要性" class="headerlink" title="监测的必要性"></a><span id="part-three">监测的必要性</span></h1><p>我们的registry几乎完成了。仅剩的问题是，如果一个bucket停止或崩溃了，registry的数据可能会变得过时。让我们增加一个测试用例到 KV.RegistryTest 来揭示这个bug：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的测试用例将在最后的断言处失败，因为bucket的名字还保留在registry里，即使在我们停止了bucket进程后。</p>
<p>为了修复这个bug，我们需要registry监测每一个由它创建的bucket。一旦我们设置了监测，每次bucket退出的时候，registry将收到一个通知，允许我们来清理字典。</p>
<p>让我们用 iex -S mix 启动一个新的控制台，先来玩一下监测：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; Process.monitor(pid)</div><div class="line"><span class="comment">#Reference&lt;0.0.0.551&gt;</span></div><div class="line">iex&gt; Agent.stop(pid)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; flush()</div><div class="line">&#123;<span class="symbol">:DOWN</span>, <span class="comment">#Reference&lt;0.0.0.551&gt;, :process, #PID&lt;0.66.0&gt;, :normal&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Process.monitor(pid) 返回一个唯一的引用，这允许我们匹配将要到来的消息，从而监测引用。我们停止Agent后，我们可以 flush/0 所有消息，注意到：一个 :DOWN 消息到达，带着与monitor返回的一样的引用，告诉我们，bucket进程因为 :normal 原因退出。</p>
<p>让我们重新实现服务端回调函数来修复这个bug并使得测试通过。首先，我们将修改GenServer的状态为两个字典：一个包含 name -&gt; pid ，另一个包含 ref -&gt; name。然后我们需要在 handle_cast/2 里监测bucket，也实现一个 handle_info/2 回调函数来处理监测消息。所有服务端回调函数的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 服务端回调函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  names = %&#123;&#125;</div><div class="line">  refs  = %&#123;&#125;</div><div class="line">  &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, &#123;names, <span class="number">_</span>&#125; = state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), state&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">  names = Map.delete(names, name)</div><div class="line">  &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意，我们能够在不改变任何客户端API的情况下，大幅度地改变服务器实现。这就是明确地隔离服务器和客户端的好处之一。</p>
<p>最后，不同于其他回调函数，我们为 handle_info/2 回调函数定义了一个“catch-all”分支，它丢弃任何未知的消息。想知道为什么，请移步下一节。</p>
<h1 id="call、cast还是info？"><a href="#call、cast还是info？" class="headerlink" title="call、cast还是info？"></a><span id="part-four">call、cast还是info？</span></h1><p>我们已经用了三个回调函数：handle_call/3，handle_cast/2 和 handle_info/2。现在我们要考虑什么时候决定和什么时候使用它们：</p>
<ol>
<li>handle_call/3 必须用于同步请求。这应该是等待服务器的回复是一个有用的反压机制的默认选择。</li>
<li>handle_cast/2 必须用于异步请求，而且当你不关心响应的时候。cast甚至不保证服务端收到了消息，因此，它应该尽量少用。例如，本章我们已经定义的 create/2 函数应该使用 call/2 。我们使用 cast/2 是为了教学目的。</li>
<li>handle_info/2 必须用于服务端接收到的不是GenServer.call/2 或 GenServer.cast/2发送的其他所有消息，包括了用send/2发送的普通消息。监测消息 :DOWN 就是其中的例子。</li>
</ol>
<p>因为任何消息，包括send/2方式的消息都由handle_info/2处理，则有机会不期望的消息到达服务器。因此，如果我们没有定义catch-all分支，那些消息将导致我们的registry崩溃，因为没有分支可以匹配它们。但是我们却不用担心这样的情况发生在handle_call/3 和 handle_cast/2。call和cast只能通过GenServer的API来做，所以一个未知消息就十分可能是由开发者的错误造成。</p>
<p>为了帮助开发者记住call，cast 和 info之间的区别，它们支持的返回值以及其他知识，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a>已经创建了非常棒的<a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf" target="_blank" rel="external">GenServer备忘录</a>.</p>
<h1 id="监测还是链接？"><a href="#监测还是链接？" class="headerlink" title="监测还是链接？"></a><span id="part-five">监测还是链接？</span></h1><p>我们已经在Process这章学习了链接。现在，我们完成了registry模块，我们可能想知道：什么时候我们应该用监测而什么时候我们应该用链接？</p>
<p>链接是双向的。如果你链接了两个进程，其中一个进程崩溃，则另一个进程也将崩溃（除非它捕获了退出信号）。监测是单向的：只有监测的进程才收到关于被监测进程的通知。也就是说：当你想链接崩溃的时候使用链接，而当你只是想获得崩溃、退出等的信息的时候就使用检测。</p>
<p>回到我们的 handle_cast/2 实现，你可以看到registry既链接也监测bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>这是一个坏注意，因为我们不想我们的registry在bucket崩溃的时候也崩溃！我们通常避免直接创建进程，而是把这个责任委托给监督者。正如我们将在下一章所见，监督者依赖于链接，这就解释了为什么基于链接的API（spawn_link，start_link，等）在Elixir和OTP里很普遍。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/genserver.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－Agent]]></title>
      <url>http://szpzs.oschina.io/2017/02/17/elixir-getting-started-mix-otp-agent/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">状态的麻烦</a></li>
<li><a href="#part-two">Agents</a></li>
<li><a href="#part-three">用ExUnit回调函数设置测试</a></li>
<li><a href="#part-four">其他Agent动作</a></li>
<li><a href="#part-five">Agent的Client/Server</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将创建一个名为 KV.Bucket 的模块。这个模块将以某种方式存储我们的键值对实体，并允许其他进程读取和修改它们。</p>
<p>如果你跳过了入门教程或已经读过了很长时间，你应该重新读一下<a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">进程</a>这一章。我们将用它作为起始点。</p>
<a id="more"></a>
<h1 id="状态的麻烦"><a href="#状态的麻烦" class="headerlink" title="状态的麻烦"></a><span id="part-one">状态的麻烦</span></h1><p>Elixir是一门不可修改的语言，也就是说默认情况下是没有任何东西是共享的。如果我们想要提供状态，在状态里我们创建“桶”，从其他地方可以放置和读取“桶”里的数据，我们在Elixir有两种主要的选择：</p>
<ul>
<li>进程</li>
<li><a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ETS（Erlang Term Storage）</a></li>
</ul>
<p>我们已经谈论过进程，而ETS是个新事物，我们将在本教程的后面讨论它。当需要使用进程的时候，我们几乎没有自己亲自处理它的，反而是使用Elixir和OTP里可用的进程抽象：</p>
<ul>
<li><a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent</a> - 对状态的简单封装</li>
<li><a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> - “通用服务器”（进程），它封装状态，提供同步和异步调用，支持代码重载等等。</li>
<li><a href="https://hexdocs.pm/elixir/GenEvent.html" target="_blank" rel="external">GenEvent</a> - “通用事件”管理器，它允许发布事件给多个处理者。</li>
<li><a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a> - 计算的异步单元，它允许创建一个进程并且在稍后获取它的结果。</li>
</ul>
<p>我们将在本教程里探讨这些抽象中的大多数。我们要记住：它们都是基于进程之上的实现，使用了Erlang虚拟机提供的基本特性，比如：send、receive、spawn和link。</p>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a><span id="part-two">Agents</span></h1><p><a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent</a>是状态的简单封装。如果你想要从一个进程的所有所得是保持状态，那么agent非常合适。让我们在项目里启动一个iex会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex -S mix</div></pre></td></tr></table></figure>
<p>并且玩一下agent：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, agent&#125; = Agent.start_link <span class="keyword">fn</span> -&gt; [] <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.57.0&gt;&#125;</span></div><div class="line">iex&gt; Agent.update(agent, <span class="keyword">fn</span> list -&gt; [<span class="string">"eggs"</span> | list] <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Agent.get(agent, <span class="keyword">fn</span> list -&gt; list <span class="keyword">end</span>)</div><div class="line">[<span class="string">"eggs"</span>]</div><div class="line">iex&gt; Agent.stop(agent)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们用一个空列表作为初识状态来启动一个agent。我们修改agent的状态，增加我们新的元素到列表头部。<a href="https://hexdocs.pm/elixir/Agent.html#update/3" target="_blank" rel="external">Agent.update/3</a> 的第二个入参是一个函数，这个函数将agent的当前状态作为输入并返回它期望的新状态。最后，我们获取整个列表。<a href="https://hexdocs.pm/elixir/Agent.html#get/3" target="_blank" rel="external">Agent.get/3</a> 的第二个入参是一个函数，这个函数把状态当做输入，然后返回 <a href="https://hexdocs.pm/elixir/Agent.html#get/3" target="_blank" rel="external">Agent.get/3</a> 将返回的值。一旦我们用完agent，我们可以调用 <a href="Agent.stop/3">Agent.stop/3</a> 来终止agent进程。</p>
<p>让我们用agent来实现我们的 KV.Bucket 。不过在开始实现之前，让我们首先写一些测试用例。创建一个文件 test/kv/bucket_test.exs （记住后缀是 .exs），内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.BucketTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"stores values by key"</span> <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="keyword">nil</span></div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">3</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们第一个测试用例启动一个新的 KV.Bucket 并且在其上执行一些 get/2 和 put/3 操作，断言结果。我们不需要明确地停止agent因为它被链接到测试进程，一旦测试结束agent自动地结束。这将一直有效除非这个进程被命名。</p>
<p>也请注意：async: true 选项被传给 ExUnit.Case 。这个选项通过使用我们机器的多核使得这个测试用例和其他 :async 测试用例平行地运行。这对加速我们的测试套件非常有用。但是， :async 必需在不依赖或修改任何全局值的情况下才能被设置。例如，如果测试需要写文件系统、注册进程或访问数据库，那么就保持它为同步的（删除 :async 选项）以避免测试之间的竞争条件。</p>
<p>不管异步与否，我们新的测试将明显会失败，因为被测试的模块里任何一个功能都没有实现。</p>
<p>为了修复失败的测试，让我们创建一个文件： lib/kv/bucket.ex ，它的内容如下所示。在看下面内容前，你自己尝试一下用agent实现 KV.Bucket 模块。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts a new bucket.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Gets a value from the `bucket` by `key`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">    Agent.get(bucket, &amp;Map.get(&amp;<span class="number">1</span>, key))</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Puts the `value` for the given `key` in the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(bucket, key, value) <span class="keyword">do</span></div><div class="line">    Agent.update(bucket, &amp;Map.put(&amp;<span class="number">1</span>, key, value))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用一个映射来保存我们的键和值。捕获运算符，&amp; ，在<a href="http://elixir-lang.org/getting-started/modules-and-functions.html#function-capturing" target="_blank" rel="external">入门教程</a>里有介绍。</p>
<p>现在 KV.Bucket 模块已经被定义，我们的测试应该pass！你可以运行 mix test 来尝试一下。</p>
<h1 id="用ExUnit回调函数设置测试"><a href="#用ExUnit回调函数设置测试" class="headerlink" title="用ExUnit回调函数设置测试"></a><span id="part-three">用ExUnit回调函数设置测试</span></h1><p>在继续往 KV.Bucket 添加更多功能之前，我们来讨论一下 ExUnit 的回调函数。正如你所期望的，所有KV.Bucket的测试用例在设置和测试后停止期间将需要一个启动的bucket。幸运的是，ExUnit支持回调函数来允许我们来跳过这样的重复任务。</p>
<p>让我们用回调函数来重新写测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.BucketTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">bucket:</span> bucket&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"stores values by key"</span>, %&#123;<span class="symbol">bucket:</span> bucket&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="keyword">nil</span></div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">3</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们首先在 setup/1 宏的帮助下定义了一个设置回调。在每次测试之前，在与测试本身相同的过程中运行setup/1 回调。</p>
<p>注意我们需要一种机制从回调传递 bucket 的pid给测试用例。我们使用测试上下文来做这种机制。当我们从回调返回 {:ok, bucket: bucket} ，ExUnit将元组的第二个元素（一个字典）合并到测试上下文。测试上下文是一个映射，我们可以在测试定义匹配它，在代码块里访问这些值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"stores values by key"</span>, %&#123;<span class="symbol">bucket:</span> bucket&#125; <span class="keyword">do</span></div><div class="line">  <span class="comment"># `bucket` 正是从setup传递过来的bucket</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你可以在<a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case模块文档</a>里读到更多关于ExUnit用例的内容，在<a href="https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html" target="_blank" rel="external">ExUnit.Callbacks文档</a>里读到更多回调的内容。</p>
<h1 id="其他Agent动作"><a href="#其他Agent动作" class="headerlink" title="其他Agent动作"></a><span id="part-four">其他Agent动作</span></h1><p>除了获取一个值和修改agent状态，agent允许我们通过 Agent.get_and_update/2 在一个函数调用里获取一个值并且修改agent状态。让我们实现KV.Bucket.delete/2函数，它从bucket删除一个键并返回它的当前值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Deletes `key` from `bucket`.</div><div class="line"></div><div class="line">Returns the current value of `key`, if `key` exists.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Agent.get_and_update(bucket, &amp;Map.pop(&amp;<span class="number">1</span>, key))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在轮到你写一个上面代码的测试用例！另外，要阅读一下<a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent模块的文档</a>学习更多内容。</p>
<h1 id="Agent的Client-Server"><a href="#Agent的Client-Server" class="headerlink" title="Agent的Client/Server"></a><span id="part-five">Agent的Client/Server</span></h1><p>在我们转到下一章内容前，让我们讨论一下agent里的客户端/服务端的概念。让我们展开我们刚刚实现的delete/2函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Agent.get_and_update(bucket, <span class="keyword">fn</span> dict-&gt;</div><div class="line">    Map.pop(dict, key)</div><div class="line">  <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在函数内我们传递给agent的所有内容都发生在agent进程中。在这个场景里，因为agent进程是接收和相应我们消息的，那么我们说agent进程是服务器。函数外不的所有事情发生在客户端。</p>
<p>这个区分很重要。如果有耗时的动作要做，你必须要考虑是在服务端还是在客户端执行这些操作更好。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Process.sleep(<span class="number">1000</span>) <span class="comment"># puts client to sleep</span></div><div class="line">  Agent.get_and_update(bucket, <span class="keyword">fn</span> dict -&gt;</div><div class="line">    Process.sleep(<span class="number">1000</span>) <span class="comment"># puts server to sleep</span></div><div class="line">    Map.pop(dict, key)</div><div class="line">  <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当一个长时间的动作在服务器上执行，则所有对这个特定服务器的其他请求将一直等待到这个动作完成才能得到处理，这可能导致一些客户端超时。</p>
<p>在下一章，我们将探讨GenServers，它的客户机和服务器之间的隔离变得更加明显。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/agent.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mix 和 OTP－Mix简介]]></title>
      <url>http://szpzs.oschina.io/2017/02/16/elixir-getting-started-mix-otp-introduction-to-mix/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个项目</a></li>
<li><a href="#part-two">项目编译</a></li>
<li><a href="#part-three">运行测试</a></li>
<li><a href="#part-four">环境</a></li>
<li><a href="#part-five">探索</a></li>
</ol>
<p>在本教程里，我们将学习如何构建一个完整的Elixir应用，该应用有自己的监督树、配置、测试等等。</p>
<p>这个应用是一个分布式键值对存储。我们将组织键值对到容器中，然后跨多节点分布这些容器。我们也将构建一个简单的客户端来让我们连接到那些节点中的任何一个，并且像如下所示发送请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>为了构建我们的键值对应用，我们将使用三个主要工具：</p>
<ul>
<li>OTP（开放电信平台）是一个Erlang自带的库的集合。Erlang开发者用OTP来构建健壮、容错的应用。在本章中我们将探讨OTP和Elixir整合有多少方面，包括监督树、事件管理器等等；</li>
<li>Mix是一个Elixir自带的构建工具，它为创建、编译、测试你的应用、管理应用的依赖等等提供任务；</li>
<li>ExUnit是一个Elixir自带的基于单元测试的框架。</li>
</ul>
<p>在本章里，我们将用Mix创建我们的第一个项目，然后逐步探索OTP、Mix和ExUnit里的不同特性。</p>
<blockquote>
<p>注意：本教程需要Elixir v1.2.0 或者更高版本。你可以用 elixir –version 来检查你的Elixir版本并且如果需要的话，你可以按 <a href="http://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="external">Elixir入门教程第一章里</a> 描述的步骤安装一个最新的版本。</p>
<p>如果你对本教程有任何疑问或改进建议请到诸如 <a href="https://elixirforum.com/" target="_blank" rel="external">Elixir论坛</a> 或 <a href="https://github.com/elixir-lang/elixir-lang.github.com/issues" target="_blank" rel="external">问题跟踪</a> 告诉我们。你的建议对我们的教程真的很重要。</p>
<p>最后，本教程的代码在这个<a href="https://github.com/josevalim/kv_umbrella" target="_blank" rel="external">仓库</a>里，你可以把它当做参考。</p>
</blockquote>
<a id="more"></a>
<h1 id="我们第一个项目"><a href="#我们第一个项目" class="headerlink" title="我们第一个项目"></a><span id="part-one">我们第一个项目</span></h1><p>当你安装Elixir的时候，除了得到 elixir、elixirc 和 iex 这些可执行文件，你也得到一个叫做Mix的可执行Elixir脚本。</p>
<p>让我们从命令行通过调用 mix new 创建我们的第一个项目。我们将传递项目名字作为这个命令的参数（在这个例子里项目名字是kv），并且告诉Mix我们的主模块应该是全部大写的KV，而不是默认的Kv：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix new kv --module KV</div></pre></td></tr></table></figure>
<p>Mix将创建一个名为kv的目录，并在这个目录里创建一些文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* creating README.md</div><div class="line">* creating .gitignore</div><div class="line">* creating mix.exs</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div><div class="line">* creating lib</div><div class="line">* creating lib/kv.ex</div><div class="line">* creating <span class="built_in">test</span></div><div class="line">* creating <span class="built_in">test</span>/test_helper.exs</div><div class="line">* creating <span class="built_in">test</span>/kv_test.exs</div></pre></td></tr></table></figure>
<p>让我们简单地看一下那些被创建的文件：</p>
<blockquote>
<p>注意：Mix是一个Elixir可执行文件。这就是说要运行mix，你需要在你的路径里有Elixir可执行文件。如果没有，你可以通过传递这个脚本作为Elixir的参数来运行它：</p>
<pre><code>$ bin/elixir bin/mix new kv --module KV
</code></pre><p>注意：你也可以通过 -S 选项用Elixir执行你路径里的任何脚本：</p>
<pre><code>$ bin/elixir -S mix new kv --module KV
</code></pre><p>当使用 -S 的时候，Elixir在你的路径里找到脚本并执行它。</p>
</blockquote>
<h1 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a><span id="part-two">项目编译</span></h1><p>在我们新项目的目录（kv）里一个名为mix.exs被创建出来，它的主要职责是配置我们的项目。让我们来看看它（注释被删除）:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.3"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps()]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>]]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的mix.exs定义了两个公共函数：project和application。project返回项目的配置，比如，项目名字和版本；application被用来生成一个应用文件。</p>
<p>还有一个名字为 deps 的私有函数，它被project函数调用，它定义我们项目的依赖。定义 deps 作为一个独立函数不是必需的，但是它有助于我们项目配置的整洁。</p>
<p>Mix也用一个简单模块定义来创建了文件 lib/kv.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样的结构已经足够编译我们的项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv</div><div class="line">$ mix compile</div></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Compiling 1 file (.ex)</div><div class="line">Generated kv app</div></pre></td></tr></table></figure>
<p>lib/kv.ex文件被编译，一个名为 kv.app 的应用清单被创建，并且<a href="http://elixir-lang.org/getting-started/protocols.html#protocol-consolidation" target="_blank" rel="external">如入门教程里所描述的一样，所有协议被整合</a>。所有编译产出物用 mix.exs文件里的选项被置于 _build 目录里，。</p>
<p>一旦项目被编译，你就可以如下所示在项目里启动一个iex会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex -S mix</div></pre></td></tr></table></figure>
<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a><span id="part-three">运行测试</span></h1><p>Mix也创建合适的结构来运行我们的项目测试。Mix项目通常遵循这样的习惯，就是lib目录里的每一个文件，在test目录里都有对应的一个文件，文件名格式为：&lt;filename&gt;_test.exs 。正因为这个缘故，我们已经可以找到一个 test/kv_test.exs 文件对应于我们的 lib/kv.ex 文件。它当前还没有做太多功能：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line">  doctest KV</div><div class="line"></div><div class="line">  test <span class="string">"the truth"</span> <span class="keyword">do</span></div><div class="line">    assert <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>重要的是要注意两点：</p>
<ol>
<li>测试文件是Elixir脚本文件（.exs）。这样很方便，因为我们不需要在运行它们前编译它们。</li>
<li>我们定义一个名为 KVTest 的测试模块，用 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case</a> 来注入测试API，并且用 test/2 宏定义一个简单的测试用例。</li>
</ol>
<p>Mix也创建了一个名为 test/test_helper.exs 的文件，它负责设置测试框架：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExUnit.start()</div></pre></td></tr></table></figure>
<p>每一次我们运行我们的测试前，这个文件将被Mix自动 require 。我们可以用 mix test 来运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Compiled lib/kv.ex</div><div class="line">Generated kv app</div><div class="line">[...]</div><div class="line">.</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.04 seconds (0.04s on load, 0.00s on tests)</div><div class="line">1 <span class="built_in">test</span>, 0 failures</div><div class="line"></div><div class="line">Randomized with seed 540224</div></pre></td></tr></table></figure>
<p>注意：通过运行 mix test ，Mix再一次编译源文件并且创建应用文件。这是因为Mix支持多环境，这个我们将在下一节讨论。</p>
<p>而且，你可以看到ExUnit为一个成功的测试用例打印一个点号，而且也自动地随机化测试。让我们故意让测试失败，看看会发生什么。</p>
<p>如下一样修改 test/kv_test.exs 里的断言：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></div></pre></td></tr></table></figure>
<p>现在我们再次运行 mix test （注意，这次没有编译）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  1) <span class="built_in">test</span> the truth (KVTest)</div><div class="line">     <span class="built_in">test</span>/kv_test.exs:5</div><div class="line">     Assertion with == failed</div><div class="line">     code: 1 + 1 == 3</div><div class="line">     lhs:  2</div><div class="line">     rhs:  3</div><div class="line">     stacktrace:</div><div class="line">       <span class="built_in">test</span>/kv_test.exs:6</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.05 seconds (0.05s on load, 0.00s on tests)</div><div class="line">1 <span class="built_in">test</span>, 1 failure</div></pre></td></tr></table></figure>
<p>对于每个失败，Mix打印详细的报告，包含测试用例的名字，失败的代码，以及 == 运算符左边的值（lhs）和右边的值（rhs）。</p>
<p>失败的第二行，正好在测试用例名字下面，这是测试被定义的位置。如果你拷贝测试位置这行（包括文件和行数）然后加在Mix test 后面，Mix将装载和运行这个指定的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> <span class="built_in">test</span>/kv_test.exs:5</div></pre></td></tr></table></figure>
<p>该快捷方式当我们建立我们的项目时将是非常有用的，让我们仅仅运行一个特定的测试来快速迭代。</p>
<p>最后，堆栈跟踪涉及失败本身，它给出有关测试和失败在源文件生成的位置信息。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><span id="part-four">环境</span></h1><p>Mix支持“环境”这个概念。它们允许开发者为特定的场景定制编译和其他选项。默认情况下，Mix理解三种环境：</p>
<ul>
<li>:dev - 这是Mix任务（像 compile）默认运行的</li>
<li>:test - 被 mix test 使用</li>
<li>:prod - 你将在生成环境运行你的项目时使用它</li>
</ul>
<p>环境仅运用到当前的项目。正如稍后我们将看到的，任何你添加到你的项目的依赖将默认运行在 :prod 环境。</p>
<p>定制化每一个环境可以通过在你的mix.exs文件里访问<a href="https://hexdocs.pm/mix/Mix.html#env/1" target="_blank" rel="external">Mix.env函数</a>来做到，这个函数以一个原子方式返回当前环境。我们已经在 :build_embedded 和 :start_permanent 选项里这么使用了：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">  [...,</div><div class="line">   <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">   <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">   ...]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当你编译你的源码的时候，Elixir把编译的生成物放置到 _build 目录里。然而，在许多场合为了避免不必要的拷贝，Elixir将创建文件系统链接，从 _build 到实际源文件。当 :build_embedded 选项为 true 时，它将禁止这个行为，因为它的目的是在 _build 目录里提供运行你的应用的所需要的一切。</p>
<p>相似地，当 :start_permanent 选项为 true 时，它以 permanent  模式启动你的应用，意思是，当你的应用的监督树结束了，Erlang虚拟机也崩溃。注意：我们不想在开发和测试的时候用这种方式，因为为了解决问题而保持Erlang虚拟机实例运行在那样的环境是有用的。</p>
<p>Mix默认使用 :dev 环境，除了 test 任务默认使用 :test 环境。环境可以通过环境变量 MIX_ENV 修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ MIX_ENV=prod mix compile</div></pre></td></tr></table></figure>
<p>或在Windows下这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> <span class="string">"MIX_ENV=prod"</span> &amp;&amp; mix compile</div></pre></td></tr></table></figure>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a><span id="part-five">探索</span></h1><p>Mix的知识还有很多，我们将在构建我们的项目中继续探索它。<a href="https://hexdocs.pm/mix/" target="_blank" rel="external">Mix官方文档里有它的总览</a>。</p>
<p>记住，你可以一直调用 help 任务列出所有可用的任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mix <span class="built_in">help</span></div></pre></td></tr></table></figure>
<p>调用 mix help TASK 你可以得到指定任务的更多信息。</p>
<p>接下来让我们写一些代码！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－下一步]]></title>
      <url>http://szpzs.oschina.io/2017/02/15/elixir-getting-started-where-to-go-next/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">构建你的第一个Elixir项目</a></li>
<li><a href="#part-two">元编程</a></li>
<li><a href="#part-three">社区和其他资源</a></li>
<li><a href="#part-four">关于Erlang</a></li>
</ol>
<p>渴望学更多吗？请继续阅读！</p>
<a id="more"></a>
<h1 id="构建你的第一个Elixir项目"><a href="#构建你的第一个Elixir项目" class="headerlink" title="构建你的第一个Elixir项目"></a><span id="part-one">构建你的第一个Elixir项目</span></h1><p>为了开始你的第一个项目，Elixir提供了一个构建工具，叫做Mix。你可以按如下所示开始你的新项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix new path/to/new/project</div></pre></td></tr></table></figure>
<p>我们已经写了一个教程，涵盖了如何构建一个Elixir应用，包括它自己的监督树、配置、测试等等。这个应用是一个分布式键值存储，我们把键值对放入容器中，并且把这些容器跨多节点分布：</p>
<ul>
<li><a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix and OTP</a></li>
</ul>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a><span id="part-two">元编程</span></h1><p>Elixir是一种可扩展和非常定制化的编程语言，这归功于它的元编程支持。Elixir中绝大多数元编程是通过宏来做的，宏在一些场景下非常有用，特别是写领域特定语言。我们已经写了一个简短教程来解释宏背后的基本机制，展示如何写宏，以及如何用宏来创建领域特定语言。</p>
<ul>
<li><a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">Elixir中的元编程</a></li>
</ul>
<h1 id="社区和其他资源"><a href="#社区和其他资源" class="headerlink" title="社区和其他资源"></a><span id="part-three">社区和其他资源</span></h1><p>我们有一个<a href="http://elixir-lang.org/learning.html" target="_blank" rel="external">学习区</a>，在里面我们推荐一些书籍、视频和其他资源，都是关于学习Elixir和浏览它的生态系统的。除此之外，社区也提供了大量Elixir资源，比如，会议的演讲、开源项目以及其他学习Elixir的资源。</p>
<p>别忘了你也可以从Github上获取<a href="https://github.com/elixir-lang/elixir" target="_blank" rel="external">Elixir它自己的源代码</a>，Elixir绝大多数代码是用Elixir写的（主要在lib目录里），或者<a href="http://elixir-lang.org/docs.html" target="_blank" rel="external">浏览Elixir的官方文档</a>。</p>
<h1 id="关于Erlang"><a href="#关于Erlang" class="headerlink" title="关于Erlang"></a><span id="part-four">关于Erlang</span></h1><p>Elixir运行在Erlang虚拟机之上，而作为一个名Elixir开发者，他迟早会想要与已存在的Erlang库进行交互。在线上有大量的资源，包括Erlang的基础知识和Erlang的更高级特性：</p>
<ul>
<li><a href="http://elixir-lang.org/crash-course.html" target="_blank" rel="external">Erlang语法：速成课程</a>提供了一个Erlang语法的简洁介绍。每一段代码都伴随着等效的Elixir代码。这是一个好机会，对于你来说不仅可以熟悉Erlang语法，也可以复习你在本教程学到的一些知识。</li>
<li>Erlang的官方网站有一个简短的<a href="http://www.erlang.org/course/concurrent_programming.html" target="_blank" rel="external">教程</a>，它用图来简单地描述了Erlang并发编程的基础知识。</li>
<li><a href="http://learnyousomeerlang.com/" target="_blank" rel="external">《Learn You Some Erlang for Great Good!》</a>是一本非常棒的介绍Erlang的设计原则、标准库、最佳实践以及其他知识的书籍。一旦你已经阅读了上面提及的速成课程，你就可以安全地略过这本书介绍语法的前面几章。当你读到 <a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency" target="_blank" rel="external">并发指南</a> 这一章的时候，才是真正有趣的开始。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/where-to-go-next.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/where-to-go-next.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－Erlang的库]]></title>
      <url>http://szpzs.oschina.io/2017/02/14/elixir-getting-started-erlang-libraries/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">binary模块</a></li>
<li><a href="#part-two">格式化文本输出</a></li>
<li><a href="#part-three">crypto模块</a></li>
<li><a href="#part-four">digraph模块</a></li>
<li><a href="#part-five">ETS</a></li>
<li><a href="#part-six">math模块</a></li>
<li><a href="#part-seven">queue模块</a></li>
<li><a href="#part-eight">rand模块</a></li>
<li><a href="#part-nine">zip和zlib模块</a></li>
</ol>
<p>Elixir提供了非常棒的与Erlang的库交互的能力。实际上，Elixir不鼓励简单地封装Erlang的库，而是提倡直接与Erlang代码交互。本文我们将介绍一些最常见和有用的而在Elixir里找不到的Erlang功能。</p>
<p>当你逐渐熟悉了Elixir，你可能想要探索Erlang的<a href="http://erlang.org/doc/apps/stdlib/index.html" target="_blank" rel="external">STDLIB指引手册</a>来获得更多细节。</p>
<a id="more"></a>
<h1 id="binary模块"><a href="#binary模块" class="headerlink" title="binary模块"></a><span id="part-one">binary模块</span></h1><p>Elixir内建的String模块处理用UTF-8编码的二进制数据。当你要处理不一定要用UTF-8编码的二进制数据的时候，<a href="http://erlang.org/doc/man/binary.html" target="_blank" rel="external">binary模块</a>就有用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.to_charlist <span class="string">"Ø"</span></div><div class="line">[<span class="number">216</span>]</div><div class="line">iex&gt; <span class="symbol">:binary</span>.bin_to_list <span class="string">"Ø"</span></div><div class="line">[<span class="number">195</span>, <span class="number">152</span>]</div></pre></td></tr></table></figure>
<p>上面的例子展示了区别；String模块返回Unicode代码点，而 :binary 处理原始数据的字节。</p>
<h1 id="格式化文本输出"><a href="#格式化文本输出" class="headerlink" title="格式化文本输出"></a><span id="part-two">格式化文本输出</span></h1><p>Elixir没有包含与C语言和其他语言里的printf函数相似的函数。幸运地是，Erlang标准库函数 :io.format/2 和 :io_lib.format/2 可以被用作这样的功能。第一个函数格式化数据输出到终端，而第二个函数格式化数据为一个iolist。格式化说明符不同于printf，<a href="http://erlang.org/doc/man/io.html#format-1" target="_blank" rel="external">细节请参阅Erlang官方文档</a>。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:io</span>.format(<span class="string">"Pi is approximately given by:~10.3f~n"</span>, [<span class="symbol">:math</span>.pi])</div><div class="line">Pi is approximately given <span class="symbol">by:</span>     <span class="number">3.142</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; to_string <span class="symbol">:io_lib</span>.format(<span class="string">"Pi is approximately given by:~10.3f~n"</span>, [<span class="symbol">:math</span>.pi])</div><div class="line"><span class="string">"Pi is approximately given by:     3.142\n"</span></div></pre></td></tr></table></figure>
<p>另外要注意Erlang的格式化函数需要特别注意Unicode的处理。</p>
<h1 id="crypto模块"><a href="#crypto模块" class="headerlink" title="crypto模块"></a><span id="part-three">crypto模块</span></h1><p>crypto模块包含哈希函数、数字签名、加解密等等函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Base.encode16(<span class="symbol">:crypto</span>.hash(<span class="symbol">:sha256</span>, <span class="string">"Elixir"</span>))</div><div class="line"><span class="string">"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"</span></div></pre></td></tr></table></figure>
<p>:crypto模块不是Erlang标准库的一部分，但是它包含在Erlang发行版里。这意味着，任何时候你要使用 :crypto 的时候，就要把它加入你的项目应用列表里。要这么做的话，编辑你的 mix.exs 文件包含它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:crypto</span>]]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="digraph模块"><a href="#digraph模块" class="headerlink" title="digraph模块"></a><span id="part-four">digraph模块</span></h1><p><a href="http://erlang.org/doc/man/digraph.html" target="_blank" rel="external">digraph模块</a>（还有<a href="http://erlang.org/doc/man/digraph_utils.html" target="_blank" rel="external">digraph工具</a>）包含了处理用点和边构建的有向图的函数。在构建了图后，模块里的算法将帮助找到图里的两个节点间的最短路径或回环路径。</p>
<p>给定三个节点，找到从第一个到最后一个节点的最短路径。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; digraph = <span class="symbol">:digraph</span>.new()</div><div class="line">iex&gt; coords = [&#123;<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;]</div><div class="line">iex&gt; [v<span class="number">0</span>, v1, v2] = (<span class="keyword">for</span> c &lt;- coords, <span class="symbol">do:</span> <span class="symbol">:digraph</span>.add_vertex(digraph, c))</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.add_edge(digraph, v<span class="number">0</span>, v1)</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.add_edge(digraph, v1, v2)</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.get_short_path(digraph, v<span class="number">0</span>, v2)</div><div class="line">[&#123;<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;]</div></pre></td></tr></table></figure>
<p>注意：:digraph里的函数在内部修改了图的结构，这是可能的，因为它们被实现为ETS表。下面我们来看看ETS。</p>
<h1 id="ETS"><a href="#ETS" class="headerlink" title="ETS"></a><span id="part-five">ETS</span></h1><p><a href="http://erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 和 <a href="http://erlang.org/doc/man/dets.html" target="_blank" rel="external">dets</a> 模块分别处理内存或硬盘的大数据结构存储。</p>
<p>ETS让你创建一个包含元组的表。默认情况下，ETS表是被保护的，就是说只有拥有者进程可以写这个表，而其他任何进程可以读这个表。ETS有一些功能被用来当做简单数据库、KV存储或者缓存机制。</p>
<p>ets模块的函数将修改表的状态作为副作用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:ets_test</span>, [])</div><div class="line"><span class="comment"># Store as tuples with &#123;name, population&#125;</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"China"</span>, <span class="number">1_374_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"India"</span>, <span class="number">1_284_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"USA"</span>, <span class="number">322_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.i(table)</div><div class="line">&lt;<span class="number">1</span>   &gt; &#123;&lt;&lt;<span class="string">"India"</span>&gt;&gt;,<span class="number">1284000000</span>&#125;</div><div class="line">&lt;<span class="number">2</span>   &gt; &#123;&lt;&lt;<span class="string">"USA"</span>&gt;&gt;,<span class="number">322000000</span>&#125;</div><div class="line">&lt;<span class="number">3</span>   &gt; &#123;&lt;&lt;<span class="string">"China"</span>&gt;&gt;,<span class="number">1374000000</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="math模块"><a href="#math模块" class="headerlink" title="math模块"></a><span id="part-six">math模块</span></h1><p><a href="http://erlang.org/doc/man/math.html" target="_blank" rel="external">math模块</a>包含常用的数学运算，覆盖三角函数、指数函数、对数函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; angle_45_deg = <span class="symbol">:math</span>.pi() * <span class="number">45.0</span> / <span class="number">180.0</span></div><div class="line">iex&gt; <span class="symbol">:math</span>.sin(angle_45_deg)</div><div class="line"><span class="number">0</span>.<span class="number">7071067811865475</span></div><div class="line">iex&gt; <span class="symbol">:math</span>.exp(<span class="number">55.0</span>)</div><div class="line"><span class="number">7.694785265142018</span>e23</div><div class="line">iex&gt; <span class="symbol">:math</span>.log(<span class="number">7.694785265142018</span>e23)</div><div class="line"><span class="number">55.0</span></div></pre></td></tr></table></figure>
<h1 id="queue模块"><a href="#queue模块" class="headerlink" title="queue模块"></a><span id="part-seven">queue模块</span></h1><p><a href="http://erlang.org/doc/man/queue.html" target="_blank" rel="external">queue是一个数据结构</a>，它高效地实现了（双端）FIFO（先进先出）队列。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; q = <span class="symbol">:queue</span>.new</div><div class="line">iex&gt; q = <span class="symbol">:queue</span>.<span class="keyword">in</span>(<span class="string">"A"</span>, q)</div><div class="line">iex&gt; q = <span class="symbol">:queue</span>.<span class="keyword">in</span>(<span class="string">"B"</span>, q)</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line">&#123;<span class="symbol">:value</span>, <span class="string">"A"</span>&#125;</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line">&#123;<span class="symbol">:value</span>, <span class="string">"B"</span>&#125;</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line"><span class="symbol">:empty</span></div></pre></td></tr></table></figure>
<h1 id="rand模块"><a href="#rand模块" class="headerlink" title="rand模块"></a><span id="part-eight">rand模块</span></h1><p><a href="http://erlang.org/doc/man/rand.html" target="_blank" rel="external">rand</a>有返回随机数和设置随机种子的函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform()</div><div class="line"><span class="number">0</span>.<span class="number">8175669086010815</span></div><div class="line">iex&gt; <span class="number">_</span> = <span class="symbol">:rand</span>.seed(<span class="symbol">:exs1024</span>, &#123;<span class="number">123</span>, <span class="number">123534</span>, <span class="number">345345</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform()</div><div class="line"><span class="number">0</span>.<span class="number">5820506340260994</span></div><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform(<span class="number">6</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<h1 id="zip和zlib模块"><a href="#zip和zlib模块" class="headerlink" title="zip和zlib模块"></a><span id="part-nine">zip和zlib模块</span></h1><p>zip模块让你从硬盘或内存读写ZIP文件，也提取文件的信息。</p>
<p>下面的代码统计ZIP文件里的文件个数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:zip</span>.foldl(<span class="keyword">fn</span> <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>, acc -&gt; acc + <span class="number">1</span> <span class="keyword">end</span>, <span class="number">0</span>, <span class="symbol">:binary</span>.bin_to_list(<span class="string">"file.zip"</span>))</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="number">633</span>&#125;</div></pre></td></tr></table></figure>
<p>zlib模块用zlib格式，就如gzip命令里找到的格式，来处理压缩数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; song = <span class="string">"</span></div><div class="line">...&gt; Mary had a little lamb,</div><div class="line">...&gt; His fleece was white as snow,</div><div class="line">...&gt; And everywhere that Mary went,</div><div class="line">...&gt; The lamb was sure to go."</div><div class="line">iex&gt; compressed = <span class="symbol">:zlib</span>.compress(song)</div><div class="line">iex&gt; byte_size song</div><div class="line"><span class="number">110</span></div><div class="line">iex&gt; byte_size compressed</div><div class="line"><span class="number">99</span></div><div class="line">iex&gt; <span class="symbol">:zlib</span>.uncompress(compressed)</div><div class="line"><span class="string">"\nMary had a little lamb,\nHis fleece was white as snow,\nAnd everywhere that Mary went,\nThe lamb was sure to go."</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/erlang-libraries.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/erlang-libraries.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－Typespecs 和 behaviours]]></title>
      <url>http://szpzs.oschina.io/2017/02/13/elixir-getting-started-typespecs-and-behaviours/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">类型和规格说明</a><br> 1.1 <a href="#part-one-one">函数规格说明</a><br> 1.2 <a href="#part-one-two">定义自定义类型</a><br> 1.3 <a href="#part-one-three">静态代码分析</a></li>
<li><a href="#part-two">行为</a><br> 2.1 <a href="#part-two-one">定义行为</a><br> 2.2 <a href="#part-two-two">采用行为</a></li>
</ol>
<a id="more"></a>
<h1 id="类型和规格说明"><a href="#类型和规格说明" class="headerlink" title="类型和规格说明"></a><span id="part-one">类型和规格说明</span></h1><p>Elixir是一门动态类型语言，所以Elixir里的所有类型是由运行时推断出来的。尽管如此，Elixir还是有一个标记叫做 <strong>typespecs</strong> ，它被用来：</p>
<ol>
<li>声明类型函数签名（规格说明）</li>
<li>声明自定义数据类型</li>
</ol>
<h2 id="函数规格说明"><a href="#函数规格说明" class="headerlink" title="函数规格说明"></a><span id="part-one-one">函数规格说明</span></h2><p>Elixir默认提供一些基本类型，比如：整形 或 pid，以及更复杂的类型：例如，round/1 函数，它返回一个浮点数最接近的整数，它的入参是一个数字（整数或浮点数）而返回的是一个整数。在<a href="https://hexdocs.pm/elixir/Kernel.html#round/1" target="_blank" rel="external">它的文档里</a>你可以看到，round/1 的类型签名写为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(number) <span class="symbol">:</span>: integer</div></pre></td></tr></table></figure>
<p>:: 的意思是，其左边的函数返回一个值，它的类型就是其左边的类型。</p>
<p>函数规格说明用指令 @spec 来写，刚好置于函数定义的前面。round/1 函数如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@spec</span> round(number) <span class="symbol">:</span>: integer</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span></span>(number), <span class="symbol">do:</span> <span class="comment"># implementation...</span></div></pre></td></tr></table></figure>
<p>Elixir也支持组合类型。例如，整数列表的类型为：[integer] 。<a href="https://hexdocs.pm/elixir/typespecs.html" target="_blank" rel="external">在 typespec 的文档里</a>，你可以看到Elixir提供的所有内建类型。</p>
<h2 id="定义自定义类型"><a href="#定义自定义类型" class="headerlink" title="定义自定义类型"></a><span id="part-one-two">定义自定义类型</span></h2><p>Elixir提供了很多有用的内建类型，这便于在适当的时候定义自定义类型。这可以在定义模块的时候通过 @type 指令来做到。</p>
<p>假设我们有一个 LousyCalculator 模块，它执行一些通常的算术运算（和、乘积，等等），但是，它不返回计算结果，而是返回一个元组，这个元组用运算结果作为第一个元素，用一个随机的评论作为第二个元素。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">LousyCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> &#123;x + y, <span class="string">"You need a calculator to do that?!"</span>&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> multiply(number, number) <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x, y), <span class="symbol">do:</span> &#123;x * y, <span class="string">"Jeez, come on!"</span>&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如你在例子看到的，元组是一个组合类型，并且每一个元组在其内部通过类型来定义。要理解为什么String.t不写作String，请看<a href="https://hexdocs.pm/elixir/typespecs.html#notes" target="_blank" rel="external">在typespec文档里的说明</a>。</p>
<p>定义函数规格说明以上述例子的方式是可行的，不过很快就变得令人烦恼了，因为我们正一遍又一遍地重复输入 {number, String.t} 。我们可以用 @type 指令来声明我们自己的自定义类型。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">LousyCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@typedoc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Just a number followed by a string.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="variable">@type</span> number_with_remark <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: number_with_remark</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> &#123;x + y, <span class="string">"You need a calculator to do that?"</span>&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> multiply(number, number) <span class="symbol">:</span>: number_with_remark</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x, y), <span class="symbol">do:</span> &#123;x * y, <span class="string">"It is like addition on steroids."</span>&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>@typedoc 指令相似于 @doc 和 @moduledoc 指令，它被用来注释自定义类型。</p>
<p>通过 @type 定义的自定义类型被导出而且在它们被定义的模块外部也可用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">QuietCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: number</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> make_quiet(LousyCalculator.add(x, y))</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> make_quiet(LousyCalculator.number_with_remark) <span class="symbol">:</span>: number</div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">make_quiet</span></span>(&#123;num, _remark&#125;), <span class="symbol">do:</span> num</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你想保留自定义类型为私有的，你可以用 @typep 指令替代 @type 指令。</p>
<h2 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a><span id="part-one-three">静态代码分析</span></h2><p>类型规格说明不仅是对开发人员有用的附加文档。例如，Erlang工具 <a href="http://www.erlang.org/doc/man/dialyzer.html" target="_blank" rel="external">Dialyzer</a> 使用类型规格说明来进行代码的静态分析。这就是为什么在 QuietCalculator  例子里，我们为 make_quiet/1 函数写规格说明，即使它被定义为私有函数。</p>
<h1 id="行为"><a href="#行为" class="headerlink" title="行为"></a><span id="part-two">行为</span></h1><p>许多模块共享相同的公共API。我们看看<a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a>，正如它自己的描述所声明，它是web应用里可组合的模块的<strong>规格说明</strong>。每一个plug是一个模块，它必须实现最少两个公共函数：init/1 和 call/2 。</p>
<p>行为提供一种方式：</p>
<ul>
<li>定义必须被一个模块实现的一个函数集合；</li>
<li>确定一个模块实现这个集合里的所有函数。</li>
</ul>
<p>如果你愿意，你可以认为行为就像Java这种面向对象语言里的接口：一个模块必须实现的函数签名的集合。</p>
<h2 id="定义行为"><a href="#定义行为" class="headerlink" title="定义行为"></a><span id="part-two-one">定义行为</span></h2><p>假如我们想实现一些分析器，它们每一个都分析结构化的数据：例如，一个JSON分析器和一个YAML分析器。这两个解析器将有相同的行为方式：两者都提供一个parse/1 函数和一个 extensions/0 函数。parse/1 函数将返回一个Elixir的结构化数据描述，而 extensions/0 函数将返回可被用于每种数据类型（例如，.json对应于JSON文件）的文件扩展名的列表。</p>
<p>我们可以创建一个 Parser 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Parser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@callback</span> parse(String.t) <span class="symbol">:</span>: any</div><div class="line">  <span class="variable">@callback</span> extensions() <span class="symbol">:</span>: [String.t]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>采用 Parser 行为的模块将必须实现所有用 @callback 指令定义的函数。如你所见，@callback 指令期望有一个函数名以及如我们前面所看到的 @spec 指令用到的函数规格说明。</p>
<h2 id="采用行为"><a href="#采用行为" class="headerlink" title="采用行为"></a><span id="part-two-two">采用行为</span></h2><p>采用一个行为很简单：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">JSONParser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> Parser</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str), <span class="symbol">do:</span> <span class="comment"># ... parse JSON</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extensions</span></span>, <span class="symbol">do:</span> [<span class="string">"json"</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">YAMLParser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> Parser</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str), <span class="symbol">do:</span> <span class="comment"># ... parse YAML</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extensions</span></span>, <span class="symbol">do:</span> [<span class="string">"yml"</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果一个模块采用一个给定的行为却没有实现行为需要的所有回调函数中的一个，则一个编译期警告将被生成。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/typespecs-and-behaviours.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－尝试、捕获和挽救]]></title>
      <url>http://szpzs.oschina.io/2017/02/12/elixir-getting-started-try-catch-and-rescue/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Errors</a></li>
<li><a href="#part-two">Throws</a></li>
<li><a href="#part-three">Exits</a></li>
<li><a href="#part-four">After</a></li>
<li><a href="#part-five">Else</a></li>
<li><a href="#part-six">变量作用域</a></li>
</ol>
<p>Elixir有三种错误机制：errors，throws，和 exits 。本章我们将探索它们每一个，并且包括应该何时使用哪一个的评论。</p>
<a id="more"></a>
<h1 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a><span id="part-one">Errors</span></h1><p>错误（或者叫异常）是在代码里有异常的事情发生的时候被使用的。例如，通过尝试将一个数字和原子相加就可以获得一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:foo</span> + <span class="number">1</span></div><div class="line">** (ArithmeticError) bad argument <span class="keyword">in</span> arithmetic expression</div><div class="line">     <span class="symbol">:erlang</span>.+(<span class="symbol">:foo</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>任何时候用 raise/1 一个运行时错误可以被抛出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; raise <span class="string">"oops"</span></div><div class="line">** (RuntimeError) oops</div></pre></td></tr></table></figure>
<p>其他种类的错误可以通过传入错误名字和一个关键字列表作为入参给函数 raise/2 来抛出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; raise ArgumentError, <span class="symbol">message:</span> <span class="string">"invalid argument foo"</span></div><div class="line">** (ArgumentError) invalid argument foo</div></pre></td></tr></table></figure>
<p>通过创建一个模块并在它里面使用 defexception 结构，你也可以定义自己的错误；用这种方式，你将创建一个和这个错误定义所在的模块的名字相同的错误。最常见的场景是定义一个自定义的异常，并且有一个消息字段：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyError</span></span> <span class="keyword">do</span></div><div class="line">iex&gt;   defexception <span class="symbol">message:</span> <span class="string">"default message"</span></div><div class="line">iex&gt; <span class="keyword">end</span></div><div class="line">iex&gt; raise MyError</div><div class="line">** (MyError) default message</div><div class="line">iex&gt; raise MyError, <span class="symbol">message:</span> <span class="string">"custom message"</span></div><div class="line">** (MyError) custom message</div></pre></td></tr></table></figure>
<p>错误可以用 try/rescue  结构来<strong>挽救</strong>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"oops"</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   e <span class="keyword">in</span> RuntimeError -&gt; e</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%RuntimeError&#123;<span class="symbol">message:</span> <span class="string">"oops"</span>&#125;</div></pre></td></tr></table></figure>
<p>上面的例子挽救了运行时错误并且返回这个错误，然后这个错误被打印在iex会话里。</p>
<p>如果错误对你无用，你就不需要返回它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"oops"</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   RuntimeError -&gt; <span class="string">"Error!"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Error!"</span></div></pre></td></tr></table></figure>
<p>但是在实践中，Elixir开发者很少使用 try/rescue 结构。例如，当一个文件不能被成功打开的时候，许多语言会强制要求你去挽救这个错误。Elixir反而是提供了一个函数 File.read/1 ，它返回一个元组，包含了关于这个文件是否被成功打开的相关消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:enoent</span>&#125;</div><div class="line">iex&gt; File.write <span class="string">"hello"</span>, <span class="string">"world"</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>这里就没有 try/rescue 。如果你想要处理打开一个文件的不同输出，你可以在case语句里使用模式匹配：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> File.read <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, body&#125;      -&gt; IO.puts <span class="string">"Success: <span class="subst">#&#123;body&#125;</span>"</span></div><div class="line">...&gt;   &#123;<span class="symbol">:error</span>, reason&#125; -&gt; IO.puts <span class="string">"Error: <span class="subst">#&#123;reason&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最终由你的程序来决定打开一个文件出现的出错是否是一个异常。这就是为什么Elixir在File.read/1和许多函数上没有强制输出异常。相反，它留给开发者选择最好的方法进行处理。</p>
<p>对于你确实期望一个文件存在（而这个文件不存在就一定是一个错误）的场景，你可以使用 File.read!/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read! <span class="string">"unknown"</span></div><div class="line">** (File.Error) could <span class="keyword">not</span> read file <span class="symbol">unknown:</span> no such file <span class="keyword">or</span> directory</div><div class="line">    (elixir) lib/file.<span class="symbol">ex:</span><span class="number">305</span>: File.read!<span class="regexp">/1</span></div></pre></td></tr></table></figure>
<p>标准库里的许多函数遵循这样的模式：它有一个副本函数，它抛出异常而不是返回用来匹配的元组。这个约定习惯是，创建一个返回 {:ok, result} 或 {:error, reason} 元组的函数（foo）而另一个函数（foo!，相同的名字不过尾部有一个！字符）接收和foo函数一样的入参，但是如果有错误的时候，它抛出一个异常。如果一切正常，foo!将返回结果（而不是用元组包裹起来）。<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File模块</a>是这个约定习惯的很好的例子。</p>
<p>在Elixir里，我们避免使用 try/rescue ，因为我们不使用错误来进行流程控制。我们真正对待错误的看法是：他们是为意外和/或例外情况预留的。如果你确实需要流程控制结构，可以使用 throws 。它就是我们接下来看到的。</p>
<h1 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a><span id="part-two">Throws</span></h1><p>在Elixir里，一个值可以被抛出然后被捕获。throw 和 catch 是为这样的情况保留的，就是：除了用throw 和 catch，不可能来获取到一个值。</p>
<p>实际上这些场景是非常罕见的，除非当你和没有提供合适API的库交互的时候。例如，让我们假设Enum模块没有提供任何API来找到一个值，而这个值就是我们需要在一个数字列表里找到第一个13的倍数的数字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   Enum.each -<span class="number">50</span>..<span class="number">50</span>, <span class="keyword">fn</span>(x) -&gt;</div><div class="line">...&gt;     if rem(x, <span class="number">13</span>) == <span class="number">0</span>, <span class="symbol">do:</span> throw(x)</div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt;   <span class="string">"Got nothing"</span></div><div class="line">...&gt; catch</div><div class="line">...&gt;   x -&gt; <span class="string">"Got <span class="subst">#&#123;x&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got -39"</span></div></pre></td></tr></table></figure>
<p>因为Enum的确是提供了合适的API，所以实际上Enum.find/2是最好的人选：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.find -<span class="number">50</span>..<span class="number">50</span>, &amp;(rem(&amp;<span class="number">1</span>, <span class="number">13</span>) == <span class="number">0</span>)</div><div class="line">-<span class="number">39</span></div></pre></td></tr></table></figure>
<h1 id="Exits"><a href="#Exits" class="headerlink" title="Exits"></a><span id="part-three">Exits</span></h1><p>所有Elixir代码运行在彼此交互的进程里。当一个进程死于“自然原因”（比如，没有处理异常），它会发送一个退出信号。一个进程也可以通过明确地发送一个退出信号而死亡：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn_link <span class="keyword">fn</span> -&gt; exit(<span class="number">1</span>) <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.56.0&gt;</span></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.56.0&gt;) 1</span></div></pre></td></tr></table></figure>
<p>上面的例子，通过发送值为1的退出信号，被链接的进程死亡。Elixir shell自动处理那些消息并打印在终端上。</p>
<p>退出可以用try/catch来“捕获”：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   exit <span class="string">"I am exiting"</span></div><div class="line">...&gt; catch</div><div class="line">...&gt;   <span class="symbol">:exit</span>, <span class="number">_</span> -&gt; <span class="string">"not really"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"not really"</span></div></pre></td></tr></table></figure>
<p>使用 try/catch 已经很少见了，用它来捕获退出更加罕见。</p>
<p>退出信号是由Erlang虚拟机提供的容错系统的一个重要部分。进程常常运行在监督树下，监督树也是进程；这些进程监听从被监督进程来的退出信号。一旦接收到一个退出信号，监督策略被触发，被监督进程被重启。</p>
<p>正是这种监督体系，使得像 try/catch 和 try/rescue 这样的结构在Elixir里那么罕见。我们宁愿“速错”而不是挽救一个错误，因为我们的监督树将保证我们的应用在错误后将回到一个可知的初始状态。</p>
<h1 id="After"><a href="#After" class="headerlink" title="After"></a><span id="part-four">After</span></h1><p>有时候，在一些可能潜在地引起错误的动作后确保资源被清理干净是必须的。try/after 结构允许你这么做。例如，我们可以打开一个文件并使用after分支关闭它，即使有一些事情出错：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"sample"</span>, [<span class="symbol">:utf8</span>, <span class="symbol">:write</span>]</div><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   IO.write file, <span class="string">"olá"</span></div><div class="line">...&gt;   raise <span class="string">"oops, something went wrong"</span></div><div class="line">...&gt; after</div><div class="line">...&gt;   File.close(file)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (RuntimeError) oops, something went wrong</div></pre></td></tr></table></figure>
<p>after分支将被执行而不管try语句块时候成功。然而需要注意，如果一个被链接的进程退出，这个进程将退出并且after分支将不会被执行。因此，after仅提供一个软保证。幸运地是，Elixir里的文件也被链接到当前进程，因此如果当前进程崩溃了，它们将总是被关闭，而与after分支无关。你将发现其他资源比如ETS表、socket、port等等也是这样。</p>
<p>有时你可能想在一个try结构中封装一个函数的整个身体部分，这样通常是为了保证一些代码在后面被执行。这样的场景，Elixir允许你省略 try 这一行：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">RunAfter</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">without_even_trying</span></span> <span class="keyword">do</span></div><div class="line">...&gt;     raise <span class="string">"oops"</span></div><div class="line">...&gt;   after</div><div class="line">...&gt;     IO.puts <span class="string">"cleaning up!"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; RunAfter.without_even_trying</div><div class="line">cleaning up!</div><div class="line">** (RuntimeError) oops</div></pre></td></tr></table></figure>
<p>任何时候，after、rescue 或 catch 其中任何一个被用到了，Elixir将自动地封装函数的身体部分到try结构里。</p>
<h1 id="Else"><a href="#Else" class="headerlink" title="Else"></a><span id="part-five">Else</span></h1><p>提供一个 else 块来允许在表达式执行结果上进行模式匹配。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">2</span></div><div class="line">try <span class="keyword">do</span></div><div class="line">  <span class="number">1</span> / x</div><div class="line">rescue</div><div class="line">  ArithmeticError -&gt;</div><div class="line">    <span class="symbol">:infinity</span></div><div class="line">else</div><div class="line">  y <span class="keyword">when</span> y &lt; <span class="number">1</span> <span class="keyword">and</span> y &gt; -<span class="number">1</span> -&gt;</div><div class="line">    <span class="symbol">:small</span></div><div class="line">  <span class="number">_</span> -&gt;</div><div class="line">    <span class="symbol">:large</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>结果被传递给else，并且在那里陪匹配。请注意，如果一个异常被捕获，else也被执行，catch/rescue 块的结果将传递给else。</p>
<p>else块的异常不被捕获。如果else块里的模式没有被匹配上，一个异常将被抛出，这个异常不被当前的 try/catch/rescue/after 块捕获。</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><span id="part-six">变量作用域</span></h1><p>重要的是要记住，定义在try/catch/rescue/after块内的变量不泄漏到外部环境。这是因为try块可能失败，并且变量可能在第一个地方没有被绑定。换句话说，下面的代码是无效的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"fail"</span></div><div class="line">...&gt;   what_happened = <span class="symbol">:did_not_raise</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   <span class="number">_</span> -&gt; what_happened = <span class="symbol">:rescued</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; what_happened</div><div class="line">** (RuntimeError) undefined <span class="symbol">function:</span> what_happened/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>相反，你可以存储try表达式的值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; what_happened =</div><div class="line">...&gt;   try <span class="keyword">do</span></div><div class="line">...&gt;     raise <span class="string">"fail"</span></div><div class="line">...&gt;     <span class="symbol">:did_not_raise</span></div><div class="line">...&gt;   rescue</div><div class="line">...&gt;     <span class="number">_</span> -&gt; <span class="symbol">:rescued</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">iex&gt; what_happened</div><div class="line"><span class="symbol">:rescued</span></div></pre></td></tr></table></figure>
<p>到此我们结束了try、catch 和 rescue的介绍。你将发现它们在Elixir里用得频率比在其他语言里少很多，虽然在一些库或某些特定的代码不“按规则”玩的情况下，它们用起来可能很方便。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/try-catch-and-rescue.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/try-catch-and-rescue.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－印记]]></title>
      <url>http://szpzs.oschina.io/2017/02/12/elixir-getting-started-sigils/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">正则表达式</a></li>
<li><a href="#part-two">字符串、字符列表和词列表印记</a><br> 2.1 <a href="#part-two-one">字符串</a><br> 2.2 <a href="#part-two-two">字符列表</a><br> 2.3 <a href="#part-two-three">词列表</a></li>
<li><a href="#part-three">在印记中插入文本和转义字符</a></li>
<li><a href="#part-four">自定义印记</a></li>
</ol>
<p>我们已经学了Elixir提供双引号字符串和单引号字符列表。然而，这只是涵盖了该语言有文本表示的数据类型结构的表面。例如，原子主要就是通过 :atom 表示来创建的。</p>
<p>Elixir其中一个目标是可扩展性：开发者可以扩展该语言来解决任何特定的领域问题。计算机科学已经成为如此广阔的领域，一门语言解决许多领域的问题来作为它的核心部分是不太可能的。相反，我们最好的方法是使语言具有可扩展性，因此开发人员、公司和社区可以将语言扩展到相关领域。</p>
<p>本章，我们将探索印记，它是由Elixir这门语言提供的处理文本描述数据类型的其中一种机制。印记由波浪字符（~）开始，紧接着是一个字符（这个字符定义本印记），然后是一个分隔符，可选性的修饰符可以增加在最后的分隔符后。</p>
<a id="more"></a>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><span id="part-one">正则表达式</span></h1><p>Elixir里最常用的印记是~r，它被用来创建<a href="https://en.wikipedia.org/wiki/Regular_Expressions" target="_blank" rel="external">正则表达式</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A regular expression that matches strings which contain "foo" or "bar":</span></div><div class="line">iex&gt; regex = ~r/foo|bar/</div><div class="line">~r/foo|bar/</div><div class="line">iex&gt; <span class="string">"foo"</span> =~ regex</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="string">"bat"</span> =~ regex</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<p>Elixir提供Perl兼容正则表达式（regexes），它由<a href="http://www.pcre.org/" target="_blank" rel="external">PCRE</a>库实现。regexes也支持修饰符。例如，i修饰符使得正则表达式不大小写敏感：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"HELLO"</span> =~ ~r/hello/</div><div class="line"><span class="keyword">false</span></div><div class="line">iex&gt; <span class="string">"HELLO"</span> =~ ~r/hello/i</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>请查阅<a href="https://hexdocs.pm/elixir/Regex.html" target="_blank" rel="external">Regex模块</a>获取正则表达式的其他修饰符和被支持的操作的信息。</p>
<p>到目前为止，所有例子都是用 / 来界定一个正则表达式。然后印记支持8种不同的分隔符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">~r/hello/</div><div class="line">~r|hello|</div><div class="line">~r<span class="string">"hello"</span></div><div class="line">~r<span class="string">'hello'</span></div><div class="line">~r(hello)</div><div class="line">~r[hello]</div><div class="line">~r&#123;hello&#125;</div><div class="line">~r&lt;hello&gt;</div></pre></td></tr></table></figure>
<p>支持不同分隔符背后的原因是提供一种不需要转义分隔符来写字面量。例如，一个有斜杠的正则表达式，这样写：~r(^https?://) 肯定比这么写 ~r/^https?:\/\/ 更容易读。相似地，如果正则表达式含有斜杠和捕获组（即使用()），那么你可以使用双引号来替代圆括号。</p>
<h1 id="字符串、字符列表和词列表印记"><a href="#字符串、字符列表和词列表印记" class="headerlink" title="字符串、字符列表和词列表印记"></a><span id="part-two">字符串、字符列表和词列表印记</span></h1><p>除了正则表达式，Elixir还有三种其他印记。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span id="part-two-one">字符串</span></h2><p>~s印记被用来创建字符串，像双引号一样。当一个字符串包含有双引号的时候，~s印记很有用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s(this is a string with <span class="string">"double"</span> quotes, <span class="keyword">not</span> <span class="string">'single'</span> ones)</div><div class="line"><span class="string">"this is a string with \"double\" quotes, not 'single' ones"</span></div></pre></td></tr></table></figure>
<h2 id="字符列表"><a href="#字符列表" class="headerlink" title="字符列表"></a><span id="part-two-two">字符列表</span></h2><p>~c印记被用来创建含有单引号的字符列表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~c(this is a char list containing <span class="string">'single quotes'</span>)</div><div class="line"><span class="string">'this is a char list containing \'single quotes\''</span></div></pre></td></tr></table></figure>
<h2 id="词列表"><a href="#词列表" class="headerlink" title="词列表"></a><span id="part-two-three">词列表</span></h2><p>~w印记被用来创建词列表（词就是普通字符串）。在~w印记里，词被空白分隔。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~w(foo bar bat)</div><div class="line">[<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"bat"</span>]</div></pre></td></tr></table></figure>
<p>~w印记也接收c， s 和 a 修饰符（分别对应，字符列表、字符串和原子），它们指定结果列表的元素的数据类型：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~w(foo bar bat)a</div><div class="line">[<span class="symbol">:foo</span>, <span class="symbol">:bar</span>, <span class="symbol">:bat</span>]</div></pre></td></tr></table></figure>
<h1 id="在印记中插入文本和转义字符"><a href="#在印记中插入文本和转义字符" class="headerlink" title="在印记中插入文本和转义字符"></a><span id="part-three">在印记中插入文本和转义字符</span></h1><p>除了小写印记，Elixir也支持大写印记来处理转义字符和插入文本。虽然 ~s 和 ~S 都返回字符串，但是前者允许转义码和插入文本，而后者则不允许：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s(String with escape codes \x26 <span class="comment">#&#123;"inter" &lt;&gt; "polation"&#125;)</span></div><div class="line"><span class="string">"String with escape codes &amp; interpolation"</span></div><div class="line">iex&gt; ~S(String without escape codes \x26 without <span class="comment">#&#123;interpolation&#125;)</span></div><div class="line"><span class="string">"String without escape codes \\x26 without \#&#123;interpolation&#125;"</span></div></pre></td></tr></table></figure>
<p>下面的转义码可以被用在字符串和字符列表里：</p>
<ul>
<li>\ - 单个反斜杠</li>
<li>\a - 铃声/警报</li>
<li>\b - 退格键</li>
<li>\d - 删除键</li>
<li>\e - 退出键</li>
<li>\f - 换页符</li>
<li>\n - 新行符</li>
<li>\r - 回车符</li>
<li>\s - 空格付</li>
<li>\t - Tab键</li>
<li>\v - 垂直Tab键</li>
<li>\0 - 空字节</li>
<li>\xDD - 用十六进制表示的单字节（比如：\x13）</li>
<li>\uDDDD 和 \u{D…} - 用十六进制表示的Unicode代码点（比如：\u{1F600}）</li>
</ul>
<p>另外，在双引号字符串里的双引号需要用\”来转义，类似的，单引号字符列表里的单引号需要用\’来转义。然而，向上述的例子那样改变分隔符而不是转义它们是一种更好的方式。</p>
<p>印记也支持 heredocs ，即 三个双或单引号作为分隔符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s<span class="string">""</span><span class="string">"</span></div><div class="line">...&gt; this is</div><div class="line">...&gt; a heredoc string</div><div class="line">...&gt; "<span class="string">""</span></div></pre></td></tr></table></figure>
<p>heredocs印记最常用的地方是在写文档的时候。例如，在文档里写转义字符很容易出错，因为需要两次转义一些字符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Converts double-quotes to single-quotes.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; convert("\\\<span class="string">"foo\\\""</span>)</div><div class="line">    <span class="string">"'foo'"</span></div><div class="line"></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line">def convert(...)</div></pre></td></tr></table></figure>
<p>但是用~S，这个问题可以完全避免：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">Converts double-quotes to single-quotes.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; convert("\<span class="string">"foo\""</span>)</div><div class="line">    <span class="string">"'foo'"</span></div><div class="line"></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line">def convert(...)</div></pre></td></tr></table></figure>
<h1 id="自定义印记"><a href="#自定义印记" class="headerlink" title="自定义印记"></a><span id="part-four">自定义印记</span></h1><p>如本文开始的时候所提示，Elixir中的印记是一种扩展。实际上，用印记 ~r/foo/i 和以一个二进制数据和一个字符列表作为入参调用 sigil_r 是等效的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; sigil_r(&lt;&lt;<span class="string">"foo"</span>&gt;&gt;, <span class="string">'i'</span>)</div><div class="line">~r<span class="string">"foo"</span>i</div></pre></td></tr></table></figure>
<p>我们可以通过访问sigil_r文档来看看~r：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; h sigil_r</div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们也可以通过遵循 sigil_{identifier} 模式来实现函数以提供我们自己的印记。例如，让我们来实现 ~i 印记，它返回一个整数（使用可选择的 n 修饰符来返回它的负数）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MySigils</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sigil_i</span></span>(string, []), <span class="symbol">do:</span> String.to_integer(string)</div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sigil_i</span></span>(string, [?n]), <span class="symbol">do:</span> -String.to_integer(string)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; import MySigils</div><div class="line">iex&gt; ~i(<span class="number">13</span>)</div><div class="line"><span class="number">13</span></div><div class="line">iex&gt; ~i(<span class="number">42</span>)n</div><div class="line">-<span class="number">42</span></div></pre></td></tr></table></figure>
<p>印记也可以在宏的帮助下被用来做编译期工作。例如，Elixir里的正则表达式可以在源代码编译期间被编译为一个高效的描述，因此在运行期跳过这一步。如果你对这个主题有兴趣，我们建议你学习更多关于宏的知识，并查阅印记在Kernel模块（即形如sigil_*相关被定义的函数）里是如何实现的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/sigils.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/sigils.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－速构]]></title>
      <url>http://szpzs.oschina.io/2017/02/11/elixir-getting-started-comprehensions/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">生成器和过滤器</a></li>
<li><a href="#part-two">位串生成器</a></li>
<li><a href="#part-three">:into选项</a></li>
</ol>
<p>在Elixir中，遍历一个枚举类型数据，过滤其中一些值并且将值映射到另一个列表里这种做法是很平常的。速构是对于这种数据结构的语法糖：Elixir里将这种语法组织成 for 的格式。</p>
<p>例如，我们可以将一个整数列表的每个值都求平方：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>一个速构有三部分组成：生成器、过滤器和收集动作。</p>
<a id="more"></a>
<h1 id="生成器和过滤器"><a href="#生成器和过滤器" class="headerlink" title="生成器和过滤器"></a><span id="part-one">生成器和过滤器</span></h1><p>上面的表达式中，n &lt;- [1, 2, 3, 4] 是<strong>生成器</strong>。它逐个生成在速构中被使用的值。任何枚举类型数据都可以置于生成器表达式的右边：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- <span class="number">1</span>..<span class="number">4</span>, <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>生成器表达式的左边也支持模式匹配；所有没有匹配到的数据被忽略。想象一下，我们用一个关键字列表而不是一个范围类型数据，键有 :good 和 :bad ，而我们只是想计算 :good 的值的平方：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; values = [<span class="symbol">good:</span> <span class="number">1</span>, <span class="symbol">good:</span> <span class="number">2</span>, <span class="symbol">bad:</span> <span class="number">3</span>, <span class="symbol">good:</span> <span class="number">4</span>]</div><div class="line">iex&gt; <span class="keyword">for</span> &#123;<span class="symbol">:good</span>, n&#125; &lt;- values, <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>除了生成器使用模式匹配，过滤器可以被用来选择一些特定的元素。例如，我们可以选择是3的倍数的值而丢弃其他的值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; multiple_of_3? = <span class="keyword">fn</span>(n) -&gt; rem(n, <span class="number">3</span>) == <span class="number">0</span> <span class="keyword">end</span></div><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- <span class="number">0</span>..<span class="number">5</span>, multiple_of_3?.(n), <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">0</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>速构丢弃所有过滤器返回false或者nil的元素，而选择其他元素。</p>
<p>速构通常提供比使用Enum 和 Stream模块里的函数更加简洁的描述。而且，速构也运行有多个生成器和过滤器。这里有一个例子，接收一个目录组成的列表，然后获得这些目录里每一个文件的大小：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dirs = [<span class="string">'/home/mikey'</span>, <span class="string">'/home/james'</span>]</div><div class="line"><span class="keyword">for</span> dir  &lt;- dirs,</div><div class="line">    file &lt;- File.ls!(dir),</div><div class="line">    path = Path.join(dir, file),</div><div class="line">    File.regular?(path) <span class="keyword">do</span></div><div class="line">  File.stat!(path).size</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>多生成器也可以被用来计算两个列表的笛卡儿积：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> i &lt;- [<span class="symbol">:a</span>, <span class="symbol">:b</span>, <span class="symbol">:c</span>], j &lt;- [<span class="number">1</span>, <span class="number">2</span>], <span class="symbol">do:</span>  &#123;i, j&#125;</div><div class="line">[<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">a:</span> <span class="number">2</span>, <span class="symbol">b:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>, <span class="symbol">c:</span> <span class="number">1</span>, <span class="symbol">c:</span> <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>一个更高级的多生成器和多过滤器的例子是毕达哥拉斯三元数组。一个毕达哥拉斯三元数组是满足形如 a<em>a + b</em>b = c*c 这样等式的一个正整数集合，让我们来写一个速构到名为triple.exs的文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Triple</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pythagorean</span></span>(n) <span class="keyword">when</span> n &gt; <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> a &lt;- <span class="number">1</span>..n,</div><div class="line">        b &lt;- <span class="number">1</span>..n,</div><div class="line">        c &lt;- <span class="number">1</span>..n,</div><div class="line">        a + b + c &lt;= n,</div><div class="line">        a*a + b*b == c*c,</div><div class="line">        <span class="symbol">do:</span> &#123;a, b, c&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>接着在终端里运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex triple.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; Triple.pythagorean(<span class="number">5</span>)</div><div class="line">[]</div><div class="line">iex&gt; Triple.pythagorean(<span class="number">12</span>)</div><div class="line">[&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;]</div><div class="line">iex&gt; Triple.pythagorean(<span class="number">48</span>)</div><div class="line">[&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">8</span>, <span class="number">6</span>, <span class="number">10</span>&#125;, &#123;<span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span>&#125;,</div><div class="line"> &#123;<span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>&#125;, &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">13</span>&#125;, &#123;<span class="number">12</span>, <span class="number">9</span>, <span class="number">15</span>&#125;, &#123;<span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>&#125;, &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">17</span>&#125;, &#123;<span class="number">16</span>, <span class="number">12</span>, <span class="number">20</span>&#125;]</div></pre></td></tr></table></figure>
<p>当输入值很大的时候，上面例子的代码是非常耗时的。另外，因为元组 {b, a, c} 和元组{a, b, c}表示的是相同的毕达哥拉斯三元数组，我们的函数产生了重复的结果。我们可以通过在后续的生成器里从前面的生成器引用变量来优化速构并排除重复的结果，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Triple</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pythagorean</span></span>(n) <span class="keyword">when</span> n &gt; <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> a &lt;- <span class="number">1</span>..n-<span class="number">2</span>,</div><div class="line">        b &lt;- a+<span class="number">1</span>..n-<span class="number">1</span>,</div><div class="line">        c &lt;- b+<span class="number">1</span>..n,</div><div class="line">        a + b + c &lt;= n,</div><div class="line">        a*a + b*b == c*c,</div><div class="line">        <span class="symbol">do:</span> &#123;a, b, c&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最后，要记住，速构里的，在生成器、过滤器或者内部代码块里赋值的变量，不会反映到速构外面去。</p>
<h1 id="位串生成器"><a href="#位串生成器" class="headerlink" title="位串生成器"></a><span id="part-two">位串生成器</span></h1><p>位串生成器也是被支持的，并且当你需要解析位串流的时候是非常有用的。下面的例子里，从一个二进制数据里接收一个由像素组成的列表，数据分别代表红、绿和蓝的值，然后将每个像素转换为三个元素的元组：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; pixels = &lt;&lt;<span class="number">213</span>, <span class="number">45</span>, <span class="number">132</span>, <span class="number">64</span>, <span class="number">76</span>, <span class="number">32</span>, <span class="number">76</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">234</span>, <span class="number">32</span>, <span class="number">15</span>&gt;&gt;</div><div class="line">iex&gt; <span class="keyword">for</span> &lt;&lt;<span class="symbol">r:</span><span class="symbol">:</span><span class="number">8</span>, <span class="symbol">g:</span><span class="symbol">:</span><span class="number">8</span>, <span class="symbol">b:</span><span class="symbol">:</span><span class="number">8</span> &lt;- pixels&gt;&gt;, <span class="symbol">do:</span> &#123;r, g, b&#125;</div><div class="line">[&#123;<span class="number">213</span>, <span class="number">45</span>, <span class="number">132</span>&#125;, &#123;<span class="number">64</span>, <span class="number">76</span>, <span class="number">32</span>&#125;, &#123;<span class="number">76</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">234</span>, <span class="number">32</span>, <span class="number">15</span>&#125;]</div></pre></td></tr></table></figure>
<p>位串生成器也可以和“常规的”枚举类型数据生成器混合使用，同时也支持过滤器。</p>
<h1 id="into选项"><a href="#into选项" class="headerlink" title=":into选项"></a><span id="part-three">:into选项</span></h1><p>上面所有的例子，所有的速构都是返回列表作为它们的结果。但是，通过传递 :into 选项给速构，则速构的结果可以被插入到不同的数据结构里。</p>
<p>例如，一个位串生成器可以使用 :into 选项来很容易地删除一个字符串里的所有空格：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> &lt;&lt;c &lt;- <span class="string">" hello world "</span>&gt;&gt;, c != ?\s, <span class="symbol">into:</span> <span class="string">""</span>, <span class="symbol">do:</span> &lt;&lt;c&gt;&gt;</div><div class="line"><span class="string">"helloworld"</span></div></pre></td></tr></table></figure>
<p>集合、映射和其他字典类型数据也可以赋给 :into 选项。总而言之，:into 接收任何实现了 Collectable 协议的数据结构。</p>
<p>:into常见用例是转换映射里的值，而不需要理会它的键：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> &#123;key, val&#125; &lt;- %&#123;<span class="string">"a"</span> =&gt; <span class="number">1</span>, <span class="string">"b"</span> =&gt; <span class="number">2</span>&#125;, <span class="symbol">into:</span> %&#123;&#125;, <span class="symbol">do:</span> &#123;key, val * val&#125;</div><div class="line">%&#123;<span class="string">"a"</span> =&gt; <span class="number">1</span>, <span class="string">"b"</span> =&gt; <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<p>让我们用流来做另一个例子。因为IO模块提供流（就是实现了Enumerable 和 Collectable 协议），那么一个回响终端，即无论输入的是什么都将其大写后返回的终端，可以使用速构来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = IO.stream(<span class="symbol">:stdio</span>, <span class="symbol">:line</span>)</div><div class="line">iex&gt; <span class="keyword">for</span> line &lt;- stream, <span class="symbol">into:</span> stream <span class="keyword">do</span></div><div class="line">...&gt;   String.upcase(line) &lt;&gt; <span class="string">"\n"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，输入任何字符串到终端里，你将看到大写化后的相同字符串打印在终端里。不幸的是，这个例子也使得你的IEx停在速构里，所以你要按两次 Ctl+C来退出。：）</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/comprehensions.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/comprehensions.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－协议]]></title>
      <url>http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">协议和结构体</a></li>
<li><a href="#part-two">实现Any</a><br> 2.1. <a href="#part-two-one">派生</a><br> 2.3. <a href="#part-two-two">回退到Any</a></li>
<li><a href="#part-three">内建协议</a></li>
<li><a href="#part-four">协议整合</a></li>
</ol>
<p>协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。</p>
<p>在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。</p>
<p>虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。</p>
<a id="more"></a>
<p>协议的定义看起来像下面这样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">"Calculates the size (and not the length!) of a data structure"</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Size协议期望有一个接受一个入参（我们想要知道大小的数据结构）叫做size的函数被实现。我们现在可以为一些数据结构实现这个协议，这些数据结构应该有一个合适的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> BitString <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(string), <span class="symbol">do:</span> byte_size(string)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Map <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(map), <span class="symbol">do:</span> map_size(map)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Tuple <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(tuple), <span class="symbol">do:</span> tuple_size(tuple)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们没有为列表实现Size协议，因为列表没有预先计算好的“大小”信息，并且列表的长度必须要被计算出来（用 length/1）。</p>
<p>现在我们有了协议定义和实现，我们可以开始使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(<span class="string">"foo"</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; Size.size(&#123;<span class="symbol">:ok</span>, <span class="string">"hello"</span>&#125;)</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; Size.size(%&#123;<span class="symbol">label:</span> <span class="string">"some label"</span>&#125;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>传入一个没有实现协议的数据类型将会引起一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>为所有Elixir数据类型实现协议是可能的：</p>
<ul>
<li>Atom</li>
<li>BitString</li>
<li>Float</li>
<li>Function</li>
<li>Integer</li>
<li>List</li>
<li>Map</li>
<li>PID</li>
<li>Port</li>
<li>Reference</li>
<li>Tuple</li>
</ul>
<h1 id="协议和结构体"><a href="#协议和结构体" class="headerlink" title="协议和结构体"></a><span id="part-one">协议和结构体</span></h1><p>Elixir的可扩展性的能力来自当协议和结构一起使用时。</p>
<p>在上一章，我们已经学到，虽然结构体底层是映射，但是它没有和映射共享协议实现。例如，<a href="https://hexdocs.pm/elixir/MapSet.html" target="_blank" rel="external">MapSet</a> （基于映射的集合）被实现为结构体。让我们尝试应用Size协议于MapSet上：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(%&#123;&#125;)</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; set = %MapSet&#123;&#125; = MapSet.new</div><div class="line"><span class="comment">#MapSet&lt;[]&gt;</span></div><div class="line">iex&gt; Size.size(set)</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> <span class="comment">#MapSet&lt;[]&gt;</span></div></pre></td></tr></table></figure>
<p>结构体没有和映射共享协议实现，而是需要它自己的协议实现。因为MapSet有它自己的预先计算大小并且可以通过MapSet.size/1访问，我们可以为它定义一个Size协议的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> MapSet <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(set), <span class="symbol">do:</span> MapSet.size(set)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果需要，你可以拿出你自己结构大小的语义。你不仅可以用结构体来构建更健壮的数据类型，比如像队列，而且可以为这个数据类型实现所有相关的协议，比如 Enumerable 和 可能的 Size。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> User <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(_user), <span class="symbol">do:</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="实现Any"><a href="#实现Any" class="headerlink" title="实现Any"></a><span id="part-two">实现Any</span></h1><p>手工为所有类型实现协议可能很快就变得重复和单调乏味。在这种情况下，Elixir提供了两种选择：我们可以明确地为我们的类型派生协议的实现或自动为所有类型实现协议。在这两种情况下，我们需要为Any实现协议。</p>
<h2 id="派生"><a href="#派生" class="headerlink" title="派生"></a><span id="part-two-one">派生</span></h2><p>Elixir允许我们基于Any的实现派生一个协议实现。让我们先实现Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述的实现可以说是不合理的。例如，说一个PID或一个整数的大小为零。</p>
<p>然而，我们应该很好地处理这个Any的实现。为了使用这个实现，我们应该需要告诉我们的结构体明确地派生于这个Size协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">OtherUser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@derive</span> [Size]</div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当派生的时候，Elixir将基于为Any提供的实现为OtherUser实现Size协议。</p>
<h2 id="回退到Any"><a href="#回退到Any" class="headerlink" title="回退到Any"></a><span id="part-two-two">回退到Any</span></h2><p>当找不到实现的时候，对于 @derive 的另外一个选择就是明确地告诉协议退回到Any。这可以在协议定义里通过设置@fallback_to_any为true来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@fallback_to_any</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>正如我们在前一节所说，为Any所做的Size实现不能应用到所有数据类型。这就是为什么@fallback_to_any是一个可选项的原因之一。对于大多数协议来说，当没有实现的时候抛出一个错误是正确的行为。也就是说，假设像上一节一样我们已经实现了Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>那么现在所有数据类型（包括结构体），如果它没有实现Size协议，则被认为大小为0。</p>
<p>派生和回退到Any哪一个技术最好，这要依赖于使用场景。但是，Elixir开发者喜欢明确的而不是推断的。你可以看到许多库倾向于 @derive 方法。</p>
<h1 id="内建协议"><a href="#内建协议" class="headerlink" title="内建协议"></a><span id="part-three">内建协议</span></h1><p>Elixir内建了一些协议。前面的章节里，我们讨论过的Enum模块，它提供了许多函数处理任意数据结构，这个模块就实现了 Enumerable 协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span></div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.reduce <span class="number">1</span>..<span class="number">3</span>, <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span></div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>另一个有用的例子是String.Chars协议，它指明如何用字符转换一个数据结构为一个字符串。它通过to_string函数暴露出来：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_string <span class="symbol">:hello</span></div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>注意到Elixir字符串插入是调用to_string函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"age: <span class="subst">#&#123;<span class="number">25</span>&#125;</span>"</span></div><div class="line"><span class="string">"age: 25"</span></div></pre></td></tr></table></figure>
<p>上面的例子可以正常运行是因为数字数据类型实现了String.Chars协议。如果传递一个元组，则会导致一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;tuple&#125;</span>"</span></div><div class="line">** (Protocol.UndefinedError) protocol String.Chars <span class="keyword">not</span> implemented <span class="keyword">for</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p>当需要“打印”一个更复杂的数据结构的时候，我们可以用基于Inspect协议的inspect函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;inspect tuple&#125;</span>"</span></div><div class="line"><span class="string">"tuple: &#123;1, 2, 3&#125;"</span></div></pre></td></tr></table></figure>
<p>Inspect协议被用来转换任何数据结构为一个易于阅读的文本。像IEx这样的工具就是用它来打印的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">name:</span> <span class="string">"john"</span>, <span class="symbol">age:</span> <span class="number">27</span>&#125;</div></pre></td></tr></table></figure>
<p>记住，按照惯例，每当被检查的价值以#开头，它是代表这是非有Elixir的语法的数据结构。这意味着inspect协议是不可逆的，因为以这种方式信息可能会丢失：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; inspect &amp;(&amp;<span class="number">1</span>+<span class="number">2</span>)</div><div class="line"><span class="string">"#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;"</span></div></pre></td></tr></table></figure>
<p>Elixir还有其他协议，不过本文讲最常用的这几个。</p>
<h1 id="协议整合"><a href="#协议整合" class="headerlink" title="协议整合"></a><span id="part-four">协议整合</span></h1><p>当处理Elixir项目的时候，使用Mix构建工具，你可以看到如下的输出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Consolidated String.Chars</div><div class="line">Consolidated Collectable</div><div class="line">Consolidated List.Chars</div><div class="line">Consolidated IEx.Info</div><div class="line">Consolidated Enumerable</div><div class="line">Consolidated Inspect</div></pre></td></tr></table></figure>
<p>这些是Elixir自带的所有协议并且它们被整合。因为一个协议可以派发消息到任何数据类型，如果对于给定的类型的实现存在，则协议一定检查每一个调用。这可能非常消耗资源。</p>
<p>但是，在我们的项目使用像Mix这样的工具被编译后，我们知道所有被定义的模块，包括协议和他们的实现。用这个方法，协议可以被合并到一个非常简单快速的派发模块。</p>
<p>从Elixir v1.2开始，对于所有项目，协议合并都自动发生。我们将在<strong>Mix和OTP指引</strong>里构建我们的项目。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/protocols.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/protocols.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－结构体]]></title>
      <url>http://szpzs.oschina.io/2017/02/09/elixir-getting-started-structs/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">定义结构体</a></li>
<li><a href="#part-two">访问和修改结构体</a></li>
<li><a href="#part-three">结构体的底层是裸映射</a></li>
<li><a href="#part-four">默认值和所需的键</a></li>
</ol>
<p>在第七章我们学了映射：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">iex&gt; map[<span class="symbol">:a</span>]</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; %&#123;map | <span class="symbol">a:</span> <span class="number">3</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">3</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>结构体是构建于映射之上的扩展，它提供了编译时检查和默认值。</p>
<a id="more"></a>
<h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a><span id="part-one">定义结构体</span></h1><p>要定义结构体，就要使用 defstruct 结构</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   defstruct <span class="symbol">name:</span> <span class="string">"John"</span>, <span class="symbol">age:</span> <span class="number">27</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>defstruct 用关键字列表定义结构体有什么字段以及它们的默认值。</p>
<p>结构体的名字就是它们被定义所在的模块的名字。上面例子中，我们定义了一个名字为User的结构体。</p>
<p>我们现在可以用与创建映射相似的语法来创建 User 结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; %User&#123;<span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div></pre></td></tr></table></figure>
<p>结构体提供编译时检查来保证只有通过 defstruct 定义的字段（包括所有被定义的字段）才被允许存在它里面：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;<span class="symbol">oops:</span> <span class="symbol">:field</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:oops</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="访问和修改结构体"><a href="#访问和修改结构体" class="headerlink" title="访问和修改结构体"></a><span id="part-two">访问和修改结构体</span></h1><p>当我们讨论映射的时候，我们展示了我们如何访问和修改映射的字段。同样的技术（和同样的语法）也应用在结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; john = %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; john.name</div><div class="line"><span class="string">"John"</span></div><div class="line">iex&gt; meg = %&#123;john | <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">iex&gt; %&#123;meg | <span class="symbol">oops:</span> <span class="symbol">:field</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:oops</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div></pre></td></tr></table></figure>
<p>当使用修改语法（|）的时候，Erlang虚拟机意识到没有新的键将加入结构体，准许底层的映射在内存里共享它们的结构。上述例子里，john 和 meg 共享内存里相同的键结构。</p>
<p>结构也可以用于模式匹配，既为匹配上的特定键的值以及确保匹配的值是一个同一类型的结构的匹配值。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;<span class="symbol">name:</span> name&#125; = john</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; name</div><div class="line"><span class="string">"John"</span></div><div class="line">iex&gt; %User&#123;&#125; = %&#123;&#125;</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> %&#123;&#125;</div></pre></td></tr></table></figure>
<h1 id="结构体的底层是裸映射"><a href="#结构体的底层是裸映射" class="headerlink" title="结构体的底层是裸映射"></a><span id="part-three">结构体的底层是裸映射</span></h1><p>上面的例子里，模式匹配可以运作是因为结构体的底层是有固定字段集合的裸映射。作为映射，结构体存储了一个名字为 __struct__ 的“特别的”字段，它持有结构体的名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_map(john)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; john.__struct_<span class="number">_</span></div><div class="line">User</div></pre></td></tr></table></figure>
<p>注意：我们称结构体为裸映射是因为为映射实现的协议没有任何一个可用于结构体。例如，你既不能枚举也不能访问一个结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; john = %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; john[<span class="symbol">:name</span>]</div><div class="line">** (UndefinedFunctionError) function User.fetch/<span class="number">2</span> is undefined (User does <span class="keyword">not</span> implement the Access behaviour)</div><div class="line">             User.fetch(%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;, <span class="symbol">:name</span>)</div><div class="line">iex&gt; Enum.each john, <span class="keyword">fn</span>(&#123;field, value&#125;) -&gt; IO.puts(value) <span class="keyword">end</span></div><div class="line">** (Protocol.UndefinedError) protocol Enumerable <span class="keyword">not</span> implemented <span class="keyword">for</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div></pre></td></tr></table></figure>
<p>然后，因为结构体就是映射，它们可以应用于Map模块的函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; kurt = Map.put(%User&#123;&#125;, <span class="symbol">:name</span>, <span class="string">"Kurt"</span>)</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Kurt"</span>&#125;</div><div class="line">iex&gt; Map.merge(kurt, %User&#123;<span class="symbol">name:</span> <span class="string">"Takashi"</span>&#125;)</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Takashi"</span>&#125;</div><div class="line">iex&gt; Map.keys(john)</div><div class="line">[<span class="symbol">:__struct__</span>, <span class="symbol">:age</span>, <span class="symbol">:name</span>]</div></pre></td></tr></table></figure>
<p>结构和协议为Elixir开发者提供了最重要的特征之一：数据多态性。这是我们下一章将要探索的。</p>
<h1 id="默认值和所需的键"><a href="#默认值和所需的键" class="headerlink" title="默认值和所需的键"></a><span id="part-four">默认值和所需的键</span></h1><p>如果在定义结构体的时候你没有指定一个键的默认值，则nil将被当做它的默认值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Product</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   defstruct [<span class="symbol">:name</span>]</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; %Product&#123;&#125;</div><div class="line">%Product&#123;<span class="symbol">name:</span> <span class="keyword">nil</span>&#125;</div></pre></td></tr></table></figure>
<p>你也可以强制在创建结构体的时候某些键必需被指定：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Car</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="variable">@enforce_keys</span> [<span class="symbol">:make</span>]</div><div class="line">...&gt;   defstruct [<span class="symbol">:model</span>, <span class="symbol">:make</span>]</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; %Car&#123;&#125;</div><div class="line">** (ArgumentError) the following keys must also be given <span class="keyword">when</span> building struct <span class="symbol">Car:</span> [<span class="symbol">:make</span>]</div><div class="line">    expanding <span class="symbol">struct:</span> Car.__struct_<span class="number">_</span>/<span class="number">1</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/structs.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/structs.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－模块属性]]></title>
      <url>http://szpzs.oschina.io/2017/02/09/elixir-getting-started-module-attributes/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">作为注释</a></li>
<li><a href="#part-two">作为常量</a></li>
<li><a href="#part-three">作为临时存储</a></li>
</ol>
<p>在Elixir里，模块属性服务于三个目标：</p>
<ul>
<li>它们常常用一些信息来注释模块被用户或Erlang虚拟机使用。</li>
<li>它们用作常量。</li>
<li>它们被用于编译期间临时模块存储。</li>
</ul>
<p>让我们一个一个地来仔细看看这三个方面。</p>
<a id="more"></a>
<h1 id="作为注释"><a href="#作为注释" class="headerlink" title="作为注释"></a><span id="part-one">作为注释</span></h1><p>Elixr从Erlang那里带来了模块属性这个概念。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@vsn</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在上面的例子里，我们显式地设置模块的版本属性。@vsn 被Erlang虚拟机的代码重装载机制用来检查模块是否已经更新。如果没有指定版本，版本被设置为模块函数的MD5码校验和。</p>
<p>Elixir有一些保留的属性。下面介绍几个最常用的：</p>
<ul>
<li>@moduledoc - 为当前模块提供文档。</li>
<li>@doc - 为紧跟该属性的函数或宏提供文档。</li>
<li>@behaviour - （注意英式拼写）用于指定一个OTP或用户自定义的行为。</li>
<li>@before_compile - 提供一个模块被编译前将被调用的钩子。这使得在编译前确切地注入函数到模块里成为可能。</li>
</ul>
<p>@moduledoc 和 @doc 是到目前为止用得最多的属性，我们希望你大量使用它们。Elixir把文档当做一等公民并且提供许多函数访问文档。你可以参阅<a href="https://hexdocs.pm/elixir/writing-documentation.html" target="_blank" rel="external">我们官方文档里的关于在Elixir里写文档</a>这篇文章来获得更多信息。</p>
<p>我们回到前面章节里定义的Math模块，增加一些文档然后保存到math.ex文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Provides math-related functions.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      iex&gt; Math.sum(1, 2)</div><div class="line">      3</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Calculates the sum of two numbers.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b), <span class="symbol">do:</span> a + b</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Elixir推荐用Markdown加上heredoc来写易于阅读的文档。Heredocs是多行字符串，它们起始都是三个双引号，并且保持内部文本的格式。我们可以从IEx里直接访问任何已经编译的文档：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ elixirc math.ex</div><div class="line">$ iex</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; h Math <span class="comment"># Access the docs for the module Math</span></div><div class="line">...</div><div class="line">iex&gt; h Math.sum <span class="comment"># Access the docs for the sum function</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们也提供了一个叫<a href="https://github.com/elixir-lang/ex_doc" target="_blank" rel="external">ExDoc</a>的工具来将文档生成HTML页面。</p>
<p>你可以查阅Module模块的文档来得到一个所支持属性的完整列表。Elixir也用属性来定义 <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html" target="_blank" rel="external">typespec</a> 。</p>
<p>本部分覆盖了内置的属性。但是，属性也能被开发者使用或者被库扩展来支持自定义行为。</p>
<h1 id="作为常量"><a href="#作为常量" class="headerlink" title="作为常量"></a><span id="part-two">作为常量</span></h1><p>Elixir开发者将经常使用模块属性作为常量。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@initial_state</span> %&#123;<span class="symbol">host:</span> <span class="string">"147.0.0.1"</span>, <span class="symbol">port:</span> <span class="number">3456</span>&#125;</div><div class="line">  IO.inspect <span class="variable">@initial_state</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：和Erlang不同，用户定义的属性默认不存储在模块里。属性的值只是在编译的时候存在。开发者可以通过调用 Module.register_attribute/3 设置一个属性来使得行为更接近Erlang。</p>
</blockquote>
<p>试图访问没有定义的属性将打印一个警告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@unknown</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="symbol">warning:</span> undefined <span class="keyword">module</span> attribute <span class="variable">@unknown</span>, please remove access to <span class="variable">@unknown</span> <span class="keyword">or</span> explicitly set it before access</div></pre></td></tr></table></figure>
<p>最后，属性也可以在函数里被读取：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@my_data</span> <span class="number">14</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">first_data</span></span>, <span class="symbol">do:</span> <span class="variable">@my_data</span></div><div class="line">  <span class="variable">@my_data</span> <span class="number">13</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">second_data</span></span>, <span class="symbol">do:</span> <span class="variable">@my_data</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyServer.first_data <span class="comment">#=&gt; 14</span></div><div class="line">MyServer.second_data <span class="comment">#=&gt; 13</span></div></pre></td></tr></table></figure>
<p>每次在函数里读取一个属性，获取到的是这个属性值的当前快照。换句话说，该值在编译时读取，而不是在运行时读取。正如我们将要看到的，这也使得在模块编译时用作存储的属性非常有用。</p>
<h1 id="作为临时存储"><a href="#作为临时存储" class="headerlink" title="作为临时存储"></a><span id="part-three">作为临时存储</span></h1><p>Elixir组织里有一个项目：<a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a>，它就是要建立Elixir中web库和框架的共同基础。</p>
<p>Plug库也允许开发者定义他们自己的能在web服务器里运行的插件：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyPlug</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Plug.Builder</div><div class="line"></div><div class="line">  plug <span class="symbol">:set_header</span></div><div class="line">  plug <span class="symbol">:send_ok</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_header</span></span>(conn, _opts) <span class="keyword">do</span></div><div class="line">    put_resp_header(conn, <span class="string">"x-header"</span>, <span class="string">"set"</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">send_ok</span></span>(conn, _opts) <span class="keyword">do</span></div><div class="line">    send(conn, <span class="number">200</span>, <span class="string">"ok"</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts <span class="string">"Running MyPlug with Cowboy on http://localhost:4000"</span></div><div class="line">Plug.Adapters.Cowboy.http MyPlug, []</div></pre></td></tr></table></figure>
<p>在上面的例子里，我们已经用 plug/1 宏来链接当有web请求的时候将被调用的那些函数。在内部，每次你调用 plug/1，Plug库存储给定的参数到一个 @plugs 属性里。仅在模块被编译前，Plug运行一个回调来定义一个函数（call/2）处理HTTP请求。这个函数将按顺序运行@plugs属性里的所有插件。</p>
<p>为了理解底层的代码，我们需要宏，所以我们将在元编程指导里对这个模式进行回顾。但是此刻我们关注的是如何用模块属性作为存储来允许开发者创建DLS（领域特定语言）。</p>
<p>另一个例子来自<a href="https://hexdocs.pm/ex_unit/" target="_blank" rel="external">ExUnit框架</a>，它用模块属性来作为注释和存储：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line"></div><div class="line">  <span class="variable">@tag</span> <span class="symbol">:external</span></div><div class="line">  test <span class="string">"contacts external service"</span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在ExUnit里标签被用来注释测试用例。标签后续可以用来过滤测试用例。例如，你可以避免在你的本机上运行外部测试用例，因为它们缓慢并且依赖其他服务，尽管在你的构建系统里它们仍然是可用的。</p>
<p>我希望这部分内容让你大概了解Elixir如何支持元编程，以及当进行元编程的时候模块属性如何扮演一个重要角色。</p>
<p>在后面的章节，我们将探索结构和协议，然后再探索异常处理和其他结构，比如印记和列表解析。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/module-attributes.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/module-attributes.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－alias、require和import]]></title>
      <url>http://szpzs.oschina.io/2017/02/08/elixir-getting-started-alias-require-and-import/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">alias</a></li>
<li><a href="#part-two">require</a></li>
<li><a href="#part-three">import</a></li>
<li><a href="#part-four">use</a></li>
<li><a href="#part-five">理解alias</a></li>
<li><a href="#part-six">模块嵌套</a></li>
<li><a href="#part-seven">多重 alias/import/require/use</a></li>
</ol>
<p>为了便于软件重用，Elixir提供了三个指令（alias、require和import）外加一个叫做use的宏。如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 别名一个模块则它可以被叫做Bar而不是Foo.Bar</span></div><div class="line"><span class="keyword">alias</span> Foo.Bar, <span class="symbol">as:</span> Bar</div><div class="line"></div><div class="line"><span class="comment"># 确认这个模块是编译好的并且可用的（常常使用于宏）</span></div><div class="line">require Foo</div><div class="line"></div><div class="line"><span class="comment"># 从Foo导入函数，所以它们被调用可以不需要 Foo. 这个前缀</span></div><div class="line">import Foo</div><div class="line"></div><div class="line"><span class="comment"># 调用Foo里作为一个扩展点定义的代码。</span></div><div class="line"><span class="keyword">use</span> Foo</div></pre></td></tr></table></figure>
<p>我们现在将详细地探讨它们。记住前三个被叫做指令因为它们有作用范围，而use是一个常见的扩展点。</p>
<a id="more"></a>
<h1 id="alias"><a href="#alias" class="headerlink" title="alias"></a><span id="part-one">alias</span></h1><p>alias允许你给任何给定的模块设置别名。</p>
<p>假设一个模块使用 Math.List 里实现的一个特殊列表。alias 指令允许在模块定义里只使用List来指代Math.List：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Stats</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">alias</span> Math.List, <span class="symbol">as:</span> List</div><div class="line">  <span class="comment"># 在模块的后续的定义里，List将展开为Math.List。</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>原来的List依然可以通过完全限定名Elixir.List在模块Stats里访问。</p>
<blockquote>
<p>注意：定义在Elixir里所有的模块定义在Elixir命名空间里。但是，为了方便，当引用它们的时候你可以省略“Elixir.”。</p>
</blockquote>
<p>别名常被用来定义快捷方式。实际上，调用 alias 而不用 :as 选项，则自动将别名设置为模块名的最后一部分，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> Math.List</div></pre></td></tr></table></figure>
<p>和如下的代码是一样的效果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> Math.List, <span class="symbol">as:</span> List</div></pre></td></tr></table></figure>
<p>注意：alias 是有作用范围的，它允许你在特定的函数里设置别名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    <span class="keyword">alias</span> Math.List</div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minus</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的例子里，因为我们在 plus/2 里调用 alias ，别名将只在 plus/2 里有效，minus/2 将一点也不受影响。</p>
<h1 id="require"><a href="#require" class="headerlink" title="require"></a><span id="part-two">require</span></h1><p>Elixir提供宏作为元编程（写代码来生成代码）的一种机制。</p>
<p>宏是一段代码，它在代码编译的时候被执行和展开。这意味着，为了使用宏，我们需要保证在编译期间它的模块和实现是可用的。这可以用 require 指令来完成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Integer.is_odd(<span class="number">3</span>)</div><div class="line">** (UndefinedFunctionError) function Integer.is_odd/<span class="number">1</span> is undefined <span class="keyword">or</span> private. However there is a macro with the same name <span class="keyword">and</span> arity. Be sure to require Integer if you intend to invoke this macro</div><div class="line">iex&gt; require Integer</div><div class="line">Integer</div><div class="line">iex&gt; Integer.is_odd(<span class="number">3</span>)</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>在Elixir里，Integer.is_odd/1 被定义成为一个宏，所以它可以被用来作为一个卫语句。也就是说，为了调用 Integer.is_odd/1 ，我们首先需要 require Integer模块。</p>
<p>总而言之，一个模块在使用前是不需要被 require 的，除非是我们想要使得模块里的宏可用。尝试调用一个没有被装载的宏将引起一个错误。注意，像 alias 指令，require 也是有作用范围的。我们将在后面的章节更深入地讨论宏。</p>
<h1 id="import"><a href="#import" class="headerlink" title="import"></a><span id="part-three">import</span></h1><p>在任何时候我们想不用完全限定名称而方便地访问其他模块的函数或宏，我们就用 import 。例如，如果我们想用 List 里的 duplicate/2 几次，我们可以 import 它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; import List, <span class="symbol">only:</span> [<span class="symbol">duplicate:</span> <span class="number">2</span>]</div><div class="line">List</div><div class="line">iex&gt; duplicate <span class="symbol">:ok</span>, <span class="number">3</span></div><div class="line">[<span class="symbol">:ok</span>, <span class="symbol">:ok</span>, <span class="symbol">:ok</span>]</div></pre></td></tr></table></figure>
<p>在这个例子里，我们仅从List里导入函数duplicate（只有两个入参）。虽然 :only 是可选的，但是为了避免将给定模块的所有函数都导入到命名空间里，这个用法是被推荐使用的。:except 也可以作为选项被设置，它的作用是为了导入一个模块里 <em>除了</em> 一些函数外其他所有函数。</p>
<p>import 也支持把 :macros 和 :functions 给 :only 选项。例如，导入模块的所有宏，可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Integer, <span class="symbol">only:</span> <span class="symbol">:macros</span></div></pre></td></tr></table></figure>
<p>或者导入模块的所有函数，你可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Integer, <span class="symbol">only:</span> <span class="symbol">:functions</span></div></pre></td></tr></table></figure>
<p>注意：import也是有作用范围的。这意味着我们可以在函数定义里导入特定的宏和函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">some_function</span></span> <span class="keyword">do</span></div><div class="line">    import List, <span class="symbol">only:</span> [<span class="symbol">duplicate:</span> <span class="number">2</span>]</div><div class="line">    duplicate(<span class="symbol">:ok</span>, <span class="number">10</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述例子，被导入的 List.duplicate/2 只在特定的函数里才可见。duplicate/2 在这个模块（就这个问题而言，在任何其他模块）里的任何其他函数都不可用。</p>
<p>注意：<em>import</em> 一个模块自动就 <em>require</em> 它了</p>
<h1 id="use"><a href="#use" class="headerlink" title="use"></a><span id="part-four">use</span></h1><p>虽然不是指令，use却是与require紧密相关的一个宏，它允许你在当前上下文里使用一个模块。这个 use 宏常常被开发者用来把外部功能带入当前作用范围，经常是模块。</p>
<p>例如，为了用 ExUnit 框架写测试，开发者应该使用 ExUnit.Case 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">AssertionTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"always pass"</span> <span class="keyword">do</span></div><div class="line">    assert <span class="keyword">true</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>背后的原理是，use require 给定的模块然后在它上面调用 __using/1__ 回调函数来允许这个模块注入一些代码到当前上下文。通常来说，如下的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Feature, <span class="symbol">option:</span> <span class="symbol">:value</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>被编译成如下样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  require Feature</div><div class="line">  Feature.__using_<span class="number">_</span>(<span class="symbol">option:</span> <span class="symbol">:value</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="理解alias"><a href="#理解alias" class="headerlink" title="理解alias"></a><span id="part-five">理解alias</span></h1><p>到此，你可能想知道：Elixir的别名到底是什么？它是如何表示的？</p>
<p>Elixir里的一个别名是一个大写开头的标识符（像String，Keyword，等等），在编译的时候它被转换成一个原子。例如，String 这个别名默认情况下被转换为 :”Elixir.String” ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_atom(String)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; to_string(String)</div><div class="line"><span class="string">"Elixir.String"</span></div><div class="line">iex&gt; <span class="symbol">:<span class="string">"Elixir.String"</span></span> == String</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>通过用 alias/2 指令，我们改变了别名所要转换成的原子。</p>
<p>别名转换为原子是因为在Erlang虚拟机里（也是Elixir里）模块总是用原子来表示。例如，如下就是我们用来调用Erlang模块的机制：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:lists</span>.flatten([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<h1 id="模块嵌套"><a href="#模块嵌套" class="headerlink" title="模块嵌套"></a><span id="part-six">模块嵌套</span></h1><p>现在我们已经讨论了别名，我们可以讨论嵌套和它在Elixir里是如何运作的。考虑一下如下例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Foo</span></span> <span class="keyword">do</span></div><div class="line">  <span class="class"><span class="keyword">defmodule</span> <span class="title">Bar</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的例子将定义两个模块：Foo 和 Foo.Bar 。第二个模块可以在Foo里以Bar来访问只要它们在相同的作用范围里。上面的代码和下面的代码完全一样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Elixir</span></span>.Foo <span class="keyword">do</span></div><div class="line">  <span class="class"><span class="keyword">defmodule</span> <span class="title">Elixir</span></span>.Foo.Bar <span class="keyword">do</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="keyword">alias</span> Elixir.Foo.Bar, <span class="symbol">as:</span> Bar</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果，以后，Bar 模块被移到Foo模块定义的外面，它必须用完全限定名称（Foo.Bar）引用或者一个别名必须用前面讨论过的alias指令来设置。</p>
<p>注意：在Elixir里，你不必在定义Foo.Bar模块前必须要定义Foo模块，因为Elixir转换所有模块名字为原子。你可以定义任意嵌套的模块而不需要定义链上的任何模块（比如，定义Foo.Bar.Baz而没有先定义Foo或Foo.Bar）。</p>
<p>正如我们将在后面章节看到的，别名在宏里也扮演了一个至关重要的角色，来保证宏的整洁。</p>
<h1 id="多重-alias-import-require-use"><a href="#多重-alias-import-require-use" class="headerlink" title="多重 alias/import/require/use"></a><span id="part-seven">多重 alias/import/require/use</span></h1><p>从Elixir v1.2开始，一次 alias、 import 或 require 多个模块是可能的。当我们开始嵌套模块这是特别有用的，当构建Elixir的应用程序时这是很常见的。例如，假设你有一个应用，所有模块都嵌套在MyApp下，你可以如下面例子一样一次性为MyApp.Foo，MyApp.Bar 和 MyApp.Baz指定别名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> MyApp.&#123;Foo, Bar, Baz&#125;</div></pre></td></tr></table></figure>
<p>我们已经完成了我们的Elixir模块之旅。最后一个主题是模块属性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/alias-require-and-import.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/alias-require-and-import.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－IO和文件系统]]></title>
      <url>http://szpzs.oschina.io/2017/02/07/elixir-getting-started-io-and-the-file-system/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">IO模块</a></li>
<li><a href="#part-two">File模块</a></li>
<li><a href="#part-three">Path模块</a></li>
<li><a href="#part-four">进程和组领导</a></li>
<li><a href="#part-five">iodata和chardata</a></li>
</ol>
<p>本章是对输入/输出机制和文件系统相关的任务以及相关模块，比如：<a href="https://hexdocs.pm/elixir/IO.html" target="_blank" rel="external">IO</a>、<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File</a>和<a href="https://hexdocs.pm/elixir/Path.html" target="_blank" rel="external">Path</a>的快速介绍。</p>
<p>我们原本计划这章在本系列教程中更早地出现。然而，我们注意到 IO 系统提供一个非常好的机会来阐明Elixir和VM的一些哲学和奇特之处。</p>
<a id="more"></a>
<h1 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a><span id="part-one">IO模块</span></h1><p>IO模块是Elixir里读写标准输入输出（:stdio）、标准错误（:stderr）、文件和其他IO设备的主要机制。这个模块的使用方式非常简单：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">"hello world"</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.gets <span class="string">"yes or no? "</span></div><div class="line">yes <span class="keyword">or</span> no? yes</div><div class="line"><span class="string">"yes\n"</span></div></pre></td></tr></table></figure>
<p>默认情况下，IO模块的函数从标准输入读数据并往标准输出写数据。我们可以改变这个默认方式，例如，通过传递 :stderr 作为一个入参（来写数据到标准错误）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="symbol">:stderr</span>, <span class="string">"hello world"</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<h1 id="File模块"><a href="#File模块" class="headerlink" title="File模块"></a><span id="part-two">File模块</span></h1><p>File模块包含函数允许我们打开文件当做IO文件。默认地，文件以二进制模式打开，这些文件就需要开发者使用IO模式的特定函数 IO.binread/2 和 IO.binwrite/2 来读写。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"hello"</span>, [<span class="symbol">:write</span>]</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.47.0&gt;&#125;</span></div><div class="line">iex&gt; IO.binwrite file, <span class="string">"world"</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.close file</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>文件也可以用 :utf8 编码方式打开，这就告诉File模块解析从文件读取的字节为UTF-8编码的字节。</p>
<p>除了打开、读写文件的函数，File模块还有许多处理文件系统的函数。那些函数命名方式和Unix的函数相对应。例如，File.rm/1 可以用来删除文件，File.mkdir/1 用来创建目录，File.mkdir_p/1 用来创建目录和它所有的父目录。甚至还有 File.cp_r/2 和 File.rm_rf/1 ，分别递归地拷贝和删除文件和目录（即也复制和删除目录的内容）。</p>
<p>你可能也注意到了File模块里的函数有两种类型：一种是“正常”的，另一种是尾部有一个!号的。例如，上面例子里当我们读”hello”文件的时候，我们使用 File.read/1 。相应地，我们可以用File.read!/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; File.read! <span class="string">"hello"</span></div><div class="line"><span class="string">"world"</span></div><div class="line">iex&gt; File.read <span class="string">"unknown"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:enoent</span>&#125;</div><div class="line">iex&gt; File.read! <span class="string">"unknown"</span></div><div class="line">** (File.Error) could <span class="keyword">not</span> read file <span class="string">"unknown"</span>: no such file <span class="keyword">or</span> directory</div></pre></td></tr></table></figure>
<p>注意：带叹号的版本返回文件的内容而不是元组，而如果有任何错误，这个函数就抛出一个错误。</p>
<p>当你想要用模式匹配处理不同的输出的时候，不带叹号的版本是首选：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> File.read(file) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, body&#125;      -&gt; <span class="comment"># do something with the `body`</span></div><div class="line">  &#123;<span class="symbol">:error</span>, reason&#125; -&gt; <span class="comment"># handle the error caused by `reason`</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>但是，如果你期望文件就在那里，带叹号版本更加有用，因为它抛出有意义的错误。避免这样写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, body&#125; = File.read(file)</div></pre></td></tr></table></figure>
<p>因为，一旦有错误，File.read/1 将返回 {:error, reason} 而且模式匹配将失败。你将仍然得到你想要的结果（一个抛出的错误），但是消息却是关于没有匹配上的模式（因此，错误实际上是什么就显得很神秘）。</p>
<p>因此，如果你不想处理错误结果，就优先使用 File.read!/1 。</p>
<h1 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a><span id="part-three">Path模块</span></h1><p>File模块里的绝大多数函数都期望用路径做入参。最常见的是，这些路径将是普通二进制数据。Path模块提供处理这样路径的工具：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Path.join(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</div><div class="line"><span class="string">"foo/bar"</span></div><div class="line">iex&gt; Path.expand(<span class="string">"~/hello"</span>)</div><div class="line"><span class="string">"/Users/jose/hello"</span></div></pre></td></tr></table></figure>
<p>使用Path模块的函数，而不是直接操纵字符串是首选，因为Path模块透明地处理不同的操作系统之间的差异。最后，记住当在Windows执行文件操作的时候，Elixir将自动将斜线（/）转成反斜线（\）。</p>
<p>到此，我们已经讲完了Elixir提供的处理IO和与文件系统交互的主要模块。下面的部分，我们将讨论关于IO的一些高级话题。这些部分不是写Elixir代码所必需的，因此可以略过它们，不过它们对VM里IO系统是如何实现的以及其他特性提供了一个好的概貌。</p>
<h1 id="进程和组领导"><a href="#进程和组领导" class="headerlink" title="进程和组领导"></a><span id="part-four">进程和组领导</span></h1><p>你可能已经注意到 File.open/2 返回一个元组 {:ok, pid} ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"hello"</span>, [<span class="symbol">:write</span>]</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.47.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>之所以是如此，是因为IO模块实际上是和进程打交道（参见<a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">11章</a>）。当你写 IO.write(pid, binary) 的时候，IO模块将发送一个消息给被pid标识的进程，消息里同时带着期望的操作。让我们看看如果我们用我们自己的进程会发生什么：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = spawn <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;  receive <span class="symbol">do:</span> (msg -&gt; IO.inspect msg)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.57.0&gt;</span></div><div class="line">iex&gt; IO.write(pid, <span class="string">"hello"</span>)</div><div class="line">&#123;<span class="symbol">:io_request</span>, <span class="comment">#PID&lt;0.41.0&gt;, #Reference&lt;0.0.8.91&gt;,</span></div><div class="line"> &#123;<span class="symbol">:put_chars</span>, <span class="symbol">:unicode</span>, <span class="string">"hello"</span>&#125;&#125;</div><div class="line">** (ErlangError) erlang <span class="symbol">error:</span> <span class="symbol">:terminated</span></div></pre></td></tr></table></figure>
<p>上述例子中，在 IO.write/2 后，我们可以看到IO模块发送的请求（四元素元组）被打印出来。紧跟其后，我们看到了失败，因为IO模块所期望的结果我们没有支持。</p>
<p><a href="https://hexdocs.pm/elixir/StringIO.html" target="_blank" rel="external">StringIO</a>模块提供了基于字符串之上的IO设备消息的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = StringIO.open(<span class="string">"hello"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; IO.read(pid, <span class="number">2</span>)</div><div class="line"><span class="string">"he"</span></div></pre></td></tr></table></figure>
<p>通过用进程模型化IO设备，Erlang虚拟机允许同一个网络里的不同节点互访文件进程来在不同节点间读写文件。在所有IO设备中，有一个对所有进程都很特别，就是：<strong>组领导</strong>。</p>
<p>当你写数据给 :stdio 的时候，你实际上是发消息给组领导，由它写数据给标注输出文件描述符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="symbol">:stdio</span>, <span class="string">"hello"</span></div><div class="line">hello</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.puts Process.group_leader, <span class="string">"hello"</span></div><div class="line">hello</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>每个进程都可以配置组领导，组领导在不同的情况下使用。例如，当在一个远程终端上执行代码，它保证远程节点上的消息被重定向并打印在触发请求的终端上。</p>
<h1 id="iodata和chardata"><a href="#iodata和chardata" class="headerlink" title="iodata和chardata"></a><span id="part-five">iodata和chardata</span></h1><p>在上面所有的例子里，当写数据到文件的时候，我们使用二进制数据。在“二进制数据、字符串和字符列表”那一章，我们提到字符串是怎样由二进制数据构成而字符列表unicode代码点的列表。</p>
<p>IO模块和File模块里的函数也允许列表作为入参。不仅如此，它们也运行混合列表，列表里包含整数和二进制数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">'hello world'</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.puts [<span class="string">'hello'</span>, ?\s, <span class="string">"world"</span>]</div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然而，在IO操作中使用列表需要一些注意。一个列表可能表示一串二进制数据或者一串字符，而到底使用哪一个依赖于IO设备的编码。如果一个文件没有指定编码方式打开，它被期望是原始模式，则IO模块里以 bin* 开头的函数就必须被使用。这些函数期望一个 iodata 作为入参，也就是，它们期望一个表示字节和二进制数据的整数列表被传入。</p>
<p>另一方面，:stdio 和以 :utf8 编码打开的文件将用其余的IO模块中的函数处理。这些函数期望一个 char_data 作为入参，也就是，一个字符或者字符串列表。</p>
<p>虽然这是一个微妙的区别，你只需要担心这些细节，如果你打算传递列表给这些函数。二进制数据已经由底层字节表示，因此它们的表示总是“原始”的。</p>
<p>到此我们结束了IO设备和IO相关功能之旅。我们已经学了四个Elixir模块：<a href="https://hexdocs.pm/elixir/IO.html" target="_blank" rel="external">IO</a>、<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File</a>、<a href="https://hexdocs.pm/elixir/Path.html" target="_blank" rel="external">Path</a>和<a href="https://hexdocs.pm/elixir/StringIO.html" target="_blank" rel="external">StringIO</a>，也学了Erlang虚拟机如何用进程来处理底层IO机制以及如何使用 chardata  和 iodata 来进行IO操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/io-and-the-file-system.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－进程]]></title>
      <url>http://szpzs.oschina.io/2017/02/06/elixir-getting-started-processes/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">创建进程</a></li>
<li><a href="#part-two">发送和接收消息</a></li>
<li><a href="#part-three">链接</a></li>
<li><a href="#part-four">任务</a></li>
<li><a href="#part-five">状态</a></li>
</ol>
<p>在Elixir，所有代码运行在进程里。进程彼此间隔离，彼此间并发运行，并且通过消息传递来交流。进程不仅是Elixir的并发基础，它也为构建分布式和容错程序提供手段。</p>
<p>Elixir的进程不应该和操作系统的进程混淆。Elixir的进程就内存和CPU的消耗来说是极其轻量的（不同于许多其他编程语言中的线程）。正因如此，成千上万的进程同时运行是很平常的。</p>
<p>在本章里，我们将学习关于创建新进程的基本结构以及进程间收发消息。</p>
<a id="more"></a>
<h1 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a><span id="part-one">创建进程</span></h1><p>创建新进程的基本机制是自动导入的 spawn/1  函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; <span class="number">1</span> + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.43.0&gt;</span></div></pre></td></tr></table></figure>
<p>spawn/1 的入参是一个函数，这个函数将在另一个进程里执行。</p>
<p>注意 spawn/1 返回一个PID（进程标识符）。像如上的例子，你产生的过程很可能是死的。被创建的进程将执行给定的函数，并且在函数结束后退出。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = spawn <span class="keyword">fn</span> -&gt; <span class="number">1</span> + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.44.0&gt;</span></div><div class="line">iex&gt; Process.alive?(pid)</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：你将很可能获得一个不同于我们这个例子里获得的进程标识符。</p>
</blockquote>
<p>我们可以调用 self/0 来获取当前进程的PID：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">self</span>()</div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line">iex&gt; Process.alive?(<span class="keyword">self</span>())</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>当我们能够发送和接收消息时，进程变得更加有趣。</p>
<h1 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a><span id="part-two">发送和接收消息</span></h1><p>我们可以用 send/2 发送消息给一个进程并且可以用 receive/1 接收消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; send <span class="keyword">self</span>(), &#123;<span class="symbol">:hello</span>, <span class="string">"world"</span>&#125;</div><div class="line">&#123;<span class="symbol">:hello</span>, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, msg&#125; -&gt; msg</div><div class="line">...&gt;   &#123;<span class="symbol">:world</span>, msg&#125; -&gt; <span class="string">"won't match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>当一条消息发送给一个进程，这个消息存储在进程的邮箱里。receive/1 语句块遍历当前邮箱来查找任何匹配给定模式的消息。receive/1 支持卫语句和许多分支，就如 case/2 一样。</p>
<p>发送消息的进程不会阻塞在 send/2 上，它只是将消息放入接收者的邮箱然后继续执行后面的语句。特别是，进程可以给自己发送消息。在上面的例子里，当 receive 语句块获得执行的时候，发送者进程可能已经死掉了。</p>
<p>如果没有邮箱里的消息匹配任何模式，则当前进程将等待一直到一个匹配的消息到来。超时也可以被指定：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, msg&#125;  -&gt; msg</div><div class="line">...&gt; after</div><div class="line">...&gt;   <span class="number">1_000</span> -&gt; <span class="string">"nothing after 1s"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"nothing after 1s"</span></div></pre></td></tr></table></figure>
<p>当你已经期待的消息已经在邮箱里的时候，可以将超时设置为0。</p>
<p>让我们把这些放在一起并在进程间发送消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; parent = <span class="keyword">self</span>()</div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; send(parent, &#123;<span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;) <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.48.0&gt;</span></div><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, pid&#125; -&gt; <span class="string">"Got hello from <span class="subst">#&#123;inspect pid&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got hello from #PID&lt;0.48.0&gt;"</span></div></pre></td></tr></table></figure>
<p>当在使用shell的时候，你可能发现帮助函数 flush/0 非常有用。它刷新并打印邮箱里的所有消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; send <span class="keyword">self</span>(), <span class="symbol">:hello</span></div><div class="line"><span class="symbol">:hello</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:hello</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><span id="part-three">链接</span></h1><p>在Elixir里最通用的创建进程的方式实际上是用 spawn_link/1 函数。在我们展示 spawn_link/1 的例子之前，让我们尝试看看当一个进程失败的时候会发生什么：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.58.0&gt;</span></div><div class="line"></div><div class="line">[error] Process <span class="comment">#PID&lt;0.58.00&gt; raised an exception</span></div><div class="line">** (RuntimeError) oops</div><div class="line">    <span class="symbol">:erlang</span>.apply/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>它只是记录一个错误，而创建者依然运行。这是因为进程间是隔离的。如果我们想一个进程的失败会传递给另一个进程，我们应该将它们链接在一起。这可以用 spawn_link/1 来做到：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn_link <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line"></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.41.0&gt;) an exception was raised:</span></div><div class="line">    ** (RuntimeError) oops</div><div class="line">        <span class="symbol">:erlang</span>.apply/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>当在shell里发生一个失败，shell自动地捕获这个失败并以合适的格式展现出来。为了理解在我们的代码里到底将发生什么，让我们在一个文件里使用 spawn_link/1 ，并运行它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># spawn.exs</span></div><div class="line">spawn_link <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">receive <span class="keyword">do</span></div><div class="line">  <span class="symbol">:hello</span> -&gt; <span class="string">"let's wait until the process fails"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ elixir spawn.exs</div><div class="line"></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.47.0&gt;) an exception was raised:</span></div><div class="line">    ** (RuntimeError) oops</div><div class="line">        spawn.exs:1: anonymous fn/0 <span class="keyword">in</span> :elixir_compiler_0.__FILE__/1</div></pre></td></tr></table></figure>
<p>这一次，进程失败并且把它的父进程也搞垮了，因为它们是链接的。链接也可以通过调用 Process.link/1 来手工做到。我们建议你看一下 Process 模块来研究进程提供的其他功能。</p>
<p>当构建容错系统的时候，进程和链接扮演重要角色。在Elixir的应用里，我们经常链接我们的进程到一个监督者，当一个进程死掉的时候，这个监督者可以检测到，并且在那个地方启动一个新进程。这是唯一可能的，因为进程是隔离的，默认情况下不共享任何东西。并且因为进程是隔离的，因此没有方法在一个进程失败的时候崩溃或破坏另一个进程的状态。</p>
<p>其他语言需要我们捕获和处理异常，而在Elixir里，我们实际上是乐于让进程失败，因为我们期望监督者正确地重新启动我们的系统。当我们写Elixir程序的时候，“快速失败”是一种常见的哲学！</p>
<p>在Elixir里，spawn/1 和 spawn_link/1 是创建进程的基本命令。虽然目前为止我们只使用了它们两个，但是绝大多数时候我们将使用构建于它们之上的抽象。让我们看看这些抽象中最常用的一个，它叫做任务。</p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a><span id="part-four">任务</span></h1><p>任务构建在创建进程函数之上，以提供更好的错误报告和内省：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex(<span class="number">1</span>)&gt; Task.start <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.55.0&gt;&#125;</span></div><div class="line"></div><div class="line"><span class="number">15</span><span class="symbol">:</span><span class="number">22</span><span class="symbol">:</span><span class="number">33.046</span> [error] Task <span class="comment">#PID&lt;0.55.0&gt; started from #PID&lt;0.53.0&gt; terminating</span></div><div class="line">** (RuntimeError) oops</div><div class="line">    (elixir) lib/task/supervised.<span class="symbol">ex:</span><span class="number">74</span>: Task.Supervised.do_apply/<span class="number">2</span></div><div class="line">    (stdlib) proc_lib.<span class="symbol">erl:</span><span class="number">239</span>: <span class="symbol">:proc_lib</span>.init_p_do_apply/<span class="number">3</span></div><div class="line"><span class="symbol">Function:</span> <span class="comment">#Function&lt;20.90072148/0 in :erl_eval.expr/5&gt;</span></div><div class="line">    <span class="symbol">Args:</span> []</div></pre></td></tr></table></figure>
<p>我们用 Task.start/1 和 Task.start_link/1 替代 spawn/1 和 spawn_link/1 ，它们返回 {:ok, pid} ，而不只是PID。这就是为什么使得任务被用在监督树里。而且Task提供像 Task.async/1 和 Task.await/1 这样的便捷的函数以及易于分布式的功能。</p>
<p>我们将在 <strong>Mix 和 OTP 指导</strong> 里探索这些功能，现在记住使用 Task 来获得更好的错误报告就足够了。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a><span id="part-five">状态</span></h1><p>到目前为止，我们的教程还没有讨论过状态。如果你正在构建一个需要状态的应用，例如，保存你的应用配置，或者你需要分析一个文件并且保存在内存里，那么你需要保存它在哪里？</p>
<p>对于这个问题，进程是最通用的回答。我们可以写无限循环的，维护状态的，并且收发消息的进程。作为一个例子，让我们写一个模块，它开始一个新进程，这个进程像一个键值对存储一样工作，这个模块在名字为kv.exs的文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Task.start_link(<span class="keyword">fn</span> -&gt; loop(%&#123;&#125;) <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">loop</span></span>(map) <span class="keyword">do</span></div><div class="line">    receive <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:get</span>, key, caller&#125; -&gt;</div><div class="line">        send caller, Map.get(map, key)</div><div class="line">        loop(map)</div><div class="line">      &#123;<span class="symbol">:put</span>, key, value&#125; -&gt;</div><div class="line">        loop(Map.put(map, key, value))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：start_link 函数启动一个新进程来运行 loop/1 函数，这个函数以一个空的映射为入参。loop/1 函数然后等待消息，并且为每个消息执行适当的操作。如果是一个 :get 消息，它发送一个消息回去给调用者并再次调用 loop/1 ，接着等待新的消息。而 :put 消息的话，实际上用一个新版本的映射作为入参调用 loop/1 ，这个新版本的映射存储了给定的键和值。</p>
<p>让我们通过运行 iex kv.exs 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.62.0&gt;&#125;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="keyword">nil</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>首先，进程的映射没有键，那么发送一个 :get 消息给它然后刷新当前进程的邮箱将返回 nil ，让我发送一个 :put 消息来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; send pid, &#123;<span class="symbol">:put</span>, <span class="symbol">:hello</span>, <span class="symbol">:world</span>&#125;</div><div class="line">&#123;<span class="symbol">:put</span>, <span class="symbol">:hello</span>, <span class="symbol">:world</span>&#125;</div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:world</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>注意进程如何保持状态，并且我们通过给进程发送消息来获取和修改这个状态。实际上，任何进程只要知道上面例子的pid都能够给这个pid发送消息并且操作它的进程。</p>
<p>注册这个pid并给它一个名字也是可以的，并且允许所有知道它名字的进程都可以给它发送消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; Process.register(pid, <span class="symbol">:kv</span>)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; send <span class="symbol">:kv</span>, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:world</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>在Elixir应用里用进程来维护状态和名字注册是非常通用的模式。但是，绝大多数时候，我们不需要像上面例子一样来手工实现那些模式，而是使用Elixir自带的许多抽象之一就可以。例如，Elixir提供了 <a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">代理者</a> ，它是以状态为基础的简单抽象：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; Agent.update(pid, <span class="keyword">fn</span> map -&gt; Map.put(map, <span class="symbol">:hello</span>, <span class="symbol">:world</span>) <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Agent.get(pid, <span class="keyword">fn</span> map -&gt; Map.get(map, <span class="symbol">:hello</span>) <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:world</span></div></pre></td></tr></table></figure>
<p>一个 :name 选项一个可以传给 Agent.start_link/2 ，这样它将被自动注册。除了代理者，Elixir提供了一个API来构建通用服务（叫做 GenServer），任务，以及其他更多事务，这些全部由下面的进程驱动。这些，连同监督树，将在 <strong>Mix 和 OTP 指导</strong>（这个指导将从开始到结束构建一个完整的Elixir应用） 里更详细地探讨。</p>
<p>接下来，让我们探索Elixir的I/O世界。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/processes.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－枚举类型和流]]></title>
      <url>http://szpzs.oschina.io/2017/02/05/elixir-getting-started-enumerables-and-streams/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">枚举类型</a></li>
<li><a href="#part-two">积极 vs 懒惰</a></li>
<li><a href="#part-three">管道运算符</a></li>
<li><a href="#part-four">流</a></li>
</ol>
<a id="more"></a>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><span id="part-one">枚举类型</span></h1><p>Elixir提供了枚举类型的概念以及<a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="external">Enum模块</a>来处理它们。我们已经学了两个枚举类型：list 和 map 。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span> x -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.map(%&#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>&#125;, <span class="keyword">fn</span> &#123;k, v&#125; -&gt; k * v <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">12</span>]</div></pre></td></tr></table></figure>
<p>Enum模块提供了大量的函数来转换、排序、分组、过滤枚举数据以及从枚举数据里获取元素。它是程序员在他们的Elixir代码里经常使用的模块之一。</p>
<p>Elixir也提供了范围这种数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)</div><div class="line">[2, 4, 6]</div><div class="line">iex&gt; Enum.reduce(1..3, 0, &amp;+/2)</div><div class="line">6</div></pre></td></tr></table></figure>
<p>Enum模块里的函数正如它的名字所示，它们被限制只能枚举数据结构的值。对于特殊的操作，比如插入和修改特定的元素，你可能需要根据特定的数据类型使用相应的模块。例如，如果你要在列表的给定位置插入一个元素，你应该使用List模块里的List.insert_at/3函数，因为它插入一个值到一个范围数据里是没意义的。</p>
<p>我们说Enum模块里的函数是多态的，是因为它们可以处理多种数据类型。尤其是，Enum模块里的函数可以处理任何实现了<a href="https://hexdocs.pm/elixir/Enumerable.html" target="_blank" rel="external">Enumerable协议</a>的数据。我们将在后续的章节讨论协议；现在我们将学习叫做流的特殊枚举类型。</p>
<h1 id="积极-VS-懒惰"><a href="#积极-VS-懒惰" class="headerlink" title="积极 VS 懒惰"></a><span id="part-two">积极 VS 懒惰</span></h1><p>Enum模块里的所有函数都是积极的。许多函数都期盼一个枚举类型数据然后返回一个列表。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; odd? = &amp;(rem(&amp;<span class="number">1</span>, <span class="number">2</span>) != <span class="number">0</span>)</div><div class="line"><span class="comment">#Function&lt;6.80484245/1 in :erl_eval.expr/5&gt;</span></div><div class="line">iex&gt; Enum.filter(<span class="number">1</span>..<span class="number">3</span>, odd?)</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>这意味着，当用Enum进行多个操作的时候，每个操作都将生成一个中间列表一直到我们最后得到结果。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Enum.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Enum.filter(odd?) |&gt; Enum.sum</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>上面的例子是一个管道操作。我们从一个范围数据开始，然后将它的每个元素乘于3。第一个操作将创建和返回一个有10万元素的列表。接着我们保留这个列表里的所有奇数元素并生成一个新的有5万元素的列表，最后我们统计这些元素的和。</p>
<h1 id="管道运算符"><a href="#管道运算符" class="headerlink" title="管道运算符"></a><span id="part-three">管道运算符</span></h1><p>上面例子使用的 |&gt; 符号是管道运算符：它获取它左边表达式的输出然后将这个输出作为第一个参数传给它右边的函数。它和Unix的 | 管道操作符相似。其目的是突出数据被一系列函数变换。为了看清楚它是如何使得代码更简洁的，我们来看看上述例子不用 |&gt; 运算符来写的样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.sum(Enum.filter(Enum.map(<span class="number">1</span>..<span class="number">100_000</span>, &amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)), odd?))</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>请阅读相关<a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" target="_blank" rel="external">文档</a>来深入理解管道运算符。</p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a><span id="part-four">流</span></h1><p>作为Enum的替代物，Elixir提供了支持懒操作的<a href="https://hexdocs.pm/elixir/Stream.html" target="_blank" rel="external">Stream模块</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Stream.filter(odd?) |&gt; Enum.sum</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>流是懒惰的，可组合的枚举数据类型。</p>
<p>在上述例子里，1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) 返回一个数据类型，实际上就是一个流，它表示在范围数据 1..100_000上的映射计算：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>))</div><div class="line"><span class="comment">#Stream&lt;[enum: 1..100000, funs: [#Function&lt;34.16982430/1 in Stream.map/2&gt;]]&gt;</span></div></pre></td></tr></table></figure>
<p>而且，它们是可组合的，因为我们可以用管道操作来组合多个流：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Stream.filter(odd?)</div><div class="line"><span class="comment">#Stream&lt;[enum: 1..100000, funs: [...]]&gt;</span></div></pre></td></tr></table></figure>
<p>流不是生成中间表，而是建立一系列计算，只有当我们传递底层的流给Enum模块，这些计算才被执行。当处理大的、可能是无限的集合数据时，流非常有用。</p>
<p>Stream模块里的许多函数接收任何枚举数据作为入参，并且返回一个流作为结果。它也提供函数来创建流。例如，Stream.cycle/1 可以通过无限循环给定的枚举数据来创建一个流。小心：不要在这样的流上调用像 Enum.map/2 这样的函数，因为它们会无限循环下去：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = Stream.cycle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">#Function&lt;15.16982430/2 in Stream.cycle/1&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">10</span>)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>另一方面，Stream.unfold/2 可以被用来从一个给定的初始值来创建流：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = Stream.unfold(<span class="string">"hełło"</span>, &amp;String.next_codepoint/<span class="number">1</span>)</div><div class="line"><span class="comment">#Function&lt;39.75994740/2 in Stream.unfold/2&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">3</span>)</div><div class="line">[<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"ł"</span>]</div></pre></td></tr></table></figure>
<p>另一个有趣的函数是 stream.resource/3，它可被用来包裹资源，从而保证资源即使在失败的情况下也可以在枚举之前被正确地打开和在后续被关闭。例如，我们可以用它来流式一个文件：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = File.stream!(<span class="string">"path/to/file"</span>)</div><div class="line"><span class="comment">#Function&lt;18.16982430/2 in Stream.resource/3&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>上面的例子将获取你选在的文件的前10行。这意味着，流在处理大文件或者像网络资源这样的慢资源上非常有用。</p>
<p>Enum和Stream模块里的函数数量可能让你一开始觉得很难，不过通过各种案例，你将会熟悉它们。尤其是，首先要专注在Enum模块，只在需要懒操作的特别场景，例如处理慢资源或者大的、可能无限的集合数据的时候才转向Stream模块。</p>
<p>下一章，我们将看看Elixir的一个核心特性：进程，它将允许我们以简单和可理解的方式来写并发、并行和分布式程序。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/enumerables-and-streams.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/enumerables-and-streams.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－递归]]></title>
      <url>http://szpzs.oschina.io/2017/02/04/elixir-getting-started-recursion/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">用递归实现循环</a></li>
<li><a href="#part-two">reduce 和 map 算法</a></li>
</ol>
<a id="more"></a>
<h1 id="用递归实现循环"><a href="#用递归实现循环" class="headerlink" title="用递归实现循环"></a><span id="part-one">用递归实现循环</span></h1><p>由于不可修改的特性，Elixir里的循环（如任何其他函数式语言原因）和命令式语言的写法不同。例如，在命令式语言，如C里，循环的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>); i++) &#123;</div><div class="line">  <span class="built_in">array</span>[i] = <span class="built_in">array</span>[i] * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述例子里，我们修改数组和变量i。在Elixir里修改变量值是不可能的。相反，函数式语言依赖于递归：一个函数被递归地调用，直到一个条件符合了才停止递归动作继续进行。在这个过程里面，没有数据被修改。思考一下下面的例子，打印一个字符串任意次数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Recursion</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_multiple_times</span></span>(msg, n) <span class="keyword">when</span> n &lt;= <span class="number">1</span> <span class="keyword">do</span></div><div class="line">    IO.puts msg</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_multiple_times</span></span>(msg, n) <span class="keyword">do</span></div><div class="line">    IO.puts msg</div><div class="line">    print_multiple_times(msg, n - <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Recursion.print_multiple_times(<span class="string">"Hello!"</span>, <span class="number">3</span>)</div><div class="line"><span class="comment"># Hello!</span></div><div class="line"><span class="comment"># Hello!</span></div><div class="line"><span class="comment"># Hello!</span></div></pre></td></tr></table></figure>
<p>和case语句相似，一个函数可能有多个分支。当传递给函数的参数匹配某个分支的参数模式，并且这个分支的卫语句结果为true，那么这个特定的分支将被执行。</p>
<p>当上述例子里的 print_multiple_times/2 函数刚开始被调用的时候，参数 n 等于3。</p>
<p>第一个分支有一个卫语句，它说，“当且仅当n小于等于1的时候使用这个分支”。因为一开始的时候n等于3，这个条件不成立，则Elixir处理下一个分支定义。</p>
<p>第二个分支定义匹配这个模式并且没有卫语句，因此它将被执行。它首先打印我们的 msg 变量，然后传递 n - 1 （2）作为第二个入参并调用自己。</p>
<p>我们的 msg 变量被打印并且 print_multiple_times/2 被再次调用，这次第二个入参为1。因为n现在为1，print_multiple_times/2 的第一个分支定义的卫语句结果为true，那么我们执行这个特定的分支定义。msg被打印，并且没有其他需要执行的。</p>
<p>我们这样定义 print_multiple_times/2 ，不管传递的第二个参数是什么数值，它可能触发我们第一个分支（也就是基准条件），或者它出发我们第二个分支，它将确保我们离我们的基准条件更近一步。</p>
<h1 id="reduce-和-map-算法"><a href="#reduce-和-map-算法" class="headerlink" title="reduce 和 map 算法"></a><span id="part-two">reduce 和 map 算法</span></h1><p>现在让我们看看我们如何利用递归的能力来对数字列表进行求和：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum_list</span></span>([head | tail], accumulator) <span class="keyword">do</span></div><div class="line">    sum_list(tail, head + accumulator)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum_list</span></span>([], accumulator) <span class="keyword">do</span></div><div class="line">    accumulator</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>) <span class="comment">#=&gt; 6</span></div></pre></td></tr></table></figure>
<p>我们用列表[1, 2, 3]和初始值0作为入参来调用 sum_list 。我们将尝试每一个分支直到我们找到一个分支，根据模式匹配规则它匹配了。在这个场景下，列表[1, 2, 3]匹配了[head | tail]，它绑定了head为1，tail为[2, 3]，accumulator为0。</p>
<p>然后，我们将列表的头元素加到累加器里：head + accumulator，并且传递列表尾部作为第一个参数，再次递归地调用 sum_list 。这个列表尾部再一次匹配 [head | tail]，这个情况一直到列表为空为止。参见如下演示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum_list [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span></div><div class="line">sum_list [<span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span></div><div class="line">sum_list [<span class="number">3</span>], <span class="number">3</span></div><div class="line">sum_list [], <span class="number">6</span></div></pre></td></tr></table></figure>
<p>当列表为空，它将匹配最后一个分支，然后返回最后结果为6。</p>
<p>将列表分解为一个值的过程称为归约算法，是函数编程的核心。</p>
<p>如果我们想将我们列表的所有元素值都翻倍，我们该如何做呢？</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double_each</span></span>([head | tail]) <span class="keyword">do</span></div><div class="line">    [head * <span class="number">2</span> | double_each(tail)]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double_each</span></span>([]) <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex math.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.double_each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#=&gt; [2, 4, 6]</span></div></pre></td></tr></table></figure>
<p>在这里我们用递归遍历列表，将其每个元素值翻倍，并且返回一个新的列表。获取列表并在其上映射的过程称为映射算法。</p>
<p>递归和尾调用是Elixir里重要的部分并且也是通常用来创建循环的方法。然后，当你在Elixir里编程，你将几乎很少像上面例子那样使用递归来操作列表。</p>
<p>我们将在下一章看到的 <a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="external">Enum模块</a> 已经提供了许多操作列表的便捷方式。例如，上述例子可以按如下方式来写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span>)</div><div class="line"><span class="number">6</span></div><div class="line">iex&gt; Enum.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>或者使用捕获语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.reduce([1, 2, 3], 0, &amp;+/2)</div><div class="line">6</div><div class="line">iex&gt; Enum.map([1, 2, 3], &amp;(&amp;1 * 2))</div><div class="line">[2, 4, 6]</div></pre></td></tr></table></figure>
<p>让我们更深入地了解可枚举的数据类型：Enumerable，以及它的懒惰对应数据类型：Steam。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/recursion.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/recursion.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－模块]]></title>
      <url>http://szpzs.oschina.io/2017/02/03/elixir-getting-started-modules/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">编译</a></li>
<li><a href="#part-two">脚本模式</a></li>
<li><a href="#part-three">命名函数</a></li>
<li><a href="#part-four">函数捕获</a></li>
<li><a href="#part-five">默认参数</a></li>
</ol>
<p>在Elixir里我们将几个函数到模块里。在前面的章节里我们已经使用了许多不用的模块，比如<a href="https://hexdocs.pm/elixir/String.html" target="_blank" rel="external">String模块</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.length(<span class="string">"hello"</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>为了在Elixir里创建我们自己的模块，我们使用 defmodule 模块。我们使用 def 宏来定义模块里的函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">...&gt;     a + b</div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"></div><div class="line">iex&gt; Math.sum(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>下面几个部分，我们的例子变得更长，在shell里将可能难以输入。现在是时候我们学习如何编译Elixir代码以及如何运行Elixir脚本。</p>
<a id="more"></a>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a><span id="part-one">编译</span></h1><p>大多数时候，将模块写入文件是很方便的，因此它们可以被编译和重用。让我们假设我们有一个名字为 math.ex 的文件，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个文件可以用 elixirc 来编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixirc math.ex</div></pre></td></tr></table></figure>
<p>这将生成一个名字为 Elixir.Math.beam 的文件，它包含了定义的模块的字节码。如果我们再次启动 iex ，我们的模块定义将有效（被提供，即 iex 和字节码文件相同的目录里启动）。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.sum(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>Elixir项目通常被组织成三个目录里：</p>
<ul>
<li>ebin - 包含被编译的字节码。</li>
<li>lib - 包含elixir代码（通常是 .ex 文件）。</li>
<li>test - 包含测试文件（通常是 .exs  文件）。</li>
</ul>
<p>当工作在实际项目上时，构建工具（mix）将负责编译和为你设置合适的路径。为了学习目的，Elixir也支持脚本模式，它更灵活而且不生成任何编译的文件。</p>
<h1 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a><span id="part-two">脚本模式</span></h1><p>除了Elixir文件后缀 .ex ，Elixir也支持脚本后缀 .exs 文件。Elixir处理这两种文件是用相同的方式，唯一的区别在于意图。.ex 文件意味着被编译，.exs 文件用于脚本。当执行的时候，两中后缀的文件编译并且装载它们的模块到内存里，而只有 .ex  文件以 .beam文件格式写它们的字节码到磁盘上。</p>
<p>例如，我们可以创建一个文件，名为math.exs：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum(<span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>并且如下方式执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir math.exs</div></pre></td></tr></table></figure>
<p>这个文件将被编译进内存并执行，结果为输出 3 。没有字节码生成。在后续的例子里，我们建议你写你的代码到脚本文件里，并且按上述所示执行它们。</p>
<h1 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a><span id="part-three">命名函数</span></h1><p>在模块里，我们可以用 def/2 定义函数，用 defp/2 定义私有函数。用def/2定义的函数可以被从其他模块调用，而私有函数只能本地调用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    do_sum(a, b)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">do_sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum(<span class="number">1</span>, <span class="number">2</span>)    <span class="comment">#=&gt; 3</span></div><div class="line">IO.puts Math.do_sum(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">#=&gt; ** (UndefinedFunctionError)</span></div></pre></td></tr></table></figure>
<p>函数定义也支持卫语句和多分支。如果一个函数有几个分支，Elixir将尝试每一个分支直到找到匹配的分支为止。如下的例子是检查给定的数字是否是零的函数的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(<span class="number">0</span>) <span class="keyword">do</span></div><div class="line">    <span class="keyword">true</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(x) <span class="keyword">when</span> is_integer(x) <span class="keyword">do</span></div><div class="line">    <span class="keyword">false</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.zero?(<span class="number">0</span>)         <span class="comment">#=&gt; true</span></div><div class="line">IO.puts Math.zero?(<span class="number">1</span>)         <span class="comment">#=&gt; false</span></div><div class="line">IO.puts Math.zero?([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#=&gt; ** (FunctionClauseError)</span></div><div class="line">IO.puts Math.zero?(<span class="number">0</span>.<span class="number">0</span>)       <span class="comment">#=&gt; ** (FunctionClauseError)</span></div></pre></td></tr></table></figure>
<p>给定的入参如果不能匹配任何一个分支则会引起一个错误。</p>
<p>和结构 if 相似，命名函数支持 do: 和 do/end 块语法，就像<a href="http://elixir-lang.org/getting-started/case-cond-and-if.html#doend-blocks" target="_blank" rel="external">我们学到的 do/end 是为关键字列表格式的便捷语法</a>。例如，我们可以改写上面例子文件 math.exs 为如下样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(<span class="number">0</span>), <span class="symbol">do:</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(x) <span class="keyword">when</span> is_integer(x), <span class="symbol">do:</span> <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>它也提供一样的功能。你可以用 do: 于一行代码内，不过应该一直用 do/end 于多行代码。</p>
<h1 id="函数捕获"><a href="#函数捕获" class="headerlink" title="函数捕获"></a><span id="part-four">函数捕获</span></h1><p>在本教程中，我们已经用符号 name/arity 来引用函数。碰巧，这个符号实际上可以用来检索命名函数作为函数类型。启动 iex ，运行上面定义的 math.exs 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex math.exs</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.zero?(0)</div><div class="line">true</div><div class="line">iex&gt; fun = &amp;Math.zero?/1</div><div class="line">&amp;Math.zero?/1</div><div class="line">iex&gt; is_function(fun)</div><div class="line">true</div><div class="line">iex&gt; fun.(0)</div><div class="line">true</div></pre></td></tr></table></figure>
<p>记住Elixir在匿名函数和命名函数之间做了一个区分，就是前者必需在调用的时候在变量名和圆括号之间加一个点号。捕获运算符通过允许命名函数用我们赋予、调用和传递匿名函数的相同方式被赋予变量并当做参数被传递来消除这种差别。</p>
<p>本地或被导入的函数，比如 is_function/1 ，可以不需要模块的方式被捕获：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &amp;is_function/<span class="number">1</span></div><div class="line">&amp;<span class="symbol">:erlang</span>.is_function/<span class="number">1</span></div><div class="line">iex&gt; (&amp;is_function/<span class="number">1</span>).(fun)</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>注意：捕获语法也可以被用来作为创建函数的便捷方式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = &amp;(&amp;<span class="number">1</span> + <span class="number">1</span>)</div><div class="line"><span class="comment">#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;</span></div><div class="line">iex&gt; fun.(<span class="number">1</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>&amp;1表示传入函数的第一个参数。上述 &amp;(&amp;1 + 1) 和 fn x -&gt; x + 1 end 是一样的。上面例子的语法特别适合短函数定义。</p>
<p>如果你想从一个模块里捕获一个函数，你可以这么做 &amp;Module.function() ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = &amp;List.flatten(&amp;<span class="number">1</span>, &amp;<span class="number">2</span>)</div><div class="line">&amp;List.flatten/<span class="number">2</span></div><div class="line">iex&gt; fun.([<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]], [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>&amp;List.flatten(&amp;1, &amp;2) 和 fn(list, tail) -&gt; List.flatten(list, tail) end 写法是一样的，在这个场景，等效于 &amp;List.flatten/2 。你可以在 <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;/1" target="_blank" rel="external">Kernel.SpecialForms 文档</a>里读到更多关于捕获运算符 &amp; 的内容。</p>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a><span id="part-five">默认参数</span></h1><p>Elixir里的命名函数也支持默认参数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Concat</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, sep \\ <span class="string">" "</span>) <span class="keyword">do</span></div><div class="line">    a &lt;&gt; sep &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>)      <span class="comment">#=&gt; Hello world</span></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>, <span class="string">"_"</span>) <span class="comment">#=&gt; Hello_world</span></div></pre></td></tr></table></figure>
<p>任何表达式都允许作为默认值，不过它在函数定义里不会被运算。每次函数调用而且任何它的默认值必须要用的时候，默认值的表达式将被运算：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">DefaultTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dowork</span></span>(x \\ <span class="string">"hello"</span>) <span class="keyword">do</span></div><div class="line">    x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; DefaultTest.dowork</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; DefaultTest.dowork <span class="number">123</span></div><div class="line"><span class="number">123</span></div><div class="line">iex&gt; DefaultTest.dowork</div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>如果一个有默认值函数有多个分支，它需要创建一个函数头（没有函数体）来声明默认值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Concat</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b \\ <span class="keyword">nil</span>, sep \\ <span class="string">" "</span>)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, _sep) <span class="keyword">when</span> is_nil(b) <span class="keyword">do</span></div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, sep) <span class="keyword">do</span></div><div class="line">    a &lt;&gt; sep &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>)      <span class="comment">#=&gt; Hello world</span></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>, <span class="string">"_"</span>) <span class="comment">#=&gt; Hello_world</span></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>)               <span class="comment">#=&gt; Hello</span></div></pre></td></tr></table></figure>
<p>当使用默认值的时候，必须要小心避免重叠函数定义。如下例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Concat</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"***First join"</span></div><div class="line">    a &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, sep \\ <span class="string">" "</span>) <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"***Second join"</span></div><div class="line">    a &lt;&gt; sep &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果我们把上述代码保存在 “concat.ex” 文件中并编译它，Elixir将输出如下警告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">warning:</span> this clause cannot match because a previous clause at line <span class="number">2</span> always matches</div></pre></td></tr></table></figure>
<p>编译器告诉我们，用两个参数来调用 join 函数将总是选择 join 函数的第一个定义，而它的第二个定义将只在传入三个参数的时候才被调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex concat.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Concat.join <span class="string">"Hello"</span>, <span class="string">"world"</span></div><div class="line">***First join</div><div class="line"><span class="string">"Helloworld"</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Concat.join <span class="string">"Hello"</span>, <span class="string">"world"</span>, <span class="string">"_"</span></div><div class="line">***Second join</div><div class="line"><span class="string">"Hello_world"</span></div></pre></td></tr></table></figure>
<p>简短的模块知识介绍到此结束。下一章，我们将学习如何用命名函数来递归；探索Elixir的词汇指令，这些指令可以用来从其他模块导入函数；讨论模块属性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/modules.html#" target="_blank" rel="external">http://elixir-lang.org/getting-started/modules.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－Keywords和maps]]></title>
      <url>http://szpzs.oschina.io/2017/02/02/elixir-getting-started-keywords-and-maps/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">关键字列表</a></li>
<li><a href="#part-two">映射</a></li>
<li><a href="#part-three">嵌套数据结构</a></li>
</ol>
<p>到目前为止，我们还没讨论过任何关联数据结构，即该数据结构是将一个值（或者多个值）和一个键关联起来。不同的语言对这种数据结构的称呼不一样，比如：字典、哈希、关联数组，等等。</p>
<p>Elixir里有两种主要的关联数据结构：关键字列表和映射。现在让我们来学习它们！</p>
<a id="more"></a>
<h1 id="关键字列表"><a href="#关键字列表" class="headerlink" title="关键字列表"></a><span id="part-one">关键字列表</span></h1><p>在许多函数式语言里，通常使用两个元素的元组组成的列表来表示一个键值对数据结构。在Elixir里，当我们有一个元组组成的列表，并且元组的第一个元素（即键）是原子，则我们叫这个列表是关键字列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [&#123;:a, <span class="number">1</span>&#125;, &#123;:b, <span class="number">2</span>&#125;]</div><div class="line">[a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">iex&gt; list == [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>正如上述所示，Elixir支持一种特殊的语法来定义这样的列表：[key: value]。它在底层是表示上述例子的元组组成的列表。既然关键字列表是列表，我们可以使用列表的所有可用操作。例如，我们可以使用  ++ 增加一个值到关键字列表里。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list ++ [c: <span class="number">3</span>]</div><div class="line">[a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>]</div><div class="line">iex&gt; [a: <span class="number">0</span>] ++ list</div><div class="line">[a: <span class="number">0</span>, a: <span class="number">1</span>, b: <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>注意：加到前面的值将被首先查询到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; new_list = [a: <span class="number">0</span>] ++ list</div><div class="line">[a: <span class="number">0</span>, a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">iex&gt; new_list[:a]</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>关键字列表很重要，因为它有三个特别的特性：</p>
<ul>
<li>键必须是原子。</li>
<li>键的顺序由开发者指定。</li>
<li>键可以重复出现。</li>
</ul>
<p>例如，Ecto库 使用这些特性来提供一个写数据库查询的优雅领域特定语言：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">query</span> = from w in Weather,</div><div class="line">      where: w.prcp &gt; <span class="number">0</span>,</div><div class="line">      where: w.temp &lt; <span class="number">20</span>,</div><div class="line">     select: w</div></pre></td></tr></table></figure>
<p>这些特性使得关键字列表成为Elixir里传递选项给函数的默认机制。在第5章，我们讨论 if/2 宏的时候，我们提到下述语法是被支持的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">false</span>, do: :this, else: :that</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>do: 和 else: 对是关键字列表！实际上，上述的调用等价于下面的调用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span>(<span class="literal">false</span>, [do: :this, else: :that])</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>也和下面的调用相同：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span>(<span class="literal">false</span>, [&#123;:do, :this&#125;, &#123;:else, :that&#125;])</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>通常，当关键字列表是函数的最后一个参数的时候，方括号是可省略的。</p>
<p>虽然我们可以在关键字列表上进行模式匹配，但是实际操作中很少用，因为在列表上进行模式匹配需要列表的元素数量和它们的顺序匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; [a: a] = [a: <span class="number">1</span>]</div><div class="line">[a: <span class="number">1</span>]</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; [a: a] = [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">iex&gt; [b: b, a: a] = [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [a: <span class="number">1</span>, b: <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>为了操作关键字列表，Elixir提供了<a href="https://hexdocs.pm/elixir/Keyword.html" target="_blank" rel="external">Keyword模块</a>。记住，关键字列表就是列表，因此它们和列表一样提供了线性性能特性。列表越长，就要花越多的时间查找到一个键、计算元素个数，诸如此类的。因为这个原因，关键字列表在Elixir里主要用来传递可选值。如果你需要存储许多项数据或者要保证一个键只对应一个值，那么你应该用映射。</p>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a><span id="part-two">映射</span></h1><p>在Elixir里，任何时候你需要键值对存储，则映射就是你所要的数据结构。映射使用 %{} 语法来创建：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line">iex&gt; map[<span class="symbol">:a</span>]</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; map[<span class="number">2</span>]</div><div class="line"><span class="symbol">:b</span></div><div class="line">iex&gt; map[<span class="symbol">:c</span>]</div><div class="line"><span class="keyword">nil</span></div></pre></td></tr></table></figure>
<p>与关键字列表比较，我们已经可以看到有两个不同：</p>
<ul>
<li>映射允许任何值作为键。</li>
<li>映射的键不遵循任何顺序。</li>
</ul>
<p>与关键字列表相反，映射非常有用于模式匹配。当一个映射用在一个模式中，它将总是匹配上一个给定值的子集：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; %&#123;&#125; = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line">iex&gt; %&#123;<span class="symbol">:a</span> =&gt; a&#125; = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; %&#123;<span class="symbol">:c</span> =&gt; c&#125; = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> %&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>如上所述，一个映射一定匹配，只要模式里的键存在于给定的映射里。因此，一个空映射匹配所有映射。</p>
<p>当访问、匹配和增加映射的键时，变量可以被使用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; n = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; map = %&#123;n =&gt; <span class="symbol">:one</span>&#125;</div><div class="line">%&#123;<span class="number">1</span> =&gt; <span class="symbol">:one</span>&#125;</div><div class="line">iex&gt; map[n]</div><div class="line"><span class="symbol">:one</span></div><div class="line">iex&gt; %&#123;^n =&gt; <span class="symbol">:one</span>&#125; = %&#123;<span class="number">1</span> =&gt; <span class="symbol">:one</span>, <span class="number">2</span> =&gt; <span class="symbol">:two</span>, <span class="number">3</span> =&gt; <span class="symbol">:three</span>&#125;</div><div class="line">%&#123;<span class="number">1</span> =&gt; <span class="symbol">:one</span>, <span class="number">2</span> =&gt; <span class="symbol">:two</span>, <span class="number">3</span> =&gt; <span class="symbol">:three</span>&#125;</div></pre></td></tr></table></figure>
<p><a href="https://hexdocs.pm/elixir/Map.html" target="_blank" rel="external">Map模块</a>提供和Keyword模块相似的API来便于操作映射：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Map.get(%&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;, <span class="symbol">:a</span>)</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; Map.to_list(%&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;)</div><div class="line">[&#123;<span class="number">2</span>, <span class="symbol">:b</span>&#125;, &#123;<span class="symbol">:a</span>, <span class="number">1</span>&#125;]</div></pre></td></tr></table></figure>
<p>当映射中的所有键都是原子时，您可以使用关键字语法来提高便捷程度：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>映射另一个有趣的特性是提供它们自己的语法来修改和访问原子键：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line"></div><div class="line">iex&gt; map.a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; map.c</div><div class="line">** (KeyError) key <span class="symbol">:c</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line"></div><div class="line">iex&gt; %&#123;map | <span class="symbol">:a</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">iex&gt; %&#123;map | <span class="symbol">:c</span> =&gt; <span class="number">3</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:c</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>上述访问和修改语法需要给定的键存在。例如，访问和修改 :c 键失败，因为映射里没有这个键。</p>
<p>当处理映射的时候，Elixir开发者一贯喜欢用 map.field 语法和模式匹配来替代 Map 模块里的函数，因为它们形成了一种断言式的编程风格。<a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/" target="_blank" rel="external">这篇博客</a> 提供了解释和例子，如何在Elixir里通过写断言代码获得更简洁和更快的软件。</p>
<blockquote>
<p>注意：映射是最近才引入Erlang虚拟机的，并且仅从Elixir v1.2开始，它们才有能力高效处理上百万键。因此，如果你使用较老的Elixir版本（v1.0或v1.1），并且你需要最少支持数百个键，那么你可以考虑使用<a href="https://hexdocs.pm/elixir/HashDict.html" target="_blank" rel="external">HashDict模块</a>。</p>
</blockquote>
<h1 id="嵌套数据结构"><a href="#嵌套数据结构" class="headerlink" title="嵌套数据结构"></a><span id="part-three">嵌套数据结构</span></h1><p>我们常常有映射中有映射，或者甚至在映射里有关键字列表，等等。Elixir通过 put_in/2 和 update_in/2 提供了操作嵌套数据结构的便利，以及你可以在命令式语言里发现其他宏也提供这样的遍历而同时保持这个语言的不可修改的特性。</p>
<p>假设你有如下的结构：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; users = [</div><div class="line">  <span class="symbol">john:</span> %&#123;<span class="symbol">name:</span> <span class="string">"John"</span>, <span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>]&#125;,</div><div class="line">  <span class="symbol">mary:</span> %&#123;<span class="symbol">name:</span> <span class="string">"Mary"</span>, <span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>, <span class="string">"Clojure"</span>]&#125;</div><div class="line">]</div><div class="line">[<span class="symbol">john:</span> %&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>], <span class="symbol">name:</span> <span class="string">"John"</span>&#125;,</div><div class="line"> <span class="symbol">mary:</span> %&#123;<span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>, <span class="string">"Clojure"</span>], <span class="symbol">name:</span> <span class="string">"Mary"</span>&#125;]</div></pre></td></tr></table></figure>
<p>我们有一个用户的关键字列表，它的每一个值是一个映射，这个映射包含名字，年龄和用户喜欢的编程语言组成的列表。如果我们想访问约翰的年龄，我们可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; users[<span class="symbol">:john</span>].age</div><div class="line"><span class="number">27</span></div></pre></td></tr></table></figure>
<p>我们也可以用相同的语法来修改这个值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; users = put_in users[<span class="symbol">:john</span>].age, <span class="number">31</span></div><div class="line">[<span class="symbol">john:</span> %&#123;<span class="symbol">age:</span> <span class="number">31</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>], <span class="symbol">name:</span> <span class="string">"John"</span>&#125;,</div><div class="line"> <span class="symbol">mary:</span> %&#123;<span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>, <span class="string">"Clojure"</span>], <span class="symbol">name:</span> <span class="string">"Mary"</span>&#125;]</div></pre></td></tr></table></figure>
<p>update_in/2 宏也相似，不过它允许我们传递一个函数来控制如何修改值。例如，让我们从玛丽的编程语言列表里删除掉Clojure：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; users = update_in users[<span class="symbol">:mary</span>].languages, &amp;List.delete(&amp;<span class="number">1</span>, <span class="string">"Clojure"</span>)</div><div class="line">[<span class="symbol">john:</span> %&#123;<span class="symbol">age:</span> <span class="number">31</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>], <span class="symbol">name:</span> <span class="string">"John"</span>&#125;,</div><div class="line"> <span class="symbol">mary:</span> %&#123;<span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>], <span class="symbol">name:</span> <span class="string">"Mary"</span>&#125;]</div></pre></td></tr></table></figure>
<p>关于 put_in/2 和 update_in/2 还有很多需要学习的，包括 get_and_update_in/2 这个函数允许我们一次性获取一个值并且修改数据结构。也有 put_in/3，update_in/3 和 get_and_update_in/3 这些函数，它们允许动态访问数据结构。请在 <a href="https://hexdocs.pm/elixir/Kernel.html" target="_blank" rel="external">Kernel模块</a>里仔细阅读它们各自的文档来深入理解它们的作用。</p>
<p>到此我们结束了Elixir里关联数据结构的介绍。你将发现，给定关键字列表和映射，你将总会有适用的工具来解决Elixir里需要关联数据结构的问题。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/keywords-and-maps.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/keywords-and-maps.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－二进制数据，字符串 和 字符列表]]></title>
      <url>http://szpzs.oschina.io/2017/02/01/elixir-getting-started-binaries-strings-and-char-lists/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">UTF-8和Unicode</a></li>
<li><a href="#part-two">二进制数据（和位串）</a></li>
<li><a href="#part-three">字符列表</a></li>
</ol>
<p>在“基本类型”那一章，我们学到了字符串以及使用 is_binary/1 函数来检查它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; string = <span class="string">"hello"</span></div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; is_binary(string)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>在本章，我们将理解二进制数据是什么；它们如何和字符串联系在一起；在Elixir里，被单引号括起来的值，比如 ‘like this’，是什么。</p>
<a id="more"></a>
<h1 id="UTF-8和Unicode"><a href="#UTF-8和Unicode" class="headerlink" title="UTF-8和Unicode"></a><span id="part-one">UTF-8和Unicode</span></h1><p>一个字符串是一个用UTF-8编码的二进制数据。为了确切理解我们的意思，我们需要理解字节和代码点之间的区别。</p>
<p>Unicode标准给我们所知的许多字符赋予了代码点。比如，字母 a 有代码点 97，而字母 ł 有代码点322。当将字符串 “hełło” 写到磁盘上时，我们需要将它的代码点转换为若干字节。如果我们采用的规则是，一个字节表示一个代码点，那么我们将无法写字符串 “hełło” ，因为它使用了代码点322来表示字母 ł ，而一个字节只能表示 0 到 255的数字。理所当然地，你要正确地在屏幕上读出字符串 “hełło” ，它必须被以某种方式表达出来。这就是编码应用之处了。</p>
<p>用字节的方式来表达代码点的时候，我们需要以某种方式编码它们。Elixir选择UTF-8编码作为它主要的和默认的编码。当我们说一个字符串是一个UTF-8编码的二进制数据，我们的意思是一个字符串是以一种方式，比如指定的UTF-8编码，来组织的表达某些代码点的一块二进制数据。</p>
<p>因为我们有字母，像 ł 被赋予代码点322，所以我们的确需要多于一个字节来表达它们。这就是为什么我们看到的 byte_size/1 和 String.length/1 之间有区别：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; string = <span class="string">"hełło"</span></div><div class="line"><span class="string">"hełło"</span></div><div class="line">iex&gt; byte_size(string)</div><div class="line"><span class="number">7</span></div><div class="line">iex&gt; String.length(string)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>byte_size/1 计算的是底层的字节数，而 String.length/1 计算的是字符数。</p>
<blockquote>
<p>注意：如果你用的是Windows，你的终端可能不是默认用UTF-8编码。你可以在运行iex（iex.bat）前通过运行 chcp 65001 来改变你当前会话的编码。</p>
</blockquote>
<p>UTF-8需要一个字节来表达字符 h，e 和 o ，但是需要两个字节表达字符 ł 。在Elixir里，你可以用 ? 来获得一个字符的代码点：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ?a</div><div class="line"><span class="number">97</span></div><div class="line">iex&gt; ?ł</div><div class="line"><span class="number">322</span></div></pre></td></tr></table></figure>
<p>你也可以用String模块里的函数将一个字符串分割为独立字符串组成的列表，其中每一个字符串是长度为一。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.codepoints(<span class="string">"hełło"</span>)</div><div class="line">[<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"ł"</span>, <span class="string">"ł"</span>, <span class="string">"o"</span>]</div></pre></td></tr></table></figure>
<p>你将看到Elixir已经非常好地支持字符串操作。它也支持许多Unicode操作。实际上，Elixir通过了<a href="http://mortoray.com/2013/11/27/the-string-type-is-broken/" target="_blank" rel="external">“The string type is broken”</a>里的所有测试。</p>
<p>然后，字符串只是本文的一部分内容。如果一个字符串是一个二进制数据，并且我们也对它使用了is_binary/1函数，那么Elixir必须有一个底层类型来支持字符串。它的确是这么做的！下面我们来谈谈二进制数据。</p>
<h1 id="二进制数据（和位串）"><a href="#二进制数据（和位串）" class="headerlink" title="二进制数据（和位串）"></a><span id="part-two">二进制数据（和位串）</span></h1><p>在Elixir里，你可以用&lt;&lt;&gt;&gt;来定义一个二进制数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">iex&gt; byte_size(&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>一个二进制数据是一个字节的序列。这些字节可以用任何方式来组织，甚至这些字节序列不是有效的字符串：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.valid?(&lt;&lt;<span class="number">239</span>, <span class="number">191</span>, <span class="number">191</span>&gt;&gt;)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>字符串的串联操作实际上是二进制数据的串联操作：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>&gt;&gt; &lt;&gt; &lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>在Elixir里的一个通用技巧是将空字节&lt;<0>&gt;串联在一个字符串后以便看看它内部的二进制表示：</0></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hełło"</span> &lt;&gt; &lt;&lt;<span class="number">0</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">104</span>, <span class="number">101</span>, <span class="number">197</span>, <span class="number">130</span>, <span class="number">197</span>, <span class="number">130</span>, <span class="number">111</span>, <span class="number">0</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>赋给一个二进制数据的每一个数字都表示一个字节，由此它的值最大是255。二进制数据允许给定修饰语来存储大于255的数字，或者转换一个代码点为它的UTF-8编码表示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">255</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">255</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span>&gt;&gt; # truncated</div><div class="line">&lt;&lt;<span class="number">0</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: size(<span class="number">16</span>)&gt;&gt; # use <span class="number">16</span> bits (<span class="number">2</span> bytes) to store the number</div><div class="line">&lt;&lt;<span class="number">1</span>, <span class="number">0</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: utf8&gt;&gt; # the number is a code point</div><div class="line"><span class="string">"Ā"</span></div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: utf8, <span class="number">0</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">196</span>, <span class="number">128</span>, <span class="number">0</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>如果一个字节有8位，那么我们只给它一位会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">1</span>::size(<span class="number">1</span>)&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">2</span> :: size(<span class="number">1</span>)&gt;&gt; # truncated</div><div class="line">&lt;&lt;<span class="number">0</span>::size(<span class="number">1</span>)&gt;&gt;</div><div class="line">iex&gt; is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; is_bitstring(&lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; bit_size(&lt;&lt; <span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>结果是这个值不再是一个二进制数据，而是一个位串 – 一些位。所以一个二进制数据是一个位串，它的位的数量被8整除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt;  is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">16</span>)&gt;&gt;)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt;  is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">15</span>)&gt;&gt;)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>我们也可以在二进制数据或位串上进行模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&gt;</div><div class="line">iex&gt; x</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>注意：在二进制模式中的每一个元素都被期望刚好匹配8位。如果我们想要匹配一个未知大小的二进制数据，在模式的尾部通过使用二进制数据修饰语是可能做到的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x :: binary&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">iex&gt; x</div><div class="line">&lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>相似的结果可以用字符串串联符&lt;&gt;来实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"he"</span> &lt;&gt; rest = <span class="string">"hello"</span></div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; rest</div><div class="line"><span class="string">"llo"</span></div></pre></td></tr></table></figure>
<p>关于二进制数据或位串的构造器&lt;&lt;&gt;&gt;的完整指导可以在<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1" target="_blank" rel="external">Elixir官方文档</a>里找到。到此，我们结束了位串，二进制数据和字符串之旅。字符串是UTF-8编码的二进制数据；二进制数据是位串，它的位的数量被8整除。虽然这表明Elixir提供了处理位和字节的灵活性，不过你的99%的时间将用来处理二进制数据，并且使用 is_binary/1 和 byte_size/1 函数。</p>
<h1 id="字符列表"><a href="#字符列表" class="headerlink" title="字符列表"></a><span id="part-three">字符列表</span></h1><p>一个字符列表就是一个代码点列表。字符列表可以用单引号括起来的字符字面值创建：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; 'hełło'</div><div class="line">[<span class="number">104</span>, <span class="number">101</span>, <span class="number">322</span>, <span class="number">322</span>, <span class="number">111</span>]</div><div class="line">iex&gt; is_list 'hełło'</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; 'hello'</div><div class="line">'hello'</div><div class="line">iex&gt; List.first('hello')</div><div class="line"><span class="number">104</span></div></pre></td></tr></table></figure>
<p>你可以看到，不是包含字节，一个字符列表包含单引号之间的字符的代码点（注意：默认情况下如果任何整数值在ASCII范围外，则IEx将只是输出代码点）。那么，双引号表示字符串（即二进制数据），单引号表示字符列表（即列表）。</p>
<p>在实践中，字符列表主要用于与Erlang交互的时候，特别是不接受二进制数据作为参数的旧库。你可以用 to_charlist/1 和 to_string/1 函数来转换字符列表为字符串或者反之将字符串转换为字符列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_charlist <span class="string">"hełło"</span></div><div class="line">[<span class="number">104</span>, <span class="number">101</span>, <span class="number">322</span>, <span class="number">322</span>, <span class="number">111</span>]</div><div class="line">iex&gt; to_string 'hełło'</div><div class="line"><span class="string">"hełło"</span></div><div class="line">iex&gt; to_string :hello</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; to_string <span class="number">1</span></div><div class="line"><span class="string">"1"</span></div></pre></td></tr></table></figure>
<p>注意：这些函数是多态的。它们不仅可以转换字符列表为字符串，也可以转换整数为字符串，转换原子为字符串，等等。</p>
<p>介绍完二进制数据，字符串和字符列表，接下来是时候讲讲键值对数据结构了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－case，cond 和 if]]></title>
      <url>http://szpzs.oschina.io/2017/01/31/elixir-getting-started-case-cond-and-if/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">case</a></li>
<li><a href="#part-two">卫语句里的表达式</a></li>
<li><a href="#part-three">cond</a></li>
<li><a href="#part-four">if 和 unless</a></li>
<li><a href="#part-five">do/end 块</a></li>
</ol>
<p>在本章，我们将学习 case，cond 和 if 这几个控制流结构。</p>
<a id="more"></a>
<h1 id="case"><a href="#case" class="headerlink" title="case"></a><span id="part-one">case</span></h1><p>case允许我们将一个值和许多模式进行比较直到我们找到一个匹配的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; do</div><div class="line">...&gt;   &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; -&gt;</div><div class="line">...&gt;     <span class="string">"This clause won't match"</span></div><div class="line">...&gt;   &#123;<span class="number">1</span>, x, <span class="number">3</span>&#125; -&gt;</div><div class="line">...&gt;     <span class="string">"This clause will match and bind x to 2 in this clause"</span></div><div class="line">...&gt;   _ -&gt;</div><div class="line">...&gt;     <span class="string">"This clause would match any value"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This clause will match and bind x to 2 in this clause"</span></div></pre></td></tr></table></figure>
<p>如果你想模式匹配已经存在的变量，你需要使用 ^ 运算符：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="keyword">case</span> <span class="number">10</span> do</div><div class="line">...&gt;   ^x -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt;   _  -&gt; <span class="string">"Will match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Will match"</span></div></pre></td></tr></table></figure>
<p>分支语句也允许用卫语句来指定额外的条件：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; do</div><div class="line">...&gt;   &#123;<span class="number">1</span>, x, <span class="number">3</span>&#125; <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Will match"</span></div><div class="line">...&gt;   _ -&gt;</div><div class="line">...&gt;     <span class="string">"Would match, if guard condition were not satisfied"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Will match"</span></div></pre></td></tr></table></figure>
<p>上例中第一个分支语句仅在x大于零的时候才被匹配上。</p>
<h1 id="卫语句里的表达式"><a href="#卫语句里的表达式" class="headerlink" title="卫语句里的表达式"></a><span id="part-two">卫语句里的表达式</span></h1><p>Elixir默认导入和允许下述表达式在卫语句里：</p>
<ul>
<li>比较运算符（==，!=，===，!==，&gt;， &gt;=， &lt;， &lt;=）</li>
<li>布尔运算符（and，or，not）</li>
<li>算术运算符（+， -， *， /）</li>
<li>一元算术运算符（+， -）</li>
<li>二进制数据串联运算符 &lt;&gt;</li>
<li>in 运算符，只要它右边是一个范围或者一个列表</li>
<li><p>所有下述类型检查函数：</p>
<pre><code>* is_atom/1
* is_binary/1
* is_bitstring/1
* is_boolean/1
* is_float/1
* is_function/1
* is_function/2
* is_integer/1
* is_list/1
* is_map/1
* is_nil/1
* is_number/1
* is_pid/1
* is_port/1
* is_reference/1
* is_tuple/1
</code></pre></li>
<li><p>加上下面的函数</p>
<pre><code>* abs(number)
* binary_part(binary, start, length)
* bit_size(bitstring)
* byte_size(bitstring)
* div(integer, integer)
* elem(tuple, n)
* hd(list)
* length(list)
* map_size(map)
* node()
* node(pid | ref | port)
* rem(integer, integer)
* round(number)
* self()
* tl(list)
* trunc(number)
* tuple_size(tuple)
</code></pre></li>
</ul>
<p>另外，用户可以定义他们自己的卫语句。例如，Bitwise模块定义作为函数和运算符的卫语句：bnot，~~~，band，&amp;&amp;&amp;，bor，|||，bxor，^^^，bsl，&lt;&lt;&lt;，bsr，&gt;&gt;&gt;。</p>
<p>注意，虽然布尔运算符，比如：and，or 和 not 运行在卫语句里使用，但是更加通用的运算符 &amp;&amp;，|| 和 ! 却不被允许在卫语句里使用。</p>
<p>切记：卫语句里的错误不会被抛出，而是使得卫语句失败：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; hd(<span class="number">1</span>)</div><div class="line">** (ArgumentError) argument error</div><div class="line">iex&gt; <span class="keyword">case</span> <span class="number">1</span> do</div><div class="line">...&gt;   x <span class="keyword">when</span> hd(x) -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt;   x -&gt; <span class="string">"Got #&#123;x&#125;"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got 1"</span></div></pre></td></tr></table></figure>
<p>如果没有一个分支匹配，则有错误抛出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> :ok do</div><div class="line">...&gt;   :error -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CaseClauseError) no <span class="keyword">case</span> clause matching: :ok</div></pre></td></tr></table></figure>
<p>注意：匿名函数也可以有多个分支和卫语句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; f = fn</div><div class="line">...&gt;   x, y <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt; x + y</div><div class="line">...&gt;   x, y -&gt; x * y</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">12.71889879</span>/<span class="number">2</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; f.(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line"><span class="number">4</span></div><div class="line">iex&gt; f.(-<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">-3</div></pre></td></tr></table></figure>
<p>匿名函数每个分支的入参格式必须相同，否则有错误抛出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; f2 = fn</div><div class="line">...&gt;   x, y <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt; x + y</div><div class="line">...&gt;   x, y, z -&gt; x * y + z</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) iex:<span class="number">1</span>: cannot mix clauses with different arities in function definition</div></pre></td></tr></table></figure>
<h1 id="cond"><a href="#cond" class="headerlink" title="cond"></a><span id="part-three">cond</span></h1><p>当你要匹配不同的值的时候，case语句有用。然而，在许多情况中，我们想要检查不同的条件并且找到第一个为true的条件。在这样的场景下，可以使用cond：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This will not be true"</span></div><div class="line">...&gt;   <span class="number">2</span> * <span class="number">2</span> == <span class="number">3</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Nor this"</span></div><div class="line">...&gt;   <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> -&gt;</div><div class="line">...&gt;     <span class="string">"But this will"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"But this will"</span></div></pre></td></tr></table></figure>
<p>这和许多命令式语言里的 else if 分支等效（虽然不常在这里使用的方法）。</p>
<p>如果没有一个条件返回true，则一个错误（CondClauseError）被抛出。因为这个原因，增加一个最后条件，它等于true，这个条件将总是可以匹配到，这样的做法可能是必要的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This is never true"</span></div><div class="line">...&gt;   <span class="number">2</span> * <span class="number">2</span> == <span class="number">3</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Nor this"</span></div><div class="line">...&gt;   <span class="literal">true</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This is always true (equivalent to else)"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This is always true (equivalent to else)"</span></div></pre></td></tr></table></figure>
<p>最后，要注意：cond认为除nil和false外，任何值都是true：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   hd([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) -&gt;</div><div class="line">...&gt;     <span class="string">"1 is considered as true"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"1 is considered as true"</span></div></pre></td></tr></table></figure>
<h1 id="if-和-unless"><a href="#if-和-unless" class="headerlink" title="if 和 unless"></a><span id="part-four">if 和 unless</span></h1><p>除了case和cond，Elixir也提供宏：if/2 和 unless/2 ，它们在你需要仅仅检查一个条件的时候很有用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;   <span class="string">"This works!"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This works!"</span></div><div class="line">iex&gt; unless <span class="literal">true</span> do</div><div class="line">...&gt;   <span class="string">"This will never be seen"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">nil</div></pre></td></tr></table></figure>
<p>如果给予if/2的条件返回false或nil，则do/end之间的语句不会被执行，并且if/2的整体返回值是nil。unless/2的情况则相反。</p>
<p>它们也支持else块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> nil do</div><div class="line">...&gt;   <span class="string">"This won't be seen"</span></div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="string">"This will"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This will"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：一个关于if/2和unless/2的有趣的注意事项是在Elixir里它们被实现为宏；它们不像在其他语言那样是一个特殊的语言结构。你可以参阅官方文档和<a href="https://hexdocs.pm/elixir/Kernel.html" target="_blank" rel="external">Kernel模块的文档</a>中if/2的说明。Kernel模块里也定义了像+/2这样的运算符和像is_function/2这样的函数，这些函数都默认地被自动导入并在你的代码中可用。</p>
</blockquote>
<h1 id="do-end块"><a href="#do-end块" class="headerlink" title="do/end块"></a><span id="part-five">do/end块</span></h1><p>到此，我们已经学了四种控制结构：case、cond、if 和 unless ，它们都包裹在 do/end 块里。我们也可以像下面这样写 if 控制结构：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span>, do: <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>注意上面的例子在 true 和 do: 之间有一个逗号，这是因为它使用了Elixir的正规语法，每个参数用逗号分割。我们说这个语法是用<em>关键字列表</em>。我们也可以传递 else 使用关键字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">false</span>, do: :this, else: :that</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>do/end是构建于关键字上的语法便利措施。这就是为什么在前面的参数和语句块之间不需要逗号。它的确非常有用，因为当写代码块的时候它删除了冗余。下面的例子是等效的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;   a = <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt;   a + <span class="number">10</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">13</span></div><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span>, do: (</div><div class="line">...&gt;   a = <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt;   a + <span class="number">10</span></div><div class="line">...&gt; )</div><div class="line"><span class="number">13</span></div></pre></td></tr></table></figure>
<p>有一件事要记住，当你使用do/end的时候，它们总是和最外层函数调用绑定的。例如，下面的表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) undefined function: is_number/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>将被解析为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number(<span class="keyword">if</span> <span class="literal">true</span>) do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) undefined function: is_number/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>这将导致一个未定义函数错误，因为这个调用传递两个参数，而 is_number/2 并不存在。if true 表达式在这里是无效的，因为它需要代码块；而因为 is_number/2 的参数个数不匹配，Elixir根本就没有调用到它。</p>
<p>增加明确的括号就足以绑定代码块到 if ：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number(<span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>关键字列表Elixir里扮演很重要的角色，并且在许多函数和宏里普遍存在。在后续的章节里我们将进一步探索它们。接下来，我们讨论“二进制、字符串和字符列表”。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/case-cond-and-if.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/case-cond-and-if.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－模式匹配]]></title>
      <url>http://szpzs.oschina.io/2017/01/30/elixir-getting-started-pattern-matching/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">匹配运算符</a></li>
<li><a href="#part-two">模式匹配</a></li>
<li><a href="#part-three">pin运算符</a></li>
</ol>
<p>在本章，我们将展示给大家 = 运算符在Elixir里如何实际上是一个匹配运算符的以及如何用它来模式匹配数据结构里的数据。最后，我们将学习pin运算符 ^，它被用来访问变量之前被绑定的值。</p>
<a id="more"></a>
<h1 id="匹配运算符"><a href="#匹配运算符" class="headerlink" title="匹配运算符"></a><span id="part-one">匹配运算符</span></h1><p>我们已经用过几次 = 运算符在Elixir里给变量赋值：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; x</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>在Elixir里，= 运算符实际上被称为<em>匹配运算符</em>。让我们来看看究竟：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> = x</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="number">2</span> = x</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们注意到 1 = x 是一个有效表达式，而它匹配的原因是因为左右两边都等于1。当两边不匹配的时候，一个MatchError错误抛出。</p>
<p>变量被赋值的时候只能够处于 = 运算符的左边：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> = unknown</div><div class="line">** (CompileError) iex:<span class="number">1</span>: undefined function unknown/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>因为之前没有定义unknown变量，Elixir就假设你是想尝试调用 unknown/0 这个函数，但是这样的函数并不存在。</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a><span id="part-two">模式匹配</span></h1><p>匹配运算符不仅是用来匹配简单的值，而且对于解构更复杂的数据类型也是有用的。例如，我们可以在元组上进行模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = &#123;:hello, <span class="string">"world"</span>, <span class="number">42</span>&#125;</div><div class="line">&#123;:hello, <span class="string">"world"</span>, <span class="number">42</span>&#125;</div><div class="line">iex&gt; a</div><div class="line">:hello</div><div class="line">iex&gt; b</div><div class="line"><span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>在两边不匹配的情况下模式匹配将出错。例如下面的例子，当元组有不同的大小的时候：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = &#123;:hello, <span class="string">"world"</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;:hello, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>或者两边的数据类型不一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = [:hello, <span class="string">"world"</span>, <span class="number">42</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [:hello, <span class="string">"world"</span>, <span class="number">42</span>]</div></pre></td></tr></table></figure>
<p>更有趣地是，我们可以在指定的值上进行匹配。比如下面的例子就断言当右边是一个以原子 :ok 开始的元组的时候左边才和右边匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;:ok, result&#125; = &#123;:ok, <span class="number">13</span>&#125;</div><div class="line">&#123;:ok, <span class="number">13</span>&#125;</div><div class="line">iex&gt; result</div><div class="line"><span class="number">13</span></div><div class="line"></div><div class="line">iex&gt; &#123;:ok, result&#125; = &#123;:error, :oops&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;:error, :oops&#125;</div></pre></td></tr></table></figure>
<p>我们也可以在列表上模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>列表也支持匹配它的头部和尾部：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; [head | tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; head</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; tail</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>像 hd/1 和 tl/1 函数一样，我们不能用一个头部和尾部的模式来匹配一个空列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; [h | t] = []</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: []</div></pre></td></tr></table></figure>
<p>[head | tail] 格式不仅用在模式匹配而且也可以用在给列表加元素上：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; [<span class="number">0</span> | list]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>模式匹配允许开发者很容易地解构诸如元组和列表这样的数据类型。正如我们将在接下来的章节看到的，这是Elixir递归的基础之一，并且也应用于像map和二进制数据等其他类型。</p>
<h1 id="pin运算符"><a href="#pin运算符" class="headerlink" title="pin运算符"></a><span id="part-three">pin运算符</span></h1><p>Elixir的变量可以重新绑定：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; x = <span class="number">2</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>当你想模式匹配已经存在的变量的值而不是重新绑定这个变量的时候，pin运算符 ^ 就有用处了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; ^x = <span class="number">2</span></div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: <span class="number">2</span></div><div class="line">iex&gt; &#123;y, ^x&#125; = &#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">iex&gt; y</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; &#123;y, ^x&#125; = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>因为我们已经将1赋值给变量x，上述最后一个表达式也可以写成下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;y, <span class="number">1</span>&#125; = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>如果一个变量在一个模式里出现了不止一次，则所有对它的引用都应该绑定到相同的模式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;x, x&#125; = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">iex&gt; &#123;x, x&#125; = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>在一些场景里，你不关心模式里的某个特别的值。通用的做法是将这些值绑定到下划线，_ 。例如，如果仅是列表头部是我们需要的，我们可以将尾部赋给下划线：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [h | _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; h</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>变量 _ 在这里很特别，它永远不会被读取。如果尝试取读取它，会得到一个 未绑定变量 的错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; _</div><div class="line">** (CompileError) iex:<span class="number">1</span>: unbound variable _</div></pre></td></tr></table></figure>
<p>虽然模式匹配允许我们构建非常有用的结构，但是它的用法是有限制的。例如，你不能在匹配的左边调用函数。下面的例子就是无效的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; length([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]) = <span class="number">3</span></div><div class="line">** (CompileError) iex:<span class="number">1</span>: illegal pattern</div></pre></td></tr></table></figure>
<p>到此就完成了我们的模式匹配介绍。正如我们将在下一章看到的，模式匹配在Elixir的许多语言构造里是非常普遍的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="">http://elixir-lang.org/getting-started/pattern-matching.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－基本运算符]]></title>
      <url>http://szpzs.oschina.io/2017/01/29/elixir-getting-started-basic-operators/</url>
      <content type="html"><![CDATA[<p>在<a href="http://elixir-lang.org/getting-started/basic-types.html" target="_blank" rel="external">前面的章节</a>，我们看到Elixir提供了 +，-，*，/ 4个算术运算符，另外还有整数的除法和取余的两个函数 div/2 和 rem/2 。</p>
<a id="more"></a>
<p>Elixir也提供了 ++ 和 - - 来操作列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ++ [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -- [<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>用 &lt;&gt; 把两个字符串串联起来：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"foo"</span> &lt;&gt; <span class="string">"bar"</span></div><div class="line"><span class="string">"foobar"</span></div></pre></td></tr></table></figure>
<p>Elixir也提供三个布尔运算符：or，and 和 not 。这些运算符严格要求布尔类型数据（true或false）作为它的第一个参数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="literal">false</span> or is_atom(:example)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>如果参数不是布尔型数据则会引起异常：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> <span class="keyword">and</span> <span class="literal">true</span></div><div class="line">** (ArgumentError) argument error: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>or和and都是短路运算符。如果左边不足以决定结果则它们才会执行右边的表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">false</span> <span class="keyword">and</span> raise(<span class="string">"This error will never be raised"</span>)</div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; <span class="literal">true</span> or raise(<span class="string">"This error will never be raised"</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你是Erlang开发者，Elixir的 and 和 or 的确和Erlang里的 andalso 和 orelse 运算符相互映射影射。</p>
</blockquote>
<p>除了这几个布尔运算符，Elixir还提供可以接收任何类型参数的 || ，&amp;&amp; 和 ！。对于这几个运算符，除了 false 和 nil 其他所有值都被认为是true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># or</div><div class="line">iex&gt; <span class="number">1</span> || <span class="literal">true</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="literal">false</span> || <span class="number">11</span></div><div class="line"><span class="number">11</span></div><div class="line"></div><div class="line"># <span class="keyword">and</span></div><div class="line">iex&gt; nil &amp;&amp; <span class="number">13</span></div><div class="line">nil</div><div class="line">iex&gt; <span class="literal">true</span> &amp;&amp; <span class="number">17</span></div><div class="line"><span class="number">17</span></div><div class="line"></div><div class="line"># !</div><div class="line">iex&gt; !<span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; !<span class="number">1</span></div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; !nil</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>根据经验，当你想要布尔值的时候就用and，or 和 not。如果有任何参数是非布尔值，则用&amp;&amp;，|| 和 ！。</p>
<p>Elixir也提供 ==，!=，===，!==，&lt;=，&gt;=，&lt; 和 &gt; 作为比较运算符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> == <span class="number">1</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> != <span class="number">2</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> &lt; <span class="number">2</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>== 和 === 不同之处在于，后者在比较整数和浮点数的时候更严格。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> == <span class="number">1.0</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> === <span class="number">1.0</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>在Elixir里，我们可以比较两个不同的数据类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> &lt; :atom</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们可以比较不同数据类型的原因是出于实用主义的考虑。排序算法不需要担心不同数据类型之间的排序问题。全部的排序顺序定义如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring</div></pre></td></tr></table></figure>
<p>你完全不需要记住这个顺序，只需要知道有这个顺序存在就足够了。</p>
<p>有关运算符（和排序）的参考信息，请查阅 <a href="http://elixir-lang.org/docs/master/elixir/operators.html" target="_blank" rel="external">运算符手册页面</a> 。</p>
<p>在下一章，我们将讨论一些基础函数，数据类型转换以及一些控制流。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/basic-operators.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/basic-operators.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－基本类型]]></title>
      <url>http://szpzs.oschina.io/2017/01/28/elixir-getting-started-basic-types/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#part-one">基本算术运算</a></li>
<li><a href="#part-two">布尔类型</a></li>
<li><a href="#part-three">原子</a></li>
<li><a href="#part-four">字符串</a></li>
<li><a href="#part-five">匿名函数</a></li>
<li><a href="#part-six">(链接) 列表</a></li>
<li><a href="#part-seven">元组</a></li>
<li><a href="#part-eight">列表还是元组？</a></li>
</ol>
<a id="more"></a>
<p>本章我们将学习更多Elixir的基本数据类型：整数、浮点数、布尔值、原子、字符串、列表和元组。一些基本类型数据如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>          # 整数</div><div class="line">iex&gt; <span class="number">0</span>x1F       # 整数</div><div class="line">iex&gt; <span class="number">1.0</span>        # 浮点数</div><div class="line">iex&gt; <span class="literal">true</span>       # 布尔值</div><div class="line">iex&gt; :atom      # 原子 / 符号</div><div class="line">iex&gt; <span class="string">"elixir"</span>   # 字符串</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  # 列表</div><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  # 元组</div></pre></td></tr></table></figure>
<h1 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a><span id="part-one">基本算术运算</span></h1><p>打开 iex 输入如下表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; <span class="number">5</span> * <span class="number">5</span></div><div class="line"><span class="number">25</span></div><div class="line">iex&gt; <span class="number">10</span> / <span class="number">2</span></div><div class="line"><span class="number">5.0</span></div></pre></td></tr></table></figure>
<p>我们注意到 10 / 2 返回了一个浮点数5.0而不是整数5。这是正常的。在Elixir里，运算符 / 总是返回浮点数。如果你想要做整数除法或者想得到除法的余数，你可以调用 div 和 rem 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">div</span>(<span class="number">10</span>, <span class="number">2</span>)</div><div class="line"><span class="number">5</span></div><div class="line">iex&gt; <span class="keyword">div</span> <span class="number">10</span>, <span class="number">2</span></div><div class="line"><span class="number">5</span></div><div class="line">iex&gt; <span class="keyword">rem</span> <span class="number">10</span>, <span class="number">3</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>注意！Elixir允许你在调用一个命名函数时候省略圆括号。这个特性使得当你写声明和控制流结构的时候由更加简洁的语法。</p>
<p>Elixir也支持快捷符号来输入二进制、八进制以及十六进制数字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">0</span>b1010</div><div class="line"><span class="number">10</span></div><div class="line">iex&gt; <span class="number">0</span>o777</div><div class="line"><span class="number">511</span></div><div class="line">iex&gt; <span class="number">0</span>x1F</div><div class="line"><span class="number">31</span></div></pre></td></tr></table></figure>
<p>浮点数最少要求小数点后有一位数字，并且也支持用e符号表达式表示指数数字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1.0</span></div><div class="line"><span class="number">1.0</span></div><div class="line">iex&gt; <span class="number">1.0e-10</span></div><div class="line"><span class="number">1.0e-10</span></div></pre></td></tr></table></figure>
<p>在Elixir里浮点数是64位双精度。</p>
<p>你可以调用 round 函数获得与给定的浮点数最接近的整数，或者调用 trunc 函数获得一个浮点数的整数部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; round(<span class="number">3.58</span>)</div><div class="line"><span class="number">4</span></div><div class="line">iex&gt; trunc(<span class="number">3.58</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<h2 id="识别函数"><a href="#识别函数" class="headerlink" title="识别函数"></a>识别函数</h2><p>Elixir里的函数是通过它的名字和函数参数个数来区分的。函数的arity指的是函数的参数个数。从这一点上，我们将在整个文档里使用的函数的名称和它的参数个数来描述函数。round/1 确定函数的名字是round，参数个数是1，而 round/2 确定一个不同（其实是不存在的）的函数，相同的名字，参数个数是2。</p>
<h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><span id="part-two">布尔类型</span></h1><p>Elixir支持 true 和 false 为布尔值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="literal">true</span> == <span class="literal">false</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>Elixir提供很多断言函数来检查一个值的类型。例如，is_boolean/2 函数可以用来检查一个值是不是布尔类型。</p>
<p>注：Elixir的函数是通过函数名和参数个数（即arity）来区分的。因此，is_boolean/1 表示函数名是is_boolean而且有一个入参。is_boolean/2 （其实并不存在这个函数）表示有相同的函数名却有不同的arity的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_boolean(<span class="literal">true</span>)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_boolean(<span class="number">1</span>)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>如果入参是一个整数、一个浮点数或者其他数字，你也可以分别用 is_integer/1，is_float/1或is_number/1来检查。</p>
<blockquote>
<p>注：在任何时候，你可以在shell里输入 h() 来打印如何使用shell的信息。这个 h 帮助者也可以用来访问任何函数的文档。例如，输入 h is_integer/1 将打印 is_integer/1 函数的文档。它也可以运用在操作符和其他结构上（试一下 h ==/2）。</p>
</blockquote>
<h1 id="原子"><a href="#原子" class="headerlink" title="原子"></a><span id="part-three">原子</span></h1><p>原子是常量，它们名字就是它们自己的值。其他语言里叫这种数据类型为符号：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; :hello</div><div class="line">:hello</div><div class="line">iex&gt; :hello == :world</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>布尔值 true 和 false 实际上是原子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span> == :<span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_atom(<span class="literal">false</span>)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_boolean(:<span class="literal">false</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span id="part-four">字符串</span></h1><p>在Elixir里，字符串被包裹在两个双引号中，并且它们被用UTF-8来编码的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hellö"</span></div><div class="line"><span class="string">"hellö"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你在Windows中，你的终端可能默认就不用UTF-8编码。你可以通过在输入IEx前运行chcp 56001来改变当前会话的编码。</p>
</blockquote>
<p>Elixir也支持字符串插入：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hellö #&#123;:world&#125;"</span></div><div class="line"><span class="string">"hellö world"</span></div></pre></td></tr></table></figure>
<p>字符串内可以有换行符。你可以用转义字符引入它们。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; "hello</div><div class="line">...&gt; world"</div><div class="line">"hello\nworld"</div><div class="line">iex&gt; "hello\nworld"</div><div class="line">"hello\nworld"</div></pre></td></tr></table></figure>
<p>你可以用IO模块内的函数IO.puts/1来打印一个字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">"hello\nworld"</span></div><div class="line">hello</div><div class="line">world</div><div class="line">:ok</div></pre></td></tr></table></figure>
<p>注意：IO.puts/1函数在打印字符串后返回原子 :ok 作为结果。</p>
<p>在Elixir内部字符串是用一组字节组成的二进制数据来表示的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_binary(<span class="string">"hellö"</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们也可以获得一个字符串内的字节数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; byte_size(<span class="string">"hellö"</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们注意到上述例子的字符串的字节数是6，即使它只有5个字符。这是因为字符 “ö” 用UTF-8来编码的时候占用了两个字节。我们可以通过用String.length/1函数来基于字符数获得字符串的实际长度。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.length(<span class="string">"hellö"</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p><a href="https://hexdocs.pm/elixir/String.html" target="_blank" rel="external">String模块</a>包含了一些操作以Unicode标准定义的字符串的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.upcase(<span class="string">"hellö"</span>)</div><div class="line"><span class="string">"HELLÖ"</span></div></pre></td></tr></table></figure>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><span id="part-five">匿名函数</span></h1><p>匿名函数可以在行内被创建，并且它是被关键字fn和end界定的函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; add = fn a, b -&gt; a + b <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">12.71889879</span>/<span class="number">2</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; add.(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; is_function(add)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_function(add, <span class="number">2</span>) #检查add是否是一个有两个参数的函数</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_function(add, <span class="number">1</span>) #检查add是否是一个有一个参数的函数</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>函数在Elixir里是“一等公民”，这意味着它跟整数和字符串一样可以被当作参数传给其他函数。上述例子，我们把持有函数的变量add传给函数is_function/1，得到了正确的结果 true。我们也能够通过调用is_function/2来检查这个函数的参数个数。</p>
<p>注意：在变量和圆括号之间的 点 号（.）在调用一个匿名函数的时候是必须存在的。这个点号确定在调用匿名函数add和命名函数add/2的时候没有歧义。在这个意义上，Elixir使匿名函数和函数名之间有明显的区别。我们将在<a href="http://elixir-lang.org/getting-started/modules.html" target="_blank" rel="external">第八章</a>来看看那些区别。</p>
<p>匿名函数都是闭包，因此它可以访问那些和函数定义在一个范围内的变量。让我们定义一个新的匿名函数，它使用我们前面已经定义的匿名函数的变量add：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; double = fn a -&gt; add.(a, a) <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">6.71889879</span>/<span class="number">1</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; double.(<span class="number">2</span>)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>记住：一个变量在一个函数里被赋值不会影响它周围的环境：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">42</span></div><div class="line"><span class="number">42</span></div><div class="line">iex&gt; (fn -&gt; x = <span class="number">0</span> <span class="keyword">end</span>).()</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; x</div><div class="line"><span class="number">42</span></div></pre></td></tr></table></figure>
<h1 id="（链接）列表"><a href="#（链接）列表" class="headerlink" title="（链接）列表"></a><span id="part-six">（链接）列表</span></h1><p>Elixir用方括号来指定一个若干值组成的列表。这些值可以是任何类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">3</span>]</div><div class="line">iex&gt; length [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>两个列表可以用 ++/2 和 - -/2 操作符来串联和相减：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ++ [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">false</span>, <span class="number">3</span>, <span class="literal">true</span>] -- [<span class="literal">true</span>, <span class="literal">false</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">true</span>]</div></pre></td></tr></table></figure>
<p>在本教材中，我们将谈论很多关于列表的头部和尾部的事情。头部是一个列表的第一个元素而尾部则是剩下的部分。它们可以用函数 hd/1 和 tl/1 来获取。让我们将一个列表赋给一个变量然后获取它的头部和尾部：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; hd(list)</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; tl(list)</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>尝试获取一个空列表的头部或尾部会发生一个错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; hd []</div><div class="line">** (ArgumentError) argument error</div></pre></td></tr></table></figure>
<p>有时候你创建一个列表，返回来的是一个用单引号括起来的值。比如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</div><div class="line">'\v\f\r'</div><div class="line">iex&gt; [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]</div><div class="line">'hello'</div></pre></td></tr></table></figure>
<p>当Elixir遇到一个由可打印的ASCII码组成的列表，Elixir将把它当作字符列表打印出来（字面上的字符列表）。当和Erlang代码交互的时候字符列表十分常见。任何时候，当你在Elixir里遇到一个值而你不能十分确定它的类型的时候，你可以用 i/1 函数来获得它的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; i 'hello'</div><div class="line">Term</div><div class="line">  'hello'</div><div class="line">Data type</div><div class="line">  List</div><div class="line">Description</div><div class="line">  ...</div><div class="line">Raw representation</div><div class="line">  [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]</div><div class="line">Reference modules</div><div class="line">  List</div></pre></td></tr></table></figure>
<p>记住：单引号括住的值和双引号括住的值在Elixir里是不想等的，因为它们表示不同的类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; 'hello' == <span class="string">"hello"</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>单引号的是字符列表，双引号的是字符串。我们将在“<a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" target="_blank" rel="external">二进制，字符串和字符列表</a>”章节中详细讨论它们。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a><span id="part-seven">元组</span></h1><p>Elixir用大括号来定义元组。和列表一样，元组可以持有任何类型的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; tuple_size &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>元组会连续将元素存储在内存中。这意味着通过索引访问一个元组的元素或获取元组的大小是一个快速的操作。索引从零开始：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; elem(tuple, <span class="number">1</span>)</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; tuple_size(tuple)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>用函数 put_elem/3 放置一个元素到一个元组的指定的索引位置也是可能的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; put_elem(tuple, <span class="number">1</span>, <span class="string">"world"</span>)</div><div class="line">&#123;:ok, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; tuple</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div></pre></td></tr></table></figure>
<p>注意：put_elem/3 返回了一个新的元组。原来存储在tuple变量里的元组没有被修改，因为Elixir的数据类型是不可修改的。由于是不可修改的，Elixir代码更容易推导，因为你永远不用担心是否有特别的代码正在某处修改你的数据结构。</p>
<h1 id="列表还是元组"><a href="#列表还是元组" class="headerlink" title="列表还是元组"></a><span id="part-eight">列表还是元组</span></h1><p>列表和元组有何不同？</p>
<p>列表在内存中就如链接列表，意味着列表中的每一个元素持有它的值和指向后继元素的指针，如此一直到列表的尾部。我们称每一个值和指针对是一个 cons cell：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span> | [<span class="number">2</span> | [<span class="number">3</span> | []]]]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>这意味着访问列表的长度是一个线性操作：我们需要遍历整改列表来计算它的长度。只要我们在列表前面加元素则更新列表是快速的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">0</span> | list]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>相反，元组在内存中连续存储。这意味着获取元组的长度和通过索引获取元素是快速的。然而，元组的修改或增加是昂贵的操作，因为它需要在内存中拷贝整个元组。</p>
<p>这些性能特性决定了两类数据结构的用法。元组的一种非常通用的使用场景是用它们从函数返回额外的信息。例如：File.read/1 是一个可以用来读取文件内容的函数，而它返回的是元组：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read(<span class="string">"path/to/existing/file"</span>)</div><div class="line">&#123;:ok, <span class="string">"... contents ..."</span>&#125;</div><div class="line">iex&gt; File.read(<span class="string">"path/to/unknown/file"</span>)</div><div class="line">&#123;:error, :enoent&#125;</div></pre></td></tr></table></figure>
<p>如果传给File.read/1的路径存在，它返回一个元组，第一个元素是原子 :ok，第一个元素是文件内容。否则，它返回一个由原子 :error 和错误描述组成的元组。</p>
<p>大多数时候，Elixir会引导你做正确的事情。例如，有一个函数 elem/2 用来访问元组元素的，而对于列表则没有对应的内建函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; elem(tuple, <span class="number">1</span>)</div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>当计算一个数据结构的元素个数的时候，Elixir也遵从一个简单的规则：如果这个操作是在常数时间内的（即是该值是预先计算的）则这个函数命名为szie；或者，如果这个操作是线性的（即是计算长度随着输入数据的增长而越来越慢）则这个函数命名为length。为便于记忆，“长度”和“线性”都是“l”字母开始的。</p>
<p>例如，我们目前已经用过4个计算函数：byte_size/1 （计算字符串的字节数），tuple_size/1 （计算元组大小），length/1 （计算列表长度）以及 String.length/1（计算字符串的字符个数）。也就是说，我们用 byte_size 来获取字符串的字节数是廉价操作，但是用 String.length 获取unicode字符的个数可能是昂贵的操作因为整个字符串需要被遍历。</p>
<p>Elixir也提供 Port，Reference和PID作为数据类型（它们通常用于进程间通信），当我们讨论进程的时候将快速浏览它们一下。接下来，让我们看看在我们基本类型上的一些基本操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/basic-types.html#identifying-functions" target="_blank" rel="external">http://elixir-lang.org/getting-started/basic-types.html#identifying-functions</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elixir入门教程－介绍]]></title>
      <url>http://szpzs.oschina.io/2017/01/27/elixir-getting-started-introduction/</url>
      <content type="html"><![CDATA[<p>欢迎你的到来！</p>
<p>本教程我们将教你Elixir的基础，语言的语法，如何定义模块，如何处理常见的数据结构和更多的特点。本章将聚焦在确保Elixir已经安装并且你能够成功地运行Elixir的交互Shell，即IEx。</p>
<a id="more"></a>
<p>我们的必要条件是：</p>
<ul>
<li>Elixir － 版本至少是1.4.0</li>
<li>Erlang － 版本至少是18.0</li>
</ul>
<p>让我们开始吧！</p>
<blockquote>
<p>如果你在本教程或本网站上发现任何错误，<a href="https://github.com/elixir-lang/elixir-lang.github.com" target="_blank" rel="external">请报告这个bug或者发一个pull requst到我们的问题跟踪里</a>。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果你还没有安装好Elixir，请到我们的<a href="http://elixir-lang.org/install.html" target="_blank" rel="external">安装指南</a>页面。一旦你安装好Elixir，你就能够运行  elixir –version 来得到当前Elixir的版本。</p>
<h1 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h1><p>当你安装Elixir，你将有三个新的可执行文件：iex，elixir和elixirc。如果你是从源码编译Elixir或者使用预先打包好的版本，你可以在bin目录里找到这三个可执行文件。</p>
<p>现在，让我们运行iex（如果你在Windows下则运行iex.bat），它代表交互式Elixir。在交互模式，我们能够输入任何Elixir表达式并且得到它的结果。让我们用一些基本表达式来热身。</p>
<p>运行iex并输入如下的表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex&gt; <span class="number">40</span> + <span class="number">2</span></div><div class="line"><span class="number">42</span></div><div class="line">iex&gt; <span class="string">"hello"</span> &lt;&gt; <span class="string">" world"</span></div><div class="line"><span class="string">"hello world"</span></div></pre></td></tr></table></figure>
<p>看来我们准备好了！我们从下下一章开始将在接下来的章节里大量使用交互shell来进一步熟悉这门语言的构造和基本类型。</p>
<blockquote>
<p>注意：如果你使用的是Windows，你也可以尝试 iex.bat - -werl 根据你正在用的控制台来提供更好的体验。</p>
</blockquote>
<h1 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h1><p>初步熟悉这门语言后，你可能想尝试写简单的程序，这个任务可以通过把下述Elixir代码放到一个文件里来完成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IO.puts “Hello world from Elixir<span class="string">"</span></div></pre></td></tr></table></figure>
<p>保存文件为simple.exs并且用elixir执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">elixir simple.exs</div><div class="line">Hello world from Elixir</div></pre></td></tr></table></figure>
<p>后续我们将学习如何编译Elixir代码（<a href="http://elixir-lang.org/getting-started/modules.html" target="_blank" rel="external">在第八章</a>）并且如何使用Mix构建工具（在<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix&amp;OTP guide</a>）。现在，让我们进入到<a href="http://elixir-lang.org/getting-started/basic-types.html" target="_blank" rel="external">第二章</a>。</p>
<h1 id="如何问问题"><a href="#如何问问题" class="headerlink" title="如何问问题"></a>如何问问题</h1><p>在本教程的学习过程中，有一些疑问是很常见的，毕竟，这是学习过程的一部分！有很多地方你可以请教他们来更多地了解Elixir：</p>
<ul>
<li><a href="irc://irc.freenode.net/elixir-lang" target="_blank" rel="external">#elixir-lang on freenode IRC</a></li>
<li><a href="https://elixir-slackin.herokuapp.com/" target="_blank" rel="external">Elixir on Slack</a></li>
<li><a href="http://elixirforum.com/" target="_blank" rel="external">Elixir Forum</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/elixir" target="_blank" rel="external">elixir tag on StackOverflow</a></li>
</ul>
<p>当问问题的时候，记住两个技巧：</p>
<ul>
<li>不是问“在Elixir里如何去做X”，而是问“在Elixir里怎样去解决Y”。换句话说，不要问如何实现一个特定的解决方案，而是描述手头上的问题。描述一个问题的时候给予更多的上下文信息以及更少的对一个正确答案的偏见。</li>
<li>如果事情并不如预想的那样，请在你的报告里尽可能多地提供相关信息，比如：你的Elixir版本，代码片段和错误信息以及错误堆栈。使用像Gist这样的网站发布这些信息。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/introduction.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[监控Erlang的原子]]></title>
      <url>http://szpzs.oschina.io/2017/01/25/about-erlang-atoms/</url>
      <content type="html"><![CDATA[<p>如果你是Erlang用户，你很可能知道<a href="http://learnyousomeerlang.com/starting-out-for-real" target="_blank" rel="external">原子是什么</a>。你也有很高的机会知道在Erlang里关于原子的<a href="http://erlang.org/doc/efficiency_guide/commoncaveats.html#id61937" target="_blank" rel="external">警告</a>：</p>
<blockquote>
<p>原子是不进行垃圾回收的。一旦原子被创建，它就不会被删除。如果原子的数量达到限制值（默认是1,048,576），模拟器就会终止。</p>
</blockquote>
<a id="more"></a>
<p>原子的文本存储在原子表里（每个元素对应唯一一个原子），而且这些数据是不会被垃圾回收的。这个原子表的条目数对应一个可配置的限制值。达到这个限制值（比如动态地不停地生成原子）可以造成Erlang虚拟机崩溃。</p>
<p>原子很棒，但是一定要小心使用它们。动态创建原子（比如通过list_to_atom/1函数）必须要不惜代价避免。毕竟，这是list_to_existing_atom/1函数为什么存在的理由。如果你想知道什么时候应该使用原子，什么时候使用其他东西，你可能喜欢<a href="http://erlang.org/pipermail/erlang-questions/2015-October/086366.html" target="_blank" rel="external">Erlang问题邮件列表里的这个贴子</a>，其中包括Richard A. O’Keefe 和 Joe Armstrong 的回答。既然太多原子可以引起我们的系统非正常崩溃，<strong>那么在运行的生产系统中关注原子表的条目的数量是非常重要的</strong>。但是我们该如何做呢？</p>
<p>在当前的OTP版本（在我写本文的时候是19.2），只有关于原子表使用内存的信息能通过erlang:memory/1函数来获取给予用户。实际上有两个相似的参数可以使用。我们先看第一个：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; erlang:memory(atom).</div><div class="line"><span class="number">202481</span></div></pre></td></tr></table></figure>
<p>这个函数返回原子表自己使用的内存加上那个时点预留给原子字符串的内存。预留给原子字符串的内存以块形式增长。返回值是以字节为单元来表示。</p>
<p>让我们看第二个：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; erlang:memory(atom_used).</div><div class="line"><span class="number">187410</span></div></pre></td></tr></table></figure>
<p>这个函数返回原子表自己使用的内存加上原子字符串空间实际使用的内存。它的返回值也是以字节为单元来表示。谢谢<a href="https://github.com/mikpe" target="_blank" rel="external">Mikael</a>为我确认这个两个函数的不同之处。</p>
<p>但是，我们如何利用这一信息呢？了解原子表分配内存是一回事，但<strong>我们真的很想知道有多少原子在我们的生产系统中</strong>，而且我们是否接近臭名昭著的1百万原子表条目数限制。在经过查阅官方文档之后，我确信这些信息不会暴露给用户。在这一点上，我的同事<a href="https://github.com/dszoboszlay" target="_blank" rel="external">Daniel</a>建议，可以将这个信息从erlang:system_info/1函数的二进制输出提取出来：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; erlang:system_info(info).</div><div class="line">&lt;&lt;<span class="string">"=memory\ntotal: 13227160\nprocesses: 4383720\nprocesses_used: 4383496\nsystem: 8843440\natom: 202481\natom_used: 187410\nbi"</span>...&gt;&gt;</div></pre></td></tr></table></figure>
<p>上述输出被Erlang shell截断了，因此让我们用更加好看的格式打印它的输出（如下的输出示例被截断了）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; io:put_chars(erlang:system_info(info)).</div><div class="line">=memory</div><div class="line">total: <span class="number">13287200</span></div><div class="line">processes: <span class="number">4394640</span></div><div class="line">processes_used: <span class="number">4394416</span></div><div class="line">system: <span class="number">8892560</span></div><div class="line">[...]</div><div class="line">=index_table:atom_tab</div><div class="line">size: <span class="number">8192</span></div><div class="line">limit: <span class="number">1048576</span></div><div class="line">entries: <span class="number">7227</span></div><div class="line">=hash_table:module_code</div><div class="line">[...]</div></pre></td></tr></table></figure>
<p>的确，我们需要的信息就这里面。让我们实现一个简单的助手模块来提取它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(atom_table)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([count/<span class="number">0</span>])</span>.</div><div class="line"><span class="function"><span class="title">count</span><span class="params">()</span> -&gt;</span></div><div class="line">  Info = erlang:system_info(info),</div><div class="line">  Chunks = binary:split(Info, &lt;&lt;<span class="string">"="</span>&gt;&gt;, [global]),</div><div class="line">  [TabInfo] = [X || &lt;&lt;<span class="string">"index_table:atom_tab"</span>, X/binary&gt;&gt; &lt;- Chunks],</div><div class="line">  Lines = binary:split(TabInfo, &lt;&lt;<span class="string">"\n"</span>&gt;&gt;, [global]),</div><div class="line">  Chunks2 = [binary:split(L, &lt;&lt;<span class="string">": "</span>&gt;&gt;) || L &lt;- Lines, L =/= &lt;&lt;&gt;&gt;],</div><div class="line">  binary_to_integer(proplists:get_value(&lt;&lt;<span class="string">"entries"</span>&gt;&gt;, Chunks2)).</div></pre></td></tr></table></figure>
<p>接着我们看看我们的助手的作用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; atom_table:count().</div><div class="line"><span class="number">7085</span></div></pre></td></tr></table></figure>
<p>不是最好的API，但至少我们得到了我们需要的信息。幸运的是，<a href="https://github.com/mikpe" target="_blank" rel="external">Mikael</a>向OTP团队提交了一个<a href="https://github.com/erlang/otp/pull/1286" target="_blank" rel="external">Pull Request</a>，其中包括一个新的API以更好的方式找回我们的小宝贝信息。这个Pull Request最近已经被接受，这就意味着从OTP 20开始，我们将能够用下面的API来获取关于原子使用的数量的信息：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erlang:system_info(atom_count).</div></pre></td></tr></table></figure>
<p>好极了，不是吗？</p>
<p>现在，我们有我们所需要的指标，我们可以设置一个周期性的工作，将我们的生产系统中的原子数发送到我们最喜欢的监控系统，并且如果一个预定义的阈值被超过则引起一个报警。我会用很低的阈值（即小于50%），因为即使在一个巨大的Erlang系统是不大可能看到几十万个原子的，而且达到那么高的数字可能就暴露一些原子动态生成的问题。如果真是这样的情况，我们需要尽快报警。</p>
<p>现在让我们创建一个新的原子，然后再用我们的助手一次：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; roberto.</div><div class="line">roberto</div><div class="line"><span class="number">3</span>&gt; atom_table:count().</div><div class="line"><span class="number">7134</span></div></pre></td></tr></table></figure>
<p>等一等！我们只是创建了一个原子。为什么原子数量从7085跳到7134了？</p>
<p>在运行中的Erlang系统里，原子随时都会被创建。例如，可能一个进程在没有见过的模块中对一个函数执行完全限定的函数调用。这将导致模块加载到系统中，并且一堆原子被添加到原子表。毕竟，模块名是原子，函数名等等也是原子。</p>
<p>现在让我们假设我们的系统原子泄露。我们怎样才能知道哪些原子在产生？有几个方法从一个运行的Erlang系统中获取原子列表，不过我最喜欢的方法是<a href="http://stackoverflow.com/questions/13480462/erlang-can-i-get-a-list-of-all-currently-registered-atoms" target="_blank" rel="external">legoscia在StackOverflow给出的</a>。这个方法真的很邪乎，它使用了外部数据格式的非官方公布特性。</p>
<p><img src="/images/about-erlang-atoms-1.jpeg" style="border:0;"></p>
<p>比如我们可以利用从Stack Overflow获取的代码读取系统中原子的列表，稍等一会儿，然后再次运行它，看两次结果的差异。我们甚至不需要在生产中运行这样的代码，因为本地工作站或测试系统足以发现意外产生这些原子的背后的根本原因。</p>
<p>如果我们发现原子是动态生成的，我们可能想确保它不再发生。在这种情况下，我推荐使用像 Erlang 风格的审阅工具：<a href="https://github.com/inaka/elvis" target="_blank" rel="external">Elvis</a>，我的同事<a href="https://github.com/jfacorro" target="_blank" rel="external">Juan</a>是它的主要贡献者。。</p>
<p>那么你有什么问题吗？有没有其他的你跟踪的Erlang指标（或者你想跟踪）很难获取或另有隐情？请在评论中让我们知道。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@robertoaloi/about-erlang-atoms-a24603a4a6e8#.cm9ha79v7" target="_blank" rel="external">https://medium.com/@robertoaloi/about-erlang-atoms-a24603a4a6e8#.cm9ha79v7</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Erlang进行分布式计算 -- 第二篇]]></title>
      <url>http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-2/</url>
      <content type="html"><![CDATA[<p>在前一篇文章里，我们已经看到如何连接一个远程节点并且运行Erlang里内建的模块。本文我们将学习如何可以运行我们自己的模块来做一些任务。例如我们将从远程节点获取分配给它们网络接口的ip地址。</p>
<a id="more"></a>
<p>我们的模块看起来像如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">% 文件名应该是 ourmodule.erl</div><div class="line">-module(ourmodule).</div><div class="line">-export([ getip/0 ]).</div><div class="line">getip()-&gt;</div><div class="line">    % 这是用于Mac终端的</div><div class="line">    % B = os:cmd('ifconfig $2 | grep \"inet \" | awk -F\' \' \'&#123;print    $2&#125;\' | awk \'&#123;print $1&#125;\''),</div><div class="line">    % 这是用于Linux终端的</div><div class="line">    B = os:cmd('ifconfig $2 | grep \"inet \" | awk -F\' \' \'&#123;print $2&#125;\' | awk \'&#123;print $1&#125;\' | awk -F \':\' \'&#123;print $2&#125;\''),</div><div class="line">    io:format("node: ~s ~n ~s ", [node(), B]),</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>保存这份代码为<strong>ourmodule.erl</strong>。</p>
<p>现在让我们来编译我们的模块。首先我们必须去到我们模块存放的目录。然后打开Erlang shell并且编译它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c(ourmodule). %%% 输出是: &#123;ok,ourmodule&#125;</div></pre></td></tr></table></figure>
<p>编译后，我们在同一个目录里将有一个 <strong>ourmodule.beam</strong> 文件，它是这个模块的erlang可执行文件。然后我们必须拷贝这个 <strong>ourmodule.beam</strong> 文件到远程节点。现在从相同的目录（远程节点上该文件存放的目录）让我们打开一个Erlang shell：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name cloud@remote-host -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>做完这些。这些就是我们在远程节点需要做的所有工作。</p>
<p>现在从你的主（也就是本地）节点执行如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpc:call('cloud@remote-host', ourmodule, getip, []).</div><div class="line"><span class="comment">% 输出是 : 将有节点名和一些ip地址的列表</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% node: cloud@remote-host</span></div><div class="line"><span class="comment">% 127.0.0.1</span></div><div class="line"><span class="comment">% 192.168.1.45</span></div><div class="line"><span class="comment">% ok.</span></div></pre></td></tr></table></figure>
<p>这是一个简单例子，就是我们如何可以在分布式Erlang环境里运行我们自己的模块。我们可以通过增加更多函数来做其他任务，或者我们可以只是为我们的目的写新的模块，然后我们可以分布可执行文件到不同的节点并远程执行它们。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@smirazzakee/distributed-computing-using-erlang-2-c57f3242a2e0#.acwcop39g" target="_blank" rel="external">https://medium.com/@smirazzakee/distributed-computing-using-erlang-2-c57f3242a2e0#.acwcop39g</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Erlang进行分布式计算 -- 第一篇]]></title>
      <url>http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-1/</url>
      <content type="html"><![CDATA[<p>本文我们将看看Erlang里的分布式系统是如何运作的。</p>
<p>Erlang是一种函数式语言，其最被大家所熟知的是分布式和并发计算。</p>
<a id="more"></a>
<p>一般Erlang程序运行在节点上（<strong>节点名默认是nonode@nohost</strong>）。</p>
<p>在一个分布式系统里，节点间彼此交互。本文我们将用两个节点：<strong>sakib@localhost</strong> 和 <strong>cloud@remote-host</strong> 。</p>
<p>节点<strong>sakib@localhost</strong>运行在我本地系统，节点<strong>cloud@remote-host</strong>运行在远程服务器上。<strong>remote-host</strong>是我的远程服务器的主机名。</p>
<p>连接到远程节点，节点名的后缀（节点名@符号后的部分）和主机名相同是很重要。</p>
<p>现在如下所示打开本地系统的Erlang的shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name sakib@localhost -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>并且如下所示打开远程服务器的Erlang的shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name cloud@remote-host -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>两个节点的cookie必须一样，或者稍后你可以设置节点的cookie。如果远程节点的cookie没有设置，那么本地节点的cookie将被用来连接远程节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 给指定的节点设置cookie</span></div><div class="line">erlang:set_cookie('cloud@remote-host', '<span class="number">12345</span>').</div><div class="line"><span class="comment">% 第一个参数是节点名，第二参数是cookie</span></div><div class="line"><span class="comment">% 连接远程节点</span></div><div class="line">net_kernel:connect_node('cloud@remote-host').</div></pre></td></tr></table></figure>
<p>如果响应是true，则连接建立；如果响应是false，则连接失败。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">% 列出已经连接的节点列表</div><div class="line">nodes().</div><div class="line">% 输出是 : ['cloud@remote-host']</div><div class="line">% 因为我们现在仅仅连接了一个远程节点</div></pre></td></tr></table></figure>
<p>现在我们可以用<strong>RPC</strong>来运行远程节点的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpc:call('cloud@remote-host', os, cmd, [whoami]).</div></pre></td></tr></table></figure>
<p>rpc:call()函数有4个入参。</p>
<p>第一个是节点名，第二个是模块名，第三个是函数名，第四个是函数的入参。</p>
<p>上述例子是我们运行<strong>os</strong>模块里的<strong>cmd()</strong>函数，入参是<strong>whoami</strong>。它将返回远程系统的当前用户名。<strong>os</strong>是Erlang的内建模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 使用multicall函数 (跨所有连接的节点执行rpc调用)</span></div><div class="line">rpc:multicall(nodes(), os, cmd, [whoami]).</div><div class="line"><span class="comment">% 与远程节点断开连接</span></div><div class="line">erlang:disconnect_node('cloud@remote-host').</div></pre></td></tr></table></figure>
<p>用同样的方式我们可以将不同的任务分布到不同的节点来处理，然后在主节点上获取结果。这就是在Erlang里一个分布式系统的运作方式。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@sakibsami/distributed-computing-using-erlang-1-cdd051a77c85#.maaswacq4" target="_blank" rel="external">https://medium.com/@sakibsami/distributed-computing-using-erlang-1-cdd051a77c85#.maaswacq4</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[耗尽弹药时你不能爆炸！]]></title>
      <url>http://szpzs.oschina.io/2017/01/13/running-out-of-ammo/</url>
      <content type="html"><![CDATA[<p>本文（和<a href="https://medium.com/erlang-battleground/beyond-the-limits-of-an-ets-cdd79fa8300c#.tsfdkduyd" target="_blank" rel="external">上一篇文章</a>一样）也是受我在哥伦比亚卡利的学生的好奇心所启发。这次的问题是：什么时候并且为什么 bang（!）（即消息发送）操作符失败？</p>
<a id="more"></a>
<p><img src="/images/running-out-of-ammo-1.jpeg" style="border:0;"></p>
<h1 id="有时候你有无限的子弹"><a href="#有时候你有无限的子弹" class="headerlink" title="有时候你有无限的子弹"></a>有时候你有无限的子弹</h1><p>那些天我和我的学生讨论的是Erlang的一个核心概念：消息传递。Erlang中消息传递是用发送操作符（即 ！，也叫做bang）来完成的。这次我给他们介绍bang，我用一个Pid放在它的左边。就像这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; Pid = self().</div><div class="line">&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">2</span>&gt; Pid ! &#123;a, message&#125;.</div><div class="line">&#123;a,message&#125;</div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下（当表达式的左边是一个Pid），bang从来不失败。即使Pid表示的是一个死亡进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">4</span>&gt; erlang:is_process_alive(Pid).</div><div class="line"><span class="literal">false</span></div><div class="line"><span class="number">5</span>&gt; Pid ! &#123;another, message&#125;.</div><div class="line">&#123;another,message&#125;</div><div class="line"><span class="number">6</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="有时候你就是不能开枪"><a href="#有时候你就是不能开枪" class="headerlink" title="有时候你就是不能开枪"></a>有时候你就是不能开枪</h1><p>但是Pid并不是在bang左边唯一有效的表达式，你也可以用原子和元组放在bang的左边，例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">7</span>&gt; my ! &#123;third, message&#125;.</div><div class="line">&#123;third,message&#125;</div><div class="line"><span class="number">8</span>&gt; &#123;my, node()&#125; ! &#123;fourth, message&#125;.</div><div class="line">&#123;fourth,message&#125;</div><div class="line"><span class="number">9</span>&gt; flush().</div><div class="line">Shell got &#123;third,message&#125;</div><div class="line">Shell got &#123;fourth,message&#125;</div><div class="line">ok</div><div class="line"><span class="number">10</span>&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下，如果没有进程被注册为这个名字，bang操作可能失败：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>&gt; no_proc ! &#123;fifth, message&#125;.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as no_proc ! &#123;fifth,message&#125;</div><div class="line"><span class="number">11</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="去读官方文档吧！"><a href="#去读官方文档吧！" class="headerlink" title="去读官方文档吧！"></a>去读官方文档吧！</h1><p>所有问题在<a href="http://erlang.org/doc/reference_manual/expressions.html#id80833" target="_blank" rel="external">官方文档</a>里都有清晰的说明。</p>
<blockquote>
<p>Expr1的计算结果必须是一个pid、一个注册的名字（原子），或者是一个格式为{Name, Node}的元组。Name是一个原子而Node是一个节点名字，也是一个原子。</p>
<p>如果Expr1的计算结果是一个名字，但是这个名字没有注册，则一个badarg运行时错误发生。</p>
<p>发送消息给一个pid永远都不会失败，即使这个pid指的是一个不存在的进程。</p>
<p>也就是说，如果Expr1的计算结果是一个格式为{Name, Node}元组（或者是另外一个节点的pid），分布式消息发送也永远不会失败。</p>
</blockquote>
<p><img src="/images/running-out-of-ammo-2.gif" style="border:0;"></p>
<h1 id="是的，不过…"><a href="#是的，不过…" class="headerlink" title="是的，不过…"></a>是的，不过…</h1><p>现在，我们不能只是满足了解这点知识。</p>
<p>正如你可能猜到的，我们没有那样做。我们问自己：</p>
<blockquote>
<p>当没有进程用相关名字注册，而如果发送消息给这个名字时，会抛出badarg错误：<br>1、一个进程可以用一个名字注册，但它却是不存在的？换句话说：bang操作失败意味着这个进程不存在？<br>2、我如何在用<strong>bang</strong>操作前检查是否有进程用相关名字注册。</p>
</blockquote>
<h2 id="问题1：我能注册已经死亡的进程吗？"><a href="#问题1：我能注册已经死亡的进程吗？" class="headerlink" title="问题1：我能注册已经死亡的进程吗？"></a>问题1：我能注册已经死亡的进程吗？</h2><p>为回答问题1，我们必须先检查一些事情。一个进程可以死掉并且还能用一个名字注册吗？我们用两种方法来尝试：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; Pid = self().</div><div class="line">&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">2</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">3</span>&gt; register(my, Pid).</div><div class="line">** exception error: bad argument</div><div class="line">     in function  register/<span class="number">2</span></div><div class="line">        called as register(my,&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;)</div><div class="line"><span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>首先我们尝试一个已经死亡的进程作为入参来调用erlang:register/2函数，结果我们失败了。然后我们尝试注册一个进程，接着杀掉它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">5</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">6</span>&gt; my ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as my ! message</div><div class="line"><span class="number">7</span>&gt;</div></pre></td></tr></table></figure>
<p>还是失败了。不过这次的失败是因为进程已经死亡了还是因为发送消息的时候它没有被注册？这就带我们进入问题2…</p>
<h2 id="问题2：我怎么能够阻止bagarg错误发生？"><a href="#问题2：我怎么能够阻止bagarg错误发生？" class="headerlink" title="问题2：我怎么能够阻止bagarg错误发生？"></a>问题2：我怎么能够阻止bagarg错误发生？</h2><p>现在，我如何可以找出实际在对某个名字使用bang操作之前是否有一个用这个名字注册的进程？</p>
<p>快速而且非常精确的答案是：你做不到。因为Erlang的并发本质，在你检测进程是否存在的时候和你发送消息的时候这两个时间点之间，这个进程可能已经死掉了（或者一个新的进程使用了相同的名字来注册）。</p>
<p>尽管如此，还是有一个方法来只是检查在你的节点上是否有一个用某个名字注册的进程，并找到那个进程是哪个进程来作为奖赏：<a href="http://erlang.org/doc/man/erlang.html#whereis-1" target="_blank" rel="external">whereis/1</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span>&gt; whereis(my).</div><div class="line">undefined</div><div class="line"><span class="number">8</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">9</span>&gt; whereis(my).</div><div class="line">&lt;<span class="number">0.75</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">10</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">11</span>&gt; whereis(my).</div><div class="line">undefined</div><div class="line"><span class="number">12</span>&gt;</div></pre></td></tr></table></figure>
<p>如果whereis/1返回undefined，你就知道在你的节点里没有用那个名字注册的进程。但是，如上所述，您不应该编写像如下的代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> whereis(my) <span class="keyword">of</span></div><div class="line">  undefined -&gt; do_nothing;</div><div class="line">  APid -&gt; APid ! message</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你那是正在给自己购买了去竞争条件之地的票。你所需要的就如下代码所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> my ! message</div><div class="line"><span class="keyword">catch</span></div><div class="line">  _:badarg -&gt; do_nothing</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><img src="/images/running-out-of-ammo-3.gif" style="border:0;"></p>
<h1 id="但是我们讨厌-try…catch！"><a href="#但是我们讨厌-try…catch！" class="headerlink" title="但是我们讨厌 try…catch！"></a>但是我们讨厌 try…catch！</h1><p>如果你真的不喜欢像上面那样用try…catch来处理每一个消息，这里有一个小技巧。还记得前面官方文档说过的吗？</p>
<blockquote>
<p>也就是说，如果Expr1的计算结果是一个格式为{Name, Node}元组（或者是另外一个节点的pid），分布式消息发送也永远不会失败。</p>
</blockquote>
<p>考虑到这一点，看看你能做些什么来替代上面的做法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">12</span>&gt; my ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as my ! message</div><div class="line"><span class="number">13</span>&gt; &#123;my, node()&#125; ! message.</div><div class="line">message</div><div class="line"><span class="number">14</span>&gt;</div></pre></td></tr></table></figure>
<p>使用元组语法，其中用到了你自己所在节点的名称，如果那个叫做my的进程存在的话，你就正在有效地发送消息给它；而如果这个进程不存在，则会丢弃这些消息。如果你用Pid来替换元组的话，也是这个结果。</p>
<p><img src="/images/running-out-of-ammo-4.gif" style="border:0;"></p>
<h1 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h1><p>我想用我们在卡利发现的另一个比较酷的事情来结束本文。当谈论这些事情的时候，我们并不真正地了解bang操作在Erlang虚拟机内部的运作过程，只是考虑bang操作失败的情况，我们尝试想像Erlang虚拟机内部如何运行。</p>
<h2 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h2><p>首先来考虑这个问题：当bang操作失败的时候，它总是报badarg错误。当你用一个没有注册为进程名字的原子的时候，它会失败，但是你用其他东西，它也会失败。看如下例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; x ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as x ! message</div><div class="line"><span class="number">2</span>&gt; <span class="string">"a list"</span> ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as <span class="string">"a list"</span> ! message</div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>用一点想象力，我们可能会认为，当你使用一个原子，Erlang虚拟机转换原子为Pid，然后在其上执行bang操作的原始版。如果它未能把原子转换成Pid，那么当然badarg错误就发生。换句话说，看起来Erlang VM在将下面的语句…</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; x ! message.</div></pre></td></tr></table></figure>
<p>改为如下的语句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; whereis(x) ! message.</div></pre></td></tr></table></figure>
<p>那么，当whereis 返回 undefined, bang操作失败。</p>
<h2 id="等一等"><a href="#等一等" class="headerlink" title="等一等"></a>等一等</h2><p>哦，不错。但是undefined也是一个原子啊。Erlang虚拟机为何在那里不陷入一个无限的递归循环呢？嗯，它可能有一个处理undefined的特殊分支。在这个分支里，它可以避免把undefined当做其他任何原子来处理。但是，那么，如果我注册一个进程的名字为undefined呢？</p>
<p><img src="/images/running-out-of-ammo-5.jpeg" style="border:0;"></p>
<p>让我们来试试，好吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; register(undefined, self()).</div><div class="line">** exception error: bad argument</div><div class="line">     in function  register/<span class="number">2</span></div><div class="line">        called as register(undefined,&lt;<span class="number">0.69</span>.<span class="number">0</span>&gt;)</div><div class="line"><span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>好吧，我们做不到。实际上<a href="http://erlang.org/doc/man/erlang.html#register-2" target="_blank" rel="external">官方文档</a>说的很清楚。</p>
<blockquote>
<p>badarg<br>如果 RegName 是原子undefined.</p>
</blockquote>
<p>干得不错，Erlang/OTP团队。干得不错，真的！</p>
<p><img src="/images/running-out-of-ammo-6.gif" style="border:0;"></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2#.sm8fbhd9q" target="_blank" rel="external">https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2#.sm8fbhd9q</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang中的通信]]></title>
      <url>http://szpzs.oschina.io/2017/01/11/erts-communication/</url>
      <content type="html"><![CDATA[<p>从概念上讲在 Erlang 中的通信是使用异步信号完成的。所有不同的执行实体，比如进程和端口，通过异步信号通信。最常用的信号是消息。其他通用的信号是退出、链接、取消链接、监测和取消监测信号。</p>
<a id="more"></a>
<h1 id="信号的传递"><a href="#信号的传递" class="headerlink" title="信号的传递"></a>信号的传递</h1><p>在信号被发送出去和信号到达目标这之间消耗的时间是不确定的但是肯定存在的。如果接受者已经终止，信号就无法到达，不过这个情况可以触发另一个信号产生。例如，一个发给不存在进程的链接信号触发一个退出信号，这个退出信号被发送回给发送这个链接信号的实体。在分布式环境下通信的时候，如果分布式信道中断了，信号可以被丢失。</p>
<p>只在如下的场景信号的顺序才能被保证：如果一个实体发送多个信号给同一个目标实体，这些信号的顺序是被保证。也就是说，如果A发送一个信号S1给B，然后A再发送一个信号S2给B，S1被保证不在S2之后到达。</p>
<h1 id="同步的通信"><a href="#同步的通信" class="headerlink" title="同步的通信"></a>同步的通信</h1><p>一些通信是同步的。如果分解来看，一个同步通信操作包含两个异步信号：一个请求信号和一个应答信号。比如，第一个入参不是self()的<a href="http://erlang.org/doc/apps/erlang/process_info/2.html" target="_blank" rel="external">erlang:process_info/2</a> 函数调用就是一个同步通信。调用者发送一个请求信息的异步信号然后等待包含所请求信息的应答信号。当请求信号到达它的目标，目标进程用被请求的信息应答。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>在虚拟机里的不同异步信号的实现会随着时间而变化，但是它的行为一直遵循如上所述异步信号在实体间传递的概念。</p>
<p>通过检阅相关实现，你可能注意到一些特定的信号给予比上述更严格的传递保证。关于实现不是用Erlang代码这样来写的知识是极其重要的，因为实现在没有提前通知下随时被修改。</p>
<p>主要的实现修改例子如下：</p>
<ul>
<li>从ERTS 5.5.2开始，发给进程的退出信号是真正地异步传输。</li>
<li>从ERTS 5.10开始，所有从进程发给端口的信号是真正地异步传输。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://erlang.org/doc/apps/erts/communication.html" target="_blank" rel="external">http://erlang.org/doc/apps/erts/communication.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[外部数据格式之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2017/01/08/eli5-etf/</url>
      <content type="html"><![CDATA[<p>与外部世界和其他Erlang节点进行通信，同时保存东西在磁盘上，Erlang都使用特殊编码格式 – 外部数据格式。</p>
<a id="more"></a>
<p>这种格式的主要要求如下：</p>
<ul>
<li>易于人类和机器看懂编码的数据和理解这些数据是什么。一个外部数据总是第一个字节值为131 (0x83)。</li>
<li>压缩的数据有压缩的标志项。数据的头部第一个字节为：131 (0x83)，第二个字节为：80<br>(0x50)，第三到第六个字节为：无符号32位大端的整数表示未压缩的数据长度，这几个元素组成一个标签表示这是一个压缩数据。</li>
<li>为了适用于跨平台，所有整数被编码为<a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">大端序</a>（从最高有效位到最低有效位字节），所有浮点数用大端的<a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">IEEE编码</a>，所有文本用UTF-8<br>或 ISO-8859-1（ASCII超集） 来编码。</li>
</ul>
<p>编码一个数据用erlang:term_to_binary，相反的操作，即解码用erlang:binary_to_term。解码包含有意设定的二进制数据也使得本来不可能构建出来的数据成为可能，比如端口号，进程标识。（注：感谢少帮主的翻译）</p>
<p>通常原子被编码为字符串。在基于网络的分布式模式下，为进一步减少协议的大小，一个分布式头部可以被添加进来。它包含了在已经编码的消息中的原子名称的表。然后在消息中的原子被替换为此表中的索引。</p>
<p>那些从来没出现在Erlang程序中的虚拟机内部值的类型是不可能被编码的，比如THE_NON_VALUE、寄存器的引用、<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cp" target="_blank" rel="external">CP</a>等。</p>
<blockquote>
<p>请参阅<br><a href="http://erlang.org/doc/apps/erts/erl_ext_dist.html" target="_blank" rel="external">外部数据格式文档</a></p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-etf.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-etf.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于属性的测试之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2017/01/07/eli5-property-based/</url>
      <content type="html"><![CDATA[<p>假设你知道通常的单元测试，可能你就会听说过common test。有另一种方法来检查你的系统，不同于普通的测试方法。它被称为基于属性的测试。</p>
<p>要做测试，应该定义输入数据的类型和范围，系统将在此基础上进行测试。输入数据的定义看起来像一个具有类型和范围参数描述的元组。它们是数据，而你在测试前生成这些数据。</p>
<a id="more"></a>
<p>然后，测试引擎将用定义的输入数据的随机组合来调用你的代码。测试引擎尝试观察被测系统是否仍然展示所定义的属性。</p>
<p>如果在某一时刻没有观察到所需的属性，测试将停止并且引擎将尝试缩小输入。这是试图找到仍然使得测试失败的最简单的输入数据。测试引擎将尽量减少尽可能多的参数的复杂性。</p>
<blockquote>
<p>请参阅：<br>提供了基于属性测试功能的库有：<a href="https://github.com/manopapad/proper" target="_blank" rel="external">PropEr</a> 和 <a href="http://www.quviq.com/products/erlang-quickcheck/" target="_blank" rel="external">Quviq QuickCheck</a> (商用的) (注意：QuickCheck 也有其他语言的版本！)</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>假设你的老板要你写一个fizz_buzz函数。它的需求非常明确，fizz_buzz的入参是1到100之间的整数。另外，入参被3整除，它返回fizz，入参被5整除，它返回buzz，入参被3和5都整除，它返回fizbuzz。</p>
<p>所以输入范围是：1到100之间的整数。</p>
<p>而且我们想要观察的三个属性是：</p>
<ol>
<li>当X rem 15 =:= 0 ，我们想看到返回值是fizzbuzz。</li>
<li>当X rem 3 =:= 0，我们想看到返回值是fizz。</li>
<li>当X rem 5 =:= 0，我们想看到返回值是buzz。</li>
</ol>
<blockquote>
<p>注意：<br>请查阅所选测试库的实际文档。库调用的语法不同。</p>
</blockquote>
<p>测试引擎将尝试从定义的输入范围随机组合的值。测试引擎将确保在运行过程中观察到所有3个属性。</p>
<blockquote>
<p>注意：<br>你可以用这种方式测试任何黑盒系统，而不需要知道它的内部情况。所测试的系统可以是C程序，甚至是真正的硬件！<br>它也可以运行并行测试（确保当并行发生时，并行系统不发生故障）和状态机测试（确保状态机在随机的输入下不会有问题）。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-property-based.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-property-based.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类型之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2017/01/06/eli5-types/</url>
      <content type="html"><![CDATA[<p>Erlang是一种动态类型语言。这意味着任何变量，字段或函数参数可以包含任何允许的值。</p>
<a id="more"></a>
<h1 id="类型规格说明"><a href="#类型规格说明" class="headerlink" title="类型规格说明"></a>类型规格说明</h1><p>有一种类型描述语言，你可以用它来描述你认为你的函数应该有什么样的入参和返回值。这些类型规格说明是可选的，并且即使有不合适的类型存在，编译器也将好像没有任何事情发生一样运行你的程序。为了确认你的类型规格说明彼此没有冲突，我们可以使用另一个工具，它叫做Dialyzer。</p>
<p>在Erlang源文件里，一个类型规格说明就是一条命令，它看起来如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-spec</span> func_name<span class="params">(Arg :: integer(), _, Y :: any())</span> -&gt; float<span class="params">()</span>.</div></pre></td></tr></table></figure>
<p>类型规格说明不是代码，它既不运行也不阻止你的程序被编译。</p>
<blockquote>
<p>请参阅：<br>你可以在<a href="http://erlang.org/doc/reference_manual/typespec.html" target="_blank" rel="external">类型规格说明参考手册</a>和其他已有的书籍，比如：<a href="http://learnyousomeerlang.com/types-or-lack-thereof" target="_blank" rel="external">Learn You Some Erlang</a> 里读到更多关于类型规格说明的内容。</p>
</blockquote>
<h1 id="Dialyzer"><a href="#Dialyzer" class="headerlink" title="Dialyzer"></a>Dialyzer</h1><p>Dialyzer把编译好的BEAM文件或Erlang源文件作为输入，然后尝试猜类型（类型推导）。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>假设你已经写了一个函数f，它有一个入参X并且返回一些值。Dialyzer首先做一个大致的假设，f是一个fun()，它的入参是任何值（(X :: any()）并且返回任何值（any()）。如下是Dialyzer一开始的猜测结果：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-spec</span> f<span class="params">(X :: any())</span> -&gt; any<span class="params">()</span>.</div></pre></td></tr></table></figure>
<p>Any()是最宽泛的类型，它可能包括任何值。然后Dialyzer分析这个函数的用法和它的代码，并尝试缩小入参和返回值类型到更狭窄特定的类型集合。</p>
<p>例如，如果Dialyzer发现仅有两个地方调用你的函数，分别传入整数入参和原子入参，那么X的类型缩小到 integer()|atom() （一个两个类型的集合）。如下就是Dialyzer可能推断出来的结果：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-spec</span> f<span class="params">(X :: integer() | atom())</span> -&gt; any<span class="params">()</span>.</div></pre></td></tr></table></figure>
<p>如果Dialyzer发现了一个矛盾，也就是一些类型其实合并后是一个空类型（none()）或不兼容的类型被发现，Dialyzer会报告一个错误。这些错误看起来令人困惑，不过它们常常（还是一直？）指出代码中存在的问题。</p>
<h1 id="Typer"><a href="#Typer" class="headerlink" title="Typer"></a>Typer</h1><p>Typer是另一个可选工具，在你的OTP环境里可以找到。Typer使用和Dialyzer一样的算法来推导给定模块里的各种类型并且打印它们。你可以把这些输出插入到你的程序里以备将来使用，或者为大的遗留项目做更好的文档。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-types.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-types.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gen_tcp 和 active_once]]></title>
      <url>http://szpzs.oschina.io/2017/01/05/active-once/</url>
      <content type="html"><![CDATA[<p>我想理解和测试gen_tcp模块使用的active_once选项。整个过程我写了一些代码，包括三个监督者，一个gen_fsm和一个gen_server。</p>
<p>这是一篇gen_tcp和active_onece选项的概念证明文章。正如我一直说的，这只是我的学习笔记并且我可能是错的。所以查阅OTP文档和其他一些不错的书籍，可以发现关于这一主题的相关内容。</p>
<a id="more"></a>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>目标很简单，就是看看active_once选项如何控制数据流。也许这一次这个博客的简单概念证明的规则被打破了。本文的这个例子并不像以前那么简单，但我认为最终它是值得的。</p>
<h1 id="主动和非主动套接字"><a href="#主动和非主动套接字" class="headerlink" title="主动和非主动套接字"></a>主动和非主动套接字</h1><p>gen_tcp模块提供两种方式来读取套接字流，主动和非主动套接字。后者是传统的方式。通过使用recv/2和recv/3函数，进程决定什么时候从输入流读取数据。这种方式下，进程负责控制输入数据流。</p>
<p>另一方面，主动套接字允许按Erlang消息方式来接收数据。这种方式的问题是，对端进程可以无节制地发送数据来淹没我们进程的接收数据队列，因为我们的进程没有相应的流控策略。</p>
<p>不过现在有办法解决这个问题。通过设置active_once选项为true，进程按Erlang消息方式从套接字接收一次数据。一旦消息被接收到，套接字又转换为非主动方式，如果缓冲区满了，则阻止发送进程发送数据。进程可以再设置active_once选项来从套接字接收下一个Erlang消息来重复这个过程。</p>
<h1 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h1><p>控制进程就是当套接字被设置成主动或active_once的时候从套接字流接收到Erlang消息的那个进程。默认情况下，控制进程就是接收套接字的进程。</p>
<p>正如我们将看到的，可以用controlling_process/2函数来改变谁是控制进程。</p>
<h1 id="概念证明的结构"><a href="#概念证明的结构" class="headerlink" title="概念证明的结构"></a>概念证明的结构</h1><p>实际上，就如下图这么简单。</p>
<p><img src="/images/structure-poc.png" style="border:0;"></p>
<p><strong>main_sup: 主监督者。</strong></p>
<p><strong>listener_sup: 接收链接进程的监督者。</strong></p>
<p><strong>worker_sup: 读取工作者的监督者。</strong></p>
<p><strong>accept_fsm: 接收链接进程。</strong></p>
<p><strong>worker_gen: 套接字读取工作者。</strong></p>
<hr>
<p><strong>main_sup - 主监督者</strong></p>
<p>它使用permanent和one_on_one 重启策略。它有两个也是监督者的子进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(main_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"main_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    RestartStrategy = one_for_one,</div><div class="line">    MaxRestarts = <span class="number">10</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = permanent,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = supervisor,</div><div class="line"></div><div class="line">    ListenerSup = &#123;'listener_sup',</div><div class="line">		   &#123;'listener_sup', start_link, []&#125;,</div><div class="line">		   Restart, Shutdown, Type, ['listener_sup']&#125;,</div><div class="line"></div><div class="line">    WorkerSup = &#123;'worker_sup',</div><div class="line">		   &#123;'worker_sup', start_link, []&#125;,</div><div class="line">		   Restart, Shutdown, Type, ['worker_sup']&#125;,</div><div class="line"></div><div class="line">    ChildList = [ListenerSup, WorkerSup],</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, ChildList&#125;&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>listener_sup: 接收链接进程的监督者。</strong></p>
<p>它使用permanent和one_on_one 重启策略。它的子进程是accept_fsm进程。三个子进程被启动起来是为了准备大量链接的冲击。监听套接字在init函数里被创建，并且它的active属性设置为false，我们想使用默认的流控方式。</p>
<p>需要注意的是，三个子进程是用一个列表解析来创建的，在这里每一个id由build_label函数创建，结果id的格式是 accept_fsm_n，n是进程的顺序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(listener_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    &#123;ok, LSocket&#125; = gen_tcp:listen(<span class="number">2000</span>, [&#123;active, false&#125;]),</div><div class="line"></div><div class="line">    NumberOfWorkers = <span class="number">3</span>,</div><div class="line">    RestartStrategy = one_for_one,</div><div class="line">    MaxRestarts = <span class="number">100</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = permanent,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = worker,</div><div class="line"></div><div class="line">    ChildList = [&#123;build_label(<span class="string">"accept_fsm_"</span>, C),</div><div class="line">		  &#123;'accept_fsm', start_link, [LSocket]&#125;,</div><div class="line">		  Restart, Shutdown, Type, ['accept_fsm']&#125;</div><div class="line">		 || C &lt;- lists:seq(<span class="number">1</span>, NumberOfWorkers)],</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, ChildList&#125;&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">build_label</span><span class="params">(Name, C)</span> -&gt;</span></div><div class="line">    io_lib:format(<span class="string">"~s~w"</span>, [Name, C]).</div></pre></td></tr></table></figure>
<hr>
<p><strong>worker_sup: 读取工作者的监督者。</strong></p>
<p>它使用temporary和simple_on_on_one重启策略按需求来启动进程。它的子进程是worker_gen进程。它导出start_child/1函数，通过传递新的接收的套接字给此函数来启动一个worker_gen子进程。另外它设置新的子进程作为套接字的控制进程，这样该子进程就可以接收到Erlang消息流。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(worker_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, start_child/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:start_link...~n"</span>),</div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_child</span><span class="params">(ASocket)</span> -&gt;</span></div><div class="line">    &#123;ok, Pid&#125; = supervisor:start_child(?MODULE, [ASocket]),</div><div class="line">    gen_tcp:controlling_process(ASocket, Pid),</div><div class="line">    &#123;ok, Pid&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    RestartStrategy = simple_one_for_one,</div><div class="line">    MaxRestarts = <span class="number">100</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = temporary,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = worker,</div><div class="line"></div><div class="line">    AChild = &#123;'worker_gen', &#123;'worker_gen', start_link, []&#125;,</div><div class="line">	      Restart, Shutdown, Type, ['worker_gen']&#125;,</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, [AChild]&#125;&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>accept_fsm: 接收链接进程。</strong></p>
<p>这个进程被实现为一个FSM（有限状态机），而且只有一个状态，即accept状态。它接收一个侦听套接字并且在其上接收链接。当一个新的链接到来，这个进程设置套接收的套接字为active_once并且传递新的接收套接字给worker_sup请求其创建一个新子进程。然后这个进程再回到accept状态。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(accept_fsm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_fsm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_event/<span class="number">3</span>,</span></div><div class="line">	 handle_sync_event/<span class="number">4</span>, handle_info/<span class="number">3</span>, terminate/<span class="number">3</span>, code_change/<span class="number">4</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([accept/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">(LSocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:start_link...~n"</span>),</div><div class="line">    gen_fsm:start_link(?MODULE, [LSocket], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([LSocket])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:init...~n"</span>),</div><div class="line">    gen_fsm:send_event(self(), accept),</div><div class="line">    &#123;ok, accept, LSocket&#125;.</div><div class="line"></div><div class="line"><span class="comment">% Events.</span></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(accept, LSocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:accept...~n"</span>),</div><div class="line">    &#123;ok, ASocket&#125; = gen_tcp:accept(LSocket),</div><div class="line">    inet:setopts(ASocket, [&#123;active, once&#125;, &#123;packet, line&#125;]),</div><div class="line">    worker_sup:start_child(ASocket),</div><div class="line">    gen_fsm:send_event(self(), accept),</div><div class="line">    &#123;next_state, accept, LSocket&#125;.</div><div class="line"></div><div class="line"><span class="comment">% All events.</span></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(accept, _StateName, State)</span> -&gt;</span></div><div class="line">    &#123;next_state, accept, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_sync_event</span><span class="params">(_Any, _From, _StateName, State)</span> -&gt;</span></div><div class="line">    &#123;reply, ok, accept, State&#125;.</div><div class="line"></div><div class="line"><span class="comment">% OTP messeges.</span></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, StateName, State)</span> -&gt;</span></div><div class="line">    &#123;next_state, StateName, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _StateName, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, StateName, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, StateName, State&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>worker_gen: 套接字读取工作者。</strong></p>
<p>本文的概念证明就在这个进程里。它只是打印收到的数据到标准输出上。</p>
<p>为了观察流控的作用，在每次读取数据之间引入了一个延迟。在这种方式下，读取速度将比写的速度慢很多。当写缓冲满的时候会强制写进程停止写数据。</p>
<p>注意：每次读取数据后如何设置active_once选项以及如何设置packet类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(worker_gen)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_call/<span class="number">3</span>, handle_cast/<span class="number">2</span>, handle_info/<span class="number">2</span>,</span></div><div class="line">	 terminate/<span class="number">2</span>, code_change/<span class="number">3</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">(ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"worker_gen:start_link...~n"</span>),</div><div class="line">    gen_server:start_link(?MODULE, [ASocket], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([ASocket])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"worker_gen:init...~n"</span>),</div><div class="line">    &#123;ok, ASocket&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(&#123;tcp, _S, Data&#125;, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"~p~n"</span>, [Data]),</div><div class="line">    inet:setopts(ASocket, [&#123;active, once&#125;, &#123;packet, line&#125;]),</div><div class="line">    timer:sleep(<span class="number">100</span>),</div><div class="line">    &#123;noreply, ASocket&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(&#123;tcp_closed, _S&#125;, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Closed...~n"</span>),</div><div class="line">    &#123;stop, normal, ASocket&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(timeout, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Closed...~n"</span>),</div><div class="line">    &#123;stop, normal, ASocket&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Terminated...~n"</span>),</div><div class="line">    gen_tcp:close(ASocket),</div><div class="line">    ok.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<h1 id="代码的运行"><a href="#代码的运行" class="headerlink" title="代码的运行"></a>代码的运行</h1><p>让我们看看代码如何运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 17 [erts-6.1] [<span class="built_in">source</span>] [64-bit] [smp:4:4] [async-threads:10] [hipe]</div><div class="line">[kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V6.1  (abort with ^G)</div><div class="line">1&gt; l(main_sup).</div><div class="line">&#123;module,main_sup&#125;</div><div class="line">2&gt; main_sup:start_link().</div><div class="line">main_sup:init...</div><div class="line">listener_sup:init...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;0.35.0&gt;&#125;</div><div class="line">3&gt;</div></pre></td></tr></table></figure>
<p>我们链接上一个客户端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;0.35.0&gt;&#125;</div><div class="line">worker_gen:start_link...</div><div class="line">worker_gen:init...</div><div class="line">accept_fsm:accept...</div><div class="line">3&gt;</div></pre></td></tr></table></figure>
<p>然后从客户端写一些文本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;<span class="number">0.35</span>.<span class="number">0</span>&gt;&#125;</div><div class="line">worker_gen:start_link...</div><div class="line">worker_gen:init...</div><div class="line">accept_fsm:accept...</div><div class="line"><span class="string">"Hello World!!!\r\n"</span></div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>我们来写一大块数据并统计它的用时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time man ls|nc -c localhost 2000</div><div class="line"></div><div class="line">real	0m39.517s</div><div class="line">user	0m0.083s</div><div class="line">sys	0m0.019s</div><div class="line">$</div></pre></td></tr></table></figure>
<p>然后我们再做一次，不过这次我们去掉在每次读取数据之间的延迟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time man ls|nc -c localhost 2000</div><div class="line"></div><div class="line">real	0m0.100s</div><div class="line">user	0m0.085s</div><div class="line">sys	0m0.020s</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这两个测试让我们明白写进程是如何停下来等待缓冲区释放空间的。</p>
<p>在压力测试后，我们检查到没有进程泄露。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">3&gt; supervisor:count_children(main_sup).</div><div class="line">[&#123;specs,2&#125;,&#123;active,2&#125;,&#123;supervisors,2&#125;,&#123;workers,0&#125;]</div><div class="line">4&gt; supervisor:count_children(listener_sup).</div><div class="line">[&#123;specs,3&#125;,&#123;active,3&#125;,&#123;supervisors,0&#125;,&#123;workers,3&#125;]</div><div class="line">5&gt; supervisor:count_children(worker_sup).</div><div class="line">[&#123;specs,1&#125;,&#123;active,0&#125;,&#123;supervisors,0&#125;,&#123;workers,0&#125;]</div><div class="line">6&gt;</div></pre></td></tr></table></figure>
<p>我不太清楚这个解决方案有没有什么我不知道的问题。我尝试遵循我读过的Erlang和Elixir相关书籍中关于这个主题里学到模式。我可能有一些错误的地方，所以请阅读那些相关的书籍来获得关于这一主题的准确解释。</p>
<p>有任何更正、评论和建议请联系我，我很乐意听到你的反馈。</p>
<p>本文到此结束。</p>
<p>祝大家玩得开心。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://jmilet.github.io/erlang/2015/02/15/active_once.html" target="_blank" rel="external">http://jmilet.github.io/erlang/2015/02/15/active_once.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[总结2016，展望2017]]></title>
      <url>http://szpzs.oschina.io/2016/12/31/2016-Summary/</url>
      <content type="html"><![CDATA[<p><img src="/images/my-road.jpg" style="border:0;"></p>
<h1 align="center">2016年：在路上</h1><br><h1 align="center">2017年：往前走</h1><br><h1 align="center">做时间的朋友</h1>

]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[纯粹且简单的事务性内存]]></title>
      <url>http://szpzs.oschina.io/2016/12/29/pure-and-simple-transaction-memories/</url>
      <content type="html"><![CDATA[<p>本文是一篇纯技术文章。</p>
<p>几个并行的程序如何维护一个状态的一致性视图？我的意思是，两个程序，可能处于不同的国家，如何用一致性方式来操作共同的状态变量？他们如何用一种不需要任何锁的方式来做到这点？</p>
<a id="more"></a>
<p>答案是令人吃惊的简单和不可思议的优美，那就是使用叫做事务性内存的方法。</p>
<h1 id="事务性内存是如何运作的？"><a href="#事务性内存是如何运作的？" class="headerlink" title="事务性内存是如何运作的？"></a>事务性内存是如何运作的？</h1><p>首先我必须解释为什么并发地更新数据会是一个问题。</p>
<p><img src="/images/tm1_problem.0.jpg" style="border:0;"></p>
<p>想像有一个服务器<strong>S</strong>有状态变量<strong>X</strong>和两个客户端<strong>C1</strong>和<strong>C2</strong>。客户端从服务器获取数据（图1）。现在两个客户端都认为<strong>X=20</strong>。<strong>C1</strong>给<strong>X</strong>增加<strong>20</strong>同时<strong>C2</strong>给<strong>X</strong>增加<strong>30</strong>。它们修改它们本地的副本（图2），并且将数据写回服务器（图3和图4）。如果这些操作是一个接一个地进行，那么最后服务器上的X的值应该是70而不是50，很明显现在有问题出现了。</p>
<p>解决此问题的常规方法是在独立的事务发生时锁定服务器，但这种方法正如<a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-dont-like-shared-memory.html" target="_blank" rel="external">我前面一篇文章</a>中指出的一样，它会有问题。</p>
<p>为了允许这些更新并行地执行而且不锁资源，我们可以使用叫做<a href="http://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="external">事务性内存</a>的方法。</p>
<h1 id="事务性内存"><a href="#事务性内存" class="headerlink" title="事务性内存"></a>事务性内存</h1><p><img src="/images/tm2_solution.0.jpg" style="border:0;"></p>
<p>一个事务性内存是一个元组（<strong>Var</strong>,<strong>Version</strong>,<strong>Value</strong>）的集合。如上图，X的版本是1而值是20，Y的版本是6而值是true。</p>
<p>版本数字表示这个变量被修改的次数。</p>
<p>现在我们来尝试做一个事务操作。假设我们想修改<strong>X</strong>和<strong>Y</strong>。首先我们给服务器发送消息：<strong>{get,X,Y}</strong>，服务器返回两个变量的值和它们各自的版本数字。</p>
<p>修改变量后，我们向服务器发送消息：{put,(X,1,30),(Y,6,false)}。仅当所有变量的版本数字与服务器中的变量的版本数字匹配，服务器将接收这个消息。然后服务器接受变量的修改并回复消息：<strong>yes</strong>。如果任何变量的版本数字不匹配，则服务器回复消息：<strong>no</strong>。</p>
<p>很明显，如果第二个进程在第一个进程回答之前更新内存，那么版本号将不一致，更新将失败。</p>
<p>请注意，该算法不锁定数据而且在一个分布式的环境中工作得很好，客户端和服务器处于物理上不同的机器上，这些机器之间的传输延迟是未知的。</p>
<p><strong>这不正是很好而且很老的基于set操作之上归纳出来的test-and-set操作吗？</strong></p>
<p>是的，当然是。如果你想想他们如何用信号量实现互斥的就明白了。信号量用一个原子的<strong>test-and-set</strong>指令来实现。一个信号量的值只能为0或1。test-and-set操作就是说，如果这个变量的值是0那么就把它的值改为1，这个操作是原子性的。要保留一个关键区域，它由一个标志保护。如果标志为0，那么它可以被保留，如果标志为1，那么它可以被使用。为了避免两个进程同时保留这个关键区域，test-and-set操作必须是原子性的。事务性内存只是概括了这个方法。</p>
<p>现在让我们用Erlang来实现它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(tm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, addVar/<span class="number">2</span>, getVars/<span class="number">2</span>, putVars/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% new() -&gt; Pid</span></div><div class="line"><span class="comment">%%   创建一个新的事务性内存 (TM)</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% addVar(Pid, Var) -&gt; ok</span></div><div class="line"><span class="comment">%%   增加一个变量到事务性内存</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% getVars([V1,...]) -&gt; [&#123;Vsn,Data&#125;,....]</span></div><div class="line"><span class="comment">%%   在事务性内存里查询变量V1，V2，...</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% putVars([&#123;Var,Vsn,Data&#125;]) -&gt; Bool</span></div><div class="line"><span class="comment">%%   修改事务性内存里的变量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">%% 下面是一个运行的例子</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% 1&gt; c(tm).</span></div><div class="line"><span class="comment">%% &#123;ok,tm&#125;</span></div><div class="line"><span class="comment">%% 2&gt; P=tm:new().</span></div><div class="line"><span class="comment">%% &lt;0.47.0&gt;</span></div><div class="line"><span class="comment">%% 3&gt; tm:addVar(x).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 4&gt; tm:addVar(P,x).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 5&gt; tm:addVar(P,y).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 6&gt; tm:getVars(P, [x,y]).</span></div><div class="line"><span class="comment">%% [&#123;ok,&#123;0,void&#125;&#125;,&#123;ok,&#123;0,void&#125;&#125;]</span></div><div class="line"><span class="comment">%% 7&gt; tm:putVars(P, [&#123;x,0,12&#125;,&#123;y,0,true&#125;]).</span></div><div class="line"><span class="comment">%% yes</span></div><div class="line"><span class="comment">%% 8&gt; tm:putVars(P, [&#123;x,1,25&#125;]).</span></div><div class="line"><span class="comment">%% yes</span></div><div class="line"><span class="comment">%% 9&gt; tm:getVars(P, [x,y]).</span></div><div class="line"><span class="comment">%% [&#123;ok,&#123;2,25&#125;&#125;,&#123;ok,&#123;1,true&#125;&#125;]</span></div><div class="line"><span class="comment">%% 10&gt; tm:putVars(P, [&#123;x,1,15&#125;]).</span></div><div class="line"><span class="comment">%% no</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span> spawn(<span class="keyword">fun</span>() -&gt; loop(dict:new()) <span class="keyword">end</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">addVar</span><span class="params">(Pid, Var)</span> -&gt;</span> rpc(Pid, &#123;create, Var&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">getVars</span><span class="params">(Pid, Vgs)</span> -&gt;</span> rpc(Pid, &#123;get, Vgs&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">putVars</span><span class="params">(Pid, New)</span> -&gt;</span> rpc(Pid, &#123;put, New&#125;).</div><div class="line"></div><div class="line"><span class="comment">%% 内部函数</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% 远程过程调用（RPC）</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Q)</span> -&gt;</span></div><div class="line">   Pid ! &#123;self(), Q&#125;,</div><div class="line">   <span class="keyword">receive</span></div><div class="line">       &#123;Pid, Reply&#125; -&gt; Reply</div><div class="line">   <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(Dict)</span> -&gt;</span></div><div class="line">   <span class="keyword">receive</span></div><div class="line">     &#123;From, &#123;get, Vars&#125;&#125; -&gt;</div><div class="line">        Vgs = lists:map(<span class="keyword">fun</span>(I) -&gt;</div><div class="line">                 dict:find(I, Dict) <span class="keyword">end</span>, Vars),</div><div class="line">        From ! &#123;self(), Vgs&#125;,</div><div class="line">        loop(Dict);</div><div class="line">     &#123;From, &#123;put, Vgs&#125;&#125; -&gt;</div><div class="line">        <span class="keyword">case</span> update(Vgs, Dict) <span class="keyword">of</span></div><div class="line">        no -&gt;</div><div class="line">                From ! &#123;self(), no&#125;,</div><div class="line">                  loop(Dict);</div><div class="line">        &#123;yes, Dict1&#125; -&gt;</div><div class="line">                From ! &#123;self(), yes&#125;,</div><div class="line">                loop(Dict1)</div><div class="line">        <span class="keyword">end</span>;</div><div class="line">    &#123;From, &#123;create, Var&#125;&#125; -&gt;</div><div class="line">       From ! &#123;self(), ok&#125;,</div><div class="line">       loop(create_var(Var, Dict))</div><div class="line">   <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">update</span><span class="params">([&#123;Var,Generation,Val&#125;|T], D)</span> -&gt;</span></div><div class="line">    &#123;G, _&#125; = dict:fetch(Var, D),</div><div class="line">    <span class="keyword">case</span> Generation <span class="keyword">of</span></div><div class="line">     G -&gt; update(T, dict:store(Var, &#123;G+<span class="number">1</span>, Val&#125;, D));</div><div class="line">     _  -&gt; no</div><div class="line">    <span class="keyword">end</span>;</div><div class="line"><span class="function"><span class="title">update</span><span class="params">([], D)</span> -&gt;</span></div><div class="line">    &#123;yes, D&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_var</span><span class="params">(Var, Dict)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> dict:find(Var, Dict) <span class="keyword">of</span></div><div class="line">   &#123;ok, _&#125; -&gt; Dict;</div><div class="line">   error -&gt; dict:store(Var, &#123;<span class="number">0</span>,void&#125;, Dict)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/09/pure-and-simple-transaction-memories.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/09/pure-and-simple-transaction-memories.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么我不喜欢共享内存]]></title>
      <url>http://szpzs.oschina.io/2016/12/26/why-i-dont-like-shared-memory/</url>
      <content type="html"><![CDATA[<p>在我上一篇博文《<a href="http://armstrongonsoftware.blogspot.com/2006/08/concurrency-is-easy.html" target="_blank" rel="external">并发是容易的</a>》里，我写了关于编写并发系统的一个简单模型。当你写博客的时候，你必须考虑目标受众和你想把博客定位在哪个级别上。它应该是技术先进的，还是应该普及你想谈论的观点？</p>
<a id="more"></a>
<p>我选择了用一个明显的非技术性的方式来谈论并发，我用人们互相交谈来类比并发这个概念。在我的博文里，我认为进程应该表现得很像人。人有私有的记忆并通过消息传递来改变自己的私有记忆。</p>
<p>现在对此文的反应超出了我的预料。首先很多人读我写的东西，这是一个惊喜。几乎没有宣传的情况下，这篇文章达到programming.reddit.com所有文章的第三位。事实上，上个星期三，排名reddit.com编程文章前五位的文章有三篇是关于Erlang的。其次，在reddit.com上有一个关于我这篇博文的讨论开始了。</p>
<p>在这里，我将回答在讨论里提出的第一个问题：</p>
<blockquote>
<p>Dogger说：</p>
<blockquote>
<p>我不太清楚为什么没有共享的内存会如此厉害。他抛出的简单的一问一答消息的例子并不是许多程序的工作机制。我认为发送消息有其地位，共享内存也一样。选择哪一个是最合适的。</p>
</blockquote>
</blockquote>
<p>很棒的评论！我们认为理所当然的事情是我们觉得最不需要解释的事情。现在我认为共享内存是错误的。在过去的二十年里，我一直这样认为，我认为这是不证自明的，而且从来没有真正解释为什么我认为共享内存是一个坏主意。所以在下面我将给出一些为什么我不喜欢共享内存的原因。</p>
<p>Dogger的第二个评论是：“他的例子…并不真正是很多程序的工作机制”，他这个评论当然是正确的。许多程序并不以我建议的方式来运行。关键点是这些程序可以用不同的编程风格编写，完全避免了共享内存和锁，并且利用了细粒度并发和纯消息传递。我也相信这样的程序更容易写和理解，因为我下面列出的所有与共享内存有关的问题都被避免了。请注意，我没有表明我有一个解决任何如下问题的方案。但我会说，这样的问题可以使用不同的编程风格来完全避免。</p>
<p>现在我将开始讲讲为什么我不喜欢共享内存：</p>
<h1 id="问题1：在关键区域崩溃的程序"><a href="#问题1：在关键区域崩溃的程序" class="headerlink" title="问题1：在关键区域崩溃的程序"></a>问题1：在关键区域崩溃的程序</h1><p>当两个或更多程序想要共享内存的时候下面的方法通常被用到。任何程序想操作共享内存必须如下列出的步骤来做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.操作共享内存</div><div class="line">3.释放这个锁</div></pre></td></tr></table></figure>
<p>获取锁之后和释放锁之前程序运行的代码被成为<em>关键区域</em>。在关键区域里的程序在运行期间不应该崩溃，而且在关键区域内不应该花太多时间。</p>
<p>如果程序在关键区域内崩溃的话会发生什么？</p>
<p>如果出现这种情况，则事情会变得很复杂。在理想的世界里，我们想要有这样的事务语义，即程序运行的净效应将是关键区域内的所有内存的改变都成功了，或者没有一个内存的改变成功并且内存的状态和程序进入关键区域前相同。</p>
<p>假设A尝试修改10个内存区域，这些区域叫做M1、M2…M10，那么程序假设如下所列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.修改 M1</div><div class="line">3.修改 M2</div><div class="line">4....</div><div class="line">5.修改 M10</div><div class="line">6.释放这个锁</div></pre></td></tr></table></figure>
<p>但是实际上可能是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.修改 M1</div><div class="line">3.修改 M2</div><div class="line">4.崩溃</div></pre></td></tr></table></figure>
<p>我们运行A想要的结果是，要么M1到M10的修改都成功，要么M1到M10的修改都不成功。因此，在上述第4步崩溃时，我们希望撤消前两个内存修改的结果。</p>
<p>要做到这点非常复杂，要假设有一些监督者程序在崩溃事件里能侦测到线程的崩溃并且恢复内存到原始状态。</p>
<h1 id="问题2：程序在关键区域花费太多时间"><a href="#问题2：程序在关键区域花费太多时间" class="headerlink" title="问题2：程序在关键区域花费太多时间"></a>问题2：程序在关键区域花费太多时间</h1><p>当一个程序位于一个关键区域内时，会发生很多事情，它可以操纵内存，这就是为什么它必须首先处于关键区域；并且它可以执行计算。问题是，这些计算发生时，该程序是在关键区域内。因此，如果这些计算需要很长的时间，那么等待访问共享内存的所有其他程序都将被排队，直到当前程序离开关键区域为止。</p>
<p>写在关键区域内执行的代码是非常困难的，因为我们要避免非常耗时的计算并将它们移到关键区域之外。我们还必须删除关键区域中的远程过程调用之类的东西，以防它们突然占用太长时间。所有这一切都是非常不自然的编程方式，很难难得到正确的结果。</p>
<h1 id="问题3：锁得太多"><a href="#问题3：锁得太多" class="headerlink" title="问题3：锁得太多"></a>问题3：锁得太多</h1><p>非常不幸地是我们经常锁的内存比我们想要的多得多，程序通常都是锁住所有共享内存，却只操作其中的一小段。在允许指针直接修改内存的语言中，可以保护的最小内存大小由页面表的粒度决定。一个典型的页面大小可能在8k到64k字节范围。8k字节的页面，你可能只想保护一个单字节，但你不得不保护最少8k字节。</p>
<p>您的程序可能只需要保护1字节，而系统中的其他程序可能希望修改在同一页的其他部分的内存，但它们必须等待，直到你的程序离开这个关键区域，它们才可以操纵他们相关的内存部分。</p>
<p>现在这一点在一个单CPU上可能并不重要，不同的线程都运行在同一个CPU，CPU总是忙，至少它在做一些事情。但在多核处理器上，这一点确实很重要。在多核CPU上，许多进程会等待获取锁，尽管逻辑上所有这些CPU可以并行运行。</p>
<p>当然，我们可以将共享内存划分成不同的分区，并让程序锁定到他们感兴趣的内存部分，但这样编程变得更加困难。</p>
<h1 id="问题4：分布式共享内存"><a href="#问题4：分布式共享内存" class="headerlink" title="问题4：分布式共享内存"></a>问题4：分布式共享内存</h1><p>现在事情变得真正复杂了。在单个主板上真正只有一个内存可以被不同的CPU访问，但在一个集群或在网络分布式系统，这是不可行的。真正发生的是，系统中的每个节点都有自己的内存，并且读写和锁被应用到本地内存。在任何一个系统中，其中一个内存必须承担某种主导角色，系统中的其他内存承担次要角色，并表现为高速缓存。然后在不同的内存之间运行某种缓存一致性协议，以确保访问该存储器的所有进程具有一致的世界观。</p>
<p>现在所有这一切是非常难以实现的。所以在这一点上，大多数程序员只有放弃并且使用容错分布式数据库。这种数据库通常是相当缓慢的，因为它必须在后台做很多复杂的东西。</p>
<h1 id="问题5：共享限制可扩展性"><a href="#问题5：共享限制可扩展性" class="headerlink" title="问题5：共享限制可扩展性"></a>问题5：共享限制可扩展性</h1><p>共享数据的线程不能独立地和并行地运行。在一个单核CPU上无所谓，但是在一个多核CPU上就有问题了。在线程共享数据的地方执行，它们的执行变成串行而不是并行。线程中的关键区域引入了限制可扩展性的串行瓶颈。</p>
<p>如果我们真的想要高性能，我们必须确保我们的应用程序不共享任何数据，这样我们就可以在许多独立的CPU上复制我们的解决方案。</p>
<h1 id="问题6：共享可以引入死锁"><a href="#问题6：共享可以引入死锁" class="headerlink" title="问题6：共享可以引入死锁"></a>问题6：共享可以引入死锁</h1><p>有时我们试图通过某种形式的细粒度共享来增加并发性。我们的想法是，不是锁定我们所有的内存，而是把内存分成更小的区域，只锁定那些我们感兴趣的内存。现在想象两个线程P和Q想要访问内存区域A和B。假设P锁定内存区域A，然后等待内存区域B，而Q刚好相反，即它先锁定B然后等待A。这导致死锁，P和Q现在无限期暂停。</p>
<h1 id="问题7：共享使得系统容易出错和调试困难"><a href="#问题7：共享使得系统容易出错和调试困难" class="headerlink" title="问题7：共享使得系统容易出错和调试困难"></a>问题7：共享使得系统容易出错和调试困难</h1><p>假设两个线程A和B共享数据。在A里的一个错误能够覆盖B使用的数据。即使B的代码都是正确的，它可能也会崩溃，因为它操作的数据结构被A破坏了。那么所有的系统应该完美地服从 <strong>我的程序不应该能够搞崩溃你的程序</strong>  这样的规则，但是当程序可以共享数据的情况下，这样的规则显然不成立。</p>
<p>调试变得可怕。线程B已经崩溃了，所以假定线程B的代码是不正确的似乎是合理的。这个假设是错误的，因为线程A的代码可能是祸因。这种因果分离使得调试非常困难。</p>
<p>最后，一个更普遍的评论是：</p>
<p><strong>共享不存在于现实世界中</strong></p>
<p>我以前是一个物理学家。在经典物理学中同时忽略量子效应情况下，现实世界中的两个物体不能同时存在于同一地点。</p>
<p>如果我们有两个物体，它们必须在不同的地方。现在，一个对象可以与另一个对象交互的唯一方式就是发送一条消息（比如说用光线）。如果光线编码一些关于状态变化的信息，那么就关心状态变化的接收对象而言，状态的变化只有在它消息收到后它才知道。</p>
<p>在简单的相对论里，同时发生的概念是不存在的。</p>
<p>关键点是现实中的对象不共享状态，我相信在软件中建模现实中不存在的东西不是一个好主意。</p>
<p>事实上您需要共享和锁来实现并行软件的想法是错误的。一切可以用共享和锁实现的，也可以用纯消息传递和无锁来实现。这就是<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>的方式。</p>
<p>在未来的博文中，我将告诉你如何做一个事务内存，它提供了一个无锁的方法在并行进程集里实现细粒度的状态一致性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/09/why-i-dont-like-shared-memory.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/09/why-i-dont-like-shared-memory.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[并发是容易的]]></title>
      <url>http://szpzs.oschina.io/2016/12/25/concurrency-is-easy/</url>
      <content type="html"><![CDATA[<p>我们了解并发。</p>
<p>对并发的深入理解已经深植于我们的大脑。我们对刺激的反应非常迅速，这由大脑的被称为杏仁核的一部分负责，没有这个反应系统我们可能会死掉。有意识的想法太慢了，当“刹车”的想法形成的时候，我们已经那么做完了。</p>
<a id="more"></a>
<p><img src="/images/many_cars.0.jpg" style="border:0;"></p>
<p>在高速公路，我潜意识地判断几十或数百辆汽车的位置，这样做是没有经过有意识的思考的。如果我不能这样做，我可能会死掉。</p>
<h1 id="世界是并行的"><a href="#世界是并行的" class="headerlink" title="世界是并行的"></a>世界是并行的</h1><p>如果我们想写的程序的行为和真实世界里事物的行为一样，那么这些程序将有一个并发的结构。</p>
<h1 id="这就是为什么我们应该用并发的编程语言编程"><a href="#这就是为什么我们应该用并发的编程语言编程" class="headerlink" title="这就是为什么我们应该用并发的编程语言编程"></a>这就是为什么我们应该用并发的编程语言编程</h1><p>然而，大多数情况下，我们用顺序的编程语言编程现实世界的应用程序。这肯定很困难。</p>
<p>用被设计为编写并发应用程序的语言（比如<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>）来编程，那么并发编程会变得容易很多。</p>
<h1 id="Erlang程序模型，我们如何思考和交互"><a href="#Erlang程序模型，我们如何思考和交互" class="headerlink" title="Erlang程序模型，我们如何思考和交互"></a>Erlang程序模型，我们如何思考和交互</h1><p>我们没有共享记忆。我有我的记忆，你有你的记忆，我们俩一共有两个大脑，彼此独立，它们不连在一起。为了要改变你的记忆，通过说话或挥动我的手臂的方式我发一个消息给你。你听到或看到，然后你的记忆改变了。但是如果我不问你或者不观察你的反应，我就不知道你是否收到了我发给你的消息。</p>
<p>Erlang进程也是如此。Erlang进程没有共享内存。每个进程有它自己的内存。为了改变其他进程的内存，你必须发送消息给它们并希望它们收到而且理解你发的消息的意思。</p>
<p>为了确认其他进程收到你的消息并改变了它的内存，你必须问它们（通过发送一条消息）。这正是我们人类如何彼此交互的方式。</p>
<p>苏：“嗨，比尔，我的电话号码是45 67 89 12”。</p>
<p>苏：“你听见了吗？”。</p>
<p>比尔：“收到，你的电话号码是45 67 89 12”。</p>
<p>这些互动模式对于我们来说非常熟悉，从出生开始，我们通过观察外部世界，并且通过发送信息给外部世界同时通过观察外部世界的反馈来学习与外部世界交互。</p>
<h1 id="人们作为独立实体通过发送消息进行交互"><a href="#人们作为独立实体通过发送消息进行交互" class="headerlink" title="人们作为独立实体通过发送消息进行交互"></a>人们作为独立实体通过发送消息进行交互</h1><p>这就是Erlang进程的工作方式，也是我们的工作方式，所以我们可以非常容易理解Erlang程序。</p>
<p>Erlang程序由许多小进程组成，这些进程之间总在喋喋不休的交流，就像我们人类。</p>
<p>一个Erlang程序由数十，可能数千，甚至数十万小进程组成。所有这些进程独立地运行。它们彼此通过发送消息来交流。每个进程有自己的私有内存。它们的行为就像一座大房子里的人们一样彼此通过聊天来交流。</p>
<p>这使得Erlang程序天生就容易管理和扩展。假设我们有十个人（进程），他们有太多的工作要做，我们该如何处理？答案就是让更多的人来做。我们怎么管理这些人？简单地朝他们喊指令就行（广播）。</p>
<p>Erlang进程没有共享内存，所以当一块内存被使用的时候就没必要给它上锁。有锁就需要钥匙，只要有锁，就有可能某天会丢失钥匙。当你丢了钥匙，会怎么样？你会惊慌失措。</p>
<p>有锁和钥匙的分布式软件系统总是出错。</p>
<h1 id="如果有人死了，其他人会注意到"><a href="#如果有人死了，其他人会注意到" class="headerlink" title="如果有人死了，其他人会注意到"></a>如果有人死了，其他人会注意到</h1><p>我在一个房间里，突然倒下死了，别人可能会注意到，至少我希望是如此。Erlang进程和我们人是一样的，他们有时也会死。不像人们死去时那样，Erlang进程在它们最后一口气的时候会大声喊出他们到底死于什么。</p>
<p>想象一个有很多人的房间，突然一个人倒下并死掉。就在他死亡的一刻，他说，“我死于心脏病”，或者，“我死于胃出血”。这就是Erlang进程的做法。一个进程死的时候可能会说：“我死于被要求被零除”，另一个进程死的时候可能会说：“我死于被要求查询空列表的最后一个元素是什么”。</p>
<p>现在在我们这个很多人的房间里，我们可以想象有一些人被特别地赋予清理尸体的特殊工作。假设有两个人，简和约翰。如果简死了，约翰会处理简的后事。如果约翰死了，简会处理约翰的后事。简和约翰被一个看不见的约定联系在一起，只要他们中的一个死亡，另一个就会处理后事。</p>
<p>这就是Erlang的错误发现机制，进程可以被链接在一起。如果其中一个进程死掉，其他进程会获得一个错误消息，这个消息告诉他们死亡进程的死亡原因。</p>
<p>基本上就是这样的。</p>
<p>这就是Erlang程序的工作机制。</p>
<h1 id="到目前为止我们学到了什么"><a href="#到目前为止我们学到了什么" class="headerlink" title="到目前为止我们学到了什么"></a>到目前为止我们学到了什么</h1><p>Erlang程序由许多进程组成。这些进程彼此之间可以发送消息。这些消息可能会或可能不会被接收和理解。如果你想知道消息是否被接收和理解，你必须给进程发送一条消息并等待回复。</p>
<p>进程可以被链接在一起。如果链接中的一个进程死掉，其他的进程会被发送一条包含这个进程为什么死掉的消息。</p>
<p>这个简单的编程模型是被我称为面向并发编程模型的一部分。你可以在<a href="http://www.sics.se/~joe/thesis" target="_blank" rel="external">这里</a>参阅更多信息。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/08/concurrency-is-easy.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/08/concurrency-is-easy.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我们没有走过的路]]></title>
      <url>http://szpzs.oschina.io/2016/12/24/road-we-didnt-go-down/</url>
      <content type="html"><![CDATA[<p>我一直在关注Erlang邮件列表里的一个有趣的讨论，在这个讨论里，Steve Vinoski和朋友们告诉我们RPC的问题是什么。</p>
<p>讨论开始在5月22日，共同话题是facebook宣布已部署了一个用Erlang写的聊天服务器。</p>
<p>在其中的一个帖子里Steve写道：</p>
<a id="more"></a>
<blockquote>
<p>“所有那些年的 CORBA 经验教给我的，也就是那个RPC，因为一些原因，总的来说它是一个<strong>真正的坏主意</strong>。它是一个来之不易的教训。Erlang 的 RPC 是很棒的，因为整个 Erlang 系统从根本上设计并将其内置到语言中，但对于普通的语言，RPC 带来的问题比它解决的问题多。”<br><a href="http://www.erlang.org/pipermail/erlang-questions/2008-May/035191.html" target="_blank" rel="external">更多…</a><br>– Steve Vinoski</p>
</blockquote>
<p>后续的帖子要求Steve详细阐述这点。</p>
<p>Steve在Erlang邮件列表里发了一篇很长并且精彩的关于RPC问题总结的帖子：</p>
<blockquote>
<p>“但是如果你没有时间或精力，最根本的问题是，RPC试图使得一个分布式调用看起来像一个本地调用。这是行不通的，因为在分布式系统中的错误模式完全不同于本地系统中的错误模式，……”<br><a href="http://www.erlang.org/pipermail/erlang-questions/2008-May/035207.html" target="_blank" rel="external">更多…</a><br>– Steve Vinoski</p>
</blockquote>
<p>精辟！是的，是的，是的。当我读到这个，我的大脑大叫：是的，是的，是的 - 谢谢你，史提夫。史提夫在《<a href="http://steve.vinoski.net/pdf/IEEE-RPC_Under_Fire.pdf" target="_blank" rel="external">RPC Under Fire</a>》里关于这点写了更多。</p>
<h1 id="这是一条我们没走过的路"><a href="#这是一条我们没走过的路" class="headerlink" title="这是一条我们没走过的路"></a>这是一条我们没走过的路</h1><p>Steve沿着这条路走，看见一些事情，也看到它非常糟糕的地方，但他活着回来，可以告诉我们他所看见的事情。</p>
<p>调用一个远程操作并且包装它看起来像一个本地操作的根本问题是本地的错误模式和远程操作的错误模式是完全不同的。</p>
<p>如果这还不够糟糕，性能方面也完全不同。本地的操作需要几微秒，当通过一个RPC执行的时候，可能忽然就花掉几毫秒。</p>
<p>如果程序员不能判断本地和远程调用之间的不同，那么要写出高效的代码基本不可能。随意放置RPC在一些乱七八糟的软件中可以（必定）破坏性能。</p>
<blockquote>
<p>我亲眼见证了几个大型项目的失败，正是因为本地和远程过程调用之间的区别还不清楚。</p>
</blockquote>
<p>注意：这个因素在有几十个程序员参与的大项目里变得更糟糕。如果是一个小团队，则还有机会挽救，这需要参与者清楚哪些是本地调用，哪些是是远程调用。</p>
<h1 id="在Erlang的世界我们是如何做的？"><a href="#在Erlang的世界我们是如何做的？" class="headerlink" title="在Erlang的世界我们是如何做的？"></a>在Erlang的世界我们是如何做的？</h1><p>所有Erlang程序是由并行进程集合组成的，这些进程可以创建其他进程并且发送和接收消息。这么做非常简单而且是一个轻量操作。</p>
<p>为了错误处理的目的，进程可以彼此链接在一起。如果A链接到B并且A崩溃了，那么B会被发送一个错误信号，反之亦然。链接机制与消息发送/接收机制完全正交。</p>
<p>当我们编写分布式系统，各种形式的RPC通常是非常有用的编程抽象，但RPC的确切形式因问题不同而不同，也因系统架构不同而不同。</p>
<p>RPC的确切形式凝固成一个刚性框架，不顾错误场景是场灾难。</p>
<p>用发送、 接收和链接，Erlang 程序员可以很容易把自定义错误处理“揉进他们自己的RPC”。</p>
<p>在Erlang里没有“标准PRC存根生成器”，Erlang也没有聪明到有一个如此的生成器。</p>
<p>在很多应用里，RPC尽可能最简单的形式就够了，我们可以定义它如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">     &#123;Pid, Response&#125; -&gt;</div><div class="line">        Response</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这一点都不复杂。这段代码只是发送一条消息然后等待回复。</p>
<p>在这个主题上有很多的变化。最简单的RPC将永远等待下去，所以如果回复一直不来的话，客户端就会挂起。我们可以用增加超时来修复这个问题：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request, Time)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    &#123;Pid, Response&#125; -&gt;</div><div class="line">        &#123;ok, Response&#125;</div><div class="line">    <span class="keyword">after</span> Time -&gt;</div><div class="line">        &#123;error, timeout&#125;</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>假设我们希望在一个PRC调用中远程机器死掉的时候一个异常在客户端被抛出，那么我们可以写如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></div><div class="line"> link(Pid),</div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    Response -&gt;</div><div class="line">        Response</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>如果在RPC里有任何差错的话，附加的链接将确保客户端终止。</p>
<p>假设我们想要“并行化两个RPC”，则代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid1, Pid2, Request)</span> -&gt;</span></div><div class="line"> Pid1 ! Pid2 ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    &#123;Pid1, Response1&#125; -&gt;</div><div class="line">        <span class="keyword">receive</span></div><div class="line">            &#123;Pid2, Response2&#125; -&gt;</div><div class="line">                &#123;Response1, Response2&#125;</div><div class="line">        <span class="keyword">end</span></div><div class="line">     <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>（不用担心这段代码的执行，消息的回复顺序是无关紧要的。）</p>
<p>我想通过一些小例子来说明的观点是，RPC的粒度级别和错误特性是在编程人员的精确控制下的。</p>
<p>如果事实证明这些RPC的抽象不是我们真正想要的，然后我们可以很容易地用原始的进程和消息方式来写我们的解决方案。</p>
<p>所以，例如，从一个消息序列图得到Erlang代码是一个简单的编程工作。</p>
<p>“标准”的RPC也做以下的疯狂的假设”，回复应该一定返回到客户”。</p>
<p>互相合作的形式，比如告诉X做Y然后发送结果到Z，这种形式是不可能用一个标准的 RPC 框架（如 SOAP)来表达的，但在Erlang中表达却很简单︰</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(tell,X,toDo,Y,replyTo,Z)</span> -&gt;</span></div><div class="line"> X ! &#123;Z, Y&#125;.</div></pre></td></tr></table></figure>
<p>（这里假设约定我前面一直用发送两个元素的元组当作消息，其中有进程的Id，它被期待当作回复消息的元组的第一元素（在前面的例子例我们用self()，这样就强制要求回复消息返回给原请求者））</p>
<p>假设我们要加版本信息到我们的协议，这也很容易做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request, Vsn)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), vsn, Vsn, Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">     ...</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>关键点是，这里展示的事情，比如像版本信息、错误处理平行化等等都是容易添加的，只要我们暴露消息和函数调用之间的接口并允许用户定制构建他们自己和远程代码的交互形式。</p>
<p>当然，组件间交互的一定通用模式将浮现，它们被加入OTP库。</p>
<h1 id="什么是OTP？"><a href="#什么是OTP？" class="headerlink" title="什么是OTP？"></a>什么是OTP？</h1><p>OTP是在相当常见的场景下像RPC一样做事的一套久经测试验证的方法。OTP方法没有覆盖所有错误场景，不过它们覆盖了通常的场景。我们经常需要跨出OTP框架外设计我们自己特定的错误和恢复策略，不过做这些都很简单，因为OTP它自己是一个消息驱动的框架，所有我们必须要做的是去掉那些存根函数，用我们自己定制的函数来替换它们来发送和接收消息。</p>
<p>OTP应该重新命名为“OTP on rails”，它真的只是一个构建容错系统的框架。</p>
<p>这种没有过度依赖一个特别的RPC方式来构建软件的方法可行吗？</p>
<p>我的回答是可行的，而且肯定可行。</p>
<p>我们用这种方式构建实时服务器软件在爱立信已经有几十年了。我们已经用PLEX, EriPascal, Erlang 和 C++ with Rose-RT好多年了。所有这些的共同点就是不依赖RPC。我们指定协议，然后我们用一些不同的技术实现它们。</p>
<p>这些协议比指定使用的RPC是更复杂的方式，但是通过暴露协议和错误模式，我们可以使得系统高可用。</p>
<p>我一直认为如果我们用RPC来做事情，我们会遇到麻烦。</p>
<p>Steve这么做过也遇到了这些问题，而我们走的是不同的路。</p>
<p>真正有趣的是，史提夫的世界和我们的世界开始碰撞-我们有很多东西要互相学习。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2008/05/road-we-didnt-go-down.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2008/05/road-we-didnt-go-down.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Erlang里用进程保存状态]]></title>
      <url>http://szpzs.oschina.io/2016/12/19/storing-state-in-erlang-with-processes/</url>
      <content type="html"><![CDATA[<p>状态是我们如何使程序做不平凡的事情。如果我们正在写一个电子游戏，它的一个状态可能是一个被打败的坏人的数字。在大多数编程语言中，我们将通过将计数分配给变量，然后在每次新的坏人被击败时更新这个值来实现这一点。然而，一旦变量已经被赋值（单次赋值），Erlang不允许我们修改这个变量的值。那么如果我们不能够改变一个变量的值，我们如何在Erlang里跟踪状态？答案是：用进程。</p>
<a id="more"></a>
<h1 id="单次赋值"><a href="#单次赋值" class="headerlink" title="单次赋值"></a>单次赋值</h1><p>Erlang从单次赋值中获得很多的能力。单次赋值意味着，一旦一个值被赋予一个变量，则没有其他值可以被赋予这同一个变量。在许多Erlang的教程里你可以看到像如下一样的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; X = <span class="number">1</span>.</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; X = <span class="number">2</span>.</div><div class="line">** exception error: no match <span class="keyword">of</span> right hand side value <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在第一步，Erlang尝试用值1<a href="http://learnyousomeerlang.com/syntax-in-functions" target="_blank" rel="external">模式匹配</a>X。因为X没有被绑定，所以它被绑定到值1。从现在开始，当X在模式匹配操作符的左手边的时候，普通的模式匹配就会发生。这就是为什么我们在第二步得到一个错误 - Erlang尝试用值2去和已经有值为1的X匹配，因此引起一个无法匹配的错误。我们依然可以匹配X只要右手边相应的值是1，如下例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; X = <span class="number">1</span>.</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; &#123;X, <span class="number">2</span>&#125; = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;.</div><div class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>单次赋值是Erlang的一个非常棒的的优点，因为它减少了有<a href="http://en.wikipedia.org/wiki/Side_effect_computer_science" target="_blank" rel="external">副作用</a>的函数调用的可能。副作用使得写高并发的代码非常困难。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>在本文剩下的部分我们将使用一个计数器的例子。我的意思是通过一个计数器也就是一段简单的代码，它能够保持计数值，并提供一个API增值和（或）访问计数的值。这是一个关于状态的非常简单的例子；计数器的状态就是计数的值。</p>
<p>面向对象语言做这个例子非常简单，它很自然地存储状态到类实例的变量里。例如，用Ruby来实现一个简单的计数器，我们可能会像下面这样做：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ruby里一个简单面向对象计数器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @count = <span class="number">0</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">click</span></span></div><div class="line">    @count += <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">c = Counter.new</div><div class="line">c.click <span class="comment"># =&gt; <span class="doctag">@count</span> is now 1</span></div><div class="line">c.click <span class="comment"># =&gt; <span class="doctag">@count</span> is now 2</span></div></pre></td></tr></table></figure>
<p>@count是Counter类的一个实例变量。当我们通过调用Counter.new来创建Counter类的一个新实例的时候，在构造器（函数initialize）里@count被初始化为0。每次我们调用click方法，@count的值被增加一。@count持有计数器的状态。我们可以很容易地创建多个计数器，它们都有自己私有的状态。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c1 = Counter.new</div><div class="line">c2 = Counter.new</div><div class="line">c1.click <span class="comment"># =&gt; 1</span></div><div class="line">c1.click <span class="comment"># =&gt; 2</span></div><div class="line">c2.click <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<h1 id="递归和状态"><a href="#递归和状态" class="headerlink" title="递归和状态"></a>递归和状态</h1><p>那么我们如何在Erlang里保持状态呢？我们可以用递归来做到，通过从初始函数调用到下一个函数调用和后续的函数调用之间传递状态。如下有一个Erlang的计数器例子，每次递归函数调用的时候打印出递增的计数器值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% loop_counter.erl</span></div><div class="line"><span class="comment">% 一个递归循环计数器</span></div><div class="line"><span class="comment">% 基于当前进程，并且没有访问计数器的值</span></div><div class="line"><span class="keyword">-module</span><span class="params">(loop_counter)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([go/<span class="number">0</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">go</span><span class="params">()</span> -&gt;</span></div><div class="line">  go(<span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">go</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"N is ~p~n"</span>, [N]),</div><div class="line">  <span class="comment">% 只是为了不让我们的终端忙疯了。</span></div><div class="line">  timer:sleep(<span class="number">1000</span>),</div><div class="line">  go(N + <span class="number">1</span>).</div><div class="line"></div><div class="line"><span class="comment">%%% Erlang shell</span></div><div class="line"><span class="number">1</span>&gt; c(loop_counter).</div><div class="line">&#123;ok,loop_counter&#125;</div><div class="line"><span class="number">2</span>&gt; loop_counter:go().</div><div class="line">N is <span class="number">0</span></div><div class="line">N is <span class="number">1</span></div><div class="line">N is <span class="number">2</span></div><div class="line">N is <span class="number">3</span></div><div class="line"></div><div class="line">(hit Ctrl-c)</div><div class="line">BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded</div><div class="line">       (v)ersion (k)ill (D)b-tables (d)istribution</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用go/1函数的输入参数N来跟踪我们的状态，我们用N+1作为下一个调用的参数递归地调用相同函数来增加计数器值。事实上，我们能够增加这个值意味着我们正在跟踪计数器的状态。但是这个例子没有太多用处，因为递归调用循环完全占据当前的Erlang进程。</p>
<p>我们可以用 <a href="http://www.erlang.org/doc/man/erlang.html#spawn-1" target="_blank" rel="external">erlang:spawn/1</a> 将我们的计数器循环从主进程（我们的Erlang shell）分开。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(loop_counter).</div><div class="line">&#123;ok,loop_counter&#125;</div><div class="line"><span class="number">2</span>&gt; Pid = spawn(<span class="keyword">fun</span> loop_counter:go/<span class="number">0</span>).</div><div class="line">N is <span class="number">0</span></div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line">N is <span class="number">1</span></div><div class="line">N is <span class="number">2</span></div><div class="line">N is <span class="number">3</span></div><div class="line">N is <span class="number">4</span></div><div class="line"><span class="number">3</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>这样我们重新获取我们Erlang shell的控制权，但是现在我们无法控制计数器或者以编程方式获取它当前的值。</p>
<h1 id="用消息控制和查询状态"><a href="#用消息控制和查询状态" class="headerlink" title="用消息控制和查询状态"></a>用消息控制和查询状态</h1><p>在前面一节，我们创建了一个计数器，通过递归地调用自己来增加自己的值，但是我们无法控制计数器或者从外部代码访问它的状态。我们可以用消息来做到这点。如下的例子，增加一个click消息给我们的计数器。我们可以用click消息增加计数器的值，并且将修改后的值作为消息返回给调用的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% counter.erl</span></div><div class="line"><span class="comment">% 创建一个计数器循环来侦听click消息。</span></div><div class="line"><span class="keyword">-module</span><span class="params">(counter)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, click/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">% 创建一个计数器，返回pid</span></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></div><div class="line">  spawn(<span class="keyword">fun</span>() -&gt; loop(<span class="number">0</span>) <span class="keyword">end</span>).</div><div class="line"></div><div class="line"><span class="comment">% 递归循环，函数中用receive块接收消息。</span></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  <span class="keyword">receive</span></div><div class="line">    &#123;click, From&#125; -&gt;</div><div class="line">      From ! N + <span class="number">1</span>,</div><div class="line">      loop(N + <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% API函数。增值计数器，计数器的pid是入参给定的。</span></div><div class="line"><span class="function"><span class="title">click</span><span class="params">(Pid)</span> -&gt;</span></div><div class="line">  Pid ! &#123;click, self()&#125;,</div><div class="line">  <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">%%% in Erlang shell</span></div><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; counter:click(C).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; counter:click(C).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">5</span>&gt; counter:click(C).</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>当我们调用counter:new/0，这个函数创建一个新的递归循环，并用0初始化计数器的值，然后返回被创建进程的pid。循环函数立即进入receive块，在这里它无限期等待从任何其他进程发来的消息。我们设置它只监听一个消息：{click, From}，并要求From是调用进程的pid。</p>
<p>如下例子是从终端创建一个计数器进程并直接发送一个消息给它然后等待接收一个消息返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; C ! &#123;click, self()&#125;.</div><div class="line">&#123;click,&lt;<span class="number">0.32</span>.<span class="number">0</span>&gt;&#125;</div><div class="line"><span class="number">4</span>&gt; <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>上述这个例子显得有点笨拙。我们不想每次要增值计数器的时候都必须写消息调用和receive块；而且这样也不安全，因为这样做留下了很多犯错的空间。因此我们引入API函数counter:click/1（参阅上面的代码例子），它的入参是一个计数器的pid，它知道以正确的方式发送和接收一个click消息。</p>
<p>注意：我们在counter:click/1里用self/0来自动获取调用进程的pid。这种用法可以正常工作，因为counter:click/1是被调用进程调用的。如果我们在counter:loop/1函数里调用self/0，它将返回被创建进程的pid，而这个被创建的进程正在执行循环。</p>
<p>使用这个范例，通过创建多个进程来创建和控制多个计数器是很容易的。此外，API隐藏了大部分的底层实现细节，我们可以与计数器实例一起工作，而不必知道它们的值实际上是一个进程标识符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C1 = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; C2 = counter:new().</div><div class="line">&lt;<span class="number">0.41</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">4</span>&gt; counter:click(C1).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">5</span>&gt; counter:click(C1).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">6</span>&gt; counter:click(C2).</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们也可以修改循环函数来侦听一个set消息来允许我们手工设置计数器的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 增加一个消息处理器来设置计数器的值。</span></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  <span class="keyword">receive</span></div><div class="line">    &#123;click, From&#125; -&gt;</div><div class="line">      From ! N + <span class="number">1</span>,</div><div class="line">      loop(N + <span class="number">1</span>);</div><div class="line">    &#123;set, Value, From&#125; -&gt;</div><div class="line">      From ! ok,</div><div class="line">      loop(Value)</div><div class="line">  <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% API函数。依据给定的pid来设置计数器的值。</span></div><div class="line"><span class="function"><span class="title">set</span><span class="params">(Pid, Value)</span> -&gt;</span></div><div class="line">  Pid ! &#123;set, self(), Value&#125;,</div><div class="line">  <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="用于生产环境的gen-server"><a href="#用于生产环境的gen-server" class="headerlink" title="用于生产环境的gen_server"></a>用于生产环境的gen_server</h1><p>我们上述例子的计数器有许多潜在问题。当一个计数器进程收到一个意料之外的消息会发生什么？当系统很忙并且无法以及时的方式响应一个click消息的时候会发生什么？我们如何停止计数器并释放它正在使用的任何系统资源？当我们增加越来越多的消息的时候，代码也很快变得不可管理。</p>
<p>Erlang有一套<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id60128" target="_blank" rel="external">行为</a>接口用来解决当试图使用Erlang解决问题时普遍遇到的各种问题。这套模块被称为<a href="http://www.erlang.org/doc/design_principles/des_princ.html" target="_blank" rel="external">OTP</a>（正式称谓是“开放电信平台”，现在只是简单地叫做“OTP”）。</p>
<p>OTP的 <a href="http://www.erlang.org/doc/design_principles/gen_server_concepts.html" target="_blank" rel="external">gen_server</a> 行为被设计和实现出来就是为了用来实现一种设计模式，这种设计模式解决我们在本文已经遇到的问题。它以一种健壮和完整的方式实现一个有状态的被创建的进程行为，并且解决很多我们还没有考虑到的问题。</p>
<p>我不打算在这里深入研究OTP行为，因为本文的目的不是教你各种OTP行为或者正确的OTP设计。如果你想学习更多的细节，请看Erlang官方的 <a href="http://www.erlang.org/doc/man/gen_server.html" target="_blank" rel="external">gen_server 文档</a>以及《Learn You Some Erlang》的 <a href="http://learnyousomeerlang.com/clients-and-servers" target="_blank" rel="external">客户端和服务端</a> 章节。然而下面的例子将给你一个不错的主意，就是gen_server如何解决在Erlang里保持状态的问题。</p>
<p>如下就是一个用gen_server实现一个简单的计数器的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% counter_server.erl</span></div><div class="line"><span class="comment">% 简单计数器实现为一个gen_server</span></div><div class="line"><span class="keyword">-module</span><span class="params">(counter_server)</span>.</div><div class="line"><span class="keyword">-behavior</span><span class="params">(gen_server)</span>.</div><div class="line"></div><div class="line"><span class="comment">% API</span></div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, click/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">% gen_server需要的</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_call/<span class="number">3</span>, handle_cast/<span class="number">2</span>, handle_info/<span class="number">2</span>, terminate/<span class="number">2</span>, code_change/<span class="number">3</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%%% API 方法</span></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></div><div class="line">  gen_server:start(?MODULE, [], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">click</span><span class="params">(Pid)</span> -&gt;</span></div><div class="line">  gen_server:call(Pid, click).</div><div class="line"></div><div class="line"><span class="comment">%%% gen_server 回调</span></div><div class="line"><span class="comment">%%%   这些是实现gen_server行为所需要的</span></div><div class="line"><span class="comment">%%%   我们只是使用了 init 和 handle_call</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  <span class="comment">% 第二个值是初始化计数器的状态</span></div><div class="line">  &#123;ok, <span class="number">0</span>&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(click, _From, N)</span> -&gt;</span></div><div class="line">  <span class="comment">% 第二个值是返回给调用者的消息</span></div><div class="line">  <span class="comment">% 第三个值是新状态</span></div><div class="line">  &#123;reply, N + <span class="number">1</span>, N + <span class="number">1</span>&#125;.</div><div class="line"></div><div class="line"><span class="comment">% 基本上，我们忽略这些函数，不过我们保持同样的计数器状态</span></div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, N)</span> -&gt;</span></div><div class="line">  &#123;noreply, N&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Msg, N)</span> -&gt;</span></div><div class="line">  &#123;noreply, N&#125;.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, N, _Other)</span> -&gt;</span></div><div class="line">  &#123;ok, N&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _N)</span> -&gt;</span></div><div class="line">  ok.</div><div class="line"></div><div class="line"><span class="comment">%%% Erlang console</span></div><div class="line"><span class="number">1</span>&gt; c(counter_server).</div><div class="line">&#123;ok,counter_server&#125;</div><div class="line"><span class="number">2</span>&gt; &#123;ok, C&#125; = counter_server:new().</div><div class="line">&#123;ok,&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;&#125;</div><div class="line"><span class="number">3</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">5</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>这个例子可能看起来像是解决一个简单问题用了很多代码，但是我们只是在这个框架里实现功能让我们获得非常大的灵活性。另外也有大量可用模版为你创建代码框架（在Emacs里，你可以从Erlang包里用 M-x tempo-template-erlang-generic-server 创建代码框架）。</p>
<p>作为一个例子，和上述例子一样增加一个set/2功能只是增加一个API函数和一个handle_call回调函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% API</span></div><div class="line"><span class="function"><span class="title">set</span><span class="params">(Value, Pid)</span> -&gt;</span></div><div class="line">  gen_server:call(Pid, &#123;set, Value&#125;).</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(&#123;set, Value&#125;, _From, _N)</span> -&gt;</span></div><div class="line">  &#123;reply, ok, Value&#125;;</div><div class="line"></div><div class="line"><span class="comment">% 来自上面的现有回调，供参考</span></div><div class="line"><span class="comment">%  (这两个函数分支在一起是为了模式匹配)</span></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(click, _From, N)</span> -&gt;</span></div><div class="line">  &#123;reply, N + <span class="number">1</span>, N + <span class="number">1</span>&#125;.</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这就是你从本文学到的。我们在Erlang里用进程保持状态跟踪，并且我们用消息访问和控制状态。在很多方面，Erlang的进程类似于其他语言中的类的实例。在许多其他方面，它们是非常不同的。在Erlang里解决问题要用不同的思考方式：用进程的概念来思考。一开始这可能很难理解，但是一旦你理解它了，许多问题以这种方式更容易解决。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://dantswain.herokuapp.com/blog/2014/09/27/storing-state-in-erlang-with-processes/" target="_blank" rel="external">http://dantswain.herokuapp.com/blog/2014/09/27/storing-state-in-erlang-with-processes/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BIF和NIF函数之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/12/18/eli5-bif-nif/</url>
      <content type="html"><![CDATA[<h1 id="BIF函数"><a href="#BIF函数" class="headerlink" title="BIF函数"></a>BIF函数</h1><p>除非你在Erlang/OTP的C源码上工作，你永远不需要创建自己的BIF函数。如果你想为你的项目实现自己的原生函数，请看下一节关于NIF的内容。</p>
<a id="more"></a>
<p>在Erlang的标准库里大多数的函数是用Erlang实现的。不过许多虚拟机的特性以及内部函数是不可能用纯Erlang语言来做到的。所以它们被用C语言来写并被导出为BIF，即内部构建函数。BIF被用作标准Erlang库，并且在编译的时候被静态地构建进Erlang虚拟机模拟器。</p>
<p>当阅读Erlang标准库的时候，你经常会看到一些函数会有一个调用是：erlang:nif_error(…)。这些是BIF的桩。BEAM装载器找到原生库并且使用对C语言的原生实现的引用来替换这些桩。你也可以用其他语言比如C++或Rust来创建BIF或NIF函数。你也可以在一个叫做bif.tab的特殊文件里注册一个新的BIF，当你构建Erlang虚拟机的模拟器的时候，这个文件串联起module:function名字和BIF的对应关系。</p>
<p>如果你好奇，你可以在Erlang/OTP的C源码中搜索一些函数，比如：erl_bif_lists.c里的lists_reverse_2。一个BIF函数接受进程指针和一个指向寄存器的指针，它可以访问它所需的许多<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">Term</a>（Eterm C 类型）寄存器。一个BIF必须返回一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">Term</a>值或者一个THE_NON_VALUE来针对特殊的执行控制功能，如trap，yield和异常。</p>
<h1 id="NIF函数"><a href="#NIF函数" class="headerlink" title="NIF函数"></a>NIF函数</h1><p>NIF是一种制作原生函数的不同方式，它更适合于分开编译和被用户模块装载。NIF接口和类型系统也是简化的，他们抽象并隐藏了Erlang虚拟机模拟器的许多内部类型、位和字段。</p>
<p>在官方标准文档里有很好的<a href="http://erlang.org/doc/tutorial/nif.html" target="_blank" rel="external">NIF教程</a>，并且大约有一百万个由用户写的以及在许多GitHub项目里可用的NIF函数。</p>
<p>就算它简化了，我们还是一定要小心 ！写得很糟糕的 NIF 是能够搞垮整个虚拟机或抢占资源和减慢执行速度。</p>
<blockquote>
<p>参见：<br>BEAM智慧：<a href="http://beam-wisdoms.clau.se/en/latest/interfacing.html" target="_blank" rel="external">Erlang与外部世界的接口</a>，针对一些NIF、交互库以及为不同语言提供的端口驱动器。</p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-bif-nif.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-bif-nif.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跟踪之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/12/18/eli5-tracing/</url>
      <content type="html"><![CDATA[<p>Erlang VM 如何跟踪函数调用、消息传递、进程的创建和结束？</p>
<a id="more"></a>
<p>跟踪是一种Erlang虚拟机模式，可以被打开和关闭。打开该模式会开始产生一个事件流。调用dbg:tracer()启动一个将接收这个事件流的进程。你可以创建你自己的跟踪器，它有自己的状态，然后给它输送事件。</p>
<p>跟踪能够产生大量不相关的数据。要限制这些不相关的数据，可以调用dbg:tp/4 （这一类函数）来产生一个跟踪过滤器。</p>
<p>当所有事情准备好了：一个跟踪器和一个过滤器，就可以开始打开开关接收事件了。一个对dbg:p/2（这一类函数）的调用设置跟踪目标（一个进程、一个端口、创建和退出事件、所有相关事件，诸如此类）。它将开始发送所有匹配跟踪目标和你给跟踪器进程设置的过滤器的事件。</p>
<h1 id="跟踪的内部运作"><a href="#跟踪的内部运作" class="headerlink" title="跟踪的内部运作"></a>跟踪的内部运作</h1><p>像进程生命周期事件或消息这样简单的事情在虚拟机的C代码中到处都有跟踪器检查。如果跟踪被开启，那么一条消息会发送给当前的跟踪器。</p>
<p>对BIF函数的调用和返回进行跟踪会更复杂。因为BIF不是真正的Erlang代码，它们必须以某种方式被包裹在跟踪代码里。这是通过用BIF的入口函数地址与另一个表替换BIF表来做到的。这个新表中的每个条目是一个简单的使用函数名称和参数来对erts_bif_trace函数的调用。这个函数执行真正的调用并且发送跟踪消息。</p>
<p>在某些时刻使用另一个技巧。在BIF结束前，特定的BEAM操作码被推送到栈上，它将发送跟踪事件。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-tracing.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-tracing.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[输入/输出和端口之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/12/17/eli5-io/</url>
      <content type="html"><![CDATA[<p>人们运行电脑程序的主要原因是因为有副作用。一个没有副作用的纯粹程序将消耗电力，温暖你的房间，除此之外别无他用。为了将程序连接到外部世界，每一种语言都有输入和输出的功能。例如：读写文件、访问硬件端口、或者与操作系统驱动器交互、在屏幕上描绘等等。</p>
<a id="more"></a>
<p>Erlang用端口来做到上述事情，端口是被叫做端口驱动器的小的C语言模块驱动。一些驱动是Erlang自带的，另一些则需要你自己创建或者请别人帮你创建。许多端口问题在GitHub上都有了解决方案（比如Unix管道）。</p>
<p>当你连接到一个资源开始使用它的时候，你收到的值是一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-port" target="_blank" rel="external">端口</a>。它的行为和进程相似：它消耗CPU时间来处理你的数据，你可以发消息给它，它也可以发消息给你。你可以连接或者监测一个端口（监测功能是从Erlang/OTP 19开始增加的）。</p>
<h1 id="端口任务"><a href="#端口任务" class="headerlink" title="端口任务"></a>端口任务</h1><p>每个端口和进程一样都是赋给一个调度器。每个CPU核上的调度器将会定期地检查赋予它的端口并且执行轮询和维护（这叫做运行端口任务）。这样就给端口驱动器分配CPU时间来执行实际的IO并且传递结果给正在等待的进程。</p>
<p>为了提高这个过程的效率并且为了从调度器分离出来端口任务，以便使得它们不影响主程序，异步线程被发明出来。虚拟机创建额外的线程，它们只有一个主要目标，就是服务IO任务。</p>
<p>异步线程的个数可以通过命令行标志 +A 正整数 来控制。默认是10个异步线程。</p>
<h1 id="端口驱动器"><a href="#端口驱动器" class="headerlink" title="端口驱动器"></a>端口驱动器</h1><p>一个C模块可以用名字的方式被注册成一个端口驱动器。你可以指定，当打开一个端口的时候，哪一个驱动器被调用。端口驱动器执行几个基本命令来打开端口、关闭端口、发送数据给端口或者从端口读取数据。例如，套接字接口、操作系统进程的创建，它们都是作为端口驱动器来实现的。</p>
<blockquote>
<p>参见：<br>技术细节：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-io.html" target="_blank" rel="external">Erlang的IO</a></p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-io.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-io.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[进程堆之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/12/16/eli5-process-heap/</url>
      <content type="html"><![CDATA[<p>Erlang里的每一个事物都是一个term。一个term是Erlang里的任何值。在Erlang内部，一个term是一个保留一些最少有效位（根据值的不同有效位从2到6不等）的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-word" target="_blank" rel="external">字</a>，这些有效位定义了它的类型。剩下的位包含它自己的值（比如<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>的值）或包含一个指向堆上数据（<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box" target="_blank" rel="external">box</a> 值）的指针。</p>
<a id="more"></a>
<p>一个进程的堆是一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。而进程的栈则是另一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。栈被分配在堆的里面。<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-registers" target="_blank" rel="external">寄存器</a>也是一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。堆上的数据大多数都是由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组，除了用<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-header" target="_blank" rel="external">头部标签</a>（详情参阅 <a href="http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html" target="_blank" rel="external">数据类型内存布局</a>）标记的数据。</p>
<h1 id="堆载体"><a href="#堆载体" class="headerlink" title="堆载体"></a>堆载体</h1><p>Erlang内的内存分配发生在所谓的“载体”内。它们看起来像游戏里使用的“区域内存”–事先分配的一大块系统堆。在载体内部，真正的内存分配在这里发生。至于它们是如何运作的，为简单起见你可以想象成简单的malloc/realloc。</p>
<p>克服内存碎片的复杂事情都被封装好了，并且不是我们要理解的重点。你可以看源码 erts/emulator/beam/erl_*alloc.c （有许多文件，每一个分配策略一个文件）。模拟器有命令行标志来控制分配策略（参阅 <a href="http://erlang.org/doc/man/erts_alloc.html" target="_blank" rel="external">http://erlang.org/doc/man/erts_alloc.html</a> 标志部分）。</p>
<h1 id="堆内的内存分配"><a href="#堆内的内存分配" class="headerlink" title="堆内的内存分配"></a>堆内的内存分配</h1><p>当一个进程需要一些内存，它的 heap_top 增大，堆顶下面的内存就准备好被使用。一些活动想在其他进程的堆上分配内存，例如发送一个消息将把一个消息的拷贝给接收进程。</p>
<p>在进程堆内部是没有记账本的。就是没有跟踪那一个字属于哪里，但是我们可能通过查看标签位是可以知道每一个内存单元存储了什么。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>垃圾回收跟踪从寄存器和栈知道的活数据并保存它们，然后将其他的数据都卸掉。</p>
<p>当一个堆达到它的容量阀值（比如75%），进程就触发垃圾回收。一个新的更大的堆可能被分配出来。扫描分代的垃圾回收算法运行在堆上。这个算法获取“<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-roots" target="_blank" rel="external">roots</a>”（垃圾回收期间，根是所有已知的活数据）并把它们移到新堆。然后扫描源堆的剩余部分，提取更多的值，由根引用。扫描后，源堆只剩下死数据接着算法把它们卸掉。</p>
<p>“扫描”的意思是，垃圾回收器将数据从头到尾过一遍，分析所有它遇到的数据。“分代的”的意思是，算法将数据分为新生代和老生代，并假设新数据经常是死掉的，老数据是不太可能被释放的。另外算法记住老的位置（成熟的），也就是上一次扫描结束的地方。这个位置下面的任何数据被保证自上次扫描以来有没有更新。这一招会减少扫描的量，并加速算法。</p>
<p>在现实中比较复杂一点。可能有一个或两个堆有不同的逻辑应用于它们。每一个进程都有自己的垃圾回收器这样就使得Erlang的垃圾回收延时低。另外它不会暂停或影响其他调度器上的其他进程。这不是一个简单的话题，不过原理都在这：<a href="http://gchandbook.org/" target="_blank" rel="external">http://gchandbook.org/</a></p>
<blockquote>
<p>另外请参阅<br>BEAM 智慧: 深层次知识: <a href="http://beam-wisdoms.clau.se/en/latest/indepth-heap-layout.html" target="_blank" rel="external">进程堆布局</a>。<br>BEAM Wisdoms: 深层次知识: <a href="http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html" target="_blank" rel="external">数据类型内存布局</a>。<br><a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html" target="_blank" rel="external">Erlang里的垃圾回收器</a></p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-process-heap.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-process-heap.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[进程之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/12/15/eli5-processes/</url>
      <content type="html"><![CDATA[<p>本文是进程如何组成的以及如何工作的高层次概述。</p>
<a id="more"></a>
<h1 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h1><p>一个进程就是一个简单的C语言结构，这个结构包含了一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-heap" target="_blank" rel="external">堆</a>，一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack" target="_blank" rel="external">栈</a>，一些<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-registers" target="_blank" rel="external">寄存器</a>，还有一个指令指针。也有一些异常处理、跟踪等额外字段。一个新的进程是以这个C语言结构创建的，创建的时候有一个最小尺寸的堆。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img src="/images/eli5-process-stack.png" style="border:0;"></p>
<p><a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack" target="_blank" rel="external">栈</a>是在新生代堆上一个内存数组，它被用来当作返回栈和变量的临时存储。栈从堆的尾部开始，向堆的首部增长。栈上的数据按<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack-frame" target="_blank" rel="external">栈帧</a>来组织。</p>
<p>当一个函数需要一些临时的内存，它在栈上分配几个字的空间，并在第0个字上设置一个特定的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cp" target="_blank" rel="external">CP</a>值。后续这个内存地址可以被当作返回地址，并且从这个内存内找到下一个栈帧从哪里开始。这个临时内存也可以被用来在递归调用的时候保存寄存器（这样会造成栈的增长）。</p>
<p>尾递归避免保存这些临时数据或者在递归前释放这些临时数据。它用更聪明的办法传递参数，这样就不需要在栈上保存参数从而不会使得栈增长。</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>每一个新进程都被赋予一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-scheduler" target="_blank" rel="external">调度器</a>。调度器从队列里取出一个进程并拿到该进程的指令指针。然后调度器执行一个指令接着进入重复执行指令的循环。在完成一定数量的工作（<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-reduction" target="_blank" rel="external">规约数</a>）后，调度器将把当前的进程放回队列然后从队列里选择另一个进程。这种机制使得一些类型的公平调度成为可能：每一个进程都可以得到CPU时间而不管队列中其他进程如何繁忙。</p>
<h1 id="杀死和退出"><a href="#杀死和退出" class="headerlink" title="杀死和退出"></a>杀死和退出</h1><p>杀死一个进程就像给它发送一个退出异常。进程从睡眠中醒来，获得CPU时间，然后发现一个异常。那么它将终止自己或者捕获这个异常并且像一个正常的消息一样进行处理。无条件杀死信号和异常很像，这是Erlang代码无法捕获它。</p>
<h1 id="调度和负载均衡"><a href="#调度和负载均衡" class="headerlink" title="调度和负载均衡"></a>调度和负载均衡</h1><p><img src="/images/eli5-process-sched.png" style="border:0;"></p>
<p>默认情况下BEAM虚拟机每个CPU核启动一个调度器。进程以某种方式（简单来说你可以认为是随机地）赋给调度器。你可以用标志 +S 和 +SP 来配置调度器。调度器可以用不同的方式（+sbt 标志）被绑定到CPU核。</p>
<p>有3种进程优先级：low、normal、high和max。处在max优先级的进程总是首先运行而其他进程一直等待。high优先级进程比normal优先级进程大约多8倍时间运行（这个倍数依赖于实现）。当没有其他工作可做的时候low优先级进程才运行。</p>
<p>在运行时，调度器和其他调度器（即在调度器数组中比它前一位的调度器）比较它们之间的进程队列。如果其他调度器的队列比它的长，调度器将从其他调度器的队列里偷一个或多个进程给自己的队列。这种默认行为是可以被改变的。负载均衡策略可以用虚拟机标志 +S 和 +scl 来配置。你可能想使用尽可能少的CPU核来让其他CPU核睡眠和节能。或者你更喜欢将进程平摊给各个CPU核从而减少时延。</p>
<p>偷进程就如将指针从一个数组移到另一个数组一样容易。当一个活动进程在CPU核间跳动的话，可能影响<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cache-locality" target="_blank" rel="external">缓存区</a>。</p>
<h1 id="进程注册"><a href="#进程注册" class="headerlink" title="进程注册"></a>进程注册</h1><p>一个全局进程表映射进程标识符（pid）到进程结构。要了解一个进程的pid，可以参阅它的Process.common.id字段。进程通过它本地的pid唯一标识。远程pid包含更多信息：一个节点名和内部节点id。远程pid必须在拥有它的节点上解析。</p>
<p>另一个全局表（进程注册）映射名字到pid。你可以用erlang:register、erlang:unregister和erlang:whereis 这些BIF来使用它。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><img src="/images/eli5-process-mqueue.png" style="border:0;"></p>
<p>消息被存储在堆上或者在堆段里，并且被用单链表串起来。消息队列是一个属于进程结构的C结构并且它包含了发给进程的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">数据项</a>。对于更大的或嵌套的数据则使用<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box" target="_blank" rel="external">Boxed data</a>，它被分配在堆上。存在一个队列位置的指针，它是先进的BEAM操作码，它用来扫描邮箱。当扫描指针到达邮箱的底部，进程将被置为接收消息状态。仅当一个消息被匹配了，指针才被复位到队列的首部。这就是为什么在一个大的邮箱队列中进行选择接收是缓慢的。</p>
<h1 id="发送一个消息"><a href="#发送一个消息" class="headerlink" title="发送一个消息"></a>发送一个消息</h1><p>发送一个消息给一个进程很简单。下面就是虚拟机的做法：</p>
<ol>
<li>锁上一个进程邮箱（如果运行在一个单核上就不需要）。</li>
<li>拷贝消息到目的进程的堆。</li>
<li>添加结果数据到进程邮箱。</li>
<li>解锁进程邮箱。</li>
<li>如果进程处在接收消息状态，它将回到调度队列并随时醒来处理消息。</li>
</ol>
<p>一个进程等待一个消息（用接收操作），直到消息到达它都不会被放入调度器运行队列等待执行。这就是为什么百万个空闲进程可以毫不费劲地同时存在于一个单机上。</p>
<h1 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h1><p>Traps是虚拟机循环的一个特性，它允许临时暂停长时间运行的BIF。状态被保存在临时内存区并且控制权回到调度器。进程设置它的指令指针到特定的trap指令并且BIF返回。</p>
<p>在trap期间，当前进程被放回进程队列，这就允许其他进程运行。当时机到来，虚拟机循环遇到trap指令，并且跳回到长时间运行BIF。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-processes.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-processes.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang垃圾回收细节及其重要性]]></title>
      <url>http://szpzs.oschina.io/2016/12/13/erlang-garbage-collection-details-and-why-it-matters/</url>
      <content type="html"><![CDATA[<p>Erlang试图解决的主要问题之一是创建一个可以实现具有高度响应能力的<a href="https://en.wikipedia.org/wiki/Real-time_computing" target="_blank" rel="external">软实时系统</a>的平台。这样的系统需要快速的<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="external">垃圾回</a>收策略，这样就不会阻止系统以及时的方式进行响应。另外当我们认为Erlang是一门无破坏性修改特性的<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="external">不可改变</a>语言的时候，垃圾回收变得更重要，因为这样的语言有更高产生垃圾的几率。</p>
<a id="more"></a>
<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>在我们深入垃圾回收之前，了解Erlang进程的内存布局是很有必要的。Erlang进程的内存布局可以分为三个主要部分：进程控制块，栈和堆。这和Unix的进程布局非常像。</p>
<p><img src="/images/erlang-memory-layout.png" style="border:0;"></p>
<ul>
<li><strong>进程控制块</strong>：进程控制块持有进程的一些信息，诸如：它在进程表里的标识符（PID），当前状态（运行、等待），它的注册名字，初始化调用和当前调用；另外进程控制块还持有指向到达消息的指针，这些消息是<em>链接列表</em>的成员，它们存储在进程私有堆里。</li>
<li><strong>栈</strong>：它是一个向下增长的内存区域，它持有函数的进出参数，返回地址，本地变量以及计算表达式的临时空间。</li>
<li><strong>堆</strong>：它是一个向上增长的内存区域，它持有进程邮箱的实际消息，像<a href="http://www.erlang.org/doc/man/lists.html" target="_blank" rel="external">列表</a>和<a href="http://www.erlang.org/documentation/doc-5.8/doc/reference_manual/data_types.html" target="_blank" rel="external">元组</a>这样的复合数据，<a href="http://www.erlang.org/doc/man/binary.html" target="_blank" rel="external">二进制数据</a>，大于一个机器字的诸如浮点数对象。大于64字节的二进制数据不保存在进程私有堆里，这样的二进制数据叫做<em>Refc Binary</em>（引用计数二进制），它们存储在一个大<em>共享堆</em>，被那些有指向引用计数二进制数据指针的进程访问。那些指针叫做<em>ProcBin</em>并且存储在进程的私有堆里。</li>
</ul>
<h1 id="垃圾回收细节"><a href="#垃圾回收细节" class="headerlink" title="垃圾回收细节"></a>垃圾回收细节</h1><p>为了解释当前默认的Erlang垃圾回收机制，我们可以简单地说，一种是独立运行在每个Erlang进程私有堆内的分代复制垃圾回收，另一种是发生在全局共享堆的引用计数垃圾回收。</p>
<h2 id="私有堆垃圾回收"><a href="#私有堆垃圾回收" class="headerlink" title="私有堆垃圾回收"></a>私有堆垃圾回收</h2><p>私有堆的垃圾回收是分代的。分代垃圾回收将堆分成两个段：年轻代和老生代。分代的原理是：如果一个对象在一个垃圾回收周期存活下来，那么它短时间成为垃圾的机会就降低了。所以年轻代给新分配的数据使用，老生代给那些已经执行了指定次数的垃圾回收后还依然幸存下来的数据使用。这种分割为两个段的方式有助于垃圾回收减少在还没有变成垃圾的数据上进行不必要的垃圾回收过程。Erlang的垃圾回有两种策略：<em>分代的</em>（轻量级的）和<em>全扫描</em>（重量级的）。分代的垃圾回收只是回收年轻代堆，而全扫描垃圾回收则回收年轻代和老生代的堆。现在让我们仔细看看一个新启动的Erlang进程在私有堆里的垃圾回收步骤：</p>
<p><strong>场景1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; No GC &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个短时存活的进程没有垃圾回收发生，它用的堆没有超过<em>min_heap_size</em>设置的值然后就终止了。在这个场景下，被进程使用的所有内存都被回收。</p>
<p><strong>场景2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个新创建的进程，它的数据增长超过<em>min_heap_size</em>设置的值，所以发生了一次全扫描垃圾回收，很明显因为在此之前从来没有发生过垃圾回收，所以就不存在年轻代和老生代两个段。在第一次全扫描垃圾回收后，堆被分割成年轻代和老生代，并且此后垃圾回收策略切换到分代的垃圾回收并且一直维持这种策略直到进程终止。</p>
<p><strong>场景3:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Generational &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在进程的生命周期里当垃圾回收策略从分代的垃圾回收再次切换到全扫描的垃圾回收的时候，这会有几种不同的情况。第一种情况是在一定数量的分代的垃圾回收发生后。这个一定的数量可以全局设置或者每个进程用<em>fullsweep_after</em>标志设置。每个进程的分代的垃圾回收次数统计和它切换到全扫描的垃圾回收前的分代的垃圾回收次数上限分别是进程的<em>minor_gcs</em>和<em>fullsweep_after</em>属性，同时这两个值可用<em>process_info(PID, garbage_collection)</em>的返回值来获得。第二种情况是分代的垃圾回收不能回收足够的内存的时候。最后一种情况是当<em>garbage_collection(PID)</em>函数被手工调用的时候。在这几种情况后，垃圾回收策略再次从全扫描的垃圾回收切换回分代的垃圾回收并且保持直到上述的情况发生。</p>
<p><strong>场景4:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Increase Heap &gt; Fullsweep &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在场景3里，如果第二次全扫描垃圾回收不能回收足够的内存，那么堆被增大，而垃圾回收策略再切换回全扫描垃圾回收，像一个新创建的进程一样。所有这四种场景可以反复发生。</p>
<p>那么现在的问题是，像Erlang这样的自动垃圾回收语言，上述这些知识为什么重要？首先这些知识能帮助你通过调优全局的或某个进程的垃圾回收的发生和策略来使得你的系统更快。其次从它的垃圾回收角度来开，我们可以理解使得Erlang成为一个软实时平台的主要原因之一。这是因为每一个进程都有它自己的私有堆和它自己的垃圾回收，因此每次在一个进程里垃圾回收发生只是让这个正在进行垃圾回收的进程停顿而不会停顿其他任何进程，这是一个软实时系统所需要的。</p>
<h2 id="共享堆垃圾回收"><a href="#共享堆垃圾回收" class="headerlink" title="共享堆垃圾回收"></a>共享堆垃圾回收</h2><p>共享堆垃圾回收是引用计数垃圾回收。每一个共享堆里的对象（Refc）都有一个引用它的计数器，这个计数器被其他对象（ProcBin）持有，而这个ProcBin对象存储在Erlang进程的私有堆里。如果一个对象的引用计数器的值变为0，这个对象变成不可访问，并且将被销毁。引用计数器方式的垃圾回收是如此的廉价而且帮助系统避免出现意外的长时间暂停同时促进了系统的响应。但是由于在设计你的参与者模式系统时不太熟悉的一些知名反模式可能会造成内存泄漏的麻烦。</p>
<ul>
<li>首先是当一个引用计数二进制数据被分割为子二进制数据。为了节省资源，子二进制数据并不是原二进制数据分割部分的新拷贝，而只是对这个分割部分的引用。然而除了原始二进制数据，这个子二进制数据的引用计数是一个新的引用，正如你能理解的，这将导致一个问题，原始二进制数据必须等它的子二进制数据被回收后才能回收。</li>
<li>另一个众所周知的问题是当有一类长期生存的中间件进程，它作为一个请求控制器或消息路由器来控制和传输大的引用计数二进制消息。因为这个进程和所有这些引用计数二进制数据关联，所以它们的计数器值就增加了。所以回收这些引用计数二进制数据依赖于回收所有的ProcBin对象，甚至包括这个中间件进程里的ProcBin对象。非常不幸的是，因为ProcBin只是一个指针，它非常廉价，以至于在这个中间件进程里要花很长时间才能遇到一次回收这个ProcBin对象。造成的结果就是，即使除了中间件进程外其他所有进程里的ProcBin对象都被回收了，引用计数二进制数据还是继续留存在共享堆里。</li>
</ul>
<p>共享堆很重要，因为它减少了进程间传递大二进制消息的IO开销。另外子二进制数据只是某个二进制数据的指针，所以它的创建是如此快速。但是按一般规律来说，为了更快而使用快捷方式是有代价的，代价就是要以某种方式好好设计你的系统不至于让你陷入到麻烦当中。另外针对引用计数二进制数据泄漏问题有一些著名的架构模式，这些在<a href="http://ferd.ca/" target="_blank" rel="external">Fred Hebert</a>的免费电子书 <a href="http://www.erlang-in-anger.com/" target="_blank" rel="external">Erlang in Anger</a> 里有详细的解释，我想我是没办法解释的比他更好。所以我强烈建议你读一下这本书。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>即使我们现在正在使用的语言，它像Erlang这样自己管理内存，但是也不能阻止我们去理解它是如何分配和回收内存的。不像<a href="https://golang.org/ref/mem" target="_blank" rel="external">Go语言内存模型文档</a>所建议的：“如果你必须读本文档剩下部分来理解你自己程序的行为，你就是太聪明了。不过别自作聪明。”，我相信我们必须足够聪明才能够使我们的系统更快更安全，有时候它不会发生除非我们更深地钻研挖进去理解它的本质。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/faq/academic.html" target="_blank" rel="external">Erlang的学术和历史问题</a></li>
<li><a href="http://lampwww.epfl.ch/resources/lamp/teaching/advancedCompiler/2004/slides/ImplementationOfConcurrency_slides.pdf" target="_blank" rel="external">FPL和并发执行</a></li>
<li><a href="http://user.it.uu.se/~jesperw/publications/Wilhelmsson_lic.pdf" target="_blank" rel="external">消息传递并发的有效内存管理</a></li>
<li><a href="http://labouseur.com/courses/erlang/programming-parallel-with-erlang.pdf" target="_blank" rel="external">用Erlang编程并行世界</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang调度器的细节及其重要性]]></title>
      <url>http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/</url>
      <content type="html"><![CDATA[<p>有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">Erlang垃圾回收细节及其重要性</a>》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。</p>
<a id="more"></a>
<h1 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度"></a>什么是调度</h1><p>通常来说，调度就是一种分派工作给工作者的机制。所谓的工作可能是一个算数运算、字符串处理或者数据抽取，而工作者是一些资源，比如像<a href="https://en.wikipedia.org/wiki/Green_threads" target="_blank" rel="external">Green Thread</a>这样虚拟的资源或者像<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Native Thread</a>这样的物理资源。调度器以一种方式执行调度活动，最大限度地提高吞吐量和公平性，最大限度地降低响应时间和延时。调度是像操作系统和虚拟机这样的多任务系统的重要组成部分，它被分为两种类型：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29" target="_blank" rel="external">抢占式</a>：一个抢占式调度器在执行的任务间进行上下文切换，它有权力抢占（中断）任务并且在不需要被抢占任务的配合下的稍后恢复执行它们。实现这样的功能是基于如下几个因素，比如：任务的优先级，时间切片或者规约数。</li>
<li><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="external">协作式</a>：一个协作式调度器需要任务协作来进行上下文切换。在这种方式下，调度器简单地让任务周期性地或者空闲地时候自愿地释放控制权，然后启动一个新的任务并且再一次等待它自愿地归还控制权。</li>
</ul>
<p>现在的问题是，哪一种调度机制适合软实时系统，也就是这个系统必须在指定的时间内响应。协作式调度系统不能满足软实时系统的要求，因为其运行的任务可能永远也不会返还控制权或者在规定时限后返还控制权。所以软实时系统通常采用抢占式调度。</p>
<h1 id="Erlang的调度"><a href="#Erlang的调度" class="headerlink" title="Erlang的调度"></a>Erlang的调度</h1><p>Erlang作为一个多任务软实时平台采用的就是抢占式调度。Erlang调度器的职责就是选择一个进程并执行它的代码。它也处理垃圾回收和内存管理。如何选择一个进程来执行是基于每个进程可配置的优先级，并且同一优先级的进程是轮询地被调度的。另外，执行中的进程被抢占的因素是基于自上次该进程被选中执行后一定数量的<strong>规约数</strong>而不管它的优先级如何。规约数是每个进程的一个计数器，一般每调用一次函数，它就加一。当一个进程的计数器达到最大规约数时，调度器就会抢占进程和进行上下文切换。例如，在Erlang/OTP R12B 计数器的最大值是2000规约数。</p>
<p>Erlang的任务调度有很长的发展历史。它随着时间而改变。这些改变受Erlang的SMP（对称多处理器）特性的改变而被影响。</p>
<h2 id="R11B之前的调度"><a href="#R11B之前的调度" class="headerlink" title="R11B之前的调度"></a>R11B之前的调度</h2><p>在R11B之前，Eralng还不支持SMP，因此它只有一个调度器运行在操作系统主进程的线程里，并且相应的只有一个<strong>运行队列</strong>。调度器从运行队列选择可运行的Erlang进程和IO任务来执行。</p>
<p><img src="/images/scheduling-before-r11b.png" style="border:0;"></p>
<p>这种方式不需要锁数据结构，但是这么写的应用无法利用并行的好处。</p>
<h2 id="R11B和R12B的调度"><a href="#R11B和R12B的调度" class="headerlink" title="R11B和R12B的调度"></a>R11B和R12B的调度</h2><p>SMP支持被加入Erlang虚拟机里，所以它可以有1到1024个运行在操作系统进程的线程里的调度器。然而，这个版本的调度器只能从一个共用运行队列里选取可执行任务。</p>
<p><img src="/images/scheduling-in-r11b-and-r12b.png" style="border:0;"></p>
<p>由于这种方式造成并行，使得所有共享数据结构都要用锁保护起来。例如运行队列本身就是一个必须被保护起来的共享数据结构。虽热锁会造成一些性能损失，但是新的调度器在多核处理器上带来的性能提升还是很可观的。</p>
<p>在这个版本里的一些瓶颈如下：</p>
<ul>
<li>当调度器增加后，共用运行队列成为瓶颈。</li>
<li>增加ETS表相关的锁，同时也影响到Mnesia。</li>
<li>当许多进程同时给一个进程发送消息的时候增加锁的冲突。</li>
<li>一个进程等待获取一个锁的时候会阻塞它的调度器。</li>
</ul>
<p>然而，每一个调度器分配一个运行队列的方案在下一个版本被选择来解决这些瓶颈。</p>
<h2 id="R13B后的调度"><a href="#R13B后的调度" class="headerlink" title="R13B后的调度"></a>R13B后的调度</h2><p>在这个版本，每个调度器有它自己的运行队列。在多核多调度器的系统里，这将减少锁冲突数量并且提升系统整体性能。</p>
<p><img src="/images/scheduling-after-r13b.png" style="border:0;"></p>
<p>这种方式在访问运行队列时锁冲突解决了，不过却引入了一些新问题：</p>
<ul>
<li>如何在运行队列中分配任务做到公平？</li>
<li>如果一个调度器被分配了过多的任务而另外的调度器却很清闲，这个问题如何解决？</li>
<li>基于什么样的命令一个调度器可以从一个过载的调度器偷任务？</li>
<li>要是我们启动了很多调度器，但是却很少任务，如何处理？</li>
</ul>
<p>这些问题使得Erlang开发团队引入一个概念使得调度公平和高效，这个概念就是<strong>迁移逻辑</strong>。它尝试在基于从系统收集来的统计数据上控制和平衡运行队列。</p>
<p>然而我们不应该让我们的调度一直维持现状，因为它很可能在将来的版本变得更好。</p>
<h1 id="控制和监督API"><a href="#控制和监督API" class="headerlink" title="控制和监督API"></a>控制和监督API</h1><p>有一些Erlang模拟器启动标志和一些内部控制和监督函数与调度器行为有关。</p>
<h2 id="调度线程"><a href="#调度线程" class="headerlink" title="调度线程"></a>调度线程</h2><p>当用erl启动脚本启动Erlang模拟器的时候，可以通过给+S标志传递两个用冒号分割的数字来指定最大可用调度线程数和在线调度线程数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S MaxAvailableSchedulers:OnlineSchedulers</div></pre></td></tr></table></figure>
<p>最大可用调度线程数只能在启动的时候指定而且在运行时是固定不变的，但是在线调度线程数可以在启动和运行时被指定和修改。例如我们可以在启动一个模拟器的时候指定16个最大调度线程和8个在线调度线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S 16:8</div></pre></td></tr></table></figure>
<p>然后在shell里在线调度线程可以被修改，如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; erlang:system_info(schedulers). <span class="comment">%% =&gt; returns 16</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_flag(schedulers_online, <span class="number">16</span>). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 16</span></div></pre></td></tr></table></figure>
<p>另外，使用+SP标志可以用百分比的方式设置这两个值。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>如前所述调度器基于进程的优先级来选择它们来执行。优先级可以在进程内通过调用erlang:process_flag/2函数来设置。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PID = spawn(<span class="keyword">fun</span>() -&gt;</div><div class="line">   <span class="comment">%% ...</span></div><div class="line">   <span class="keyword">end</span>).</div></pre></td></tr></table></figure>
<p>优先级可以是 low、normal、high、max 这些原子中的任何一个。默认优先级是normal，max优先级是保留给Erlang运行时内部使用不应被一般进程使用。</p>
<h2 id="运行队列统计"><a href="#运行队列统计" class="headerlink" title="运行队列统计"></a>运行队列统计</h2><p>如前所述运行队列持有准备好执行但未被调度器选中执行的进程。可以通过调用erlang:statistics(run_queue)获取在所有可用运行队列已经准备好可运行的进程数。作为一个真实例子，让我启动Erlang模拟器，给它4个在线调度器，并且给它们10个非常消耗CPU的并发进程。这些进程<a href="https://gist.github.com/hamidreza-s/9e3ed289f65759048875" target="_blank" rel="external">计算一个很大数字的素数</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%% 就绪</span></div><div class="line">&gt; erlang:statistics(online_schedulers). <span class="comment">%% =&gt; 4 译者注：此处的函数有误，应该是 erlang:system_info(schedulers_online).</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div><div class="line"></div><div class="line"><span class="comment">%% 并发创建10个重型进程</span></div><div class="line">&gt; [spawn(<span class="keyword">fun</span>() -&gt; calc:prime_numbers(<span class="number">10000000</span>) <span class="keyword">end</span>) || _ &lt;- lists:seq(<span class="number">1</span>, <span class="number">10</span>)].</div><div class="line"></div><div class="line"><span class="comment">%% 运行队列中还有任务要做</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 8</span></div><div class="line"></div><div class="line"><span class="comment">%% Erlang shell依然可以响应，非常棒！</span></div><div class="line">&gt; calc:prime_numbers(<span class="number">10</span>). <span class="comment">%% =&gt; [2, 3, 5, 7]</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 4</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div></pre></td></tr></table></figure>
<p>因为并发进程数大于在线调度器，这将花些时间让调度器执行运行队列里的进程并最终清空运行队列。有趣的是，创建了这些重型进程后，Erlang模拟器任然因为它的抢占式调度可以响应其他请求。Erlang的抢占式调度不会让这些重型进程消耗掉所有运行时，其他轻量并且重要的进程也可以被执行，这个特性在实现一个软实时系统的时候是非常棒的。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>虽然实现一个抢占式调度系统可能很复杂，但是在Erlang里这些不是开发者的责任，因为抢占式调度特性已经在Erlang虚拟机里。另一方面，当在一个软实时系统里系统以高水平的公平性和即时的响应需要扩展到所有处理资源的时候，跟踪、平衡、执行、迁移和抢占进程这些额外的处理成本是完全可负担的。顺便值得一提的是，完全抢占式调度是几乎所有操作系统都支持的特性，但在高层次的平台，语言或库里，Erlang虚拟机几乎是唯一完全抢占式调度的，因为JVM依赖于操作系统的调度器，CAF这个C++ actor库用协作式调度，Go也不是完全抢占式调度，还有诸如Python的Twisted，Ruby的Event Machine和Nodejs也不是完全抢占式调度的。这并不意味着对于所有的挑战这都是最好的选择，而是说我们如果要实现一个低延时的软实时系统，Erlang是一个好的选择。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/doc/man/erl.html" target="_blank" rel="external">erl脚本官方文档</a></li>
<li><a href="http://erlang.org/doc/man/erlang.html" target="_blank" rel="external">erlang模块官方文档</a></li>
<li><a href="http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html" target="_blank" rel="external">Erlang如何调度</a></li>
<li><a href="http://www.erlang.org/euc/08/euc_smp.pdf" target="_blank" rel="external">深入Erlang虚拟机</a></li>
<li><a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html" target="_blank" rel="external">Erlang调度器：它是如何工作的</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Rebar3热更新Erlang代码]]></title>
      <url>http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/</url>
      <content type="html"><![CDATA[<p>在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：</p>
<blockquote>
<p>代码热更新就是一门给正在飞奔的汽车换引擎的艺术。</p>
</blockquote>
<p>简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。</p>
<a id="more"></a>
<p>我们将创建一个样例项目，然后学习如何来做代码热更新。这个项目的代码我已经放在<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">这里</a>。让我们用rebar3来创建一个模版项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new release nine9s</div></pre></td></tr></table></figure>
<p>现在我们在我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config" target="_blank" rel="external">rebar.config</a>文件里增加cowboy和lager为依赖。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [</div><div class="line">	&#123;lager, &#123;git, <span class="string">"git://github.com/basho/lager.git"</span>, &#123;tag, <span class="string">"2.1.1"</span>&#125;&#125;&#125;,</div><div class="line">	&#123;cowboy, &#123;git, <span class="string">"https://github.com/ninenines/cowboy.git"</span>, &#123;tag, <span class="string">"2.0.0-pre.1"</span>&#125;&#125;&#125;</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>为了更加真实的体验，请按如下修改我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config#L14-L15" target="_blank" rel="external">rebar.config</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;relx, [</div><div class="line">		&#123;release, &#123;'nine9s', <span class="string">"0.1.0"</span>&#125;, ['nine9s', sasl]&#125;,</div><div class="line">		&#123;sys_config, <span class="string">"./config/sys.config"</span>&#125;,</div><div class="line">		&#123;vm_args, <span class="string">"./config/vm.args"</span>&#125;,</div><div class="line">		&#123;dev_mode, false&#125;,</div><div class="line">		&#123;include_erts, true&#125;,</div><div class="line">		&#123;extended_start_script, true&#125;</div><div class="line">	]</div><div class="line">&#125;.</div></pre></td></tr></table></figure>
<p>你可能想知道这个“nine9s”应用将会做些什么？我的想法是先让这个应用做成一个hello world的web服务，然后再热更新它的代码。修改你的nine9s_app.erl文件以便让start/2看起来像下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line"> Dispatch = cowboy_router:compile(</div><div class="line">                                  [&#123;‘_’, [</div><div class="line">                                          &#123;“/”, default_handler, []&#125;</div><div class="line">                                         ]&#125;</div><div class="line">                                  ]),</div><div class="line"> &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line"> [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line"> ‘nine9s_sup’:start_link().</div></pre></td></tr></table></figure>
<p>现在我们创建一个模块，它叫做default_handler.erl。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-module(default_handler).</div><div class="line">-export([init/2]).</div><div class="line">init(Req, Opts) -&gt;</div><div class="line">    Req2 = cowboy_req:reply(200, [ &#123;&lt;&lt;”content-type"&gt;&gt;,</div><div class="line">                                    &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                            &lt;&lt;”Hello world!”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>接下来，我们编译并运行这个应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile &amp;&amp; rebar3 release</div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 console</div></pre></td></tr></table></figure>
<p>现在你已经运行了你的应用，你可以浏览<a href="http://localhost:9090" target="_blank" rel="external">http://localhost:9090</a>来验证一下。请保持这个应用一直运行，因为我们将创建这个应用的一个新版本并且尝试在线进行代码热更新。</p>
<p>上述代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0分支</a>里。</p>
<p>我们开始添加一些新的特性到我们的项目里，这样将形成我们项目的0.2.0版本，然后我们将尝试在运行着的0.1.0版本上在线进行代码热更新。版本0.2.0的代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0分支</a>。</p>
<p>我们想统计我们的default_handler已经响应的请求数。这个很好解决，我们创建一个模块<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/state_handler.erl" target="_blank" rel="external">state_handler.erl</a>，它是一个gen_server，它将存储default_handler.erl被调用的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(state_handler)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"><span class="comment">%% API functions</span></div><div class="line"><span class="keyword">-export</span><span class="params">([hello_world/<span class="number">0</span>,</span></div><div class="line">         get_hello_world_count/<span class="number">0</span>,</div><div class="line">         start_link/<span class="number">0</span>]).</div><div class="line"><span class="comment">%% gen_server callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>,</span></div><div class="line">         handle_call/<span class="number">3</span>,</div><div class="line">         handle_cast/<span class="number">2</span>,</div><div class="line">         handle_info/<span class="number">2</span>,</div><div class="line">         terminate/<span class="number">2</span>,</div><div class="line">         code_change/<span class="number">3</span>]).</div><div class="line"><span class="keyword">-record</span><span class="params">(state, &#123;count = <span class="number">0</span>&#125;)</span>.</div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="comment">%%% API functions</span></div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="function"><span class="title">hello_world</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:cast(?MODULE, hello_world).</div><div class="line"><span class="function"><span class="title">get_hello_world_count</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:call(?MODULE, hello_world_count).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:start_link(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="comment">%%% callback functions</span></div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    &#123;ok, #state&#123;&#125;&#125;.</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(hello_world_count, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, State#state.count, State&#125;;</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    Reply = ok,</div><div class="line">    &#123;reply, Reply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(hello_world, State)</span> -&gt;</span></div><div class="line">    Count = State#state.count,</div><div class="line">    &#123;noreply, State#state&#123;count = Count + <span class="number">1</span>&#125;&#125;;</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>我们修改我们的<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/default_handler.erl" target="_blank" rel="external">default_handler.erl</a>，以便每次它接收到请求的时候就通知state_handler。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(default_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    state_handler:hello_world(),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         &lt;&lt;”Hello world <span class="number">2</span> !”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>我们的state_handler将是<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_sup.erl" target="_blank" rel="external">nine9s_sup</a>监督者下的一个工作进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_sup’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(CHILD(Id, Mod, Args, Restart, Type)</span>, &#123;Id, &#123;Mod, start_link, Args&#125;, Restart, 60000, Type, [Mod]&#125;).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?SERVER&#125;, ?MODULE, []).</div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    State_Handler = ?CHILD(state_handler, state_handler, [], transient, worker),</div><div class="line">    &#123;ok, &#123; &#123;one_for_all, <span class="number">0</span>, <span class="number">1</span>&#125;, [State_Handler]&#125; &#125;.</div></pre></td></tr></table></figure>
<p>既然我们已经记录了default_handler的访问次数，我们就想有一个cowboy的路由来给出当前的访问次数，所以我们修改<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_app.erl" target="_blank" rel="external">nine9s_sup.erl</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_app’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(application)</span>.</div><div class="line"><span class="comment">%% Application callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">2</span></span></div><div class="line">         ,stop/<span class="number">1</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([set_routes_new/<span class="number">0</span></span></div><div class="line">        ,set_routes_old/<span class="number">0</span> ]).</div><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line">    Dispatch = cowboy_router:compile([&#123;‘_’, get_new_routes()&#125;]),</div><div class="line">    &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line">    [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line">    ‘nine9s_sup’:start_link().</div><div class="line"><span class="function"><span class="title">stop</span><span class="params">(_State)</span> -&gt;</span> ok.</div><div class="line"><span class="function"><span class="title">get_new_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/count”, count_handler, []&#125;] ++ get_old_routes().</div><div class="line"><span class="function"><span class="title">get_old_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/”, default_handler, []&#125;].</div><div class="line"><span class="function"><span class="title">set_routes_new</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_new_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div><div class="line"><span class="function"><span class="title">set_routes_old</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_old_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div></pre></td></tr></table></figure>
<p>请注意，我们把路由分成两部分，一部分是版本0.1.0里就有的，也就是老路由，还有一部分就是新路由。函数set_routes_new/0和set_routes_old/0我们将在后面解释。</p>
<p>下述代码是count_handler模块，就是处理路由 “/count”的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(count_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    Count = state_handler:get_hello_world_count(),</div><div class="line">    BCount = integer_to_binary(Count),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         BCount, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>最后，我们将修改在<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s.app.src#L3" target="_blank" rel="external">nine9s.app.src</a>和<a href="https://github.com/kansi/nine9s/blob/0.2.0/rebar.config#L7" target="_blank" rel="external">rebar.config</a>里的版本数字。版本0.2.0的特性就完成了。现在我们将尝试将正在运行的0.1.0版本升级到版本0.2.0。</p>
<p>为了升级到新的版本，我们需要创建一个appup文件，也就是nine9s.app.src文件，它描述了如何从版本0.1.0升级到0.2.0。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"vsn in app.src"</span>,</div><div class="line">    [ &#123;<span class="string">"upgrade from vsn"</span>, Instructions1&#125;],</div><div class="line">    [ &#123;<span class="string">"downgrade to vsn"</span>, Instructions2&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>appup文件是一个三元素组成的元组文件。第一个元素是和.app.src文件里一样的版本号（也就是当前版本）。第二个元素是一个元组列表，它的第一个元素是将要被升级的版本号，它的第二个元素是一些指令组成的列表，这些指令指示该如何从这个版本升级到新的版本。第三个元素也是一个元组列表，它的第一个元素是将要降级到的版本号，它的第二个元素是也是一些指令组成的列表，这些指令指示该如何降级到这个版本。</p>
<p>下面是应用nine9s的appup文件内容：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;“<span class="number">0.2</span>.<span class="number">0</span>”,</div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;add_module, state_handler&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, restart_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;add_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_new, [] &#125;&#125; ] &#125;],</div><div class="line"></div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, terminate_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, delete_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;delete_module, state_handler&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_old, [] &#125;&#125;</div><div class="line">             ,&#123;delete_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ]</div><div class="line">&#125;]&#125;.</div></pre></td></tr></table></figure></p>
<p>现在我们先来解释一下升级指令。注意：这些指令是按它们在文件中的先后顺序来执行的。</p>
<ul>
<li>{add_module, state_handler} : 指示增加state_handler模块到运行环境里。</li>
<li>{update, nine9s, supervisor} : 这条指令将修改监督者的内部状态，也就是改变重启策略和最大重启频率，同时也改变子进程规格说明。最终将增加state_handler这个模块到监督者的子进程规格说明里。</li>
<li>{apply, {supervisor, restart_child, [nine9s, state_handler]}} : “apply”指令接收{M,F,A}做为参数，然后执行 M:F(A1, … An)。所以我们实际上是执行supervisor:restart_child(nine9s, state_handler)，这将在nine9s_sup监督者下启动state_handler做为工作进程。请注意：上述三条指令的顺序。首先我们增加state_handler模块，然后改变监督者的状态，最后创建state_handler进程。</li>
<li>{load_module, default_handler} : 这条指令将重新装载default_handler模块，替换它的老版本代码。</li>
<li>{add_module, count_handler} : 增加count_handler模块。</li>
<li>{load_module, nine9s_app} : 我们重新装载nine9s_app，从而我们新增加的函数被装载进虚拟机。</li>
<li>{apply, {nine9s_app, set_routes_new, [ ] }} ] } ] : 既然我们装载了新的函数，我就执行 nine9s_app:set_routes_new() 增加新的路由到我们的服务器。</li>
</ul>
<p>接下来的元素是如何降级的指令，它的工作模式和前一个元素相似，但是是用老模块替换新模块。</p>
<ul>
<li>{load_module, default_handler} : 这个指令将装载老的default_handler模块。</li>
<li>{apply, {supervisor, terminate_child, [nine9s_sup, state_handler]}} : 终止state_handler进程。</li>
<li>{apply, {supervisor, delete_child, [nine9s_sup, state_handler]}} : 从nine9s_sup里删除state_handler这个子进程规格。</li>
<li>{update, nine9s_sup, supervisor} : 修改监督者nine9s_sup的内部状态。</li>
<li>{delete_module, state_handler} : 删除state_handler模块。</li>
<li>{apply, {nine9s_app, set_routes_old, [ ] }} : 设置路由为老版本路由。</li>
<li>{delete_module, count_handler} : 删除count_handler模块。</li>
<li>{load_module, nine9s_app} : 装载老的nine9s_app模块。</li>
</ul>
<p>既然我们的appup文件准备好了，我们就开始升级到最新的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先我们拷贝appup文件到lib目录下nine9s/ebin下</span></div><div class="line">$ cp apps/nine9s/src/nine9s.appup.src _build/default/lib/nine9s/ebin/nine9s.appup</div><div class="line"><span class="comment"># 接着我们编译和发布应用</span></div><div class="line">$ rebar3 compile</div><div class="line">$ rebar3 release</div><div class="line"><span class="comment"># 生成relup到前一个版本</span></div><div class="line">$ rebar3 relup -n nine9s -v <span class="string">"0.2.0"</span> -u <span class="string">"0.1.0"</span></div><div class="line"><span class="comment"># 生成新版本的tar文件</span></div><div class="line">$ rebar3 tar -n nine9s -v <span class="string">"0.2.0"</span></div><div class="line">$ mv _build/default/rel/nine9s/nine9s-0.2.0.tar.gz _build/default/rel/nine9s/releases/0.2.0/nine9s.tar.gz</div><div class="line"><span class="comment"># 升级到新的版本</span></div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 upgrade <span class="string">"0.2.0"</span></div></pre></td></tr></table></figure>
<p>搞定！如果所有执行都成功，那么我们就升级到0.2.0版本了。你可以浏览 <a href="http://localhost:9090和http://localhost:9090/count来验证一下。" target="_blank" rel="external">http://localhost:9090和http://localhost:9090/count来验证一下。</a></p>
<p>项目有两个分支<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0</a>和<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0</a>。你可以先编译和运行分支0.1.0，然后切换到0.2.0分支，使用python脚本<a href="https://github.com/kansi/nine9s/blob/0.2.0/upgrade.py" target="_blank" rel="external">upgrade.py</a>来升级到0.2.0版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4" target="_blank" rel="external">https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Rebar3 Shell]]></title>
      <url>http://szpzs.oschina.io/2016/12/07/rebar3-shell/</url>
      <content type="html"><![CDATA[<p>这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。</p>
<a id="more"></a>
<p>它有很多好的特性，不过在我的观点来看，这些是一个Erlang shell工具最少要支持的。因此，尝试展示这些特性听起来好像是吹嘘你该做的本分事情一样；多说无益，下面就进入正题。</p>
<p>不过，一些Erlang的东西的可用性一直很糟糕，我们（贡献者）已经在rebar3上做了很多工作来尝试解决这些糟糕的体验。我不得不说，很多社区已经有大量的非常好的工具，但是它们都是独立的，如何用好它们必须要读者自己去逐个尝试。这个时候，rebar3横空出世了。</p>
<p>当使用rebar3 shell命令的时候首先吸引人的是，它会自动编译项目（如果项目还没有被编译）并且将编译后的项目加入你的代码搜索路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; vegur:module_info().</div><div class="line">[&#123;module,vegur&#125;,</div><div class="line">&#123;exports,[&#123;start_http,3&#125;,</div><div class="line">&#123;start_proxy,3&#125;,</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个功能作用于所有项目。这至少摆脱很多需要你自己手写默认设置的许多烦恼。现在这些都由rebar3 shell来做。</p>
<p>对于一个编程语言来说，一个好的shell环境就是关于它的互动性。期望能够快速地重编译代码或者运行测试，并且重新装载代码而不需要任何中断或丢失状态。rebar3 shell有一个代理，隐藏在r3模块背后，它准备着所有需要重新编译代码或者运行任务的状态的管理。所以，例如任何存在的项目，我可以要求重新编译或者任何其他任务运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; r3:do(compile).</div><div class="line">===&gt; This feature is experimental <span class="keyword">and</span> may be modified or removed at any time.</div><div class="line">Verifying dependencies...</div><div class="line">Compiling vegur</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(ct).</div><div class="line">Verifying dependencies...</div><div class="line">Fetching websocket_client (&#123;git,<span class="string">"git@github.com:jeremyong/websocket_client.git"</span>,</div><div class="line">&#123;tag,<span class="string">"v0.7"</span>&#125;&#125;)</div><div class="line">Linking _build/default/lib/cowboyku to _build/test/lib/cowboyku</div><div class="line">Linking _build/default/lib/cowlib to _build/test/lib/cowlib</div><div class="line">Linking _build/default/lib/erequest_id to _build/test/lib/erequest_id</div><div class="line">...</div><div class="line">Running Common Test suites...</div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_callback: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_timeout: OK</span></div><div class="line">...</div><div class="line">All <span class="number">140</span> tests passed.</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(dialyzer).</div><div class="line">Verifying dependencies...</div><div class="line">...</div><div class="line">Analyzing <span class="number">19</span> files with <span class="string">"/home/ferd/code/self/vegur/_build/default/rebar3_18.1.5_plt"</span>...</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>如上述例子等等。所有这些任务都会用你的最新版本的rebar.config文件来运行它的任务和切换路径重装载模块等等。</p>
<p>rebar3的代理还有一个名字使得可以在外部调用它。你可以用一个名字来启动一个shell（rebar3 shell –name my_shell 或 rebar3 shell –sname my_shell）然后远程向它发送消息或者直接RPC调用当作指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --sname=my_shell</div><div class="line">erl -sname remote -eval <span class="string">'rpc:call(my_shell@localhost, r3, do, [ct]), halt(0).'</span> -noshell</div></pre></td></tr></table></figure>
<p>当作人们的工具的目的应该是可以被用来从你的IDE或编辑器里增加钩子到Erlang shell里。</p>
<p>被写出来的和rebar3代理一起工作的插件也是一种选择。例如，通过监控硬盘，<a href="https://www.rebar3.org/docs/using-available-plugins#auto-compile-and-load" target="_blank" rel="external">rebar3_atuo 能够被用来自动重新编译修改过的文件</a>，这样也省了这个的功能要和IDE或编辑器合成的需求。</p>
<p>这提供了一个非常好的改进，例如，在运行调试周期，在测试，代码分析和交互式调试都可以在同一个环境进行。</p>
<p>为了使得开发周期更加与你的项目成长无缝对接，rebar3 shell将在构建工具里自动侦测<a href="https://www.rebar3.org/docs/releases" target="_blank" rel="external">release配置</a>，并且以你的release遵循的的<a href="https://www.rebar3.org/docs/releases#section-application-configuration" target="_blank" rel="external">应用配置</a>【1】启动你的系统。</p>
<p>这意味着只要你的代码库配置成装配为一个可执行版本，你可以在它里面访问shell的代码重装载特性，使用的是同样的工具，而这些工具你可能以别的方式使用。</p>
<p>如果你不使用release呢？应用可以在你的rebar.config文件里被指定为{shell, [{apps, [myapp]}]}  或者在命令行里的参数里指定（–apps app1,app2）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --apps vegur</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">...</div><div class="line">===&gt; Booted midjan</div><div class="line">===&gt; Booted quickrand</div><div class="line">===&gt; Booted uuid</div><div class="line">===&gt; Booted erequest_id</div><div class="line">===&gt; Booted vegur</div></pre></td></tr></table></figure>
<p>万一你的开发环境和生产环境不匹配，任意的代码可以被运行来设置shell并且通过escript来设置它。这些设置指定的动态环境变量或启动外部依赖的模拟模块是特别有用的。为了进一步解释，下面的例子将展示我们如何不让shell启动，除非所有需要设置的环境变量都设置好了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env escript</div><div class="line"></div><div class="line"><span class="function"><span class="title">main</span><span class="params">(_)</span> -&gt;</span></div><div class="line">	OSVars = [<span class="string">"USER"</span>, <span class="string">"PASS"</span>],</div><div class="line">	[check_is_set(Var) || Var &lt;- OSVars].</div><div class="line"></div><div class="line"><span class="function"><span class="title">check_is_set</span><span class="params">(Var)</span> -&gt;</span></div><div class="line">	<span class="keyword">case</span> os:getenv(Var) <span class="keyword">of</span></div><div class="line">		<span class="literal">false</span> -&gt;</div><div class="line">			rebar_api:error(<span class="string">"Missing var ~s"</span>, [Var]),</div><div class="line">			halt(<span class="number">1</span>);</div><div class="line">		_ -&gt;</div><div class="line">			ok</div><div class="line">	<span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个escript文件可以通过增加{shell, [{script_file, “path/to/file”}]}到你的rebar.config文件配置成总是执行，或者通过在命令行被直接调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --script_file <span class="built_in">test</span>/check_env.escript</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; ===&gt; Missing var PASS</div></pre></td></tr></table></figure>
<p>希望这些工具比那些开箱即用的更可以让Erlang开发者的生活轻松些。</p>
<p>【1】这里有些警告：因为rebar3 shell是一个开发工具，诸如Erlang虚拟机配置的选项（例如，调度器的数量）已经在运行时里有了而且不能被修改。它不能复制所有release的配置，因此，你应该在生产环境保持使用release。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">http://ferd.ca/rebar3-shell.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Rebar3构建你的第一个Erlang应用]]></title>
      <url>http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/</url>
      <content type="html"><![CDATA[<p>Rebar3是Erlang的构建工具和包管理工具。归功于<a href="http://www.rebar3.org/" target="_blank" rel="external">Rebar3</a>以及它的插件<a href="https://hex.pm/" target="_blank" rel="external">Hex</a>，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。</p>
<a id="more"></a>
<h1 id="下载Rebar3"><a href="#下载Rebar3" class="headerlink" title="下载Rebar3"></a>下载Rebar3</h1><p>从Rebar3官方网站下载最新版本的Rebar3，网址：<a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -O https://s3.amazonaws.com/rebar3/rebar3</div></pre></td></tr></table></figure>
<p>用chmod赋予其可执行权限，并将它加入你的环境变量PATH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x rebar3</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:rebar3所在目录</div></pre></td></tr></table></figure>
<h1 id="你的第一个Erlang应用"><a href="#你的第一个Erlang应用" class="headerlink" title="你的第一个Erlang应用"></a>你的第一个Erlang应用</h1><p>使用rebar3 new命令采用内建模块app可以创建一个新的项目。在本例子里我们创建一个叫做myapp的项目。其他可用内建模版是：release、lib、plugin、escript、cmake。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new app myapp</div><div class="line">===&gt; Writing myapp/src/myapp_app.erl</div><div class="line">===&gt; Writing myapp/src/myapp_sup.erl</div><div class="line">===&gt; Writing myapp/src/myapp.app.src</div><div class="line">===&gt; Writing myapp/rebar.config</div><div class="line">===&gt; Writing myapp/.gitignore</div><div class="line">===&gt; Writing myapp/LICENSE</div><div class="line">===&gt; Writing myapp/README.md</div></pre></td></tr></table></figure>
<p>代码在src目录里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> myapp</div><div class="line">$ tree</div><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── rebar.config</div><div class="line">└── src</div><div class="line">    ├── myapp.app.src</div><div class="line">    ├── myapp_app.erl</div><div class="line">    └── myapp_sup.erl</div></pre></td></tr></table></figure>
<p>因为Rebar3只处理 <a href="http://www.erlang.org/doc/design_principles/applications.html" target="_blank" rel="external">OTP结构的项目</a> ，所以约定成俗用一个 .app.src 文件定义你的应用是一个OTP应用。看起来是不是很熟悉？这个文件也是Erlang文件。你可以阅读 <a href="http://www.erlang.org/doc/design_principles/applications.html#id73836" target="_blank" rel="external">详细的指引</a> 来看看它都能包括些什么元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp.app.src</div><div class="line">&#123;application, <span class="string">'myapp'</span>,</div><div class="line"> [&#123;description, <span class="string">"An OTP application"</span>&#125;,</div><div class="line">  &#123;vsn, <span class="string">"0.1.0"</span>&#125;,</div><div class="line">  &#123;registered, []&#125;,</div><div class="line">  &#123;mod, &#123;<span class="string">'myapp_app'</span>, []&#125;&#125;,</div><div class="line">  &#123;applications,</div><div class="line">   [kernel,</div><div class="line">    stdlib</div><div class="line">   ]&#125;,</div><div class="line">  &#123;env,[]&#125;,</div><div class="line">  &#123;modules, []&#125;</div><div class="line"> ]&#125;.</div></pre></td></tr></table></figure>
<p>src/myapp_app.erl是一个非常简单的代码框架。它只是让你可以启动和停止你的Erlang应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp_app.erl</div><div class="line">-module(<span class="string">'myapp_app'</span>).</div><div class="line">-behaviour(application).</div><div class="line">-export([start/2, stop/1]).</div><div class="line">start(_StartType, _StartArgs) -&gt;</div><div class="line">    <span class="string">'myapp_sup'</span>:start_link().</div><div class="line">stop(_State) -&gt;</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>Rebar3用rebar.config来指定一些额外的元数据，比如<a href="https://github.com/rebar/rebar/wiki/Dependency-management" target="_blank" rel="external">依赖</a>。rebar.config还可以包含很多配置项。你可以参考 <a href="https://github.com/rebar/rebar/blob/master/rebar.config.sample" target="_blank" rel="external">详细例子</a> 来学习各种配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat rebar.config</div><div class="line">&#123;erl_opts, [debug_info]&#125;.</div><div class="line">&#123;deps, []&#125;.</div></pre></td></tr></table></figure>
<p>现在我们用Rebar3启动一个Erlang shell，它包含了你的应用及依赖的路径。然后运行 application:start(myapp). 来确认你的应用被正确地装载了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling myapp</div><div class="line">Erlang R16B03-1 (erts-5.10.4) [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line">Eshell V5.10.4  (abort with ^G)</div><div class="line">1&gt; application:start(myapp).</div><div class="line">ok</div><div class="line">2&gt; application:stop(myapp).</div><div class="line">ok</div><div class="line">3&gt;</div><div class="line">=INFO REPORT==== 29-Jun-2015::16:14:10 ===</div><div class="line">    application: myapp</div><div class="line">    exited: stopped</div><div class="line">    <span class="built_in">type</span>: temporary</div></pre></td></tr></table></figure>
<p><a href="https://github.com/ferd" target="_blank" rel="external">Fred Hebert</a> （<a href="http://learnyousomeerlang.com/" target="_blank" rel="external">Learn You Some Erlang</a> 的作者）写了一篇很好的<a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">文章</a>介绍rebar3 shell的命令。</p>
<h1 id="Erlang的包"><a href="#Erlang的包" class="headerlink" title="Erlang的包"></a>Erlang的包</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要安装一个叫做<a href="https://github.com/hexpm/rebar3_hex" target="_blank" rel="external">rebar3_hex</a>的插件来从<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>（Erlang和Elixir的包管理者）获取和安装Erlang包。简单地把如下一行加入到rebar.config文件中（你需要Erlang/OTP17.4或以上版本）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;plugins, [rebar3_hex]&#125;.</div></pre></td></tr></table></figure>
<p>然后运行命令：rebar3 update 来启用这个插件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rebar3 update</div><div class="line">===&gt; Fetching jsx (&#123;pkg,&lt;&lt;<span class="string">"jsx"</span>&gt;&gt;,&lt;&lt;<span class="string">"2.6.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching ssl_verify_hostname (&#123;pkg,&lt;&lt;<span class="string">"ssl_verify_hostname"</span>&gt;&gt;,</div><div class="line">                                           &lt;&lt;<span class="string">"1.0.5"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching rebar3_hex (&#123;pkg,&lt;&lt;<span class="string">"rebar3_hex"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.6.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling ssl_verify_hostname</div><div class="line">===&gt; Compiling jsx</div><div class="line">===&gt; Compiling rebar3_hex</div><div class="line">===&gt; Updating package index…</div></pre></td></tr></table></figure>
<p>如果你想避免每次创建一个新Erlang应用都要做这个步骤，则将上述配置添加到全局的配置文件rebar.config中，并把这个配置文件放置在如下目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.config/rebar3/rebar.config</div></pre></td></tr></table></figure>
<h2 id="查找Erlang包"><a href="#查找Erlang包" class="headerlink" title="查找Erlang包"></a>查找Erlang包</h2><p>搜索命令让你远程查找在<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>上发布的Erlang包。你可以在查询语句里用正则表达式字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 hex search cowboy</div><div class="line">cloudi_service_http_cowboy</div><div class="line">cowboy</div></pre></td></tr></table></figure>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>Rebar3能下载和安装Erlang包以及任何必要的依赖。在你的rebar.config文件里增加应用名字到deps配置项，然后运行命令：rebar3 compile。下面的例子，我们尝试使用两个Erlang包，cowboy和meck。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [cowboy, meck]&#125;.</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Fetching ranch (&#123;pkg,&lt;&lt;<span class="string">"ranch"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching meck (&#123;pkg,&lt;&lt;<span class="string">"meck"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.8.2"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowlib (&#123;pkg,&lt;&lt;<span class="string">"cowlib"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowboy (&#123;pkg,&lt;&lt;<span class="string">"cowboy"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling cowlib</div><div class="line">===&gt; Compiling ranch</div><div class="line">===&gt; Compiling meck</div><div class="line">===&gt; Compiling cowboy</div><div class="line">===&gt; Compiling myapp</div></pre></td></tr></table></figure>
<p>想要安装一个Erlang包的指定版本？在配置中把应用名字和版本写在一个元组中。你可以在<a href="https://hex.pm/" target="_blank" rel="external">Hex主页</a>上查询Erlang包的可用版本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [&#123;cowboy, “<span class="number">1.0</span>.<span class="number">2</span>”&#125;, &#123;meck, <span class="string">"0.8.3"</span>&#125;]&#125;.</div></pre></td></tr></table></figure>
<h2 id="列出已安装的包"><a href="#列出已安装的包" class="headerlink" title="列出已安装的包"></a>列出已安装的包</h2><p>rebar3 deps 命令列出你本地已经安装的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div><div class="line">meck (locked package 0.8.2)</div></pre></td></tr></table></figure>
<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>要卸载一个包，你首先要在rebar.config文件中将它删除，然后使用命令：rebar unlock。现在我们卸载meck包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 unlock</div><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div></pre></td></tr></table></figure>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz" target="_blank" rel="external">https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红回调和绿回调]]></title>
      <url>http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/</url>
      <content type="html"><![CDATA[<p>有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。</p>
<p>为了解释这个问题，我必须先回过头来讲讲I/O。</p>
<a id="more"></a>
<h1 id="Erlang的并发I-O"><a href="#Erlang的并发I-O" class="headerlink" title="Erlang的并发I/O"></a>Erlang的并发I/O</h1><p>Erlang是如何处理并发I/O的？相当简单！假设我们有三个进程A、B和C，它们在并行执行。我用如下的方式描述这个场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A || B || C</div></pre></td></tr></table></figure>
<p>上述描述假设三个进程A、B、C正在进行I/O操作。</p>
<p>进程A如下所描述做一些事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A: --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>进程B则如下描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B: ---- write --- write --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>C进程也大致如此。虚线表示一些顺序的计算。进程A的Erlang代码框架如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">a</span><span class="params">()</span> -&gt;</span></div><div class="line">    ...</div><div class="line">    X = read(),</div><div class="line">    ...</div><div class="line">    Y = read(),</div><div class="line">    ...</div><div class="line">    write(...),</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>进程B和进程C的代码也和这个差不多。</p>
<p>Erlang里实际上是没有read()这个函数的。Erlang有  <a href="http://www.erlang.org/course/concurrent_programming.html#select" target="_blank" rel="external">select receive</a>  模式来处理消息，所以我们实际上定义的read()函数像如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        Pattern1 -&gt;</div><div class="line">           ...</div><div class="line">        Pattern2 -&gt;</div><div class="line">           ...</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>select receive 模式如何工作的细节不是本次讨论的重点，因此本文我将忽略这些细节。</p>
<p>重点是我在进程A的代码里如下所写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">X = read()</div><div class="line">...</div></pre></td></tr></table></figure>
<p>那么，我们的进程将在read函数处被挂起（或者叫做阻塞）直到read函数执行完毕。因此我们的代码“看起来像”是正在做一个同步阻塞的读动作。</p>
<p>看起来像是用双引号括起来的，因为它不是一个真正的阻塞读，而是一个真正的异步读，这个读操作不阻塞其他任何Erlang进程。</p>
<p>这真是棒极了，因为从一开始，程序就等待读请求完成，然后获得读取到的数据，程序继续运行。</p>
<h1 id="理解并发"><a href="#理解并发" class="headerlink" title="理解并发"></a>理解并发</h1><p>Erlang的I/O非常特别。当我们有两个并行的进程A和B，A进程里的一个读请求将明显地阻塞A进程，但是不会对其他任何并行的进程（这里指B）有影响。</p>
<p>所以A和B可以都同时执行写入操作就好像它们是连续的进程。</p>
<p>现在假设我们没有一个合适的基础并发模型。假设所有我们要做的事情都放入一个单独线程来执行。假设我们做一个读操作（它是阻塞的）而其他事情都在等待。啊！亲！我们的编程模型是更加清晰简单了，但是我们却浪费了CPU的宝贵资源。</p>
<p>现在在一些语言（正是我在研究的Javascript）没有多进程和多线程。不确切地说，它有一个线程，所有的事情都揉进这个线程里。在Javascript里要写与读相关操作的代码，你不得不用红回调，并且发明你自己的并发概念。</p>
<h1 id="红回调"><a href="#红回调" class="headerlink" title="红回调"></a>红回调</h1><p>在Javascript里你肯定不想在主线程里做一个阻塞同步读操作（记住它只有一个线程），那么你必需设置一个回调，当读操作完成的时候触发这个回调。我叫这样的回调为红回调。你写的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; ... do something <span class="keyword">with</span> x ..&#125;;</div><div class="line"><span class="keyword">var</span> error = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; .... x …&#125;</div><div class="line">read(Something, &#123;onSuccess:done, onError:error&#125;);</div><div class="line">... ... more code ...</div></pre></td></tr></table></figure>
<p>这样的代码搞得我脑袋一团浆糊。</p>
<p>当程序正在上述代码 more code 的某个地方执行的时候，读操作完成了，则必需立即回到done这个函数来执行，然后再回到前面 more code 中断的地方。我发现这个方式非常难以理解。</p>
<p>这的确很糟糕，每一个要解决并发问题的Javascript程序员必需要发明他自己的并发模型。问题就在于他们不知道他们正在做的是什么。每次一个Javascript程序员写下一行代码，说是“此处就该这么做”的时候，他实际上是在发明一个新的并发模型，并且在这些代码执行的时候他是没有任何线索知道这些代码是怎样交织在一起的。</p>
<p>（其实我对Javascript又爱又恨，它的大部分我都喜欢，但是就是恨它的并发模型。不过好笑的是，Javascript是没有并发模型的，所以对它也无从可恨了。:-）</p>
<p>更加难以理解的是错误。在共享内存的多线程回调代码里的错误更加是令我极度头痛！</p>
<h1 id="绿回调"><a href="#绿回调" class="headerlink" title="绿回调"></a>绿回调</h1><p>只是为了使得生活更加困惑，在Erlang里我们大量使用了回调。我把这些回调称为“绿回调”。因此回调并不一定是不好的。在Erlang里，我们可以在一个进程的上下文里更清晰地看到回调的执行，所以我们没有如何查看回调执行过程的问题。</p>
<p>如下是Erlang里一个绿回调的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">loop</span><span class="params">(F)</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;new_callback, F1&#125; -&gt;</div><div class="line">            loop(F1);</div><div class="line">        Msg -&gt;</div><div class="line">            F(Msg),</div><div class="line">            loop(F)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>当一个进程运行这段代码的时候收到一个消息Msg，它就执行函数F(Msg)。这里没有任何不确定的，当回调被触发的时候我们确切地知道。在收到消息Msg后，这个回调被立即触发。</p>
<p>这一小段代码却非常漂亮。如果你给进程发送一个消息{new_callbak, F1}，那么它将改变它的行为，在下一次调用的时候，它将执行新的回调。</p>
<p>我不知道你在Javascript里如何写出这样的代码。我写过大量的JQurey代码并且明白如何设置和删除回调。但是在删除一个事件处理并新增一个事件处理这期间里，这个事件被触发了，这会发生什么？我不知道。生命如此短暂如何花的起那么多时间来找这个答案。</p>
<h1 id="Erlang的I-O是如何工作的"><a href="#Erlang的I-O是如何工作的" class="headerlink" title="Erlang的I/O是如何工作的"></a>Erlang的I/O是如何工作的</h1><p>我们实际上并没有给进程发送消息。我们给进程的邮箱发送消息。每一个进程有一个邮箱，当我们给一个进程发送消息，这个消息被放入这个进程的邮箱（如果快递小子能找到这个进程的话）。</p>
<p>想像一下，Erlang的进程是有邮箱的房子。发送消息就好比你把你的消息给快递小子。快递小子的工作就是做两件事：把邮件放入目的邮箱并敲门说：“有新信到了”。</p>
<p>进程可能在忙着也可能在睡觉，就如一个房东一个样，他可能在干这活或者在睡觉。如果他在睡觉，那么当邮递员来了并敲响了房门，房东就会走到邮箱那里检查是否有令人感兴趣的邮件。</p>
<p>如果房东此时把手头的活干完后，正在做其他事情的时候，房东可能会走到邮箱那里检查是否有新的邮件到了，</p>
<p>这就是Erlang的消息工作机制。每一个房子（进程）有它自己的生命周期。邮递员投递邮件，房东根据自己的意愿决定什么时候去检查邮箱。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html" target="_blank" rel="external">http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang(和Elixir)无epmd之分布式]]></title>
      <url>http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/</url>
      <content type="html"><![CDATA[<p>当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：</p>
<ul>
<li>epmd（Erlang端口映射守护进程）端口4369，</li>
<li>Erlang节点自己的端口，一个不可预知的大数字端口。</li>
</ul>
<p>这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的<a href="http://erlang.org/doc/man/kernel_app.html" target="_blank" rel="external">kernel文档</a>里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。</p>
<a id="more"></a>
<p>但是如果我们限制了Erlang节点在一个单独的端口，那么我们还真的需要一个端口映射吗？运行epmd有以下几个潜在的缺点：</p>
<ul>
<li>我们可能想要以运行Erlang节点的用户来运行epmd，但是正如我们将见到的，这个很难得到保证。</li>
<li>我们可能想要配置epmd监听一个特定的端口，但是这依赖于在本机上我们如何第一次运行epmd。</li>
<li>任何人无需身份验证可以连接epmd并且可以列出本地的所有Erlang节点。</li>
<li>与epmd的连接都没有加密，即使你按 <a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">Erlang distribution over TLS</a> 这篇文章的方法去做，与epmd的连接也是不受保护的，并且有被中间人攻击的潜在风险。</li>
<li>虽然epmd很稳定，它也有发生崩溃的可能。一旦它崩溃了，任何已经存在的分布式Erlang节点将继续运行，即使epmd恢复了，这些节点也不会重新连接empd。这意味着存在的分布式连接继续工作着，但是与这些节点的新的连接将不起作用。阅读俄文博客 <a href="https://habrahabr.ru/post/49535/" target="_blank" rel="external">Экстренная реанимация epmd</a> 可能可以在不重启epmd的情况下解决这个问题。</li>
</ul>
<p>那么我们来研究一下epmd是如何工作的，然后我们如何做就可以在不用epmd的情况下运行一个Erlang集群。</p>
<h1 id="epmd是如何第一次启动的？"><a href="#epmd是如何第一次启动的？" class="headerlink" title="epmd是如何第一次启动的？"></a>epmd是如何第一次启动的？</h1><p>让我们来读读源码！epmd是在<a href="https://github.com/erlang/otp/blob/OTP-19.1.1/erts/etc/common/erlexec.c#L1234-L1279" target="_blank" rel="external">erlexec.c文件的start_epmd函数</a>里被启动的。实际上，每一次一个Erlang分布式节点启动epmd都无条件地被启动。如果一个epmd实例已经在运行，新的epmd在侦听端口4369的时候将失败，它将因此悄无声息地结束运行。</p>
<p>事实上，这就是即使由另一个用户启动的epmd实例存在系统将发生的事情。任何epmd实例都非常乐意为由任何用户启动的Erlang节点服务，因此这个通常不会引起任何问题。</p>
<h1 id="那么谁可以连接epmd？"><a href="#那么谁可以连接epmd？" class="headerlink" title="那么谁可以连接epmd？"></a>那么谁可以连接epmd？</h1><p>任何人都可以！默认情况下，epmd侦听在所有有效的接口上，并且响应关于当前有哪些节点以及这些节点所侦听的端口的查询。一听到这个场景，系统管理员应该有点紧张。</p>
<p>你可以在epmd启动前通过手工指定 -address 选项或设定ERL_EPMD_ADDRESS 环境变量启动epmd来改变上述情况。这个方法在<a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="external">官方文档</a>里有描述。这个方法需要在你第一次启动epmd的时候来做，否则，已经存在的epmd实例将不受影响地继续运行。</p>
<h1 id="为什么我们需要一个端口映射守护进程？"><a href="#为什么我们需要一个端口映射守护进程？" class="headerlink" title="为什么我们需要一个端口映射守护进程？"></a>为什么我们需要一个端口映射守护进程？</h1><p>很明显，epmd就是一个中间人。我们可以绕过这个中间人吗？</p>
<p>我们可以让每个Erlang节点侦听在一个大家熟知的端口–如果我们打算去除掉epmd的话，我们可以用empd默认保留的端口，4369。但是这就意味着我们只能够在每个主机上运行一个Erlang节点（当然，在某些场景下这就足够了）。</p>
<p>那么让我们指定一些其他端口。前面我们提到变量 inet_dist_listen_min 和 inet_dist_listen_max 。这两个变量定义一个端口范围，不过如果我们设置它们为相同的值，我们就把范围缩小到一个端口：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">erl -sname foo \</div><div class="line">    -kernel inet_dist_listen_min <span class="number">4370</span> \</div><div class="line">            inet_dist_listen_max <span class="number">4370</span></div></pre></td></tr></table></figure>
<p>这个方法不错，不过我们也需要告诉其他节点不要再去询问epmd来获取端口号，而是只用这个端口号来代替。如果我们在同一个主机上有几个节点，我们需要为这些节点配置不同的端口号。</p>
<h1 id="用别的方法"><a href="#用别的方法" class="headerlink" title="用别的方法"></a>用别的方法</h1><p>在Erlang/OTP 19.0里，有两个新的命令行选项：</p>
<ul>
<li>当我们指定 -start_epmd false，Erlang将不会在启动一个分布式节点的时候尝试去启动epmd；</li>
<li>选项 -epmd_module foo 让你指定一个不同的模块替代默认的模块erl_epmd，用来节点名字注册和查询。</li>
</ul>
<p>接下来我们来构建一些代码！</p>
<p>我想用一个无状态的方式来实现这个方法：既然发起连接的节点知道了它要连接的节点的名字，那么我就用这个名字作为资源来得到相应的端口号。我选择4370这个端口作为基准端口，它比epmd的端口大一。接着我从节点名称的“节点”部分抽取出数字，比如节点名称为 myapp3@foo.example.com 抽取的数字是3。最后我把这个数字和基准端口相加。由此得知，节点 myapp3@foo.example.com 侦听在端口4373。如果节点名字最后不是数字，我这种情况将处理为0。这意味着节点 myapp3 和 myotherapp3 不能运行在同一个主机上，但是我准备好了处理对这种场景。（感谢 Luca Favatella 的完美建议）</p>
<p>为此我们来写一个小模块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([dist_port/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% 返回被一个指定节点使用的端口号。</span></div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_atom</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    dist_port(atom_to_list(Name));</div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_list</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 获取基端口号。如果没有在 kernel 的环境变量</span></div><div class="line">    <span class="comment">%% inet_dist_base_port 里指定, 则默认为</span></div><div class="line">    <span class="comment">%% 4370, 比epmd端口大1。</span></div><div class="line">    BasePort = application:get_env(kernel, inet_dist_base_port, <span class="number">4370</span>),</div><div class="line"></div><div class="line">    <span class="comment">%% 现在，算出我们相对于基端口号的偏移值。</span></div><div class="line">    <span class="comment">%% 这个偏移值就是我们节点名的@符号左边的数字。</span></div><div class="line">    <span class="comment">%% 如果这个数字不存在，则偏移量设置为0。</span></div><div class="line">    <span class="comment">%%</span></div><div class="line">    <span class="comment">%% 同时我们也处理主机名没有指定的情况。</span></div><div class="line">    NodeName = re:replace(Name, <span class="string">"@.*$"</span>, <span class="string">""</span>),</div><div class="line">    Offset =</div><div class="line">        <span class="keyword">case</span> re:run(NodeName, <span class="string">"[0-9]+$"</span>, [&#123;capture, first, list&#125;]) <span class="keyword">of</span></div><div class="line">            nomatch -&gt;</div><div class="line">                <span class="number">0</span>;</div><div class="line">            &#123;match, [OffsetAsString]&#125; -&gt;</div><div class="line">                list_to_integer(OffsetAsString)</div><div class="line">        <span class="keyword">end</span>,</div><div class="line"></div><div class="line">    BasePort + Offset.</div></pre></td></tr></table></figure>
<p>同时我们还要写一个模块用作 -epmd_module。有一点小复杂就是因为OTP19.0期望这个模块导出 register_node/2 函数，而从OTP19.1开始则是期望导出 register_node/3 函数。我们把这两个函数都包含进去。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_epmd_client)</span>.</div><div class="line"></div><div class="line"><span class="comment">%% epmd_module 回调函数</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>,</span></div><div class="line">         register_node/<span class="number">2</span>,</div><div class="line">         register_node/<span class="number">3</span>,</div><div class="line">         port_please/<span class="number">2</span>,</div><div class="line">         names/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="comment">%% 监督者模块 erl_distribution 尝试着把我们当做一个被监督的子进程。</span></div><div class="line"><span class="comment">%% 我们不需要子进程，所以返回 ignore 。</span></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    ignore.</div><div class="line"></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(_Name, _Port)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 本函数是我们连接epmd并告诉它我们监听哪个端口，</span></div><div class="line">    <span class="comment">%% 不过因为我们是无epmd的，所以我们不需要做这些。</span></div><div class="line"></div><div class="line">    <span class="comment">%% 需要返回一个1到3的 ”creation” 数字。</span></div><div class="line">    Creation = rand:uniform(<span class="number">3</span>),</div><div class="line">    &#123;ok, Creation&#125;.</div><div class="line"></div><div class="line"><span class="comment">%% 从Erlang/OTP19.1开始，register_node/3函数替代register_node/2函数，</span></div><div class="line"><span class="comment">%% 该函数多了一个地址族的入参，取值为 ‘inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line"><span class="comment">%% 这一点对我们来说没有多大的改动。</span></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(Name, Port, _Family)</span> -&gt;</span></div><div class="line">    register_node(Name, Port).</div><div class="line"></div><div class="line"><span class="function"><span class="title">port_please</span><span class="params">(Name, _IP)</span> -&gt;</span></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line">    <span class="comment">%% 分布式协议版本从Erlang/OTP16开始就是5。</span></div><div class="line">    Version = <span class="number">5</span>,</div><div class="line">    &#123;port, Port, Version&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">names</span><span class="params">(_Hostname)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 因为我们没有epmd，所以我们真的不知道此处是否有其他节点。</span></div><div class="line">    &#123;error, address&#125;.</div></pre></td></tr></table></figure>
<p>正如你所见，大多数事情基本完成了。</p>
<p>当这个模块被加为 erl_distribution 监督者的子进程的时候，start_link/0 将被调用。我们并不需要在这个启动一个进程，因此我们只是返回 ignore。</p>
<p>register_node函数通常会连接epmd并告诉它我们使用哪一个端口。epmd将返回一个“creation”数字。“creation”数字上一个介于1和3的整数。epmd跟踪每一个节点名字的“creation”数字并且当一个确定名字的节点重连的时候增加这个数字。这意味着它可以区分先前某一个节点“存活期间”的进程id。</p>
<p>既然我们没有epmd，那么我们就没有获得它跟踪节点生命周期的好处。在这里我们返回一个随机数，它有三分之二的机会不同于前面的“creation”数字。</p>
<p>port_please/2 获取远程主机的IP地址以便连接它的epmd，但是我们不关心这些；我们用我们自己的算法来算出我们的端口号。</p>
<p>我们也需要返回一个分布式协议版本号。从Erlang/OTP 6开始它就是5（参阅 <a href="http://erlang.org/doc/apps/erts/erl_dist_protocol.html" target="_blank" rel="external">分布式协议官方文档</a> ），就这么简单。</p>
<p>最后，names/1 函数被调用来返回某个主机上的Erlang节点列表。我们没有办法知道这些信息，所以让我们假装我们连接不上这个主机。</p>
<p>目前为止，一起都顺利。但是我们需要一个方法来确认我们正侦听在合适的端口上。我认为最好的方法是写一个新的分布式协议模块，该模块仅是设置端口号而让真正的协议模块做它自己的事情：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_dist)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([listen/<span class="number">1</span>,</span></div><div class="line">         select/<span class="number">1</span>,</div><div class="line">         accept/<span class="number">1</span>,</div><div class="line">         accept_connection/<span class="number">5</span>,</div><div class="line">         setup/<span class="number">5</span>,</div><div class="line">         close/<span class="number">1</span>,</div><div class="line">         childspecs/<span class="number">0</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">listen</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 在此处我们算出我们想要侦听在什么端口。</span></div><div class="line"></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line"></div><div class="line">    <span class="comment">%% 设置 “最小” 和 “最大” 两个变量，强制侦听端口为一个值。</span></div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_min, Port),</div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_max, Port),</div><div class="line"></div><div class="line">    <span class="comment">%% 最后运行真正的函数！</span></div><div class="line">    inet_tcp_dist:listen(Name).</div><div class="line"></div><div class="line"><span class="function"><span class="title">select</span><span class="params">(Node)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:select(Node).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept_connection</span><span class="params">(AcceptPid, Socket, MyNode, Allowed, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">setup</span><span class="params">(Node, Type, MyNode, LongOrShortNames, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:setup(Node, Type, MyNode, LongOrShortNames, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">close</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:close(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">childspecs</span><span class="params">()</span> -&gt;</span></div><div class="line">    inet_tcp_dist:childspecs().</div></pre></td></tr></table></figure>
<p>几乎所有的代码都在这。listen/1函数在将控制权交给真正的处理模块inet_tcp_dist前，根据我们的节点名来设置inet_dist_listen_min和inet_dist_listen_max两个变量。</p>
<p>（请注意：虽然inet_tcp_dist是默认的处理模块，但是它仅提供基于IPv4上的未加密连接。如果你想用IPv6，你应该用inet6_tcp_dist，而如果你想用<a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">基于TLS上的Erlang分布式功能</a>，那就应该选择inet_tsl_dist或inet6_tsl_dist。增加这些弹性的尝试留给读者自己练习。）</p>
<p>我们准备好了！现在我们启动两个节点，foo1和foo2，并且使它们彼此互连：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo1</div><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo2</div></pre></td></tr></table></figure>
<p>系统能正常运行吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(foo2@poki-sona-sin)<span class="number">1</span>&gt; net_adm:ping('foo1@poki-sona-sin').</div><div class="line">pong</div></pre></td></tr></table></figure>
<p>看起来没问题！</p>
<h1 id="接着在Elixir下尝试"><a href="#接着在Elixir下尝试" class="headerlink" title="接着在Elixir下尝试"></a>接着在Elixir下尝试</h1><p>当然，因为Erlang和Elixir都运行在同样的虚拟机上，那么就没有什么可以阻止我们在Elixir里实现上述功能了。</p>
<p>在Elixir里，我们可以将所有代码放在一个单独文件里，编译器会将它编译成我们需要的不同的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个包含根据一个节点名来决定端口号的函数的模块。</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_atom(name) <span class="keyword">do</span></div><div class="line">    dist_port Atom.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_list(name) <span class="keyword">do</span></div><div class="line">    dist_port List.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_binary(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 算出基端口。如果没有指定则用</span></div><div class="line">    <span class="comment"># inet_dist_base_port 这个kernel的环境变量,</span></div><div class="line">    <span class="comment"># 默认值是4370, 比epmd的端口大1。</span></div><div class="line">    base_port = <span class="symbol">:application</span>.get_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_base_port</span>, <span class="number">4370</span></div><div class="line"></div><div class="line">    <span class="comment"># 现在，基于基端口算出我们的“偏移量”。</span></div><div class="line">    <span class="comment"># 偏移量就是一个我们节点名@符号左边的整数。</span></div><div class="line">    <span class="comment"># 如果这个整数不存在，则偏移量是0。</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># 也处理主机名没有指定的情况。</span></div><div class="line">    node_name = Regex.replace ~r/@.*<span class="variable">$/</span>, name, <span class="string">""</span></div><div class="line">    offset =</div><div class="line">      <span class="keyword">case</span> Regex.run ~r/[<span class="number">0</span>-<span class="number">9</span>]+<span class="variable">$/</span>, node_name <span class="keyword">do</span></div><div class="line">    <span class="keyword">nil</span> -&gt;</div><div class="line">      <span class="number">0</span></div><div class="line">    [offset_as_string] -&gt;</div><div class="line">      String.to_integer offset_as_string</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    base_port + offset</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_dist</span></span> <span class="keyword">do</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 此处我们算出我们想要侦听的端口。</span></div><div class="line"></div><div class="line">    port = Epmdless.dist_port name</div><div class="line"></div><div class="line">    <span class="comment"># 设置“min”和“max”变量，强制两个端口为一个值。</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_min</span>, port</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_max</span>, port</div><div class="line"></div><div class="line">    <span class="comment"># 最后运行真正的函数！</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.listen name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(node) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.select node</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept_connection</span></span>(accept_pid, socket, my_node, allowed, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept_connection accept_pid, socket, my_node, allowed, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>(node, type, my_node, long_or_short_names, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.setup node, type, my_node, long_or_short_names, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.close listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">childspecs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.childspecs</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_epmd_client</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># erl_distribution想要我们启动一个工作进程，然而我们并不需要。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ignore</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 因为Erlang/OTP 19.1用register_node/3来替换register_node/2，</span></div><div class="line">  <span class="comment"># 只是多传了一个参数：地址族，’inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line">  <span class="comment"># 这对于我们来说没什么问题。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(name, port, _family) <span class="keyword">do</span></div><div class="line">    register_node(name, port)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(_name, _port) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 在此处我们应该连接epmd并告诉它哪个是我们侦听的端口，</span></div><div class="line">    <span class="comment"># 但是因为我们是无epmd的，所以我们不需要这么做。</span></div><div class="line"></div><div class="line">    <span class="comment"># 需要返回一个介于1和3的"creation”数字。</span></div><div class="line">    creation = <span class="symbol">:rand</span>.uniform <span class="number">3</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, creation&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">port_please</span></span>(name, _ip) <span class="keyword">do</span></div><div class="line">    port = Epmdless.dist_port name</div><div class="line">    <span class="comment"># 分布式协议版本数字从Erlang/OTP R6开始就是5。</span></div><div class="line">    version = <span class="number">5</span></div><div class="line">    &#123;<span class="symbol">:port</span>, port, version&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">names</span></span>(_hostname) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 既然我们没有epmd，那么我们就不真正需要知道其他节点。</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:address</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们启动Elixir，我们需要用 - -erl 来传递一些参数来使得功能启用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --erl <span class="string">"-proto_dist Elixir.Epmdless -start_epmd false -epmd_module Elixir.Epmdless_epmd_client"</span> --sname foo3</div></pre></td></tr></table></figure>
<p>让我们ping我们前面已经启动的两个节点：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">1</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo1@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">2</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo2@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div></pre></td></tr></table></figure>
<p>它们都连通了并且没有epmd参与！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文描述的只是其中一种不需要epmd的Erlang分布式方式；我相信你可以用别的办法来更好地符合你的需求。我希望上述的示例代码是有用的指南！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang快速安装]]></title>
      <url>http://szpzs.oschina.io/2016/09/28/erlang-quick-install/</url>
      <content type="html"><![CDATA[<p><img src="/images/erlang-logo.png" style="border:0;"><br>在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的<a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank" rel="external">完全安装指引</a>。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。</p>
<ul>
<li><a href="#part1">在Mac OS X上安装Erlang</a></li>
<li><a href="#part2">在Linux上安装Erlang</a></li>
<li><a href="#part3">在Windows上安装Erlang</a></li>
<li><a href="#part4">用最新版本预编译包安装Erlang</a></li>
<li><a href="#part5">从源码编译安装Erlang</a></li>
</ul>
<a id="more"></a>
<h2 id="在Mac-OS-X上安装Erlang"><a href="#在Mac-OS-X上安装Erlang" class="headerlink" title="在Mac OS X上安装Erlang"></a><span id="part1">在Mac OS X上安装Erlang</span></h2><p><strong>使用HomeBrew来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install erlang</div></pre></td></tr></table></figure>
<p><strong>用MacPorts来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install erlang</div></pre></td></tr></table></figure>
<h2 id="在Linux上安装Erlang"><a href="#在Linux上安装Erlang" class="headerlink" title="在Linux上安装Erlang"></a><span id="part2">在Linux上安装Erlang</span></h2><p>大多数操作系统在它们的包管理系统里有预构建的Erlang发行版本。</p>
<p><strong>在Ubuntu和Debian下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install erlang</div></pre></td></tr></table></figure>
<p><strong>在Fedora下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<p><strong>在FreeBSD下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pkg update</div><div class="line">sudo pkg install erlang</div></pre></td></tr></table></figure>
<h2 id="在Windows上安装Erlang"><a href="#在Windows上安装Erlang" class="headerlink" title="在Windows上安装Erlang"></a><span id="part3">在Windows上安装Erlang</span></h2><p><a href="http://www.erlang.org/download.html" target="_blank" rel="external">直接下载安装程序来安装</a></p>
<h2 id="用最新版本预编译包安装Erlang"><a href="#用最新版本预编译包安装Erlang" class="headerlink" title="用最新版本预编译包安装Erlang"></a><span id="part4">用最新版本预编译包安装Erlang</span></h2><p>你在寻找最新的稳定Erlang版本或者前一个Erlang版本吗？<a href="https://www.erlang-solutions.com/" target="_blank" rel="external">Erlang Solutions</a> 给OS X，Windows，Ubuntu，Debian，Fedora，CentOS，Raspbian 以及其他平台都提供了一个<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp" target="_blank" rel="external">预编译安装包</a>。它们也提供了一个企业级Erlang发行版。</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="external">从Erlang Solutions下载</a></p>
<h2 id="从源码编译安装Erlang"><a href="#从源码编译安装Erlang" class="headerlink" title="从源码编译安装Erlang"></a><span id="part5">从源码编译安装Erlang</span></h2><p>你可以用Kerl脚本在你自己的机器上从源码来构建Erlang。Kerl是一个脚本，它使得你用几个命令就轻松地构建不同版本的Erlang。</p>
<p><strong>下载Kerl指令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O https://raw.githubusercontent.com/spawngrid/kerl/master/kerl</div><div class="line">chmod +x kerl</div></pre></td></tr></table></figure>
<p>选择一个可用的Erlang源码发行版本并且像如下指令一样来构建它（在这个例子里，我们选择18.0版本并且命名它为mybuild-18.0）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list releases</div><div class="line">./kerl build 18.0 mybuild-18.0</div></pre></td></tr></table></figure>
<p>选择一个目录来安装，例如 ~/erlang-r16b03</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list builds</div><div class="line">./kerl install mybuild-18.0 ~/erlang-18.0</div></pre></td></tr></table></figure>
<p>最后，把目录 ~/erlang-18.0/bin 加到你的环境变量 $PATH 里。</p>
<p><strong>搞定！</strong></p>
<p>在你的终端运行erl来启动一个Erlang shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 18 [erts-7.0] [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.0  (abort with ^G)</div><div class="line">1&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634" target="_blank" rel="external">https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[往Elixir里的Map塞东西]]></title>
      <url>http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/</url>
      <content type="html"><![CDATA[<p>Elixir的<a href="http://elixir-lang.org/docs/stable/elixir/Map.html" target="_blank" rel="external">Map</a>模块提供了一些不同的函数来操作map数据结构。其中一个函数就是<a href="http://elixir-lang.org/docs/stable/elixir/Map.html#put/3" target="_blank" rel="external">Map.put/3</a> 。这个函数允许你将一个健值对放入一个map中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">9</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">10</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果这个键对于此map来说是新的话，这个键值对就简单地加入map。如果这个键对于此map来说是已存在的，那么对应的老的值则被新的值替换。</p>
<p>同样的效果可以用Map.merge/2来实现。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">10</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">11</span>, <span class="symbol">bulbasaur:</span> <span class="number">14</span>&#125;)</div><div class="line">%&#123;<span class="symbol">bulbasaur:</span> <span class="number">14</span>, <span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">11</span>&#125;</div></pre></td></tr></table></figure>
<p>Map.merge/2的优势是它的灵活性。它能够更容易地在不同情况下使用。它甚至允许一次增加并且替换多个健值对。因为两个入参都是map，它让我们感觉到更容易阅读。</p>
<p>也有一个语法糖的方法，就是用map字面符号和一个管道来替换已经存在的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = %&#123;pokemon | <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>这个是最简洁的方法，但是，它仅仅是用来替换一个健值对。如果这个键不存在map中，则一个错误将发生。</p>
<p>除此之外当然还有其他函数来设置值到map中，包括 <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/3" target="_blank" rel="external">Kernel.put_in/3</a> 和 <a href="http://elixir-lang.org/docs/stable/elixir/Map.html#get_and_update/3" target="_blank" rel="external">Map.get_and_update/3</a> 。然而上述几个方法是我自己最经常接触到的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/" target="_blank" rel="external">http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[原子之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/eli5-atoms/</url>
      <content type="html"><![CDATA[<p><img alt="Atom Table" src="/images/eli5-atom-tab.png" style="border: 0;"><br><a id="more"></a><br>原子表是一个全局表，它将原子内部值（一个整数值）映射到一个字符串。同时也有一个反向的查询表，它将一个字符串映射到一个原子内部值。原子表有一个固定的记录条数上限：1048576。如果它一旦到达了这个上限，当前节点将崩溃 －－ 这就是为什么在运行时动态创建原子是很危险的做法。原子表的记录条数上限可以通过给erl命令指定 +t 标签来设置。</p>
<p>原子是在运行时不能改变它的值的一个符号。当一个新的原子被创建，它得到一个唯一的值来给当前节点来使用。原子在系统内部仅仅是指向原子表对应记录索引的整数值。这就是为什么原子的操作如此廉价的原因。</p>
<p>BEAM装载器例程读取原子值并且在原子表里查询它们。它将它们的整数值标记为原子<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>来替代原子名称。然后代码只是操作这些立即数而不是它们的名称。</p>
<p>这些内部值不能当做整数（通过网络或磁盘）离开节点。这是因为其他节点对于相通的原子有不同的内部值。因此当原子离开当前节点的时候都被转换为字符串。这会影响到BEAM文件，外部pid，外部port，Mnesia或DETS里的原子等等。这就是为什么一些开发者更喜欢给数据库字段名使用短原子名称的原因 －－ 它们将以字符串的形式出现在数据库数据中。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BEAM虚拟机之浅显易懂]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/eli5-vm/</url>
      <content type="html"><![CDATA[<p>BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。</p>
<a id="more"></a>
<h2 id="寄存器和调用"><a href="#寄存器和调用" class="headerlink" title="寄存器和调用"></a>寄存器和调用</h2><p>作为一个寄存器虚拟机就意味着在函数调用的时候不是通过栈而是用寄存器来传递参数。它们与我们所理解的CPU架构中的寄存器不一样，而只是一个Erlang数据结构的值所组成的数组。这样的寄存器有1024个，但是有这么多入参的函数几乎不存在，所以通常虚拟机仅仅使用了前面3到10个寄存器。</p>
<p>例如，当调用一个有三个入参的函数的时候，寄存器x0，x1和x2分别被设置为三个入参值。如果我们需要进行递归调用，我们将不得不改写寄存器并丢失它们的原始值。在这种情况下，我们将需要保存旧的值到栈中。除了栈帧外没有动态栈分配，这是由编译器决定的。</p>
<p>每一个进程有自己的寄存器集。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>BEAM指令集包含大约158个基本指令，它们中的大部分可以通过调用 erlc -S yourfile.erl 生成汇编文件来查看到。每一个指令有零或多个参数。不同的技巧用来在便携方式和紧凑方式编码参数。例如，代码中的位置定位（也叫做标签）是用它们的索引来编码的，并且代码装载器后续会把它们翻译成内存地址。</p>
<p>在BEAM代码装载过程中，一些混合的操作码被更快的操作码替换。这个优化的技巧叫做超级指令。对于每一个操作码，在beam_emu.c文件中都有一个C标签对应的一段代码。一个C标签组成的数组存储在同一个虚拟机循环例程的尾部并且被当作查询表来使用。</p>
<p>请参见：<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-file.html" target="_blank" rel="external">BEAM文件格式</a>。<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-instructions.html" target="_blank" rel="external">BEAM指令代码</a>。</p>
<h2 id="线程虚拟机循环"><a href="#线程虚拟机循环" class="headerlink" title="线程虚拟机循环"></a>线程虚拟机循环</h2><p>虚拟机模拟器循环在 emulator/beam/beam_emu.s 里包含许多代码小片段，每一个代码小片段有一个标签和处理一个BEAM指令。它们都属于一个非常长的函数。一个标签表存储在此相同函数里，它被用来作为查询表。</p>
<p>装载操作码被标签地址替换后，紧跟着它们的是参数。例如，操作码 ＃1，一个来自标签数组第一索引元素被置于在代码内存。</p>
<p>这种方式很容易跳转到处理下一个操作码的 C 代码中的某个位置。只需要读一个 void* 指针并执行一个goto *p 的动作。此功能是C和C++编译器的一个扩展。这种类型的虚拟机循环称为直接线程调度虚拟机循环。</p>
<p>其他虚拟机循环的类型有：</p>
<ul>
<li>切换调度虚拟机（如果C编译器拒绝支持标签扩展，则这种类型被BEAM虚拟机源使用）。它也比直接线程调度虚拟机慢20%至30%；</li>
<li>直接调用线程</li>
<li><a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html" target="_blank" rel="external">其他</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-vm.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-vm.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我最喜欢的erlang程序]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/</url>
      <content type="html"><![CDATA[<p>前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。</p>
<p>他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。</p>
<a id="more"></a>
<h1 id="通用服务器"><a href="#通用服务器" class="headerlink" title="通用服务器"></a>通用服务器</h1><p>一般来说服务器都是做特定的事情的。一个HTTP服务器响应HTTP请求而一个FTP服务器响应FTP请求，等等。那么什么是通用服务器呢？我们肯定能归纳出一个服务器的概念，然后做出一个通用服务器，并且我们可以在晚些时候让它变成一个特定的服务器。</p>
<p>下面就是我的通用服务器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">universal_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;become, F&#125; -&gt;</div><div class="line">            F()</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个服务器相当简单。一旦我创建了一个通用服务器，它只是呆在那里等待一个 {become, F}消息，收到这样的消息后，他就变成了F服务器。</p>
<h1 id="阶乘服务器"><a href="#阶乘服务器" class="headerlink" title="阶乘服务器"></a>阶乘服务器</h1><p>一个阶乘服务器就是等待一个整数然后返回这个整数的阶乘。下面就是非常简单的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">factorial_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;From, N&#125; -&gt;</div><div class="line">            From ! factorial(N),</div><div class="line">            factorial_server()</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(N)</span> -&gt;</span> N * factorial(N-<span class="number">1</span>).</div></pre></td></tr></table></figure>
<p>现在我们已经准备好high起来了。</p>
<h1 id="把它们集成起来"><a href="#把它们集成起来" class="headerlink" title="把它们集成起来"></a>把它们集成起来</h1><p>我将写一个小函数来创建一个通用服务器，然后给它发送“变成阶乘服务器”消息，接着我将发送一个整数给它，等它返回结果并打印出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></div><div class="line">    Pid = spawn(fun universal_server/0), Pid ! &#123;become, fun factorial_server/0&#125;,</div><div class="line">    Pid ! &#123;self(), <span class="number">50</span>&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        X -&gt;</div><div class="line">            X</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这些函数都属于这个模块  <a href="http://joearms.github.io/code/fav1.erl" target="_blank" rel="external">/code/fav1.erl</a>.</p>
<p>现在我们需要做的就是启动一个Erlang shell并运行这个测试程序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line"><span class="number">1</span> &gt; c(fav1).</div><div class="line">&#123;ok, fav1&#125;</div><div class="line"><span class="number">2</span> &gt; fav1:test().</div><div class="line"><span class="number">30414093201713378043612608166064768844377641568960512000000000000</span></div></pre></td></tr></table></figure>
<h1 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h1><p>多年前当我在SICS的时候，我接触到 <a href="http://www.planet-lab.org/" target="_blank" rel="external">Planet 实验室</a>。Planet 实验室是一个有9000台计算机的研究网络。加入Planet实验室很容易，你所要做的是买一台标准PC，将它连接到网络并捐献它的使用给Planet实验室组织。你捐献你的机器给这个网络，相应的你可以使用Planet实验室里的所有其他机器。</p>
<p>Planet实验室是一个为分布式应用的真实世界的测试环境，它当前有1171个节点在562个站上。</p>
<p>当时我要用Planet实验室来做什么呢？我也不知道。最终我做的是写一些脚本在所有Planet实验的机器上安装了空转的通用服务器（和本文的代码很相似）。然后我设计了一套goosip算法来给这个网络发送 <strong>become</strong> 消息。这样我就有了一个空转的网络，我可以在数秒内将它变成我想要的任何服务器。</p>
<p>大概一年后，我必须要写一篇论文。作为一个研究者，最不划算的一个事情就是为了挣钱养家你必须要写关于这样或那样的论文，这样的论文所写的从来不是你当时感兴趣的，但是却一定是关于资助你研究的项目所期望读到的。</p>
<p>我已经在Planet实验室上建立了我的gossip网络，我可以让它成为任何服务器，因此我让它成为一个内容分发网络并且用一个gossip算法来将一个同样的文件拷贝到这个网络上的所有机器上。最后我把这件事写成一篇论文然后大家都哈皮了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html" target="_blank" rel="external">http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang的事件驱动应用]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/</url>
      <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://en.wikipedia.org/wiki/Event_%28computing%29" target="_blank" rel="external">事件</a> 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门<a href="http://www.erlang.org/doc/design_principles/events.html" target="_blank" rel="external">一章</a>是关于事件的，还有一种 <a href="http://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="external">事件驱动架构</a> 可以让你的代码和架构更牛X：</p>
<ul>
<li>它更易于将你的代码真正地解耦。</li>
<li>它打开了一扇门，通往令人感兴趣的新的架构模式，比如 <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="external">CQRS</a>（命令查询职责分离模式），<a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="external">event sourcing</a>（事件源模式），和<br><a href="http://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="external">event collaboration</a>（事件合作模式）。</li>
<li>应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。</li>
<li>事件和命令能够被非常小的事件处理器来处理。</li>
<li>如果你真的要用事件来开发系统，那么就可能像<a href="http://www.rabbitmq.com/" target="_blank" rel="external">rabbitmq</a>，<a href="http://www.zeromq.org/" target="_blank" rel="external">0mq</a>一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：</li>
<li>系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。</li>
<li>为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。</li>
<li>一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。</li>
</ul>
<a id="more"></a>
<p>Erlang已经提供了一种方式来实现事件驱动架构：gen_event 行为。<a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event</a> 是 Erlang/OTP 自带的<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id59741" target="_blank" rel="external">默认行为</a>之一。对我来说，它也是Erlang/OTP最酷的特性之一，因为你在许多语言或环境里都无法得到这样开箱即用（并且免费）的特性，因此这真的是非常棒。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>Gen_event 有一个或多个事件管理器、事件处理器，来派发和处理事件：</p>
<p><strong>事件管理器</strong>：一个事件管理器是一个 gen_event 进程。<br><strong>事件处理器</strong>：事件处理器是正真处理事件的回调模块，并且被注册到一个或多个事件管理器。<br><strong>事件</strong>：一个事件是任何erlang term，比如一个元组，一个原子，一个列表，等等。</p>
<p>在某些方面，gen_event 用起来像<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>里的<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external">EventEmitter</a>类，在概念上说也像<a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>。这个概念是有某种事件总线（事件管理器）负责接收来自系统的事件并且将它们路由到相应的监听者。其基本的工作流如下：</p>
<ul>
<li>创建一个或者多个实现 <a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event<br>行为</a><br>的回调模块。在本文末尾的<strong>附录B</strong>里有完整的例子。</li>
<li>启动一个事件管理器进程。</li>
<li>注册一个或者多个事件处理器到事件管理器上。</li>
<li>通过事件管理器派发事件。</li>
<li>在你的事件处理器里异步（同步）处理派发过来的事件。</li>
</ul>
<p>现在让我们按顺序研究上述每一步。</p>
<h1 id="启动一个事件管理器"><a href="#启动一个事件管理器" class="headerlink" title="启动一个事件管理器"></a>启动一个事件管理器</h1><p>这就是调用如下函数一样简单：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start().</div></pre></td></tr></table></figure>
<p>或者你计划把你的事件管理器包含在一个<a href="http://www.erlang.org/doc/design_principles/sup_princ.html" target="_blank" rel="external">监督树</a>里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link().</div></pre></td></tr></table></figure>
<h2 id="用一个给定的名字注册一个事件管理器"><a href="#用一个给定的名字注册一个事件管理器" class="headerlink" title="用一个给定的名字注册一个事件管理器"></a>用一个给定的名字注册一个事件管理器</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start(my_event_bus).</div></pre></td></tr></table></figure>
<p>或者也可以：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link(my_event_bus).</div></pre></td></tr></table></figure>
<p>这些函数与start/0以及start_link/0的目的一样，只是它们允许你用一个指定的名字注册一个新的事件管理器。引述<a href="http://www.erlang.org/doc/man/gen_event.html#start_link-1" target="_blank" rel="external">官方文档</a>如下：</p>
<p>如果 EventMgrName={local, Name}，这个事件管理器被以Name为名字用 register/2 本地注册。</p>
<p>如果 EventMgrName={global, GlobalName}，这个事件管理器被以GlobalName为名字用 global:register_name/2 全局注册。</p>
<p>如果没有名字提供，则这个事件管理器不能被注册。</p>
<p>如果 EventManager={via, Module, ViaName}，这个事件管理器将被Module注册到系统。这个回调模块Module应该导出如下函数 register_name/2 ，unregister_name/1 ，whereis_name/1 and send/2，这些函数和global模块里的相应函数的行为一样。因此，{via, global, GlobalName} 是一个有效的引用。</p>
<h1 id="注册事件处理器"><a href="#注册事件处理器" class="headerlink" title="注册事件处理器"></a>注册事件处理器</h1><p>一旦你已经有了你的事件管理器并且把它运行起来了，就该通过用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_handler/3</a> 来添加一些事件处理器了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>上述函数将添加一个新的事件处理器到指定的事件管理器（你传入的第一个入参所指的）。事件管理器可以用如下几种方式指定：</p>
<ul>
<li>进程PID。</li>
<li>Name，如果事件管理器是本地注册的。</li>
<li>{Name, Node}，如果事件管理器是在另一个节点本地注册的，或者 {global,<br>GlobalName}，如果事件管理器是全局注册的。</li>
<li>{via, Module, ViaName}，如果事件管理器的注册是通过一个替代进程注册的。</li>
</ul>
<p>第二个入参指定事件处理器的模块名，不过它也可以是{Module, Id}，Module是回调模块的名字，而当有多个事件处理器用同一个回调模块的时候，Id则用于识别指定的事件处理器。</p>
<p>紧接着my_event_handler里的回调函数 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:init-1" target="_blank" rel="external">init/1</a> 被调用，传给 add_handler/3 的第三个入参将原封不动地传给 init/1 做入参。init/1 可能返回：</p>
<p>如果成功，函数将返回{ok, State} 或 {ok, State, hibernate}，State是事件处理器内部初始状态。</p>
<p>如果返回{ok, State, hibernate}，事件管理器将通过调用 proc_lib:hibernate/3 进入冬眠状态，一直等到下一个事件发生。</p>
<h2 id="被监督的事件处理器"><a href="#被监督的事件处理器" class="headerlink" title="被监督的事件处理器"></a>被监督的事件处理器</h2><p>你可以用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_sup_handler/3</a> 在调用进程（也就是注册新事件处理器的进程）和事件处理器自己之间建立某种形式的监测（或监督）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_sup_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>正如官方文档描述：</p>
<p>如果调用进程后续因为原因Reason而终止，事件管理器将通过用 {stop, Reason} 作为入参调用 Module:terminate/2 来删除事件处理器。</p>
<p>如果事件处理器后来被删除，事件管理器给调用进程发送一个消息 {gen_event_EXIT, Handler, Reason}。Reaseon是下列之一：</p>
<pre><code>normal，如果事件处理器因为 delete_handler/3 的调用而被删除，或者被一个回调函数（见下面段落）返回 remove_handler 。

shutdown，如果事件处理器因为事件管理器结束而被删除。

{swapped, NewHandler, Pid}，如果进程Pid已经调用 swap_handler/3 或 swap_sup_handler/3 来用另一个事件处理器 NewHandler 替换了当前事件处理器。一个term，如果事件处理器因为一个错误而被删除。term的值是依据错误而来的。
</code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>事件处理器是按顺序执行的，所以要尽量保持它的代码短小。如果你需要有上千个事件处理器，那么实现某种<a href="https://gist.github.com/1230182" target="_blank" rel="external">转发器</a>是更好的选择。转发器的思路是有好几个子gen_event订阅一个主gen_event。这样将负载分发给所有感兴趣的监听者。</p>
<p>另一方面，如果你必需要在一个事件处理器里做费时的操作，你应该尝试用一个 <a href="https://gist.github.com/4474770" target="_blank" rel="external">gen_event caster</a>，他将监听事件并派发独特的（普通的）erlang消息。</p>
<p>我们也要注意，当一个被监督的事件处理器退出的时候，gen_event讲给所有的事件处理器<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L319" target="_blank" rel="external">发送消息</a>，因此要准备好如何处理这些消息。</p>
<h1 id="派发事件"><a href="#派发事件" class="headerlink" title="派发事件"></a>派发事件</h1><p>通过事件管理器派发一个事件实际上是相当简单的，仅仅需要调用 <a href="http://www.erlang.org/doc/man/gen_event.html#notify-2" target="_blank" rel="external">gen_event:notify/2</a> 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>你可以在本文的<strong>附录A</strong>里看到gen_event如何派发一个事件的具体细节。</p>
<p>这个函数将异步地派发这个事件。这意味着这个函数调用将不会阻塞而是立即返回。也有同步派发事件的方式，就是使用函数 <a href="http://www.erlang.org/doc/man/gen_event.html#sync_notify-2" target="_blank" rel="external">gen_event:sync_notify/2</a>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:sync_notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>同步在这里的意思是这个函数的调用将阻塞并仅在所有事件处理器已经被调用并且处理了这个事件后才返回。</p>
<h2 id="用消息替代-Notify-2"><a href="#用消息替代-Notify-2" class="headerlink" title="用消息替代 Notify/2"></a>用消息替代 Notify/2</h2><p>另一种方式来调用事件处理器是通过派发普通消息给事件管理器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pid ! &#123;new_user_created&#125;</div></pre></td></tr></table></figure>
<p>这将调用<strong>所有</strong>注册的事件处理器的 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数，gen_event官方文档说明如下：</p>
<p>当一个事件管理器接收到不是事件或者一个同步请求（或者一个系统消息）的任何其他消息时，每一个已经安装在这个事件管理器上的事件处理器的这个函数被调用。</p>
<h1 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h1><p>为了处理由notify/2派发的事件，你的回调模块需要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_event-2" target="_blank" rel="external">handle_event/2</a> 函数，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div></pre></td></tr></table></figure>
<p>另外，为了处理消息，要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(Info, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"Got message: ~p"</span>, [Info]),</div><div class="line">  &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>上面两个例子里的State是由 init/1 返回的数据。</p>
<p>上述两个函数返回值如下所述（当然我们还是引用官方文档）：</p>
<p>如果这个函数返回 {ok, NewState} 或者 {ok, NewState, hibernate} ，这个事件处理器将留在事件管理器里并且带着可能被修改过的内部状态NewState。</p>
<p>如果{ok, NewState, hibernate} 返回，事件管理器也将进入冬眠状态（通过调用 proc_lib:hibernate/3），并等待下一个事件的发生。只要一个事件处理器返回{ok, NewState, hibernate} 则整个事件管理器进程进入冬眠状态。</p>
<p>如果函数返回 {swap_handler, Args1, NewState, Handler2, Args2}，这个事件处理器将被 Handler2 替代，替换过程首先是调用 Module:terminate(Args1, NewState)，然后再调用 Module2:init({Args2, Term}) ，这里的Term是 Module:terminate/2 的返回值。更多信息可以查看 gen_event:swap_handler/3 。</p>
<p>如果函数返回 remove_handler ，这个事件处理器将通过调用 Module:terminate(remove_handler, State)来被删除。</p>
<h1 id="额外事项"><a href="#额外事项" class="headerlink" title="额外事项"></a>额外事项</h1><h2 id="停止事件管理器"><a href="#停止事件管理器" class="headerlink" title="停止事件管理器"></a>停止事件管理器</h2><p>停止事件管理器有时候是必须的并且通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#stop-1" target="_blank" rel="external">stop/1</a> 很容易就做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:stop(my_event_bus).</div></pre></td></tr></table></figure>
<p>这也会引起在所有已经注册的事件处理器上调用 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 。</p>
<h2 id="在一个事件处理器上调用函数"><a href="#在一个事件处理器上调用函数" class="headerlink" title="在一个事件处理器上调用函数"></a>在一个事件处理器上调用函数</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-3" target="_blank" rel="external">call/3</a> 来确切地调用一个事件处理器上指定的函数，就像你在 gen_server上做的一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;).</div></pre></td></tr></table></figure>
<p>和gen_server一样，你可以在调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-4" target="_blank" rel="external">call/4</a> 到时候指定一个超时时间：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;, <span class="number">5000</span>).</div></pre></td></tr></table></figure>
<p>gen_event将调用事件处理器模块的 handle_call/2 回调函数。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, this_is_my_reply, State&#125;.</div></pre></td></tr></table></figure>
<h2 id="删除事件处理器"><a href="#删除事件处理器" class="headerlink" title="删除事件处理器"></a>删除事件处理器</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#delete_handler-3" target="_blank" rel="external">delete_handler/3</a> 来删除你的事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:delete_handler(my_event_bus, my_event_handler, [arg1, arg2]).</div></pre></td></tr></table></figure>
<p>这个函数将从事件管理器删除这个事件处理器，而且也会将第三个参数传给 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 并调用它并将将调用结果返回。</p>
<p>列出所有已经注册的事件处理器</p>
<p>为了列出一个事件管理器当前注册的所有事件处理器，可以调用 <a href="http://www.erlang.org/doc/man/gen_event.html#which_handlers-1" target="_blank" rel="external">which_handlers/1</a> ：</p>
<p>gen_event:which_handlers(my_event_bus).</p>
<h2 id="替换-交换-事件处理器"><a href="#替换-交换-事件处理器" class="headerlink" title="替换 (交换) 事件处理器"></a>替换 (交换) 事件处理器</h2><p>通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_handler-3" target="_blank" rel="external">swap_handler/3</a> 也可以在运行时更换事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:swap_handler(my_event_bus, &#123;my_event_handler, [arg1]&#125;, &#123;my_new_event_handler, [arg2]&#125;).</div></pre></td></tr></table></figure>
<p>整个过程是：首先调用 my_event_handler:terminate([arg1], State) 然后调用 my_new_event_handler:init([arg2])，用一个新的事件处理器替换一个久的事件处理器。</p>
<p>如果老的事件处理器是被监督的，则新的事件处理器也被监督。你当然可以直接用同样的参数调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_sup_handler-3" target="_blank" rel="external">swap_sup_handler/3</a> 来做到。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>再一次我要感谢 <a href="https://github.com/elbrujohalcon" target="_blank" rel="external">Fernando “El Brujo” Benavides</a> 对本文的总体思考，关于gen_event缺陷的评论，以及他分享的gen_event转发器和caster。</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Marcelo Gornstein <a href="marcelo@inakanetworks.com">marcelo@inakanetworks.com</a></p>
<p>Github: <a href="https://github.com/marcelog" target="_blank" rel="external">marcelog</a></p>
<p>Homepage: <a href="http://marcelog.github.com/" target="_blank" rel="external">http://marcelog.github.com</a></p>
<h1 id="附录-A-gen-event实际上是如何派发一个事件的"><a href="#附录-A-gen-event实际上是如何派发一个事件的" class="headerlink" title="附录 A: gen_event实际上是如何派发一个事件的"></a>附录 A: gen_event实际上是如何派发一个事件的</h1><p>函数 notify/2 的实际调用最终在你的erlang/otp源码的 <a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl" target="_blank" rel="external">lib/stdlib/src/gen_event.erl</a> 文件的504行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="keyword">catch</span> Mod1:Func(Event, State) <span class="keyword">of</span></div></pre></td></tr></table></figure>
<p>Func是原子 handle_event 或 handle_info。所以如果你的事件处理器崩溃或不知何故失败了，事件管理器是不会崩溃的。</p>
<p>如果运行一个被监督的事件处理器（用add_sup_handler/3启动的），在同一个文件的<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L635" target="_blank" rel="external">635行</a>的 terminate/2 函数被调用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Res = (<span class="keyword">catch</span> Mod:terminate(Args, State)),</div></pre></td></tr></table></figure>
<p>另外，被监督的事件处理器，在<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L648" target="_blank" rel="external">648行</a>一个消息被发送给这个事件处理器注册到的进程</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Handler#handler.supervised <span class="keyword">of</span></div><div class="line">  <span class="literal">false</span> -&gt;</div><div class="line">      ok;</div><div class="line">  Pid -&gt;</div><div class="line">      Pid ! &#123;gen_event_EXIT,handler(Handler),Reason&#125;,</div><div class="line">      ok</div><div class="line">  <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="附录-B-回调模块样例"><a href="#附录-B-回调模块样例" class="headerlink" title="附录 B: 回调模块样例"></a>附录 B: 回调模块样例</h1><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_event_handler)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">  init/<span class="number">1</span>, terminate/<span class="number">2</span>, handle_info/<span class="number">2</span>,</div><div class="line">  handle_call/<span class="number">2</span>, code_change/<span class="number">3</span>, handle_event/<span class="number">2</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  &#123;ok, []&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, not_implemented, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(_Event, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Arg, _State)</span> -&gt;</span></div><div class="line">  ok.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://inaka.net/blog/2013/01/21/erlang-event-driven/" target="_blank" rel="external">http://inaka.net/blog/2013/01/21/erlang-event-driven/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS的查询、分页和并发的数据插入]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</url>
      <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">上星期的Erlang Thursday</a>的结尾，我说我们将继续研究ets模块的select函数的特性。</p>
<p>所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">TestOrderedSetTable = ets:new(ordered_set_table, [public, ordered_set]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line"><span class="comment">% 20499</span></div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:give_away(TestOrderedSetTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>接着我们给我们的测试ETS表装载一些测试数据，在数据的序列中留出一些空隙，为了后面我们填补这些空隙。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>然后我们从表里查询所有数据，我们可以看到不同类型的表的数据排序是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;]</span></div></pre></td></tr></table></figure>
<p>ets模块也有一个函数 <a href="http://erlang.org/doc/man/ets.html#select_reverse-2" target="_blank" rel="external">ets:select_reverse</a> ，我们停下来看一看它能做些什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select_reverse(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select_reverse(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;]</span></div></pre></td></tr></table></figure>
<p>我们比较 ets:select/2 和 ets:select_reverse/2 的结果，TestTable的结果是一样的，而TestOrderedSetTable的结果刚好是反序，这个结果和官方文档对 ets:select_reverse/2 描述一样。其实我们思考一下也就明白了。</p>
<p>结束了这个简单的小插曲，我们接着运行我们上面相同的匹配规则只是结果集限制在5个纪录，同时我们得到一个continuation。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;Result, Continuation&#125; = ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;19,19&#125;,&#123;29,29&#125;,&#123;27,27&#125;,&#123;17,17&#125;,&#123;5,5&#125;],</span></div><div class="line"><span class="comment">% &#123;20499,214,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">&#123;OrdSetResult, OrdSetContinuation&#125; = ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;3,3&#125;,&#123;5,5&#125;,&#123;7,7&#125;,&#123;9,9&#125;],&#123;16402,9,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>有了这些continuation，我们看看我们取回来的下一个结果集是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;23,23&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;9,9&#125;],&#123;20499,111,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;11,11&#125;,&#123;13,13&#125;,&#123;15,15&#125;,&#123;17,17&#125;,&#123;19,19&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,19,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>还记得我们用来创建元组的数字序列里留的那些间隙吗？</p>
<p>现在来看看我们填上那些序列间隙，同时我们用已经获取的continuation来查询数据会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>现在我们用前面获取到的continuation重新运行 ets:select/1 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;12,12&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;10,10&#125;,&#123;9,9&#125;],</span></div><div class="line"><span class="comment">%  &#123;20499,224,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;10,10&#125;,&#123;11,11&#125;,&#123;12,12&#125;,&#123;13,13&#125;,&#123;14,14&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,14,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们比较以前的结果，我们看到现在的结果里有了偶数元素在列表里。对于我们的 TestTable ，如果我们看上面的Continuation变量的值，它有一个continuation 的点，值是214，因为它是当前continuation和调用 ets:select(Countinuation) 后的结果continuation里唯一变化的值，所以通过这个值我们很难推断continuation的变化。</p>
<p>另一方面，OrdsetContinuation，它的第二个元素的值是9，也就是ETS表id 16402 后面的元素。而后面其它的continuation的这个值分别是19和14也碰巧和对应结果集的最后元素匹配上。因此在有序集合的情况下，我们能推断作为ordered_set类型的ETS表的continuation的一部分，这个continuation告诉我们返回结果集里最后纪录的键，我们可以不管任何同时插入动作发生而继续从这个纪录开始获取数据。</p>
<p>下次我们将看看 ets:is_compiled_ms/1 这个函数，并基于对官方文档的该函数的阅读，我们如何将匹配规则应用在continuation上。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - 限制返回结果的ETS查询]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-using-ets-select-with-a-limit/</url>
      <content type="html"><![CDATA[<p><a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">上星期的Erlang Thursday</a>我们继续研究 ets:select/2 并且用 ets:fun2ms/1生成匹配规则来和它配合使用。</p>
<p>这个星期我们将看看ets模块提供的select函数的其它版本。</p>
<a id="more"></a>
<p>还是老样子，我们将设置好我们新的ETS表的环境，以便我们的shell崩溃了我们的表不会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = fun() -&gt; receive after infinity -&gt; ok end end.</div><div class="line">% #Fun&lt;erl_eval.20.54118792&gt;</div><div class="line">SomeProcess = spawn(Fun).</div><div class="line">% &lt;0.52.0&gt;</div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line">% 16402</div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>接下来我们将装载我们的测试ETS表，它是一些测试“产品”。为了例子的简单，我们将仅用一个数字代表一个产品id，然后用一个100以内的随机整数加上0.99作为价格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;ProductId, random:uniform(100) + 0.99&#125;)</div><div class="line">  || ProductId &lt;- lists:seq(1, 10000) ]].</div><div class="line">% [[true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true|...]]</div></pre></td></tr></table></figure>
<p>我们将创建一个匹配规则（价格在19.99至30之间）来查找数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ProductsInTheTwenties = ets:fun2ms(fun(&#123;Product, Price&#125;)</div><div class="line">                                     when Price &gt;= 19.99 andalso Price &lt; 30</div><div class="line">                                     -&gt; &#123;Product, Price&#125;</div><div class="line">                                   end).</div><div class="line">% [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;,</div><div class="line">%   [&#123;&apos;andalso&apos;,&#123;&apos;&gt;=&apos;,&apos;$2&apos;,19.99&#125;,&#123;&apos;&lt;&apos;,&apos;$2&apos;,30&#125;&#125;],</div><div class="line">%   [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;&#125;]&#125;]</div></pre></td></tr></table></figure>
<p>如果我们用 ets:select/2 和上面这个匹配规则在我们的表上，我们在一个查询里得到所有结果就和前面我们看到的一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties).</div><div class="line">% [&#123;4351,29.99&#125;,</div><div class="line">%  &#123;635,19.99&#125;,</div><div class="line">%  &#123;6005,20.99&#125;,</div><div class="line">%  &#123;3742,27.99&#125;,</div><div class="line">%  &#123;5956,29.99&#125;,</div><div class="line">%  &#123;3753,28.99&#125;,</div><div class="line">%  &#123;6653,25.99&#125;,</div><div class="line">%  &#123;5151,28.99&#125;,</div><div class="line">%  &#123;2693,27.99&#125;,</div><div class="line">%  &#123;4253,21.99&#125;,</div><div class="line">%  &#123;7636,23.99&#125;,</div><div class="line">%  &#123;1935,19.99&#125;,</div><div class="line">%  &#123;9044,22.99&#125;,</div><div class="line">%  &#123;7797,22.99&#125;,</div><div class="line">%  &#123;2147,23.99&#125;,</div><div class="line">%  &#123;2574,26.99&#125;,</div><div class="line">%  &#123;7575,29.99&#125;,</div><div class="line">%  &#123;2130,28.99&#125;,</div><div class="line">%  &#123;4908,27.99&#125;,</div><div class="line">%  &#123;2218,22.99&#125;,</div><div class="line">%  &#123;9848,21.99&#125;,</div><div class="line">%  &#123;7632,26.99&#125;,</div><div class="line">%  &#123;3562,21.99&#125;,</div><div class="line">%  &#123;3130,27.99&#125;,</div><div class="line">%  &#123;575,26.99&#125;,</div><div class="line">%  &#123;4622,28.99&#125;,</div><div class="line">%  &#123;5678,25.99&#125;,</div><div class="line">%  &#123;4022,...&#125;,</div><div class="line">%  &#123;...&#125;|...]</div></pre></td></tr></table></figure>
<p>不过ets模块也给我们一个限制结果集的方式如果我们愿意的话，用 ets:select/3 并传入一个要一次返回结果数的限制。</p>
<p>那么我们来用 ets:select/3 并给它的限制是10，然后看看结果是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们的结果是一个元组而不是一个结果的列表。第一个元组元素是一个我们期望的10个结果组成的列表，第二个元素是一个奇怪的元组，我们查阅官方文档中 ets:select/3 的描述，这个奇怪的元组表示一个概念：continuation 。</p>
<p>所以我们再运行我们的查询，这次我们把结果绑定到变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;Results, Continuation&#125; = ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们有了这个continuation，不过它是什么？它对我们来说有什么用？</p>
<p>简而言之，它可以被认为是一个不可变的书签。它不仅表示我们在查询结果的哪一页，也表示我们正在读的内容（我们的查询）。</p>
<p>它允许我们把这个continuation传给 <a href="http://www.erlang.org/doc/man/ets.html#select-1" target="_blank" rel="external">ets:select/1</a> ，就能快速获取我们前面看过的结果内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>因为它是我们的特殊的不可变的书签，每次我们用这个书签它都带我们到这同样书的相同的地方，并且我们仅能读到我们原先设置的每页最大纪录数。</p>
<p>所以不管我们在我们同一个continuation上调用多少次 ets:select/1 ，每次我们都将获得相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>而如果我们仔细看结果的元组，我们看到得到一个不同的下一个continuation的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;SecondResults, SecondContinuation&#125; = ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们可以用这个新的continuation用在我们下一次调用 ets:select/1 上，来得到下一个结果集和另一个continuation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(SecondContinuation).</div><div class="line">% &#123;[&#123;8569,19.99&#125;,</div><div class="line">%   &#123;1805,28.99&#125;,</div><div class="line">%   &#123;6819,23.99&#125;,</div><div class="line">%   &#123;9313,28.99&#125;,</div><div class="line">%   &#123;9527,27.99&#125;,</div><div class="line">%   &#123;1737,29.99&#125;,</div><div class="line">%   &#123;700,26.99&#125;,</div><div class="line">%   &#123;142,25.99&#125;,</div><div class="line">%   &#123;6792,29.99&#125;,</div><div class="line">%   &#123;9295,29.99&#125;],</div><div class="line">%  &#123;16402,513,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果我们在获取完结果集后再执行一次查询，我们得到一个 ‘$end_of_table’ 原子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;&apos;$1&apos;, &apos;$2&apos;&#125;, [&#123;&apos;&lt;&apos;, &apos;$2&apos;, 0&#125;], [&apos;$$&apos;]&#125;], 10).</div><div class="line">% &apos;$end_of_table&apos;</div></pre></td></tr></table></figure>
<p>指定一个限制并有一个continuation的能力也可以用在 ets:match/3 和 ets:match/1 上，同时也可以用在 ets:match_object/3 和 ets:match_object/1 上。</p>
<p>下星期，我们将继续研究ets模块里的不同select函数，同时看看它们的行为方式和有序集合，将比较一下 select 函数和 select_reverse函数的不同，也研究一下如果我们当我们用一个continuation的时候在结果集里插入一些数据，continuation将会怎样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS，匹配规则和函数]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-match-specs-and-functions/</url>
      <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">上星期的Erlang Thursday</a>我展示了怎样通过使用ets:select带来的好处而且使我们的查询更丰富的优势来结束文章。</p>
<p>首先我们将需要一个新的ETS表，那么我们以一个新的public类型的“产品”表开始，并且按我们的标准来创建一个进程然后将表的所有权转移给它。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">Products = ets:new(products, [public]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">ets:give_away(Products, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>下一步我们将装载我们的“产品”进入表里。</p>
<p>在我们这个例子里，我们只是创建一个产品，用一个二进制数据当做产品的名字并用一个整数当做“共同世界货币里的价格”。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(Products, &#123;integer_to_binary(X), X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">100</span>) ]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>和我们在上星期一样，我们可以手工创建一个元组列表到匹配规则里去运行我们的查询，说是获取小于10CWC的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"8"&gt;&gt;,&lt;&lt;"6"&gt;&gt;,&lt;&lt;"5"&gt;&gt;,&lt;&lt;"3"&gt;&gt;,&lt;&lt;"7"&gt;&gt;,&lt;&lt;"1"&gt;&gt;,&lt;&lt;"4"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"9"&gt;&gt;,&lt;&lt;"2"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>我们也可以查询到那些大于10CWC并且小于25CWC的产品名称。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&gt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;, &#123;'&lt;', '$<span class="number">2</span>', <span class="number">25</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"11"&gt;&gt;,&lt;&lt;"15"&gt;&gt;,&lt;&lt;"23"&gt;&gt;,&lt;&lt;"20"&gt;&gt;,&lt;&lt;"21"&gt;&gt;,&lt;&lt;"14"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"12"&gt;&gt;,&lt;&lt;"13"&gt;&gt;,&lt;&lt;"16"&gt;&gt;,&lt;&lt;"19"&gt;&gt;,&lt;&lt;"17"&gt;&gt;,&lt;&lt;"18"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"22"&gt;&gt;,&lt;&lt;"24"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>但是这样并不一定清晰明了，因为我们正在使用元组里的元素的数值以及在它们里面元组列表的元组列表。</p>
<p>这个时候 <a href="http://www.erlang.org/doc/man/ets.html#fun2ms-1" target="_blank" rel="external">ets:fun2ms/1</a> 来解救我们。</p>
<p>ets:fun2ms/1 的入参是一个函数并且将把这个函数转换成一个匹配规则。</p>
<p>这就允许我们写一个函数，这个函数入参是一个产品和价格组成的元组，然后它返回价格小于10的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &lt; <span class="number">10</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&lt;','$2',10&#125;],['$1']&#125;]</span></div></pre></td></tr></table></figure>
<p>我们也能在传递给 ets:fun2ms/1 的这个函数的判断分支里用一个组合检查，相当于分支类型语句，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Between_25_And_35_CWC = ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">25</span>, Cost &lt; <span class="number">35</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&gt;','$2',25&#125;,&#123;'&lt;','$2',35&#125;],['$1']&#125;]</span></div><div class="line">ets:select(Products, Between_25_And_35_CWC).</div><div class="line"><span class="comment">% [&lt;&lt;"30"&gt;&gt;,&lt;&lt;"33"&gt;&gt;,&lt;&lt;"32"&gt;&gt;,&lt;&lt;"29"&gt;&gt;,&lt;&lt;"28"&gt;&gt;,&lt;&lt;"26"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"34"&gt;&gt;,&lt;&lt;"27"&gt;&gt;,&lt;&lt;"31"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>或者也可以是类型分支语句。</p>
<p>虽然这个函数有用，但是它还是有它的限制，因为这是在函数上解析转换，所以你不能像在普通函数上一样用任何东西。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">90</span> -&gt; lists:reverse(binary:bin_to_list(Product)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% Error: Unknown error code &#123;122,lists,reverse&#125;</span></div><div class="line"><span class="comment">% &#123;error,transform_error&#125;</span></div></pre></td></tr></table></figure>
<p>但是，匹配规则的结果部分也是不支持任何高级函数功能的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', <span class="number">90</span>, '$<span class="number">2</span>'&#125;], [binary:bin_to_list('$<span class="number">1</span>')]&#125;]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  binary:bin_to_list/1</span></div><div class="line"><span class="comment">%         called as binary:bin_to_list('$1')</span></div></pre></td></tr></table></figure>
<p>即使有这些限制，ets:fun2ms/1 依然帮助我们做了更富表现力的ETS查询。我们不仅能用有意义的变量名替代那些 $X 变量来引用一个函数，也用判断分支语句来替代判断元组，而且我们也可以在我们的结果里用这些变量名同时做基本的格式化作为函数的一部分。</p>
<p>请确认在下周回来，因为我们将继续研究 ets:select 的不同版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – 更多的ETS数据匹配和查询]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-more-ets-data-matching-and-querying/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续上周开始的从ETS获取数据研究。</p>
<p>我们已经有一个模块 markov_words ，本周我们将添加一个函数 markov_words:create_word_triples/1 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>,</span></div><div class="line">         create_word_triples/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_triples<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_triples(Words, []).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([_Word, _SecondWord | []], WordTriples)</span> -&gt;</span></div><div class="line">    WordTriples;</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([FirstWord | Words], WordTriples)</span> -&gt;</span></div><div class="line">    [SecondWord, Following | _] = Words,</div><div class="line">    UpdatedWordTriples = [&#123;FirstWord, SecondWord, Following&#125; | WordTriples],</div><div class="line">    create_word_triples(Words, UpdatedWordTriples).</div></pre></td></tr></table></figure>
<p>添加新函数的原因是它将允许我们得到更精确的马尔科夫链，这是通过能看到后续两个词的复合键的情形而提高获取下一个单词的概率。</p>
<p>修改和重新定义我们的模块后，我们回到Erlang shell，编译我们的模块并转载我们的介绍文本给一个变量，测试开始。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line"></div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>本周我们创建新的ETS表，创建一个新的进程并且把表转移给它（在例子中我们输入一些错误的东西来引起当前的shell进程崩溃）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MarkovWords = ets:new(markov_word_tuples, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div><div class="line">ets:give_away(MarkovWords, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这周，除了添加我们的词对元组到ETS，我们也将添加新的词三元组到ETS的同样的表里。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(MarkovWords, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"></div><div class="line">[[ ets:insert(MarkovWords, WordTriple) || WordTriple &lt;- markov_words:create_word_triples(ToTC)]].</div></pre></td></tr></table></figure>
<p>既然我们已经有词对和三词组在同一个ETS表中，我们可以用 ets:match_object/2 函数并指定一个匹配模式仅获得二元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者指定另一个匹配模式仅获得三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;]</span></div></pre></td></tr></table></figure>
<p>而如果我们用 ets:lookup/2 函数并传入键，那么我们得到这个键的所有数据而不管它是二元组还是三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:lookup(MarkovWords, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>和 ets:lookup/2 不一样，ets:match_object/2 可以匹配元组中的任何元素而不仅是键。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>和 ets:match_object/2 一样，ets:match/2 也可以如此匹配元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(MarkovWords, &#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>但有时候我们可能想要对如何返回结果给我们有更细粒度的控制能力，比如用一个元素单列表而不是一个字符串嵌套列表。或者我们甚至有一些标准是我们想要的真正作为我们选择的数据的一部分。</p>
<p>让我们开始研究 <a href="http://www.erlang.org/doc/man/ets.html#select-2" target="_blank" rel="external">ets:select/2</a> 。</p>
<p>ets:select/2 第一个入参是一个表，第二个入参是一个匹配规则。</p>
<p>这个匹配规则是一个三元组列表，元组的第一个元素是一个匹配模式，第二个元素是一个判断语句元组的列表，最后一个元素是一个表示每个匹配的结果。</p>
<p>如果我们想让调用 ets:select/2 结果和 ets:match/2 相似，就如像下面输出一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], [['$<span class="number">1</span>']]&#125;]).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>第二个入参是一个匹配规则列表，它只有一个元素，这个元素的组成是：<br>1）一个{“was”, “the”, ‘$1’}样式的匹配模式，它和我们传给 ets:match/2 的一样<br>2）一个空的条件判断元组列表3）一个返回结果的term： [[‘$1’]]，它是我们想要的结果格式列表，在本例子里我们想要每个结果都在它自己的列表里。</p>
<p>如果我们只是想得到一个词组成的列表，我们可以修改匹配规则的返回结果的term为[‘$1’]。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% ["winter","spring","season","season","epoch","epoch","age",</span></div><div class="line"><span class="comment">%  "age","worst","best"]</span></div></pre></td></tr></table></figure>
<p>如果我们想让返回结果看起来更像是一个 ets:match<em>object/2 返回的结果集，我们可以使用 ‘$</em>‘作为结果term，它表示整个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>如果你想要只是匹配某些元素并且提取元组中其它元素，我们可以用 ‘$$’ 作为结果term，它将返回所有匹配变量到一个列表里，返回列表里元素的顺序是按匹配模式里匹配变量的数值排序。</p>
<p>用 ets:select/2 我们也可以有指定多个匹配规则的能力。这样就允许我们查找到所有中间的词是 of 或 the 的三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;, &#123;&#123;'$<span class="number">1</span>', <span class="string">"of"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"some","of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"preserves","of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"worst","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"winter","of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"degree","of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"spring","of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"best","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>使用判断分支，我们可以找到在三元组数据里第一个元素是 was ，而且第二个词在字典排序上小于第三个词这样的第三个词。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;], ['$<span class="number">2</span>']&#125;]).</div><div class="line"><span class="comment">% ["than","winter","worst"]</span></div></pre></td></tr></table></figure>
<p>本周的文章我们已经学到使用 ets:match/2 和 ets:match_object/2 函数的其它方式，以及他们能克服使用 ets:lookup/2 的时候只能指定一个键的弱点，也可以能够通过使用 ets:select/2 来获得更强的查询能力。</p>
<p>下周，我们将研究 ets:select/2 的更多使用方式，以及我们怎样用ets模块的其它函数来帮助创建查询来更容易地快速解构数据。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS 数据匹配]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-data-matching/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday开始从介绍系列文章改为专门讲ETS，开始用ETS存储一些数据然后在ETS里做一些数据的检索。</p>
<p>首先我们需要在ETS有一些数据，所以我们回到马尔科夫链这个问题上。</p>
<a id="more"></a>
<p>马尔科夫链是一个状态机，它是基于概率而不是特定的输入来转换状态的。它的一个普通的例子就是人们熟悉的智能手机里的“日常使用”的预测输入功能，也就是下一个词或字母会被预测并提供给使用者，而被选择的预测单词是遵循预测它跟随当前单词的历史有关的可能性。</p>
<p>首先我们将创建一个模块，该模块有一个函数将接收一个文本字符串，它返回的是一个元组列表，而这个元组的元素是由一个词和该词的后续词组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div></pre></td></tr></table></figure>
<p>上述代码输入的是一个文本字符串，然后基于空格、tab和新行字符作为词的边界将文本分割成词列表。基于这个词列表，我们创建一个列表，该列表元素是由词和词的后续词组成的元组，而这些元组将被我们插入我们的ETS表中。</p>
<p>是时候打开Erlang shell开始我们的试验了。</p>
<p>首先我们需要编译我们的模块，然后我们将创建一个变量来持有我们的文本，这个文本是为我们的马尔科夫链准备的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>我们将创建一个新进程并把我们的ETS表转移给它，以防万一我们的Erlang shell崩溃。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.60.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个ETS表，它将用来存储数据，这些数据为我们用来作为我们的马尔科夫链生成器的一部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WordPairs = ets:new(word_pairs, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:give_away(WordPairs, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们设置表为 public，因为我们想让不再是表的所有者的shell进程可以添加数据到表里，同时我们设置表的类型为 duplicate bag。</p>
<p>设为 duplicate_bag 是为了演示的原因。我们希望能有相同键的多个数据，因为我们很可能会看到任何词多次，而且有些词对的词的集合很常见，所以我们希望能捕获（以及保留）那些重复的词。</p>
<p>为了方便从shell里生成数据，我们将用列表解析把我们从文本创建的每一个词对元组通过调用 ets:insert/2 函数来插入到我们的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(WordPairs, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>现在我们已经有了一些数据在我们的ETS表里，是时候看看我们怎样才能访问我们的数据。为访问数据，我们开始介绍函数 ets:match/2 ，它的入参是一个要查询的表以及一个模式。</p>
<p>模式是由一个Erlang term组成用来匹配：_ ，匹配任意数据而且不做绑定；或者模式变量，它的格式是$N，N是任意正整数。ets:match/2 的返回结果是一个列表，这个是由模式变量的值组成的，它们按照模式变量名的序列排序。</p>
<p>所以有了这些知识，我们可以尝试查询这些词对来找到所有跟在 of 后的词。如果我们写一个模式匹配，它可能看起来像 {“of”, Following}，但是使用ETS，我们需要用一个模式变量按规范来写成：{“of”, ‘$1’}.</p>
<p>让我们在shell里运行。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["loaves"],</span></div><div class="line"><span class="comment">%  ["the"],</span></div><div class="line"><span class="comment">%  ["France."],</span></div><div class="line"><span class="comment">%  ["England;"],</span></div><div class="line"><span class="comment">%  ["comparison"],</span></div><div class="line"><span class="comment">%  ["its"],</span></div><div class="line"><span class="comment">%  ["despair,"],</span></div><div class="line"><span class="comment">%  ["hope,"],</span></div><div class="line"><span class="comment">%  ["Darkness,"],</span></div><div class="line"><span class="comment">%  ["Light,"],</span></div><div class="line"><span class="comment">%  ["incredulity,"],</span></div><div class="line"><span class="comment">%  ["belief,"],</span></div><div class="line"><span class="comment">%  ["foolishness,"],</span></div><div class="line"><span class="comment">%  ["wisdom,"],</span></div><div class="line"><span class="comment">%  ["times,"],</span></div><div class="line"><span class="comment">%  ["times,"]]</span></div></pre></td></tr></table></figure>
<p>我们看到结果是一个由变量匹配数据的列表组成的列表，在本例子中，就是 ‘$1’ 匹配的。</p>
<p>为了好玩和探索，让我们确认一下在我们的双城记介绍文本里跟在 it 后面的词都有什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"it"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"]]</span></div></pre></td></tr></table></figure>
<p>就是一堆 was ，这刚好是这本书的头两段里的情况。</p>
<p>然后我们仔细检查看看跟在 Scrooge 后的词是什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"Scrooge"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>如果我们想得到整个元组，我们应该用 ets:match_object/2 ，它将返回满足匹配的整个对象。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者，在这个例子里，我们可以用 ets:lookup/2 ，它将返回所有键匹配的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>所以为了采取一个从马尔科夫链简短绕道的例子，为什么我们想要使用 ets:lookup/2 或 ets:match_object/2 而不是其它函数？为了回答这个问题我们用一个例子，让我们添加另一种数据到我们的马尔科夫链表里，它是一个三元素元组。</p>
<p>To start with, we will insert 100_000 items into our ETS tables and see what the resulting memory size becomes. We will insert a new tuple of {X, X}, for all numbers from 1 to 100_000.（译者注：这一段应该是作者手误，从另外一篇文章错误地拷贝粘贴过来的，这一段和本文无关。）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(WordPairs, &#123;<span class="string">"of"</span>, <span class="string">"times,"</span>, <span class="string">"it"</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>如果我们调用 ets:lookup/2 ，我们将得到指定键的所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>,<span class="string">"it"</span>&#125;]</div></pre></td></tr></table></figure>
<p>但是如果我们用 ets:match_object/2 ，并且用了一个两元组，因为我们只是想得到词对，我们在结果里将不会得到那个三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '_'&#125;).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;]</div></pre></td></tr></table></figure>
<p>回到马尔科夫链的场景，我们可以开始看看我们是怎样遵循马尔科夫链规则能够获得一些文本。</p>
<p>我们从一个给定的词得到匹配的潜在的词，并且我们从后续词列表里均匀随机抓取一个结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PotentialChoices = ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line">[NextWord] = lists:nth(random:uniform(length(PotentialChoices)), PotentialChoices).</div></pre></td></tr></table></figure>
<p>我们可以写一个函数，让它重复上面的这些步骤，直到终结为止。一些终结状态的例子应该是一个词而且没有后续词；我们得到一定数量的词来拼装我们的文本；或者我们得到一定的总长度，使得它符合社交网络和Tweet的要求。</p>
<p>本文里，我们已经开始将一些“真实”的数据加入ETS里，并且为一些给定的模式来匹配数据。下个星期我们将继续看看在这个例子里用其它方式从我们ETS表取出数据放到一些地方，在那里这些数据可能被更好的消费。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-data-matching/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-data-matching/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第五篇：keypos，compressed，read_conncurrency 和 write_concurren]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-5-keypos-compressed-read-conncurrency-and-write-concurrency/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且就<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">上星期我所预告的</a>，要研究ETS表的 keypos 设置以及其他一下设置。</p>
<p>首先我们来看看 keypos 设置。</p>
<a id="more"></a>
<p>keypos是被存储的元组的基于1的索引，并且将被作为表的数据项的键。如果你记得我们<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">第三篇介绍ETS的关于不同表类型的文章</a>所描述，表用这个索引作为它们的键进行比较来决定数据是否唯一。</p>
<p>如果我们创建一个新表而不指定它的 keypos 选项，则 keypos 默认是1。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>为了显示keypos的作用，我们将创建一些数据插入到我们的ETS表，这样我们就能看到keypos的作用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div><div class="line">Item4 = &#123;a, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;a,"a"&#125;</span></div><div class="line">Item5 = &#123;<span class="string">"a"</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;"a",a&#125;</span></div></pre></td></tr></table></figure>
<p>上述数据，我们在二元素元组里既有第一元素重复的也有第二元素重复的。</p>
<p>我们将继续依次把所有元素插入表中，我们要记住这个表是set类型的，所以任何新数据插入都会覆盖与它有相同键的前面插入的数据值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ets:insert(Table, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(Table, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;"a",a&#125;,&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们如上例子插入Item3，它覆盖表中的Item1，因为它们的元组第一个元素都是1。</p>
<p>我们现在创建一个kepos是2的新表，然后看看按上述例子同样的步骤来插入数据会有什么样的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">KeyPosTwo = ets:new(key_pos_2, [&#123;keypos, <span class="number">2</span>&#125;]).</div><div class="line"><span class="comment">% 24595</span></div><div class="line">ets:insert(KeyPosTwo, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;"a",a&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，当插入Item4时，就发生了覆盖，因为Item2和Item4的第二个元素都是“a”。然后插入Item5时，会覆盖Item1，因为它们的第二个元素都是原子a。</p>
<p>如果我们设置的keypos是其他值，比如说3，然后我们尝试插入一个元素小于3的元组，我们会得到一个bag argument异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">KeyPosThree = ets:new(key_pos_3, [&#123;keypos, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% 28692</span></div><div class="line">ets:insert(KeyPosThree, Item1).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(28692,&#123;1,a&#125;)</span></div></pre></td></tr></table></figure>
<p>现在我们来看看创建表的时候用compressed选项。</p>
<p>当创建一个新表，默认是不压缩的，因为我们可以从下面例子里看到表信息显示{compressed, false}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UncompressedTable = ets:new(uc, []).</div><div class="line"><span class="comment">% 32786</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新表，用了compressed选项，然后用ets:info/1查看表信息，我们看到{compressed, true}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CompressedTable = ets:new(uc, [compressed]).</div><div class="line"><span class="comment">% 45074</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>至少根据官方文档的说法，compressed选项会使得数据以更压缩的格式存储而减少内存的消耗。文档也警告这也会造成获取元素元组的操作更慢，并且键是不压缩存储的，至少在当前的版本里是这样。</p>
<p>让我们来看看compressed对内存的消耗有什么样的不同。</p>
<p>我们将给两种表分别插入100000条记录，然后看它们的内存大小。插入纪录的格式是{X, X}，X从1到100000。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,714643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,814643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>有意思！</p>
<p>压缩表的内存大小是814643，而非压缩表的内存大小却小一点，是714643。</p>
<p>可能是对整数值的压缩效果不好，所以我们再做一次，这次是用字符串替换元组的第二个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,914644&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,1692433&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>用字符串替换元素第二元素后，压缩表内存大小是914644，而非压缩表的内存大小是1692433。</p>
<p>所以当你要决定是否使用压缩表的时候除了要更仔细的考虑你将用何种方式如何匹配数据外，你还要考虑你将要放入ETS表的数据是什么样的类型。</p>
<p>最后两个要讨论的选项是 read_concurrency 和 write_concurrency。</p>
<p>read_concurrency 默认被设置为false，根据官方文档的说法这个选项在“读比写操作频繁很多，或者当并发读写的量非常巨大的时候”最适合设置为true。</p>
<p>因此如果你有一个表有大量的读操作，而写操作零零散散，这个时候你应该设置read_concurrency为true，因为官方文档的说法是在读和写之间切换是很昂贵的。</p>
<p>write_concurrency 默认被设置为false，这会使得当一个写操作正在进行的时候会造成其它并发的写操作阻塞。当把该选项设置为true，则同一个表的不同的元组可以通过并发进程写入，并且不影响任何ordered_set类型表。</p>
<p>ETS的一系列介绍文章到此告一段路。下星期我们将开始研究用ETS和ETS表进行不同的操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第四篇：ETS的访问保护]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-4-ets-access-protections/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并研究ETS支持的不同访问级别。</p>
<p>ETS支持的不同访问级别：public，protected和private。</p>
<a id="more"></a>
<p>在创建一个新ETS表的时候可以传入不同访问类型的任意一个，不过我们先看看当我们不指定访问级别的时候ETS表的访问级别是哪一个？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20501</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>从上面的输出可以看到不指定访问级别的话默认就是protected。</p>
<p>那么一个ETS表是被保护的意味着什么呢？官方文档说明被保护的表只可以被所有者进程写入，但是其他进程可以读取。</p>
<p>现在让我们一起看看它是如何工作的。</p>
<p>首先我们创建一个进程以便我们可以把ETS表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的ETS表并指定它是被保护的，同时也指定它是有名字的以方便后续操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ProtectedNamedETS = ets:new(protected_named_ets, [protected, named_table]).</div><div class="line"><span class="comment">% protected_named_ets</span></div></pre></td></tr></table></figure>
<p>函数的输出是 protected_name_ets 而不是像前面调用 ets:new/2 那样输出的是数字，这样一来我们能够用表的名字替代表标识码访问这个表。</p>
<p>我们将插入一条数据到这个ETS表里，并且我们将用这个ETS表的名字作为它的引用因为我们创建表的时候指定了 named_table 选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;foobar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>ets:insert/2 返回true，那么现在我们应该有一些数据在表里。让我们用ets:match/2把数据取出来，而且通过用一个$1的模式匹配出所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>那么作为这个ETS表的所有者进程，因为这个表是由这个进程创建的，所有我们能读写这个表。</p>
<p>现在我们把这个表转移给另外的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(protected_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>既然官方文档说表是可读的，我们在刚刚转移所有权后做同样的match操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>我们读取到我们的数据。<br>那么尝试写会发生什么？因为官方文档说只有所有者进程才能有写的权限，并且在调用 ets:insert/2 的时候总是返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;barbaz, foo&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(protected_named_ets,&#123;barbaz,foo&#125;)</span></div></pre></td></tr></table></figure>
<p>上面的例子返回了一个异常，异常的类型是 bag argument，也就是说它不允许非所有者进程写数据入表，但是这个异常没有确切地说明到底发生了什么。</p>
<p>如果我们尝试调用 ets:insert/2 往不存在的表插入数据将会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(no_such_table, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(no_such_table,&#123;foo,bar&#125;)</span></div></pre></td></tr></table></figure>
<p>一样的异常和一样的错误提示格式，仅仅是表名和元组不同。</p>
<p>仔细想想这些现象，这两种不同的情况有一样的错误是有意义的。当一个进程尝试去做一个插入而如果没有表存在或者如果表被设置为 protected，则就是要让正在调用插入动作的这个进程知道这样的表不存在。总之，就是调用者将一个错的ETS表的引用传给ets:insert/2 。</p>
<p>所以我们现在已经知道 protected 的行为，它是默认的访问级别，那么下面让我们看看 public 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PublicNamedETS = ets:new(public_named_ets, [public, named_table]).</div><div class="line"><span class="comment">% public_named_ets</span></div></pre></td></tr></table></figure>
<p>我们将从我们当前的进程，也就是表的所有者插入一条数据并且获取所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;]]</span></div></pre></td></tr></table></figure>
<p>一切正常。</p>
<p>官方文档说public的表允许任何进程读和写，所以让我们把这个public表转给进程 SomeProcess 并且尝试去读和写。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(public_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在我们已经将表转移出去，是时候来尝试添加一条新的数据到表里，同时来看看我们能否将写入的内容读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;bar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;],[&#123;bar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>完全没问题。我们已经插入新数据到那个表里，并且当我们调用 ets:match/2 获取所有数据的时候，我们看到新数据在结果集里。</p>
<p>现在让我们创建一个 private 表。官方文档说对于 private 的ETS表，只有表的所有者才被允许读写这个ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PrivateNamedETS = ets:new(private_named_ets, [private, named_table]).</div><div class="line">private_named_ets</div></pre></td></tr></table></figure>
<p>当进程还拥有这个表的时候，我们添加一条数据并读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;fizz, buzz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;fizz,buzz&#125;]]</span></div></pre></td></tr></table></figure>
<p>然后我们又把表转移给进程 SomeProcess。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(private_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在这个ETS表属于另一个进程了，我们再来尝试读取它的数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:match/2</span></div><div class="line"><span class="comment">%         called as ets:match(private_named_ets,'$1')</span></div></pre></td></tr></table></figure>
<p>又是 bad argument 异常，就像前面例子我们尝试在一个 protected ETS表上用 ets:insert/2 函数，而当时那个表属于另外一个进程。<br>再来看看写的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;buzz, fizz&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(private_named_ets,&#123;buzz,fizz&#125;)</span></div></pre></td></tr></table></figure>
<p>也是 bad argument 异常，现在这样的情况不会让人奇怪了，因为 protected 表的写以及这个 private 表的读都造成一样的异常。</p>
<p>总之，在所有到目前为止的ETS的介绍文章里，我们已经见过了ETS表的类型、访问级别、表命名、继承人和所有者这些属性的设置以及它们之间的关系。</p>
<p>下星期，我们将通过介绍ETS表的键位置的设置和其他一些设置来结束ETS介绍系列文章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第三篇：ETS表类型]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-3-ets-table-types/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且研究一下ETS支持的不同存储策略类型。</p>
<p>ETS支持的不同存储类型是：set，ordered_set，bag，和duplicate bag。</p>
<a id="more"></a>
<p>每种类型都可以在创建一个新ETS表的时候传给创建函数，不过我们来看看创建ETS表的时候不指定任何类型的话ETS表是什么类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ETS_Empty = ets:new(ets_empty, []).</div><div class="line"><span class="comment">% 36886</span></div><div class="line">ets:info(ETS_Empty).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,ets_empty&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>上面的输出中，type 标签元组显示类型是 set。</p>
<p>为了研究不同类型的ETS表如何工作的，我们将创建三个元组加入不同ETS表里来看看它们是如何存储的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div></pre></td></tr></table></figure>
<p>我们有两个第一元素都是1的元组，还有一个第一元素是1.0的元组，这是为了看看在相同的键情况下不同类型ETS表如何处理。</p>
<p>为什么有1和1.0两个键？因为根据使用的比较操作符的不同，它们可以被看作相同的也可以被看作不相同的，所以把它们当作一种相同键的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> == <span class="number">1.0</span>.</div><div class="line"><span class="comment">% true</span></div><div class="line"><span class="number">1</span> =:= <span class="number">1.0</span>.</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>首先我们看看一个set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Set = ets:new(ets_set, [set]).</div><div class="line"><span class="number">40978</span></div></pre></td></tr></table></figure>
<p>我们插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Set, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>set类型的ETS表把1和1.0当作不同的键。那么我们插入Item3也就是插入一个已经存在的键会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>原先1为键的元组已经被我们刚刚插入的Item3元组替换了。</p>
<p>我们再来看看ordered_set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_OrdSet = ets:new(ets_ordset, [ordered_set]).</div><div class="line"><span class="comment">% 45075</span></div></pre></td></tr></table></figure>
<p>我们还是插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_OrdSet, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，1.0被认为和先插入的1是相等的，所以它覆盖了第一个插入的元素。</p>
<p>我们再插入Iterm3，结果是它也覆盖了1.0那个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们来看看bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Bag = ets:new(ets_bag, [bag]).</div><div class="line"><span class="comment">% 49172</span></div></pre></td></tr></table></figure>
<p>我们还是给表里加入Item1和Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Bag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>从 ets:tab2list/1 的输出我们看到bag类型的ETS表把Item1和Item2当作两个不同的元素。</p>
<p>再将Item3加入表里看看会有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>在这个bag类型的ETS表中，我们有了Item2以及Item1和Item3三个元素，甚至Item1和Item3有相同当键。</p>
<p>最后我们来看看duplicate_bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_DupBag = ets:new(ets_dupbag, [duplicate_bag]).</div><div class="line"><span class="comment">% 53269</span></div></pre></td></tr></table></figure>
<p>像前面几种类型的ETS表一样，我们插入Item1再插入Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_DupBag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>也和前面的例子一样，我们接着插入Item3。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是我们在这个duplicate_bag表中有所有三个元素。</p>
<p>如果我们比较bag和duplicate_bag两种表，我们发现它们似乎有一样的行为。</p>
<p>那么它们两者之间有什么不同呢？</p>
<p>如果你深入挖掘官方文档，仔细阅读 ets:new/2 函数中关于表类型的描述，它说明一个bag表允许有重复键，但是只不允许两个一样的一个元素存在，而duplicate_bag允许相同元素存在即时它们的键值都相同。</p>
<p>为验证这个结论，我们往bag表和duplicate_bag表都加入Item1，看看结果是什么。</p>
<p>首先是bag表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果和原来没有不同，所以往bag里添加已经存在的元素不会改变表的内容。</p>
<p>那么duplicate_bag表呢？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是元组{1, a}有两份，因为我们调用 ets:insert/2 将这个元素插入了两次。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第二篇]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍 <a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 模块以及ETS的概况。</p>
<p>上次我们看到ETS表在其父进程崩溃的时候被删除了，那么问题来了，我们怎么能够在其父进程崩溃的时候依然保持ETS表活着呢？</p>
<a id="more"></a>
<p>为解决这个问题，我们将研究函数 ets:give_away/3 以及在创建表的时候指定的参数 heir 。</p>
<p>首先我们创建一个函数，它将代表一个进程，而我们可以将表的所有权赋予它的。这个函数只是等待消息而且永远不超时。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div></pre></td></tr></table></figure>
<p>现在我们创建一个运行该函数的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Process = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.53.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个新的ETS表，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(table, []).</div><div class="line"><span class="comment">% 20498</span></div></pre></td></tr></table></figure>
<p>并且将它赋予我们刚刚创建的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(Table, Process, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我查看表信息可以看到表的所有者是我们创建的进程，因为这个进程的PID和表消息里的所有者元组的PID一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.53.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们已经进行了所谓的所有权转移，那么是时候将原来的所有者进程也就是我们当前的shell进程崩溃掉。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.58.0&gt;</div></pre></td></tr></table></figure>
<p>我们检查我们创建的进程是否还活着，绝大多数情况下应该是活着的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">is_process_alive</span><span class="params">(Process)</span>.</span></div><div class="line">% <span class="title">true</span></div></pre></td></tr></table></figure>
<p>在检查表的信息，看看它是否还活着。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.53.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>它依然还活着！！！我们已经转移了所有权，所以如果我们自己的进程崩溃的话，ETS表依然是活着的。</p>
<p>是时候杀掉那个进程了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exit</span><span class="params">(Process, <span class="string">"Because"</span>)</span>.</span></div><div class="line">% <span class="title">true</span></div><div class="line"><span class="title">is_process_alive</span><span class="params">(Process)</span>.</div><div class="line">% <span class="title">false</span></div></pre></td></tr></table></figure>
<p>然后表就消失了…</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% undefined</span></div></pre></td></tr></table></figure>
<p>这一次，让我们在创建一个ETS表的时候用 heir 选项，来利用ETS表的所有权转移给一个继承人的魔法。</p>
<p>在这次场景里，当所有者进程死掉的时候shell将是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TableWithHeir = ets:new(table, [&#123;heir, self(), <span class="string">"something went wrong"</span>&#125;]).</div><div class="line"><span class="comment">% 24594</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的进程，然后将ETS表的所有权赋予这个新的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Process2 = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.71.0&gt;</span></div><div class="line">ets:give_away(TableWithHeir, Process2, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们检查表的信息，我们可以看到表的所有者是新的进程，而它的继承人是我们当前的shell进程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">self().</div><div class="line">% &lt;0.58.0&gt;</div><div class="line">ets:info(TableWithHeir).</div><div class="line">% [&#123;read_concurrency,false&#125;,</div><div class="line">%  &#123;write_concurrency,false&#125;,</div><div class="line">%  &#123;compressed,false&#125;,</div><div class="line">%  &#123;memory,349&#125;,</div><div class="line">%  &#123;owner,&lt;0.71.0&gt;&#125;,</div><div class="line">%  &#123;heir,&lt;0.58.0&gt;&#125;,</div><div class="line">%  &#123;name,table&#125;,</div><div class="line">%  &#123;size,0&#125;,</div><div class="line">%  &#123;node,nonode@nohost&#125;,</div><div class="line">%  &#123;named_table,false&#125;,</div><div class="line">%  &#123;type,set&#125;,</div><div class="line">%  &#123;keypos,1&#125;,</div><div class="line">%  &#123;protection,protected&#125;]</div></pre></td></tr></table></figure>
<p>现在再次杀掉所有者进程了……</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exit</span><span class="params">(Process2, <span class="string">"Because"</span>)</span>.</span></div><div class="line">% <span class="title">true</span></div><div class="line"><span class="title">is_process_alive</span><span class="params">(Process2)</span>.</div><div class="line">% <span class="title">false</span></div></pre></td></tr></table></figure>
<p>我们在检查表的信息，我们可以看到当前的shell进程既是所有者又是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableWithHeir).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,349&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的进程，然后我们把表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Process3 = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.78.0&gt;</span></div><div class="line">ets:give_away(TableWithHeir, Process3, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>所有者变成了新的进程，我们当前的shell进程依然是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableWithHeir).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,349&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.78.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>通过利用指定继承人的能力，同时用 ets:give_away/3 函数，我们可以帮助ETS表长生不死。</p>
<p>一种可能利用的方式是，我们有一个监督进程，它创建一个“继承人”进程，然后创建一个子进程，这个子进程拥有ETS表，如果这个子进程死掉，它将转移所有权给继承人进程。直到新的所有者进程被重新创建，然后继承人进程便可以将ETS表的所有权转移给这个新创建的进程。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - ETS介绍第一篇]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday开始介绍 <a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 模块以及ETS的概况。</p>
<p>ETS是 Erlang Term Storage的缩写，是Erlang term（各种Erlang数据类型）的内存存储，它提供对存储的数据恒定的访问时间。</p>
<a id="more"></a>
<p>ETS可以被认为是一种键值对存储类型的存储，并且它用表的概念来组织数据。</p>
<p>第一个很有用的知识点是，ETS表是被一个进程创建的，这个表的创建者就是这个表的所有者，除非它把表转移给别的进程。</p>
<p>一旦所有者进程死掉，这个表也就被删除，而且再也不能被访问。</p>
<p>让我们看一下这会是什么样子。</p>
<p>首先，在启动了一个新的Erlang shell后，我们先看看我们所在shell的PID（进程标识符）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.34.0&gt;</div></pre></td></tr></table></figure>
<p>接着创建一个新的ETS表。我们在以后的文章里会专门详细介绍各种创建新表的方式，而今天我们只是仅仅指定一个名字和一个空的参数列表来创建一个新表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TableId = ets:new(table, []).</div><div class="line"><span class="comment">% 20496</span></div></pre></td></tr></table></figure>
<p>获得表的id后，我们用 ets:info/1 函数来看看表的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableId).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.34.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>是时候来让所有者进程崩溃了。在这个场景，我们用一个错误的模式匹配来引起一个错误匹配异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div></pre></td></tr></table></figure>
<p>现在我们检查PID变量和当前shell的进程是否匹配来证实Erlang真的启动了一个新的shell进程让我们使用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.40.0&gt;</div></pre></td></tr></table></figure>
<p>很明显，当前的shell的PID和我们第一次调用self()获得的PID不一样。</p>
<p>再来看看我们刚才创建的表的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:info(TableId).</div><div class="line"><span class="comment">% undefined</span></div></pre></td></tr></table></figure>
<p>结果是 undefined 。因此我们再也找不到那个表id所指的表了。</p>
<p>接下来我们用 ets:all/0 是否能看到虽然用 ets:info/1 找不到的表在某个地方藏着呢。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>还是没找到。让我们用和前面同样的名字创建另外一个表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Table2Id = ets:new(table, []).</div><div class="line"><span class="comment">% 24592</span></div></pre></td></tr></table></figure>
<p>创建成功而且没有报这个名字已经存在的错误。</p>
<p>我们再用 ets:all/0 来看看，这回能看到刚才 ets:new/2 返回的id。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [24592,8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>我们再让shell崩溃一次。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div></pre></td></tr></table></figure>
<p>我们注意到我们又有了新的shell进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.47.0&gt;</div></pre></td></tr></table></figure>
<p>如果我们再调用 ets:all/0 ，前面我们刚刚创建的表的id又没有了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>上述就是我们对ETS的初始印象，我们演示了所有者进程崩溃会删除表，我们也预览了ets模块的一些函数，特别是 ets:new/2 ，ets:info/1 和 ets:all/0 。</p>
<p>我们将继续在后面几篇文章里浏览ETS，并且在大概预览一些ets模块的函数后，我们会深入研究ets模块里与众不同的函数。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:del_path/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-del-path-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#del_path-3" target="_blank" rel="external">digraph:del_path/3</a>.</p>
<p>我们继续使用上次文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a>  一样的有向图。</p>
<a id="more"></a>
<p><img src="/images/digraph-del-path01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>digraph:del_path/3 有三个入参，一个有向图，一个源节点，一个目标节点，函数将删除有向图中从源节点到目标节点的每一条路径上的所有边，直到源节点和目标节点之间没有路径为止。</p>
<p>digraph:del_path/3 的返回值总是true。</p>
<p>我们将调用 digraph:del_path/3 传入上面例子的有向图，节点V1作为源节点，节点V4作为目标节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:del_path(Graph, V1, V4).</div><div class="line"><span class="comment">% true</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],['$v'|3]]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|4]]</span></div></pre></td></tr></table></figure>
<p>根据边的名字来看，从节点1到节点2点边已经被删除，从节点2到节点4点边也被删除。</p>
<p>那么Erlang是怎么得到这样的结果的？</p>
<p>它的结果一开始让我困惑，因为结果并不是我所预期的两种结果之一。我预期的结果是：除了从节点4到节点1的边其他边全部删除，或者仅删除从节点1到节点2的边。</p>
<p>为了解惑，我找到托管在Github上的Erlang源码来阅读 <a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/stdlib/src/digraph.erl" target="_blank" rel="external">digraph</a> 模块，在代码里我终于明白了其中缘由。</p>
<p>首先 digraph:del_path 调用 digraph:get_path/3 ，并且删除路径上所有的边，然后递归执行直到没有再找到路径。</p>
<p>这就是为什么Erlang只删除那些边对原因。</p>
<p>当我们在原始样例有向图上调用 digraph:get_path/3 ，我们得到的路径是 V1 -&gt; V2 -&gt; V4 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">digraph:get_path(Graph, V1, V4).</div><div class="line">[['$v'|<span class="number">0</span>],['$v'|<span class="number">1</span>],['$v'|<span class="number">3</span>]]</div></pre></td></tr></table></figure>
<p>Erlang将路径里的边都删除，然后再递归调用 digraph:del_path/3 ，而这个函数再一次调用 digraph:get_path/3 ，但是因为节点1和节点2之间的边已经被删除，所以没有找到路径，整个处理过程就此结束。</p>
<p>这就是为什么我们看到更多的边被删除，如果我们再次重置样例有向图（退出erlang shell，然后重新打开一个erlang shell，把初始化样例有向图的语句重新执行一遍），然后将节点2和节点4传给 digraph:del_path/3 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:del_path(Graph, V2, V4).</div><div class="line"><span class="comment">% true</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|0],['$e'|4]]</span></div></pre></td></tr></table></figure>
<p>这个场景有两个路径：V2 -&gt; V4 和 V2 -&gt; V3 -&gt; V4 ，如果我们删除路径V2 -&gt; V4路径，与这条路径的所有相关的边都被删除但是不会中断路径V2 -&gt; V3 -&gt; V4，所以函数也可以删除这条路径上的所有边。</p>
<p>所以在官方文档没有很清晰说明白函数内部机制的这个场景，我们可以通过开源的Erlang标准库来彻底了解其中奥妙，因为我们可以获取Erlang的源码来研究它底层的实现机制。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-del_path-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-del_path-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:get_cycle/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-get-cycle-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#get_cycle-2" target="_blank" rel="external">digraph:get_cycle/2</a>.</p>
<p>我们将继续在上一篇文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a> 用的有向图上讲解。</p>
<a id="more"></a>
<p><img src="/images/digraph-get-cycle01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>digraph:get_cycle/2 两个入参分别是一个有向图G，一个节点V，该函数尝试在有向图中找到一条路径使得节点V在其中并且形成一个环。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:get_cycle(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_cycle(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3],['$v'|0],['$v'|1]]</span></div></pre></td></tr></table></figure>
<p>接着我们增加一个新节点V5，并且新增一条从节点V4发出到节点V5的边。</p>
<p>然后我们调用 digraph:get_cycle/2 第二个入参是V5，我们会得到一个false，因为在图中没有一个环使得V5在其中。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">V5 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">E6 = digraph:add_edge(Graph, V4, V5).</div><div class="line"><span class="comment">% ['$e'|5]</span></div><div class="line">digraph:get_cycle(Graph, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>digraph模块还有一个函数 <a href="http://www.erlang.org/doc/man/digraph.html#get_short_cycle-2" target="_blank" rel="external">digraph:get_short_cycle/2</a> 。</p>
<p>digraph:get_short_cycle/2 尝试为节点V在图G中找到一条最短的环。</p>
<p>官方文档解释 digraph:get_short_cycle/2 的原话是：</p>
<p>尝试在有向图G上找到尽可能短的通过节点V的简单环。</p>
<p>因此这取决于你如何理解这句话，可能不能保证返回最短的环，而只是返回更短的一个环，这可能取决于有向图的整体大小和复杂度。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:get_short_cycle(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_short_cycle(Graph, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-get_cycle-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-get_cycle-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:in_neighbors/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-in-neighbors-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#in_neighbors-2" target="_blank" rel="external">digraph:in_neighbors/2</a>.</p>
<p>digraph:in_neighbors/2 第一个入参是一个有向图G，第二个入参是一个节点V，函数将返回一个由若干节点组成的列表，而且有从这些节点发出并进入节点V的边。</p>
<a id="more"></a>
<p>我们继续用上个星期的文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a> 里的例子基础上进行讲解。</p>
<p><img src="/images/digraph-in-neighbors01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>图和相关元素都设置好后，我们可以开始在我们的图里找不同节点的入站邻居节点 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:in_neighbours(Graph, V4).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|2]]</span></div><div class="line">digraph:in_neighbours(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|3]]</span></div><div class="line">digraph:in_neighbours(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|0]]</span></div></pre></td></tr></table></figure>
<p>上述输出我们可以看到对于节点4函数返回值是[[‘$v’ | 1],[[‘$v’ | 2]]]，也就是节点2和节点3。对于节点1，我们得到一个 inbound 邻居节点4，而对于节点2，我们得到inbound邻居节点1。</p>
<p><strong>digraph:out_neighbors/2</strong></p>
<p>digraph模块也包含函数 <a href="http://www.erlang.org/doc/man/digraph.html#out_neighbours-2" target="_blank" rel="external">digraph:out_neighbors/2</a> ，它的返回值是由从入参节点发出的边相应的所有节点组成的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:out_neighbours(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|3],['$v'|2]]</span></div><div class="line">digraph:out_neighbours(Graph, V4).</div><div class="line"><span class="comment">% [['$v'|0]]</span></div><div class="line">digraph:out_neighbours(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|1]]</span></div></pre></td></tr></table></figure>
<p>我们从上图看到节点2有“指向”节点3和节点4的边，而我们再看 digraph:out_neighbors/2 的输出，得到的结果就是节点3和节点4。</p>
<p>这个例子里我们得到的节点列表是节点4在节点3点前面，但是这个顺序是不确定的，正如官方文档所讲的，“边是没有特定的顺序的”，这个情况对于 digraph:in_neighbors/2 也一样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-in_neighbors-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-in_neighbors-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:get_path/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-get-path-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#get_path-3" target="_blank" rel="external">digraph:get_path/3</a>.</p>
<p>digraph:get_path/3 接收三个入参，一个有向图，一个开始节点和一个结束节点，该函数将尝试在图中找到一些大于0的路径，在路径里除了允许第一个节点和最后一个节点相同，其他所有的节点都不能相同。</p>
<a id="more"></a>
<p>如果找到一个路径，函数将返回一个在路径中按顺序被访问到的节点所组成的列表，如果找不到路径，函数将返回false。</p>
<p>首先我们创建一个新的有向图以便我们可以遍历它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>上述语句将给我们一个如下的有向图：</p>
<p><img src="/images/digraph-get-path01.png" alt="有向图"></p>
<p>现在我们可以使用 digraph:get_path/3 函数来看看图中任何两个节点间有什么路径。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">digraph:get_path(Graph, V2, V3).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|2]]</span></div><div class="line">digraph:get_path(Graph, V2, V4).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3]]</span></div><div class="line">digraph:get_path(Graph, V2, V1).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_path(Graph, V3, V1).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_path(Graph, V1, V4).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3]]</span></div><div class="line">digraph:get_path(Graph, V1, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div></pre></td></tr></table></figure>
<p>注意：上述结果中只是碰巧有最短的路径，但是该函数并不保证最短路径是第一个返回的路径。</p>
<p>如果我们新增加一个节点，但是没有将它和其他节点连接起来，然后我们就调用 digraph:get_path/3 来获取与它相关的路径，那么函数会返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">V5 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">digraph:get_path(Graph, V1, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-get_path-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-get_path-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:add_edge/4]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-add-edge-4/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#add_edge-4" target="_blank" rel="external">digraph:add_edge/4</a>.</p>
<p>digraph:add_edge/4 第一个入参是一个有向图，第二个入参是原节点（<a href="http://www.erlang.org/doc/man/digraph.html#emanate" target="_blank" rel="external">发出节点</a>），第三个入参是目标节点（<a href="http://www.erlang.org/doc/man/digraph.html#incident" target="_blank" rel="external">接收节点</a>），最后一个入参是一个标签。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">Vertex1 = digraph:add_vertex(Graph, foo).</div><div class="line"><span class="comment">% foo</span></div><div class="line">Vertex2 = digraph:add_vertex(Graph, bar).</div><div class="line"><span class="comment">% bar</span></div><div class="line">Edge1 = digraph:add_edge(Graph, Vertex1, Vertex2, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|0]]</span></div><div class="line">Edge2 = digraph:add_edge(Graph, Vertex2, Vertex1, &#123;bar, foo&#125;).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|0]]</span></div></pre></td></tr></table></figure>
<p>digraph模块也有 digraph:add_edge/5 函数，它允许你指定边的标识符，下面的例子我给一条边的标识符是 myEdge 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:add_edge(Graph, myEdge, Vertex2, Vertex1, myLabel).</div><div class="line"><span class="comment">% myEdge</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|3],myEdge,['$e'|0]]</span></div></pre></td></tr></table></figure>
<p>另外 digraph:add_edge/3 函数则允许你不指定边或者标签。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:add_edge(Graph, Vertex2, Vertex1).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">digraph:add_edge(Graph, Vertex2, Vertex1).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|3],['$e'|0]]</span></div></pre></td></tr></table></figure>
<p>如果你注意到上述的 digraph:add_edge/3 和 digraph:add_edge/5 函数的例子中，我们给同样的发出节点和接收节点增加几个边，函数都很乐意地为我们创建这些边。</p>
<p>我们也可以通过指定 acyclic 参数给 digraph:new/1 来创建一个无循环有向图。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Graph2 = digraph:new([acyclic]).</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,false&#125;</span></div><div class="line">VertexA = digraph:add_vertex(Graph2, foo).</div><div class="line"><span class="comment">% foo</span></div><div class="line">VertexB = digraph:add_vertex(Graph2, bar).</div><div class="line"><span class="comment">% bar</span></div><div class="line">EdgeAB = digraph:add_edge(Graph2, VertexA, VertexB, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">EdgeBA = digraph:add_edge(Graph2, VertexB, VertexA, &#123;bar, foo&#125;).</div><div class="line"><span class="comment">% &#123;error,&#123;bad_edge,[foo,bar]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>当我们想创建一条边从而在一个无循环有向图里创建一个环的时候，我们将得到一个带有指定边的 bad_edge 错误。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-add_edge-4/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-add_edge-4/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – digraph:add_vertex/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-add-vertex-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday如上星期保证的开始深入digraph模块，今天讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#add_vertex-1" target="_blank" rel="external">digraph:add_vertex/1</a>.</p>
<p>首先我们创建一个新的有向图以便我们可以往里加节点。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div></pre></td></tr></table></figure>
<p>我们用 digraph:add_vertex/1 往此有向图里加入一些节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div></pre></td></tr></table></figure>
<p>因为我们没有指定我们想要加入的节点的任何信息，Erlang将为我们创建一个 [‘$v’ | I]格式的节点，它有一个空列表做为标签，I是一个非负整数。</p>
<p>如果我们希望提供节点标识符，我们也可以用 digraph:add_vertex/2 来添加一个节点，或者用 digraph:add_vertext/3 来提供节点标识符和标签。正如 digraph:add_vertex/1 ，digraph:add_vertex/2 也用空列表来做为标签。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:add_vertex(Graph, vertex1).</div><div class="line"><span class="comment">% vertex1</span></div><div class="line">digraph:add_vertex(Graph, vertex2, <span class="string">"Vertex 2"</span>).</div><div class="line"><span class="comment">% vertex2</span></div></pre></td></tr></table></figure>
<p>我们现在添加了5个节点，可以用 <a href="http://www.erlang.org/doc/man/digraph.html#vertices-1" target="_blank" rel="external">digraph:vertices/1</a> 来检查在这个有向图里有哪些节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],vertex2,vertex1]</span></div></pre></td></tr></table></figure>
<p>如果我们决定以 [‘$v’ | I]格式自己尝试添加一个节点，然后接着调用 digraph:add_vertex/1 ，那么我们可能会有麻烦。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">digraph:add_vertex(Graph, ['$v' | <span class="number">3</span>]).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],['$v'|3],vertex2,vertex1]</span></div><div class="line">digraph:add_vertex(Graph, ['$v' | <span class="number">4</span>]).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|4],</span></div><div class="line"><span class="comment">%  ['$v'|2],</span></div><div class="line"><span class="comment">%  ['$v'|1],</span></div><div class="line"><span class="comment">%  ['$v'|0],</span></div><div class="line"><span class="comment">%  ['$v'|3],</span></div><div class="line"><span class="comment">%  vertex2,vertex1]</span></div></pre></td></tr></table></figure>
<p>我们自己通过制定格式来添加一个节点，然后又让Erlang帮我们添加一个新的节点，那么最终的结果就是“丢失”一个节点，因为当我们看这个有向图的状态的时候可以看到原来是发生了覆盖的情况。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-add_vertex-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-add_vertex-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – The digraph module]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-the-digraph-module/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们开始看 <a href="http://erlang.org/doc/man/digraph.html" target="_blank" rel="external">digraph</a> 模块。</p>
<p>当我研究这个模块的时候，发现这个模块并不和我预料的Erlang行为一样，所以我想在研究它的函数前仔细看看它那些与众不同的地方。</p>
<a id="more"></a>
<p>如果我们查看所有digraph模块的函数，我们只能找到两个函数 digraph:new/0 和 digraph:new/1 返回 digraph 类型数据。</p>
<p>我想看看这个Erlang API有什么奇怪的，我打开Erlang shell，添加一个节点到有向图然后检查这个操作的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">G = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,69651,73748,77845,true&#125;</span></div><div class="line">G2 = digraph:add_vertex(G, foo, bar).</div><div class="line"><span class="comment">% foo</span></div></pre></td></tr></table></figure>
<p>调用 digraph:add_vertex/3 返回的结果是foo，也就是传给它的第二个入参，这个结果并不像一个有向图的样子。<br>那么，再回过头来看看变量G是否有变化。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">G.</div><div class="line"><span class="comment">% &#123;digraph,69651,73748,77845,true&#125;</span></div></pre></td></tr></table></figure>
<p>元组形式的结果看起来和原来一样，那么我们看看那个节点是否在图里，因为我们获得返回值是foo。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [foo]</span></div><div class="line">digraph:vertex(G, foo).</div><div class="line"><span class="comment">% &#123;foo,bar&#125;</span></div></pre></td></tr></table></figure>
<p>看来那个节点的确在图中。</p>
<p>让我们再加入另一个节点到与变量G绑定到图中。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">V = digraph:add_vertex(G).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [['$v'|0],foo]</span></div></pre></td></tr></table></figure>
<p>这个节点也添加成功。</p>
<p><strong>困惑所在</strong></p>
<p>所以在研究这个模块的函数之前在本文中我要重点讲出来的这个行为模式是这些函数在图中显而易见地展现了可修改的行为模式。</p>
<p>我说它是显而易见的可修改的，因为如果它在底层的实现上是不可修改的，结构可以改变同时绑定的变量的引用保持不变。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [['$v'|0],foo]</span></div><div class="line">Copy = G.</div><div class="line"><span class="comment">% &#123;digraph,69651,73748,77845,true&#125;</span></div><div class="line">V2 = digraph:add_vertex(G, wat).</div><div class="line"><span class="comment">% wat</span></div><div class="line">digraph:vertices(Copy).</div><div class="line"><span class="comment">% [['$v'|0],foo,wat]</span></div><div class="line">digraph:vertices(G).</div><div class="line"><span class="comment">% [['$v'|0],foo,wat]</span></div></pre></td></tr></table></figure>
<p>甚至其他变量引用也改变，所以它颠覆了我见过的在Erlang生态圈里关于所有数据是不可变的任何常规。</p>
<p>我们将在后续的<a href="http://www.proctor-it.com/tag/erlang-thursday/" target="_blank" rel="external">Erlang Thursday</a>文章中研究digraph模块的函数，但是我想花点时间讲这个模块中的可变性的内在本质，所以当你需要使用这个模块的时候，你一定要认识到如果不谨慎的话你想在你的应用的并发部分使用它将很危险。</p>
<p><strong>修改 (10月18日)</strong></p>
<p>做为 <a href="http://blog.lfe.io/tags.html#lfe%20friday-ref" target="_blank" rel="external">LFE Fridays</a> 的 <a href="http://blog.lfe.io/tutorials/2015/10/18/1701-lfe-friday---the-digraph-module/" target="_blank" rel="external">translation into Lisp Flavored Erlang</a> 的一部分，Robert Virding 告诉我这个模块的可变性的原因，这个内容也包含在他翻译本文的文章里。</p>
<p><strong>屠龙（解惑）</strong></p>
<p>这背后的原因是这个模块是如何实现的。一个 有向图 底层的实现上有三个 <a href="http://erlang.org/doc/man/ets.html" target="_blank" rel="external">ETS</a> 表。在上述例子里，这些表的id是 8207，12304和16401。你可以调用 ets:i/0 来看到，这个函数列出所有当前ets表。你可以看到那3个表属于Erlang shell进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; self().</div><div class="line">&lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line">&gt; ets:i().</div><div class="line"> id              name              type  size   mem      owner</div><div class="line"> ----------------------------------------------------------------------------</div><div class="line"> <span class="number">1</span>               code              set   <span class="number">282</span>    <span class="number">10393</span>    code_server</div><div class="line"> <span class="number">4098</span>            code_names        set   <span class="number">64</span>     <span class="number">7713</span>     code_server</div><div class="line"> <span class="number">8207</span>            vertices          set   <span class="number">3</span>      <span class="number">328</span>      &lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line"> <span class="number">12304</span>           edges             set   <span class="number">0</span>      <span class="number">305</span>      &lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line"> <span class="number">16401</span>           neighbours        bag   <span class="number">2</span>      <span class="number">319</span>      &lt;<span class="number">0.28</span>.<span class="number">0</span>&gt;</div><div class="line"> ac_tab          ac_tab            set   <span class="number">6</span>      <span class="number">839</span>      application_controller</div><div class="line"> file_io_servers file_io_servers   set   <span class="number">0</span>      <span class="number">305</span>      file_server_2</div><div class="line"> global_locks    global_locks      set   <span class="number">0</span>      <span class="number">305</span>      global_name_server</div><div class="line"> global_names    global_names      set   <span class="number">0</span>      <span class="number">305</span>      global_name_server</div><div class="line">...</div><div class="line"></div><div class="line">ok</div></pre></td></tr></table></figure>
<p>有向图它自己的结构仅是一个标签元组，包含着ets表id。所有的改变都发上在ETS表里，图的结构本身从未改变。表的数据和内容可以用 <a href="http://erlang.org/doc/man/ets.html#info-1" target="_blank" rel="external">ets:info/1</a> 和 <a href="http://erlang.org/doc/man/ets.html#i-1" target="_blank" rel="external">ets:i/1</a> 来读取。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-the-digraph-module/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-the-digraph-module/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tar:table/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tar-table-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/erl_tar.html#table-1" target="_blank" rel="external">erl_tar:table/1</a> 。</p>
<p>erl_tar:table/1 返回一个tar文件包含的文件名列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">erl_tar:table(<span class="string">"animal_sounds.tar"</span>).</div><div class="line"><span class="comment">% &#123;ok,["dog.txt","cat.txt","pony.txt","bear.txt"]&#125;</span></div><div class="line">还有一个版本 erl_tar:table/<span class="number">2</span> 多了一个选项列表入参。</div><div class="line">erl_tar:table(<span class="string">"animal_sounds.tar.gz"</span>, [compressed]).</div><div class="line"><span class="comment">% &#123;ok,["dog.txt","cat.txt","pony.txt","bear.txt"]&#125;</span></div><div class="line">erl_tar:table(<span class="string">"animal_sounds.tar.gz"</span>, [compressed,verbose]).</div><div class="line"><span class="comment">% &#123;ok,[&#123;"dog.txt",regular,5,</span></div><div class="line"><span class="comment">%       &#123;&#123;2015,9,23&#125;,&#123;22,18,47&#125;&#125;,</span></div><div class="line"><span class="comment">%       420,501,20&#125;,</span></div><div class="line"><span class="comment">%      &#123;"cat.txt",regular,5,&#123;&#123;2015,9,23&#125;,&#123;22,18,56&#125;&#125;,420,501,20&#125;,</span></div><div class="line"><span class="comment">%      &#123;"pony.txt",regular,8,&#123;&#123;2015,9,23&#125;,&#123;22,19,10&#125;&#125;,420,501,20&#125;,</span></div><div class="line"><span class="comment">%      &#123;"bear.txt",regular,19,</span></div><div class="line"><span class="comment">%       &#123;&#123;2015,9,23&#125;,&#123;22,21,16&#125;&#125;,</span></div><div class="line"><span class="comment">%       420,501,20&#125;]&#125;</span></div></pre></td></tr></table></figure>
<p>用verbose选项，我们得到元组的列表而不仅是得到文件名列表。</p>
<p>这个元组包括：文件名，文件类型（标准文件／目录或者符号链接），文件的字节数，时间戳元组，访问权限（用十进制表示而不是用8进制），用户id，组id。</p>
<p>官方文档并没有指定任何返回类型的信息，另外澄清420，501，20这些元素代表的意思的荣誉是全部属于Robert Virding，属于他把本篇文章翻译成 <a href="http://blog.lfe.io/tags.html#lfe%20friday-ref" target="_blank" rel="external">LEF Fridays</a> 的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-table-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-table-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tar:extract/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tar-extract-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erl_tar.html#extract-1" target="_blank" rel="external">erl_tar:extract/1</a> 。</p>
<p>erl_tar:extract/1 有一个入参，这个入参可能是一个二进制元组、文件描述符元组或是文件名，函数把tar文件的内容解压到当前目录。</p>
<a id="more"></a>
<p>由于我们需要一个tar文件来演示解压它，那么我们来创建一些文件并将它们加入一个新的tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"woof"</span> &gt; dog.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"meow"</span> &gt; cat.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"sparkle"</span> &gt; pony.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">'Wocka Wocka Wocka!'</span> &gt; bear.txt</div><div class="line">$ tar -cvf animal_sounds.tar dog.txt cat.txt pony.txt bear.txt</div><div class="line">a dog.txt</div><div class="line">a cat.txt</div><div class="line">a pony.txt</div><div class="line">a bear.txt</div></pre></td></tr></table></figure>
<p>接着我们也创建一个压缩版本的tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ tar -cvzf animal_sounds.tar.gz dog.txt cat.txt pony.txt bear.txt</div><div class="line">a dog.txt</div><div class="line">a cat.txt</div><div class="line">a pony.txt</div><div class="line">a bear.txt</div></pre></td></tr></table></figure>
<p>为了测试解压这两个tar文件，我们清空当前目录的已经加入tar文件的相关文件。</p>
<p>`` bash<br>$ rm dog.txt cat.txt pony.txt bear.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">确保我们准备好了用来试验的tar文件后，我们打开Erlang shell，然后调用 erl_tar:extract/1 函数。</div><div class="line"></div><div class="line">``` erlang</div><div class="line">erl_tar:extract(&quot;animal_sounds.tar&quot;).</div><div class="line">% ok</div></pre></td></tr></table></figure></p>
<p>看起来直截了当，我们回到命令行看看我们解压出来的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls dog.txt cat.txt pony.txt bear.txt</div><div class="line">bear.txt cat.txt  dog.txt  pony.txt</div><div class="line">$ rm dog.txt cat.txt pony.txt bear.txt</div></pre></td></tr></table></figure>
<p>确认文件后，为了试验，我们把它们删除继续下面的试验。</p>
<p><strong>erl_tar:extract/2</strong></p>
<p>Erlang还有一个 <a href="http://www.erlang.org/doc/man/erl_tar.html#extract-2" target="_blank" rel="external">erl_tar:extract/2</a> 函数，它允许我们通过提供一个列表做为它第二个入参来做为解压的选项。</p>
<p>我们可以用 erl_tra:extract/2 解压文件并让它在控制台打印相关的信息，并且可以增加指定另外的选项，不仅打印相关信息而且解压动作不重写已经存在的任何对应的文件。</p>
<p>`` erlang<br>erl_tar:extract(“animal_sounds.tar”, [verbose]).<br>% x /Users/proctor/tmp/dog.txt<br>%<br>% x /Users/proctor/tmp/cat.txt<br>%<br>% x /Users/proctor/tmp/pony.txt<br>%<br>% x /Users/proctor/tmp/bear.txt<br>%<br>% ok<br>erl_tar:extract(“animal_sounds.tar”, [verbose, keep_old_files]).<br>% x /Users/proctor/tmp/dog.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/cat.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/pony.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/bear.txt - exists, not created<br>%<br>% ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">接着还是回到命令行把解压出来的文件删除继续试验。</div><div class="line"></div><div class="line">``` bash</div><div class="line">$ rm dog.txt cat.txt pony.txt bear.txt</div></pre></td></tr></table></figure></p>
<p>接下来我们通过传入有原子 compressed 组成的列表做为第二个参数来解压 animal_sounds.tar.gz。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, compressed, keep_old_files]).</div><div class="line"><span class="comment">% x /Users/proctor/tmp/dog.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/cat.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/pony.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/bear.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>有些时候在你的程序中处理tar文件的时候，你不想必需要在文件系统下操作所有tar里的文件而只是读取tar文件的内容，所以有一个选贤可以让tar文件内容保存在内存中</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, compressed, keep_old_files, memory]).</div><div class="line"><span class="comment">% &#123;ok,[&#123;"dog.txt",&lt;&lt;"woofn"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"cat.txt",&lt;&lt;"meown"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"pony.txt",&lt;&lt;"sparklen"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"bear.txt",&lt;&lt;"Wocka Wocka Wocka!n"&gt;&gt;&#125;]&#125;</span></div></pre></td></tr></table></figure>
<p>当传入 memory 这个选项，erl_tar:extract/2 的返回值变为一个状态元组，其中有一个包含了被解压tar文件内每一个文件的文件名和它们的二进制内容组成的元组形成的列表。<br>如果一个错误在解压文件到内存的时候发生，比如我们忘了传入 compressed 选项给一个压缩tar文件，函数将返回一个错误元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, memory]).</div><div class="line"><span class="comment">% &#123;error,eof&#125;</span></div></pre></td></tr></table></figure>
<p>erl_tar:extract/2 还可以接收跟多的选项，所以我强烈建议你仔细阅读官方文档获取全部可选项。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-extract-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-extract-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tar:create/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tar-create-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/erl_tar.html#create-2" target="_blank" rel="external">erl_tar:create/2</a> 。</p>
<p>erl_tar:create/2 根据传入的文件名来创建一个tar文件并将参提供的文件列表加入到tar文件里。</p>
<a id="more"></a>
<p>erl_tar:create/2 有两个入参，第一个入参是一个要写入内容到文件名，第二个入参是一个将要加入tar文件里的文件列表。</p>
<p>首先我们打开一个新的操作系统shell会话并且创建一些文件，这些文件将加入到一个新tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"foo"</span> &gt; foo.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"bar"</span> &gt; bar.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"baz"</span> &gt; baz.txt</div><div class="line">$ ls</div><div class="line">bar.txt  baz.txt  foo.txt  test.tar</div></pre></td></tr></table></figure>
<p>现在我们有了一些可以归档的文件，我们可以打开一个新的erl shell，并且创建一个新的tar文件，它的名字是test.tar。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"test.tar"</span>, [<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"baz.txt"</span>]).</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>看起来好像是有用的，所以我们回到OS shell，看看刚才我们给 erl_tar:create/2（译者注：作者手误写成了 erl_tar:create/3 ） 函数传的那个tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -tf test.tar</div><div class="line">foo.txt</div><div class="line">bar.txt</div><div class="line">baz.txt</div></pre></td></tr></table></figure>
<p>没错，tar可以读这个文件并且告诉我们，那三个我们传入的文件都真的在tar文件里。</p>
<p>erl_tar:create/3</p>
<p>Erlang也提供了 erl_tar:create/3 它最后一个入参是一个选项列表。</p>
<p>我们将创建一个新的tar文件，它里面的文件和上面的例子是一样的，第三个入参我们表明我们想要这个tar文件被压缩而且执行过程中在控制台输出执行过程的内容。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"options.tar.gz"</span>,</div><div class="line">               [<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"baz.txt"</span>],</div><div class="line">               [compressed, verbose]).</div><div class="line"><span class="comment">% a foo.txt</span></div><div class="line"><span class="comment">% a bar.txt</span></div><div class="line"><span class="comment">% a baz.txt</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>再次回到OS shell，来看看这个tar文件里包含的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -tf options.tar.gz</div><div class="line">foo.txt</div><div class="line">bar.txt</div><div class="line">baz.txt</div></pre></td></tr></table></figure>
<p>然后我们来测试一下，这个文件是否能被gzip解压缩。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gzip --test options.tar.gz</div><div class="line">$</div></pre></td></tr></table></figure>
<p>结果gzip认为这个文件压缩完整性很好。接着我们来看看我们创建的这两个tar文件在大小上的差异。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls <span class="_">-l</span> test.tar options.tar.gz</div><div class="line">-rw-r--r--  1 -------  -----    154 Sep XX HH:MM options.tar.gz</div><div class="line">-rw-r--r--  1 -------  -----  10240 Sep XX HH:MM test.tar</div></pre></td></tr></table></figure>
<p>从文件大小来看，options.tar.gz 的确是被压缩的，因为它比test.tar小了两个数量级。</p>
<p>创建一个已经存在的文件</p>
<p>我们刚刚创建了 test.tar 并且看了它内部的内容。现在我们来看看传入相同的文件名test.tar和一个空的文件列表来创建一个已经存在的文件，这样做会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"test.tar"</span>, []).</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>然后我们看看它的内容，发现它原来的内容被替换了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar -tf test.tar</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这说明，erl_tar:create/2 创建tar文件并且覆盖已经存在的文件，如果文件已经存在它不会输出错误（假设用户的shell有权限写该文件或目录）。</p>
<p>在一个不存在的路径上创建tar文件</p>
<p>如果我们给一个不存在的路径, 我们可以看到 erl_tar:create/2 将返回一个错误元组，包括了文件名以及错误原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create('/path/does/<span class="keyword">not</span>/exist.tar', []).</div><div class="line"><span class="comment">% &#123;error,&#123;'/path/does/not/exist.tar',enoent&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>其他潜在的陷阱</p>
<p>首先官方文档说该函数入参是文件名，但是它没有指明erl_tar模块中文件名的数据类型是什么。</p>
<p>如果你用原子来做文件名，你会像我第一次用字符串做文件名前一样得到下面例子的错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">erl_tar:create('test.tar', ['foo.txt', 'bar.txt', 'baz.txt']).</div><div class="line">** exception error: no function clause matching filename:join([]) (filename.erl, line <span class="number">392</span>)</div><div class="line">     in function  erl_tar:split_filename/<span class="number">4</span> (erl_tar.erl, line <span class="number">423</span>)</div><div class="line">     in call from erl_tar:create_header/<span class="number">3</span> (erl_tar.erl, line <span class="number">352</span>)</div><div class="line">     in call from erl_tar:add1/<span class="number">4</span> (erl_tar.erl, line <span class="number">305</span>)</div><div class="line">     in call from erl_tar:foreach_while_ok/<span class="number">2</span> (erl_tar.erl, line <span class="number">940</span>)</div><div class="line">     in call from erl_tar:create/<span class="number">3</span> (erl_tar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<p>其次，根据erl_tar官方文档的 <a href="http://erlang.org/doc/man/erl_tar.html#id180770" target="_blank" rel="external">限制</a> 这一节，为了最大的兼容性，在各种不同操作系统和tar程序版本中，文件名应该少于100个字符。</p>
<p>最后，当我们指定文件名的时候，包不包括扩展名由我们使用者决定，这和 erl_tar:compress/2 函数一样不为我们使用者管理文件扩展名。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-create-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-create-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erl_tidy:file/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-erl-tidy-file-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们看看Erlang的 erl_tidy 模块，我们从 <a href="http://www.erlang.org/doc/man/erl_tidy.html#file-1" target="_blank" rel="external">erl_tidy:file/1</a> 开始。</p>
<p>erl_tidy:file/1 入参是一个文件名，它整理并简洁美观地输出入参指定的文件的源码。</p>
<a id="more"></a>
<p>在我的tmp目录里有我解决 FizzBuzz 的快速实现模块，我将看看 erl_tidy:file/1 如何处理这个文件，因为我确定它的处理不是那么的漂亮。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>我们打开一个新的Erlang shell，然后用入参 fizzbuzz.erl 来调用 erl_tidy:file/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erl_tidy:file(<span class="string">"fizzbuzz.erl"</span>).</div><div class="line"><span class="comment">% fizzbuzz.erl:6: replacing call to `lists:map/2' with a list comprehension.</span></div><div class="line"><span class="comment">% fizzbuzz.erl:6: changing application of implicit fun to direct local call.</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>看起来它不喜欢我在代码中用map而且它修改了我调用 translate/1 函数的方式。</p>
<p>关掉shell，我们来看看目录下多了什么。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls <span class="_">-l</span></div><div class="line">total 16</div><div class="line">-rw-r--r--  1 proctor  staff  402 Sep  9 22:06 fizzbuzz.erl</div><div class="line">-rw-r--r--  1 proctor  staff  405 Sep  9 22:05 fizzbuzz.erl.bak</div></pre></td></tr></table></figure>
<p>让我们来看看 fizzbuzz.erl.bak ，主要是确认它的内容是 fizzbuzz.erl 的原始内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>它的确是 fizzbuzz.erl 的原始内容。</p>
<p>现在我们来看看被 erl_tidy:file/1 修改后的 fizzbuzz.erl 文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = [translate(V1) || V1 &lt;- lists:seq(1, N)],</div><div class="line">    lists:foreach(fun (Item) -&gt; io:format("~s~n", [Item])</div><div class="line">		  end,</div><div class="line">		  Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">    'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt; 'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt; 'Buzz';</div><div class="line">translate(N) -&gt; integer_to_list(N).</div></pre></td></tr></table></figure>
<p>正如函数输出的两行消息所说的，我们现在用一个列表解析替代map，并且直接调用 translate/1 函数。</p>
<p>它还把传给 lists:foreach/2 的匿名函数的 end 放在新的一行，也把列表 Translations 放在新的一行。</p>
<p>最后，translate/1 三个分支被改成一行，而且文件最后的换行符也被删掉。</p>
<p>据官方文档所讲，如果 fizzbuzz.erl 有任何没使用的函数都会被删除，同时过时的结构和函数也会被修改。</p>
<p>总的来说，这个好用的Erlang应用小工具可以帮助你的代码保持稳定的风格并将代码保持整洁。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tidy-file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tidy-file-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:pid/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/20/erlang-thursday-c-pid-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们简单讲讲 <a href="http://erlang.org/doc/man/c.html#pid-3" target="_blank" rel="external">c:pid/3</a>.</p>
<p>c:pid/3 三个入参分别是一个pid的三个部分的整数值，返回值的类型是与入参值对应的Pid类型。</p>
<a id="more"></a>
<p>我们调用 self 函数来得到当前的pid，然后我们可以调用 c:pid/3 和 self 返回的值进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self().</div><div class="line">% &lt;0.42.0&gt;</div><div class="line">c:pid(0, 42, 0).</div><div class="line">% &lt;0.42.0&gt;</div><div class="line">self() =:= c:pid(0, 42, 0).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>这个函数有什么用呢？有时候当我们检测一个在线系统的时候，在Erlang里有些调用是需要Pid类型的入参而不只是pid的三个整数值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  128774    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163760    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                 448    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.27.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                17940    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div><div class="line">erlang:is_process_alive(c:pid(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>)).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>让我们以正常的方式给这个函数传入一些让其异常的值看看它会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">c:pid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% &lt;0.0.0&gt;</span></div><div class="line">c:pid(<span class="number">111110</span>, <span class="number">0</span>, <span class="number">1111110</span>).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  list_to_pid/1</span></div><div class="line"><span class="comment">%         called as list_to_pid("&lt;111110.0.1111110&gt;")</span></div><div class="line"><span class="comment">%      in call from c:pid/3 (c.erl, line 424)</span></div></pre></td></tr></table></figure>
<p>像<0.0.0>这样的pid是有效的pid，但是传入无效的pid，函数抛出异常，从异常信息里我们看到它尝试调用 list_to_pid 。</0.0.0></p>
<p>让我们快速看看 list_to_pid 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erlang:list_to_pid(<span class="string">"&lt;0.42.0&gt;"</span>).</div><div class="line"><span class="comment">% &lt;0.42.0&gt;</span></div><div class="line">c:pid(<span class="number">0</span>, <span class="number">42</span>, <span class="number">0</span>) =:= erlang:list_to_pid(<span class="string">"&lt;0.42.0&gt;"</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>看起来 c:pid/3 是一个 list_to_pid 的封装函数，它把pid的三个部分的整数值构建成一个字符串，然后调用 list_to_pid 来得到一个 Pid 类型的值。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-pid-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-pid-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – user_default]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-user-default/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们来看看user_default模块。</p>
<p>我是在想验证当我在erl shell中调用 c/1 和 l/1 的函数的版本的时候偶然发现这个模块的，然后研究 <a href="http://www.erlang.org/doc/man/shell_default.html" target="_blank" rel="external">shell_default</a> 的文档。</p>
<a id="more"></a>
<p>文档中提到，如果我们想让一些函数在shell里直接可用，我们可以生成一个名字为user_default的模块，然后在自己的 .erlang 文件里指定该模块的路径，这样的话user_default模块里的导出函数就可以直接在shell里可用了。</p>
<p>既然我手上有一个 fizzbuzz 的例子，那么让我们开始按文档的说明生成一个user_default模块证明我们可以让它正常工作。我们将把它放在我们home目录的tmp目录里。</p>
<p>~/tmp/user_default.erl</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(user_default).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>在我们的home目录下新建一个 .erlang 文件，添加如下内容，指明我们刚刚创建的user_default文件的路径。</p>
<p>～/.erlang<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code:load_abs(<span class="string">"tmp/user_default"</span>).</div></pre></td></tr></table></figure></p>
<p>如果你已经有一个 .erlang 文件，那么在这个文件的第一行必须是 <a href="http://www.erlang.org/doc/man/code.html#load_abs-1" target="_blank" rel="external">code:load_abs/1</a> 函数，其参数为 user_default 模块。</p>
<p>确定上述两个文件都保存好了，然后打开erlang shell来尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line">** exception error: undefined shell command fizzbuzz/<span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>然而并没有像文档里讲的那样起作用。我意识到，我们用的是 load_abs 函数，并且 user_default 是一个新模块，这个错误可能是因为没有文件可装载。让我们用erlc编译这个模块，然后再尝试。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd tmp/</div><div class="line">$ erlc user_default.erl</div><div class="line">$ ls user_default.*</div><div class="line">user_default.beam user_default.erl</div><div class="line">$ cd ..</div></pre></td></tr></table></figure>
<p>我们现在有一个BEAM文件在~/tmp目录里，所以让我们再次启动Erlang shell并尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">Fizz</div><div class="line"><span class="number">4</span></div><div class="line">Buzz</div><div class="line">Fizz</div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Fizz</div><div class="line">Buzz</div><div class="line"><span class="number">11</span></div><div class="line">Fizz</div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">14</span></div><div class="line">FizzBuzz</div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">17</span></div><div class="line">Fizz</div><div class="line"><span class="number">19</span></div><div class="line">Buzz</div><div class="line">ok</div><div class="line"><span class="number">2</span>&gt;</div></pre></td></tr></table></figure>
<p>终于正常工作了！我们现在可以在shell里不需要指定模块名而直接调用 fizzbuzz/1 。</p>
<p>更多的关于 .erlang 文件的信息可以阅读 <a href="http://www.erlang.org/documentation/doc-5.1/doc/getting_started/getting_started.html#1.7" target="_blank" rel="external">Erlang中关于配置部分的文档</a> 。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-user_default/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-user_default/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:i/0]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-c-i-0/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续讲c模块的另一个函数 <a href="http://erlang.org/doc/man/c.html#i-0" target="_blank" rel="external">c:i/0</a> 。</p>
<p>c:i/0 输出系统的信息，展示本节点的所有进程信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">c:i().</div><div class="line"><span class="comment">% Pid                   Initial Call                          Heap     Reds Msgs</span></div><div class="line"><span class="comment">% Registered            Current Function                     Stack</span></div><div class="line"><span class="comment">% &lt;0.0.0&gt;               otp_ring0:start/2                      987     4987    0</span></div><div class="line"><span class="comment">% init                  init:loop/1                              2</span></div><div class="line"><span class="comment">% &lt;0.3.0&gt;               erlang:apply/2                        6772   823443    0</span></div><div class="line"><span class="comment">% erl_prim_loader       erl_prim_loader:loop/3                   6</span></div><div class="line"><span class="comment">% &lt;0.6.0&gt;               gen_event:init_it/6                    376      220    0</span></div><div class="line"><span class="comment">% error_logger          gen_event:fetch_msg/5                    8</span></div><div class="line"><span class="comment">% &lt;0.7.0&gt;               erlang:apply/2                        1598      463    0</span></div><div class="line"><span class="comment">% application_controlle gen_server:loop/6                        7</span></div><div class="line"><span class="comment">% &lt;0.9.0&gt;               application_master:init/4              376       44    0</span></div><div class="line"><span class="comment">%                       application_master:main_loop/2           6</span></div><div class="line"><span class="comment">% &lt;0.10.0&gt;              application_master:start_it/4          233       69    0</span></div><div class="line"><span class="comment">%                       application_master:loop_it/4             5</span></div><div class="line"><span class="comment">% &lt;0.11.0&gt;              supervisor:kernel/1                   4185    49109    0</span></div><div class="line"><span class="comment">% kernel_sup            gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.12.0&gt;              rpc:init/1                             233       35    0</span></div><div class="line"><span class="comment">% rex                   gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.13.0&gt;              global:init/1                          233       51    0</span></div><div class="line"><span class="comment">% global_name_server    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.14.0&gt;              erlang:apply/2                         233       19    0</span></div><div class="line"><span class="comment">%                       global:loop_the_locker/1                 5</span></div><div class="line"><span class="comment">% &lt;0.15.0&gt;              erlang:apply/2                         233        3    0</span></div><div class="line"><span class="comment">%                       global:loop_the_registrar/0              2</span></div><div class="line"><span class="comment">% &lt;0.16.0&gt;              inet_db:init/1                         233      206    0</span></div><div class="line"><span class="comment">% inet_db               gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.17.0&gt;              global_group:init/1                    233       59    0</span></div><div class="line"><span class="comment">% global_group          gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.18.0&gt;              file_server:init/1                    2586     2562    0</span></div><div class="line"><span class="comment">% file_server_2         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.19.0&gt;              erlang:apply/2                        2586   155919    0</span></div><div class="line"><span class="comment">% code_server           code_server:loop/1                       3</span></div><div class="line"><span class="comment">% &lt;0.20.0&gt;              supervisor_bridge:standard_error/      233       41    0</span></div><div class="line"><span class="comment">% standard_error_sup    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.21.0&gt;              erlang:apply/2                         233        9    0</span></div><div class="line"><span class="comment">% standard_error        standard_error:server_loop/1             2</span></div><div class="line"><span class="comment">% &lt;0.22.0&gt;              supervisor_bridge:user_sup/1           610       87    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.23.0&gt;              erlang:apply/2                         233       24    0</span></div><div class="line"><span class="comment">% user                  user:server_loop/2                       5</span></div><div class="line"><span class="comment">% &lt;0.24.0&gt;              kernel_config:init/1                   233      286    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.25.0&gt;              supervisor:kernel/1                    233       58    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.29.0&gt;              kjell_profile:init/1                   987    27100    0</span></div><div class="line"><span class="comment">% kjell_profile         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.30.0&gt;              kjell_extension:init/1                2586     3903    0</span></div><div class="line"><span class="comment">% kjell_extension       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.45.0&gt;              k_user_drv:server/2                    987     2218    0</span></div><div class="line"><span class="comment">% user_drv              k_user_drv:server_loop/5                 8</span></div><div class="line"><span class="comment">% &lt;0.46.0&gt;              k_group:server/3                       987    14541    0</span></div><div class="line"><span class="comment">%                       k_group:server_loop/3                    4</span></div><div class="line"><span class="comment">% &lt;0.47.0&gt;              erlang:apply/2                       28690     4406    0</span></div><div class="line"><span class="comment">%                       kjell:shell_rep/4                       17</span></div><div class="line"><span class="comment">% &lt;0.48.0&gt;              erlang:apply/2                        1598    20585    0</span></div><div class="line"><span class="comment">%                       c:pinfo/1                               49</span></div><div class="line"><span class="comment">% Total                                                      58707  1110447    0</span></div><div class="line"><span class="comment">%                                                              237</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个函数返回进程的id，进程的初始化函数即启动进程的函数，进程堆的大小，进程的规约数，进程消息队列里的消息数，进程的注册名字，进程当前所处的函数，以及进程的栈大小。</p>
<p>c:i/0 的输出也包括堆大小、规约数，消息队列大小以及栈大小的各项数据的总和。</p>
<p>c模块也提供 c:ni/0 函数，它展示所有联通的节点的系统信息。</p>
<p>从该函数输出的进程信息来看，我们可以找到几个和 <a href="https://karlll.github.io/kjell/" target="_blank" rel="external">kjell</a> 相关的进程，kjell是我用来替换 erl shell的，它易于查找进程的信息。</p>
<p>查看一个kjell相关的进程，我们可以获得其pid，然后通过调用 <a href="http://erlang.org/doc/man/c.html#i-3" target="_blank" rel="external">c:i/3</a> 展示进程的信息来深入观察该进程，我们可以用pid的3个整数做为此函数的入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c:i(<span class="number">0</span>, <span class="number">47</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% [&#123;current_function,&#123;kjell,shell_rep,4&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;status,waiting&#125;,</span></div><div class="line"><span class="comment">%  &#123;message_queue_len,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;messages,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;links,[&lt;0.48.0&gt;,&lt;0.46.0&gt;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;dictionary,[&#123;&#123;result,1&#125;,ok&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;command,1&#125;,[&#123;call,1,&#123;remote,1,&#123;atom,1,c&#125;,&#123;atom,1,i&#125;&#125;,[]&#125;]&#125;,</span></div><div class="line"><span class="comment">%               &#123;evaluator,&lt;0.48.0&gt;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;trap_exit,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;error_handler,error_handler&#125;,</span></div><div class="line"><span class="comment">%  &#123;priority,normal&#125;,</span></div><div class="line"><span class="comment">%  &#123;group_leader,&lt;0.46.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;total_heap_size,46421&#125;,</span></div><div class="line"><span class="comment">%  &#123;heap_size,28690&#125;,</span></div><div class="line"><span class="comment">%  &#123;stack_size,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;reductions,4479&#125;,</span></div><div class="line"><span class="comment">%  &#123;garbage_collection,[&#123;min_bin_vheap_size,46422&#125;,</span></div><div class="line"><span class="comment">%                       &#123;min_heap_size,233&#125;,</span></div><div class="line"><span class="comment">%                       &#123;fullsweep_after,65535&#125;,</span></div><div class="line"><span class="comment">%                       &#123;minor_gcs,2&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;suspending,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们查看指定的进程的信息，我们可以看到它的链接进程，消息和消息队列长度，堆栈的信息，以及其他各种可能有用的相关设置。</p>
<p>同样，这几个函数也没有observer那样有漂亮的界面，不过它们在你无法直接通过一个终端来访问节点的时候可以派上用场，比如在一个跳板机上工作；它们能给你一个好的方式使得你能知道你的erlang节点的运行情况。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-i-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-i-0/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:regs/0]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-c-regs-0/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看看c模块并研究 <a href="http://erlang.org/doc/man/c.html#regs-0" target="_blank" rel="external">c:regs/0</a>.</p>
<p>c:regs/0 输出当前节点上注册的进程的信息，比如进程的名字，进程的id，执行规约数，以及其他信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  121202    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  156994    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                  92    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.28.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                 1219    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>尽管这个函数的输出没有observer函数提供的图形界面漂亮，但是它是一个有用的工具，在你无法运行observer函数来获得图形界面的时候能够帮助你得到这些进程是什么进程以及这些进程在做什么。</p>
<p>c模块还提供了一个 c:nregs/0 函数，它展示本节点以及与本节点联通的所有节点的所有注册进程的信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">node().</div><div class="line">% 'foo@127.0.0.1'</div><div class="line">nodes().</div><div class="line">% ['bar@127.0.0.1']</div><div class="line">c:nregs().</div><div class="line">%</div><div class="line">% ** Registered procs on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;0.19.0&gt;     auth:init/1                        880    0</div><div class="line">% code_server           &lt;0.25.0&gt;     erlang:apply/2                  122302    0</div><div class="line">% erl_epmd              &lt;0.18.0&gt;     erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163458    0</div><div class="line">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                264    0</div><div class="line">% file_server_2         &lt;0.24.0&gt;     file_server:init/1                  92    0</div><div class="line">% global_group          &lt;0.23.0&gt;     global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;0.13.0&gt;     global:init/1                      339    0</div><div class="line">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     255    0</div><div class="line">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 5405    0</div><div class="line">% kernel_safe_sup       &lt;0.34.0&gt;     supervisor:kernel/1                 58    0</div><div class="line">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;0.20.0&gt;     net_kernel:init/1                  792    0</div><div class="line">% net_sup               &lt;0.17.0&gt;     supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</div><div class="line">% standard_error        &lt;0.27.0&gt;     erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;0.26.0&gt;     supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;0.30.0&gt;     group:server/3                      36    0</div><div class="line">% user_drv              &lt;0.29.0&gt;     user_drv:server/2                 1661    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">%</div><div class="line">% ** Registered procs on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;6108.7.0&gt;   erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;6108.19.0&gt;  auth:init/1                        880    0</div><div class="line">% code_server           &lt;6108.25.0&gt;  erlang:apply/2                  124588    0</div><div class="line">% erl_epmd              &lt;6108.18.0&gt;  erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;6108.3.0&gt;   erlang:apply/2                  164400    0</div><div class="line">% error_logger          &lt;6108.6.0&gt;   gen_event:init_it/6                301    0</div><div class="line">% file_server_2         &lt;6108.24.0&gt;  file_server:init/1                  92    0</div><div class="line">% global_group          &lt;6108.23.0&gt;  global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;6108.13.0&gt;  global:init/1                      341    0</div><div class="line">% inet_db               &lt;6108.16.0&gt;  inet_db:init/1                     255    0</div><div class="line">% inet_gethost_native   &lt;6108.42.0&gt;  inet_gethost_native:serve           83    0</div><div class="line">% inet_gethost_native_s &lt;6108.41.0&gt;  supervisor_bridge:inet_ge           41    0</div><div class="line">% init                  &lt;6108.0.0&gt;   otp_ring0:start/2                 5515    0</div><div class="line">% kernel_safe_sup       &lt;6108.34.0&gt;  supervisor:kernel/1                127    0</div><div class="line">% kernel_sup            &lt;6108.11.0&gt;  supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;6108.20.0&gt;  net_kernel:init/1                  796    0</div><div class="line">% net_sup               &lt;6108.17.0&gt;  supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;6108.12.0&gt;  rpc:init/1                        1302    0</div><div class="line">% standard_error        &lt;6108.27.0&gt;  erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;6108.26.0&gt;  supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;6108.30.0&gt;  group:server/3                      36    0</div><div class="line">% user_drv              &lt;6108.29.0&gt;  user_drv:server/2                 2801    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">% ok</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-regs-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-regs-0/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday Bonus – Functional fizzbuzz]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-bonus-functional-fizzbuzz/</url>
      <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday红包。</p>
<p>过去的这个周末我读了文章  <a href="http://comp-phil.blogspot.com/2015/08/bro-do-you-even-fizzbuzz.html" target="_blank" rel="external">Bro, Do You Even FizzBuzz?!?</a> ，它阐述如何在Clojure里不用取模运算符来解决 FizzBuzz 问题。</p>
<a id="more"></a>
<p>在以同样的算法用Ruby来解决这个问题并发布<a href="http://www.proctor-it.com/ruby-tuesday-functional-fizzbuzz/" target="_blank" rel="external">博客</a>后，我想我应该将这个问题用Erlang也来解决，同时也看看有何不同。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(fizzbuzz)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([fizzbuzz/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Results = do_fizzbuzz(N),</div><div class="line">    lists:foreach(<span class="keyword">fun</span>(X) -&gt; io:format(<span class="string">"~p~n"</span>, [X]) <span class="keyword">end</span>, Results).</div><div class="line"></div><div class="line"><span class="function"><span class="title">do_fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Fizzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">"fizz"</span>], N),</div><div class="line">    Buzzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"buzz"</span>], N),</div><div class="line">    FizzBuzzes = lists:zipwith(<span class="keyword">fun</span> lists:append/<span class="number">2</span>, Fizzes, Buzzes),</div><div class="line">    Numbers = lists:seq(<span class="number">1</span>, N),</div><div class="line">    lists:zipwith(fun translate/2, Numbers, FizzBuzzes).</div><div class="line"></div><div class="line"><span class="function"><span class="title">cycle</span><span class="params">(List, N)</span> -&gt;</span></div><div class="line">    lists:sublist(lists:append(lists:duplicate(N, List)), N).</div><div class="line"></div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(Number, <span class="string">""</span>)</span> -&gt;</span></div><div class="line">    integer_to_list(Number);</div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(_, Translation)</span> -&gt;</span></div><div class="line">    Translation.</div></pre></td></tr></table></figure>
<p>在Erlang的解决方案里有几个点要注意。</p>
<p>首先，Erlang没有任何懒列表或序列的直接概念，也没有 cycle 函数，所以我只能临时凑合着调用 lists:duplicate, lists:append 和 lists:sublist 来处理一个列表，从而循环处理原列表来生成一个有N个元素的列表。虽然这个做法不是最高效的方式，但是它是可行的。</p>
<p>其次，lists:zipwith 的能力对于一些管道的想法有帮助，因为我们可以处理这些链在一起的元素，而不是必须在不同的步骤中去处理它们。</p>
<p>第三，我们不用case语句，而是用一个有guard分支的函数来决定一个翻译存在与否，如果是是否用这个翻译，如果不是是否用这个数字。</p>
<p>我希望这起到抛砖引玉的作用，也希望听到你怎样更高效的方案，或者除了用一般的有guard分支来检查剩余元素的模式匹配的其他方法来解决FizzBuzz问题。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:m/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/19/erlang-thursday-c-m-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续研究c模块，讲的函数是 <a href="http://erlang.org/doc/man/c.html#m-1" target="_blank" rel="external">c:m/1</a>.</p>
<p>c:m/1 入参是一个表示模块名字的原子，返回值是这个模块的信息。它打印出来的信息包括编译的日期、时间和编译选项，还有装载的目标（BEAM）文件以及这个模块中导出函数组成的列表。</p>
<a id="more"></a>
<p>我们来看看erlang中的string模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">c:m(string).</div><div class="line"><span class="comment">% Module string compiled: Date: November 28 2014, Time: 06.47</span></div><div class="line"><span class="comment">% Compiler options:  [&#123;outdir,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../ebin"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../include"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../../kernel/include"&#125;,</span></div><div class="line"><span class="comment">%                     warnings_as_errors,debug_info]</span></div><div class="line"><span class="comment">% Object file: /usr/local/Cellar/erlang/17.3.4/lib/erlang/lib/stdlib-2.2/ebin/string.beam</span></div><div class="line"><span class="comment">% Exports:</span></div><div class="line"><span class="comment">% centre/2                      rstr/2</span></div><div class="line"><span class="comment">% centre/3                      span/2</span></div><div class="line"><span class="comment">% chars/3                       str/2</span></div><div class="line"><span class="comment">% chars/2                       strip/1</span></div><div class="line"><span class="comment">% chr/2                         strip/2</span></div><div class="line"><span class="comment">% concat/2                      strip/3</span></div><div class="line"><span class="comment">% copies/2                      sub_string/2</span></div><div class="line"><span class="comment">% cspan/2                       sub_string/3</span></div><div class="line"><span class="comment">% equal/2                       sub_word/2</span></div><div class="line"><span class="comment">% join/2                        sub_word/3</span></div><div class="line"><span class="comment">% left/2                        substr/2</span></div><div class="line"><span class="comment">% left/3                        substr/3</span></div><div class="line"><span class="comment">% len/1                         to_float/1</span></div><div class="line"><span class="comment">% module_info/0                 to_integer/1</span></div><div class="line"><span class="comment">% module_info/1                 to_lower/1</span></div><div class="line"><span class="comment">% rchr/2                        to_upper/1</span></div><div class="line"><span class="comment">% right/2                       tokens/2</span></div><div class="line"><span class="comment">% right/3                       words/1</span></div><div class="line"><span class="comment">%                               words/2</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个模块是2014年11月28日在我的机器上编译的，还看到 warnings_as_errors 和 debug_info 这两个编译选项打开了，还有beam文件的路径以及string模块所有导出的不同函数。</p>
<p>接着我们看看在erlang shell里编译的模块。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">c(fizzbuzz).</div><div class="line">% &#123;ok,fizzbuzz&#125;</div><div class="line">c:m(fizzbuzz).</div><div class="line">% Module fizzbuzz compiled: Date: August 5 2015, Time: 22.14</div><div class="line">% Compiler options:  []</div><div class="line">% Object file: /Users/proctor/tmp/fizzbuzz.beam</div><div class="line">% Exports:</div><div class="line">%          fizzbuzz/1</div><div class="line">%          module_info/0</div><div class="line">%          module_info/1</div><div class="line">% ok</div></pre></td></tr></table></figure>
<p>c:m(fizzubzz)的输出显示fizzbuzz被编译了，并且是从我的用户目录下的tmp目录装载的，同时还有一个导出函数fizzbuzz/1 和在每个模块都有的两个版本导出函数module_info。</p>
<p>今天讲的这个函数不是你每天都可能用的函数，不过了解它对你调试和检查你的erlang应用很有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-m-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-m-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – c:xm/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-c-xm-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 <a href="http://erlang.org/doc/man/c.html#xm-1" target="_blank" rel="external">c:xm/1</a>.</p>
<p>c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。</p>
<a id="more"></a>
<p>首先让我们检查一下erlang模块，看看它是否有废弃的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c:xm(erlang).</div><div class="line"><span class="comment">% [&#123;deprecated,[]&#125;,&#123;undefined,[]&#125;,&#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是没有调用废弃的函数，没有未定义的函数，也没有未被使用的函数在erlang模块里。注：上述结果我是在Erlang 17.3.4 下得到的，根据你使用不同的erlang版本，你可能得到不一样的结果，因为 erlang:now/0 在18.0版本里已经是废弃的函数。（译者注：这句话有点费解，官网对 c:xm/1 对解析是：This function finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1. ）</p>
<p>为了找到符合这样标准的现存模块，我查看 Erlang 17.0 的 <a href="http://erlang.org/download/otp_src_17.0.readme" target="_blank" rel="external">README</a> 来搜索 deprecated 这个词。 找到如下这句：</p>
<p>pg 模块已经废弃，它将在Erlang/OTP 18中被删除。</p>
<p>那么让我们把这个模块名传给 c:xm/1 看看有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c:xm(pg).</div><div class="line"><span class="comment">% [&#123;deprecated,[&#123;&#123;pg,create,1&#125;,&#123;pg,master,1&#125;&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;pg,create,2&#125;,&#123;pg,master,1&#125;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;undefined,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>我们可以看到我们得到了pg模块里有关废弃的函数信息。</p>
<p>虽然你在日常工作中需要使用这个函数的几率很低，因为erlang相关的工具通常都非常注意这些方面，这足够引起人们的好奇，看起来调用这个函数似乎很值得，尤其如果那个时间Erlang代码的编译是Erlang内部完成的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-xm-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-xm-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:is_subset/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#is_subset-2" target="_blank" rel="external">ordsets:is_subset/2</a>.</p>
<p>ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">10</span>)).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">SetB = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)).</div><div class="line"><span class="comment">% [2,4,6,8,10]</span></div><div class="line">SetC = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>)).</div><div class="line"><span class="comment">% [1,4,7,10,13]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:is_subset(SetB, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetB).</div><div class="line"><span class="comment">% false</span></div><div class="line">ordsets:is_subset(SetC, SetA).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>有几个事实要跟不熟悉集合理论的同学讲讲。首先，空集合是所有集合的子集；其次，一个集合是它自己的子集；最后，如果集合B是集合A的超集，则集合A是集合B的子集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ordsets:is_subset(EmptySet, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetB).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetC).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, EmptySet).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetA).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:subtract/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-subtract-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#subtract-2" target="_blank" rel="external">ordsets:subtract/2</a>.</p>
<p>ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">OrderedSetA = ordsets:from_list([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">OrderedSetB = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">OrderedSetC = ordsets:from_list([<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">16</span>, -<span class="number">16</span>]).</div><div class="line"><span class="comment">% [-16,-4,-2,2,4,16]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetA, OrderedSetB).</div><div class="line"><span class="comment">% [4]</span></div><div class="line">ordsets:subtract(OrderedSetA, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">ordsets:subtract(OrderedSetB, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">ordsets:subtract(EmptySet, OrderedSetA).</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetB, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5,8,13]</span></div></pre></td></tr></table></figure>
<p>请注意，ordsets:subtract/2 的入参顺序是不可换的，这一点和 ordsets:union/2 或者 ordsets:intersection/2 不一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:subtract(OrderedSetA, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">ordsets:subtract(OrderedSetC, OrderedSetA).</div><div class="line"><span class="comment">% [-16,-4,-2,16]</span></div></pre></td></tr></table></figure>
<p>如果你不是一直跟读Erlang Thursday的话，我再次友情提醒你，虽然Erlang用列表来表示有序集合，但是并不意味着列表是有序集合。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday Bonus! Performace of erlang:length/1 on a list]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</url>
      <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday福利。</p>
<p>上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：</p>
<p>有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？</p>
<a id="more"></a>
<p>我可以百分之九九确定Erlang必须每次都要遍历列表来计算其长度，因为它用链接列表类的数据结构来构造它的列表，但是我不确定是否有一些聪明的实现方法是我没有意识到，这些方法能提高获取列表长度到速度。</p>
<p>在写今天的Erlang Thursday的时候，我意识到，我应该用 timer:tc 函数，通过它来展示需要多长时间来获取不同列表的长度来证明 erlang:length/1 函数的执行情况。</p>
<p>为了纪念这个问题，也为了在下一次会议的时候能回忆其它，我在这里记录相关内容。我们要明白，timer:tc 函数返回的结果里第一个元素是被测量函数执行的微秒时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10</span>)]).</div><div class="line">&#123;<span class="number">2</span>,<span class="number">10</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000</span>)]).</div><div class="line">&#123;<span class="number">5</span>,<span class="number">1000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000</span>)]).</div><div class="line">&#123;<span class="number">41</span>,<span class="number">10000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000</span>)]).</div><div class="line">&#123;<span class="number">134</span>,<span class="number">100000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>)]).</div><div class="line">&#123;<span class="number">1918</span>,<span class="number">1000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000000</span>)]).</div><div class="line">&#123;<span class="number">25139</span>,<span class="number">10000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000000</span>)]).</div><div class="line">&#123;<span class="number">1368691</span>,<span class="number">100000000</span>&#125;</div></pre></td></tr></table></figure>
<p>在链接列表有大概1000元素以后，我们可以看到计算其长度的时间线性增长，尽管不是真正对所有节点做遍历，但是在算法复杂度（大O）上看是相同复杂度级别。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:intersection/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-intersection-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看ordsets模块并且讲讲 <a href="http://erlang.org/doc/man/ordsets.html#intersection-2" target="_blank" rel="external">ordsets:intersection/2</a> 。</p>
<p>ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OrderedSet1 = ordsets:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>]</div><div class="line">OrderedSet2 = ordsets:from_list([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet1, OrderedSet2).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet2, OrderedSet1).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>因为 ordsets:intersection/2 在集合中找共同的元素，就向上面的例子一样，入参的顺序是可以交换的，不管两个入参的有序集合的参数顺序如何，我们得到的结果是一样的。</p>
<p>如果没有共同的元素，则结果是一个空的有序集合（其实就是一个空列表，上周的文章 <a href="http://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">ordsets:union/2</a> 里强调了用一个列表来当做一个有序集合是危险的）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Evens = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</div><div class="line">Odds = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>]</div><div class="line">ordsets:intersection(OrderedSet2, ordsets:new()).</div><div class="line">[]</div><div class="line">ordsets:intersection(Evens, Odds).</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>Erlang也提供了 <a href="http://erlang.org/doc/man/ordsets.html#intersection-1" target="_blank" rel="external">ordsets:intersection/1</a> 函数，它的入参是一个由多个有序集合为元素组成的列表，它返回的结果是列表里所有的有序集合的交集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">OrderedSet3 = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</div><div class="line">ordsets:intersection([Evens, Odds, OrderedSet1]).</div><div class="line">[]</div><div class="line">ordsets:intersection([Odds, OrderedSet2, OrderedSet1]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection([Evens, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">2</span>]</div><div class="line">ordsets:intersection([Odds, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – ordsets:union/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-ordsets-union-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#union-2" target="_blank" rel="external">ordsets:union/2</a> 。</p>
<p>ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">SetB = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">SetC = ordsets:from_list([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]).</div><div class="line"><span class="comment">% [1,3,4,5,9]</span></div><div class="line">SetD = ordsets:from_list([a, b, c, d, e]).</div><div class="line"><span class="comment">% [a,b,c,d,e]</span></div><div class="line">UnionAB = ordsets:union(SetA, SetB).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">UnionAC = ordsets:union(SetA, SetC).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div></pre></td></tr></table></figure>
<p>因为Erlang里的字符串实际上是字符列表，我们可以从字符串产生有序集合，然后通过这个函数得到两个字符串里不重复的字符并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:from_list(<span class="string">"Kermit"</span>).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list([<span class="number">75</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">116</span>]).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list(<span class="string">"Mississippi"</span>).</div><div class="line"><span class="comment">% "Mips"</span></div><div class="line">ordsets:union(ordsets:from_list(<span class="string">"Kermit"</span>), ordsets:from_list(<span class="string">"Mississippi"</span>)).</div><div class="line"><span class="comment">% "KMeimprst"</span></div></pre></td></tr></table></figure>
<p>ordsets模块也包含 <a href="http://erlang.org/doc/man/ordsets.html#union-1" target="_blank" rel="external">ordsets:union/1</a> ，它的入参是一个由有序集合组成的列表，它返回的是列表里所有有序集合的并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UnionAC = ordsets:union([SetA, SetC]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABC = ordsets:union([SetB, SetC, SetA]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABCD = ordsets:union([SetB, SetC, SetA, SetD]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9,a,b,c,d,e]</span></div><div class="line">UnionCD = ordsets:union([SetC, SetD]).</div><div class="line"><span class="comment">% [1,3,4,5,9,a,b,c,d,e]</span></div></pre></td></tr></table></figure>
<p>警告：有序集合的表现形式虽然只是一个列表，但是如果你传递一个普通列表给 ordsets:union/2 ，你将得不到你预期的结果，因为这个函数要求每个有序集合里的元素是真正的有序并且是一个集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c,1]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-union-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thrusday – queue:out/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thrusday-queue-out-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的的是queue模块原生API中的  <a href="http://erlang.org/doc/man/queue.html#out-1" target="_blank" rel="external">queue:out/1</a> 函数。</p>
<p>queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。</p>
<a id="more"></a>
<p>“是什么让这个函数这么厉害？”，你可能会这么问我。</p>
<p>这应该是这个函数由元组、标签元组组成，它的不可变性，它的宽容性，以及我们最终看到它返回结果的事实，所有这些使得我希望更多的队列实现都有像这样的一个API。</p>
<p>首先应该由很多次我自己或别人的过往经历中，在尝试弹出队列第一个元素的时候忘了检查这个队列是否是空的，从而造成一个很不友好的运行时错误。</p>
<p>queue:out/1 恰恰相反，当你给它的入参是一个空队列的时候，它并不触发一个错误，而是返回一个标签元组来告诉你，你传入的队列是空的，另外它还返回一个空队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:out(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们的入参是一个非空队列，queue:out/1 返回一个两元素元组。第一个元素是一个标签元组，它告诉我们，我们得到了一个值以及入参队列的头部元素，第二个元素，我们得到了入参队列移除头部元素后剩下的元素组成的队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([a, b, c, d]).</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">&#123;&#123;value, Head&#125;, NewQueue&#125; = queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">Head.</div><div class="line"><span class="comment">% a</span></div><div class="line">NewQueue.</div><div class="line"><span class="comment">% &#123;[d],[b,c]&#125;</span></div><div class="line">queue:head(NewQueue).</div><div class="line"><span class="comment">% b</span></div></pre></td></tr></table></figure>
<p>当我们在跨语言条件下谈论队列的理论上的概念时，“pop”这个概念做了两个事情，返回队列的头部元素，同时修改队列将其头部元素删除。</p>
<p>由于Erlang的队列是不可改变的，那么你仔细想想几分钟，你就会感觉到 queue:out/1 这个函数的妙处了，它也做了“pop”概念中的两件事情，就是返回队列头部，同时返回一个删除了头部元素的新的队列。</p>
<p>Erlang的queue模块也提供了函数 <a href="http://erlang.org/doc/man/queue.html#out_r-1" target="_blank" rel="external">queue:out_r/1</a> ，它的行为和 queue:out/1 基本一样，不一样的是它操作的是队列的尾部元素而不是队列的头部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:out_r(queue:from_list([a, b, c, d])).</div><div class="line"><span class="comment">% &#123;&#123;value,d&#125;,&#123;,[a,b]&#125;&#125;</span></div><div class="line">queue:out_r(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我希望你和我一样发现 queue:out/1 方便好用。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thrusday-queue-out-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thrusday-queue-out-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:split/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-queue-split-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲queue模块的原生API：<a href="http://erlang.org/doc/man/queue.html#split-2" target="_blank" rel="external">queue:split/2</a> 。</p>
<p>queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([a, <span class="number">1</span>, b, <span class="number">2</span>, c, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:split(<span class="number">4</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[2],[a,1,b]&#125;,&#123;[4,3],&#125;&#125;</span></div><div class="line">queue:split(<span class="number">0</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[]&#125;,&#123;[4,3,c],[a,1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">1</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[a]&#125;,&#123;[4,3,c],[1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">7</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[4,3,c],[a,1,b,2]&#125;,&#123;[],[]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">15</span>, QueueOne).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:split/2</span></div><div class="line"><span class="comment">%         called as queue:split(15,&#123;[4,3,c],[a,1,b,2]&#125;)</span></div><div class="line">&#123;SplitFirst, SplitSecond&#125; = queue:split(<span class="number">3</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[b,1],[a]&#125;,&#123;[4,3,c],[2]&#125;&#125;</span></div><div class="line">SplitFirst.</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">SplitSecond.</div><div class="line"><span class="comment">% &#123;[4,3,c],[2]&#125;</span></div><div class="line">queue:peek(SplitFirst).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(SplitSecond).</div><div class="line"><span class="comment">% &#123;value,2&#125;</span></div></pre></td></tr></table></figure>
<p>Erlang也提供一个 <a href="http://erlang.org/doc/man/queue.html#join-2" target="_blank" rel="external">queue:join/2</a> 函数，它有两个入参，入参类型都是队列，函数返回值是一个新的队列，新队列是由第二个入参队列添加到第一个入参队列后面形成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:join(SplitFirst, SplitSecond).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:join(SplitSecond, SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[2,c,3,4,a]&#125;</span></div><div class="line">queue:join(queue:new(), SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">queue:join(queue:new(), queue:new()).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-split-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-split-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:peek/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-queue-peek-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 <a href="http://erlang.org/doc/man/queue.html#peek-1" target="_blank" rel="external">queue:peek/1</a> 。</p>
<p>queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:peek(QueueOne).</div><div class="line"><span class="comment">% &#123;value,1&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>queue:peek/1 绝对不会修改入参队列，所以我们可以再一次调用上述例子，或者像下面例子一样多次调用，而我们的入参队列不会被修改。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueTwo = queue:from_list([a, b, c, d, e, f]).</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div></pre></td></tr></table></figure>
<p>不像上一篇文章里我们看到的 <a href="http://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">queue:head/1</a> ，我们可以安全地在入参队列为空的情况下调用 queue:peek/1 函数，而不是获得一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:head/1</span></div><div class="line"><span class="comment">%         called as queue:head(&#123;[],[]&#125;)</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>Erlang的 queue 模块也包含函数 <a href="http://erlang.org/doc/man/queue.html#peek_r-1" target="_blank" rel="external">queue:peek_r/1</a> ，它返回入参队列的尾部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">queue:peek_r(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,f&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue.</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-peek-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-peek-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:tail/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/18/erlang-thursday-queue-tail-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 <a href="http://erlang.org/doc/man/queue.html#tail-1" target="_blank" rel="external">queue:tail/1</a>.</p>
<p>queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">Tail = queue:tail(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Tail).</div><div class="line"><span class="comment">% 2</span></div><div class="line">queue:to_list(Tail).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>我们可以看到上述调用 queue:tail/1 的例子不像其它语言一样是一个破坏性操作，它完全保留了原始的入参队列的完整性。</p>
<p>做为将一个队列做为双端来处理的Okasaki API的一部分，queue:tail/1 有一个对应的函数 <a href="http://erlang.org/doc/man/queue.html#liat-1" target="_blank" rel="external">queue:liat/1</a> ，这个函数返回移除入参队列的最后一个元素后形成的新队列。queue:liat/1 也有一个别名函数，就是Okasaki API的 <a href="http://erlang.org/doc/man/queue.html#init-1" target="_blank" rel="external">queue:init/1</a>.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:liat(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">queue:init(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Erlang官方文档也指出有一个别名函数 queue:lait/1 ，大家最好不要用它，因为它的拼写是错误的。</p>
<p>因为我们是要深入细节然后看看我们能学到什么，那么让我们一起来到目前为止我们接触到的不同的tail函数在接收一个空队列为入参会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:tail(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop/1</span></div><div class="line"><span class="comment">%         called as queue:drop(&#123;[],[]&#125;)</span></div><div class="line">queue:liat(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div><div class="line">queue:init(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>当我们分别调用 <a href="http://erlang.org/doc/man/queue.html#drop-1" target="_blank" rel="external">queue:tail/1</a> 和 <a href="http://erlang.org/doc/man/queue.html#drop_r-1" target="_blank" rel="external">queue:liat/1</a> 的时候，看起来像我们在调用 queue:drop/1 和 queue:drop_r/1 得到的异常错误一样。</p>
<p>当我们用一个有若干元素的队列做为入参来调用 queue:drop/1 和 queue:drop_r/1 ，然后看看的执行情况，看起来 queue:tail/1 就是 queue:drop/1 的别名函数，而 queue:list/1 和 queue:init/1 就是 queue:drop_r/1 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:drop(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">queue:drop_r(Queue).</div><div class="line">&#123;[<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-tail-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-tail-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:head/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-queue-head-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看<a href="http://erlang.org/doc/man/queue.html#head-1" target="_blank" rel="external">queue:head/1</a>.</p>
<p>queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Queue).</div><div class="line"><span class="comment">% 1</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>上述例子显示，queue:head/1 函数没有修改原来的队列，而仅是返回它的第一个元素。</p>
<p>因为 queue:head/1 仅仅是返回队列头部能找到的值，而且不是一个标签元组，如果我们尝试从一个空的队列获取它的头部元素则会抛出一个错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">%** exception error: empty</span></div><div class="line"><span class="comment">%     in function  queue:head/1</span></div><div class="line"><span class="comment">%        called as queue:head(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>为了安全起见，让我们不在一个空队列上运行该函数而造成抛出异常，queue模块也定义了一个函数 queue:is_empty/1 ，你可以用它来检查一个队列是否为空。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:is_empty(EmptyQueue).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>像 queue:cons/2 和Okazaki API的其它函数一样，模块里也有一个函数<a href="http://erlang.org/doc/man/queue.html#daeh-1" target="_blank" rel="external">queue:dash</a> （head单词倒过来写），它从队列获取最后一个元素，它也是 <a href="http://erlang.org/doc/man/queue.html#last-1" target="_blank" rel="external">queue:last/1</a> 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:daeh(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:last(Queue).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>如果你调用 queue:dash/1 和 queue:last/1 的时候用空队列做入参也会引起错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:daeh(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:last(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>如果我们仔细看 queue:dash/1 和 queue:last/1 引起的错误，我们看到这个错误来自扩展API的 queue:get_r/1 。如果我们仔细看 queue:get_r/1 的执行情况，他看起来像 queue:tail/1 和 queue:dash/1 ，而这两个函数真的仅是 <a href="http://erlang.org/doc/man/queue.html#get_r-1" target="_blank" rel="external">queue:get_r/1</a> 别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:get_r(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-head-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – queue:cons/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-queue-cons-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday我们稍微深入一下queue模块，我们讲讲来自Okazaki的API：<a href="http://www.erlang.org/doc/man/queue.html#cons-2" target="_blank" rel="external">queue:cons/2</a> 。</p>
<p>queue:cons/2 有两个入参，一个是元素，一个是队列，它执行后返回一个元素加在队列头部形成的新队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">7</span>, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[7]&#125;</span></div><div class="line">queue:cons(<span class="number">3</span>, queue:cons(<span class="number">7</span>, queue:new())).</div><div class="line"><span class="comment">% &#123;[7],[3]&#125;</span></div><div class="line">queue:cons(nil, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[nil]&#125;</span></div><div class="line">queue:cons(<span class="number">5</span>, queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>])).</div><div class="line"><span class="comment">% &#123;[21],[5,7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们传入一个列表给 queue:cons/2 ，我们看到它出错，表明它想要一个队列，而不会隐式地将一个列表转成一个队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:in_r/2</span></div><div class="line"><span class="comment">%         called as queue:in_r(5,[1,2,3,4])</span></div></pre></td></tr></table></figure>
<p>因为队列被设置成一个双端队列，Okasaki API 也提供了一个对应的函数 <a href="http://www.erlang.org/doc/man/queue.html#snoc-2" target="_blank" rel="external">queque:snoc/2</a> ，它将元素加在传入的队列的尾部。注意，queue:snoc/2 和 queue:cons/2 两个函数的两个入参的顺序也是相反的；queue:snoc/2 的第一个入参上一个队列，而要加在它尾部的元素做为第二个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:snoc(queue:new(), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:snoc(queue:new(), <span class="number">7</span>), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5,21],[7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-cons-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-cons-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – filelib:is_file/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-filelib-is-file-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/filelib.html#is_file-1" target="_blank" rel="external">filelib:is_file/1</a>.</p>
<p>filelib:is_file/1 入参是一个表示文件名的字符串，它根据这个文件名所指的是否是文件或目录而返回true或者false。</p>
<p>这个函数在你正在需要从一个配置文件读取内容并且在尝试处理前确认这个文件或目录是否存在的时候有用，以便你可以在退出前得到一个友好的错误信息而不仅是引起一个系统错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(<span class="string">"foo"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"junk"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tmp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tempmp"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"temp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/bin"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/var"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/vars"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"."</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">".."</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>filelib:is_file/1 的入参也可以是一个原子，或者甚至也可以是一个嵌套的列表来表示一个文件名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(foo).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(junk).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file([<span class="string">"/usr"</span>, ['/local', '/bin']]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:iso_week_number/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#iso_week_number-1" target="_blank" rel="external">calendar:iso_week_number/1</a>.</p>
<p>calendar:iso_week_number/1 接收一个日期元组做为入参，然后返回一个由年份和周数字组成的元组。年份是入参里的年份，而周数字是一个1到53的整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">04</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">19</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">03</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">18</span>&#125;</div></pre></td></tr></table></figure>
<p>如果我们拿本周做为一个例子，我们可以看到本周是从星期一（五月四日）开始，而前一个星期天（五月三日）是属于上一个星期的。</p>
<p>我们看到一月一日是这一年的第一周，这没什么奇怪，而2015年的十二月三十一日是这一年的第53周。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">1</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">53</span>&#125;</div></pre></td></tr></table></figure>
<p>一开始听到一年有53周我们会很惊讶，因为几乎每个人都认为一年只有52周，直到你意识到有些十二月三十一日有时候是处于一周的开始，所以造成了它处在第53周，而它仅仅是这周的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:is_leap_year/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#is_leap_year-1" target="_blank" rel="external">calendar:is_leap_year/1</a>.</p>
<p>calendar:is_leap_year/1 接收一个非负整数表示的年份，如果这个年份是闰年，则返回true，否则返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(<span class="number">2015</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2012</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">2017</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2000</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">1900</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">0</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>有了这个Erlang核心库的内置函数，意味着你不需要编写代码或者甚至不需要查找规则来记住如何判断某个年份到底是不是闰年。</p>
<p>如果你传递一个负数来表示年份，Erlang将抛出一个异常，因为没有一个函数分支能匹配用负数来表示的年份。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(-<span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-1) (calendar.erl, line 183)</span></div><div class="line">calendar:is_leap_year(-<span class="number">4</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-4) (calendar.erl, line 183)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:valid_date/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-valid-date-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#valid_date-3" target="_blank" rel="external">calendar:valid_date/3</a>.</p>
<p>本来这次我是想讲函数 calendar:time_difference/3 ，但是当我详细看了 <a href="http://www.erlang.org/doc/man/calendar.html" target="_blank" rel="external">calendar</a> 模块的官方文档后，发现文档里已经说这个函数被淘汰了，所以今天我讲 calendar:valid_date/3 。</p>
<a id="more"></a>
<p>calendar:valid_date/3 的入参分别是一个表示年份的整数、一个表示月份的整数以及一个表示日的整数。如果传入的日期是有效的，则 calendar:valid_date/3 返回原子true，如果传入的日期是无效的，则 calendar:valid_date/3 返回原子false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">30</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2012</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">17</span>, <span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>我们也可以快速地检查一下本篇文章发布的日期也是有效日期。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在让我们看看入参中有0或负整数情况会怎么样？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(-<span class="number">1</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, -<span class="number">7</span>, <span class="number">21</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">7</span>, -<span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>正如人们所希望的，除非你要经常处理公元前的日期，不然的话有一个负数的日期是无效的。</p>
<p>Erlang也提供了函数 calendar:valid_date/1 ，它的入参是由年、月、日三个整数组成的元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>&#125;).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:date_to_gregorian_days/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-date-to-gregorian-days-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#date_to_gregorian_days-3" target="_blank" rel="external">calendar:date_to_gregorian_days/3</a>.</p>
<p>正如我们上星期在 <a href="http://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">Erlang Thursday calendar:day_of_the_week/3</a> 中讲到的，当我们看到一些错误消息的时候，我们看到错误来自于 calendar:date_to_gregorian_days/3。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>在上星期那篇文章里我保证我们下次将深入了解 calendar:date_to_gregorian_days/3 ，所以现在让我们来完成这个任务。</p>
<p>calendar:date_to_gregorian_days/3 有三个入参，一个代表年份的非负整数，一个代表月份的从1到12的整数，一个代表某月第几日的从1到31的整数，该函数返回的值是从公元元年1月1日截止到入参日期的天数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 366</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 719528</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 730484</span></div></pre></td></tr></table></figure>
<p>还有一个只接收一个入参的版本 calendar:date_to_gregorian_days/1，它的入参是由年、月、日三个整数组成元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>&#125;).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 366</span></div></pre></td></tr></table></figure>
<p>如果我们传给 calendar:date_to_gregorian_days/1 无效的日期，我们就会在错误消息里看到它正在调用 calendar:date_to_gregorian_days/3 。所以它是一个不错的辅助函数，不破坏我们的模式匹配。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;).</div><div class="line">** exception error: no function clause matching calendar:date_to_gregorian_days(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>) (calendar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:day_of_the_week/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-day-of-the-week-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#day_of_the_week-3" target="_blank" rel="external">calendar:day_of_the_week/3</a>.</p>
<p>calendar:day_of_the_week/3 允许你传入年、月、日然后得到这个日子在一个星期里是第几天。</p>
<a id="more"></a>
<p>第一个入参表示年份而且必须是非负整数。第二个入参是月份而且必须是1到12的整数（包括1和12），它表示公历的12个月份，1表示1月份。最后一个入参是第几日，必须是1到31（包括1和31）的整数。</p>
<p>calendar:day_of_the_week/3 返回一个1到7（包括1和7）的整数值，1表示星期一，7表示星期日。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 1</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 5</span></div><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 6</span></div></pre></td></tr></table></figure>
<p>本篇文章的发布日期是2015年4月9日，把它传给 calendar:day_of_the_week/3 ，得到返回值是4，正好表示星期四，也就是本系列文章发布的日子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>).</div><div class="line"><span class="comment">% 4</span></div></pre></td></tr></table></figure>
<p>还有一个 calendar:day_of_the_week/1 函数，它和上面的函数功能和参数要求基本一样，只是它只接收一个入参，这个入参是由年、月、日组成的三元素元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>为了帮助大家认识 calendar:day_of_the_week/3 函数返回的错误消息，让我们看看，当我们给该函数传递无效日期，我们会得到什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>如果你仔细看这些错误消息，你会看到 calendar:day_of_the_week/3 调用了 calendar:date_to_gregorian_days/3 ，我们将在下个星期的Erlang Thursday来介绍它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thurday – lists:delete/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thurday-lists-delete-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#delete-2" target="_blank" rel="external">lists:delete/2</a> 。</p>
<p>lists:delete/2 接收一个Erlang term作为它的第一个入参，它将把该term从第二个入参－－一个列表里删除掉。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [8,7,6,5,4,3,2]</span></div><div class="line">lists:delete(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,5,8]</span></div><div class="line">lists:delete(<span class="number">72</span>, <span class="string">"Hello World!"</span>).</div><div class="line"><span class="comment">% "ello World!"</span></div><div class="line">lists:delete(d, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:delete(<span class="number">4</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:delete(&#123;b, <span class="number">2</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% [&#123;a,1&#125;,&#123;c,3&#125;]</span></div><div class="line">lists:delete([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]).</div><div class="line"><span class="comment">% [[4,5,6],[7,8,9]]</span></div></pre></td></tr></table></figure>
<p>注意：lists:delete/2 仅仅是将第一个在列表里发现的term删掉，而其他任何在列表里同样的term它不会删除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8]</span></div></pre></td></tr></table></figure>
<p>因为 lists:delete/2 是一个非常简单就能讲清楚用法的函数，这样这篇文章将可能非常短，所以我想在下面我们展示一下如何自己来写一个非常简单(1) 的 lists:delete/2 实现是非常值得的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>让我们一起看看我们的delete函数在被调用的时候是如何执行的？</p>
<p>my_lists:delete/2 是一个友好的API函数，它仅仅是调用一个“私有”函数（没有导出的函数）－－ delete/3，所以调用者不需要担心那个我们传递的已经检查了的一个空列表作为初始值的累加器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div></pre></td></tr></table></figure>
<p>delete/3函数的第一个分支用模式匹配来检查我们想要删除掉元素是否也是需要检查的列表的第一个元素。如果模式匹配成果，我们会看到第一个元素被删除！接着我们就能停止处理列表并返回的结果，而这个结果是由我们已经检查过的元素组成列表的反转列表和那些剩下的我们还没有检查的元素组成的列表一起构成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div></pre></td></tr></table></figure>
<p>第二个分支“知道”我们想删除掉元素和剩下的列表的第一个元素不匹配。它是怎么“知道”的？因为如果它们匹配，第一个分支将模式匹配成功而第二个分支将得不到执行的机会。因为我们找不到元素需要被删除，我们通过将元素加到被检查过的元素组成的列表头部，并且继续调用 delete/3 。我们通过在被检查过的元素组成的列表头部加上元素形成新的被检查过元素组成的列表的做法就是为什么我们在第一分支和第三分支需要反转被检查元素组成的列表的原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div></pre></td></tr></table></figure>
<p>第三个也是最后一个 delete/3 函数的分支已经搜索到列表的结尾并且没有发现相同的元素，所以我们只是将被检查过的元素组成的列表反转后返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>这就是你自己的简单(1)版 lists:delete/2 的实现。</p>
<p>1、简单的意思是因为这个版本没有进行性能优化，或者没有做彻底的是否完全符合 lists:delete/2 规范的测试。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-lists-delete-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-lists-delete-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erlang:list_to_atom/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-erlang-list-to-atom-1/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erlang.html#list_to_atom-1" target="_blank" rel="external">erlang:list_to_atom/1</a>.</p>
<p>erlang:list_to_atom/1 的入参是一个字符串，返回的是一个Erlang的原子。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>)</span>.</span></div><div class="line">% <span class="title">foo</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo"</span>)</span>.</div><div class="line">% <span class="title">'Foo'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo_bar"</span>)</span>.</div><div class="line">% <span class="title">'Foo_bar'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo_bar"</span>)</span>.</div><div class="line">% <span class="title">foo_bar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>++<span class="string">"bar"</span>)</span>.</div><div class="line">% <span class="title">foobar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Erlang"</span>)</span>.</div><div class="line">% <span class="title">'Erlang'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Elixir"</span>)</span>.</div><div class="line">% <span class="title">'Elixir'</span></div></pre></td></tr></table></figure>
<p>这个函数在你必须要基于从外部系统读到的字符串，比如解析一个CSV类型的头部，生成键或标识符的时候有用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> erlang:list_to_atom/<span class="number">1</span>,      	     string:tokens(<span class="string">"firstName,lastName,age,gender,preferredName,dateOfBirth"</span>, <span class="string">","</span>)).</div><div class="line"><span class="comment">% [firstName,lastName,age,gender,preferredName,dateOfBirth]</span></div></pre></td></tr></table></figure>
<p>当你用 erlang:list_to_atom/1 将从外部系统获取的字符串转换成原子的时候一定要小心，因为它只能处理值为256以下的字符。任何字符值在256（注1）以下的字符串都能正常地用该函数转成一个原子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">list_to_atom("Joe, Mike, and Robert").</div><div class="line">% 'Joe, Mike, and Robert'</div><div class="line">list_to_atom("it's").</div><div class="line">% 'it's'</div><div class="line">list_to_atom("heyn").</div><div class="line">% 'heyn'</div><div class="line">list_to_atom("with_supported_char"++[255]).</div><div class="line">% with_supported_charÿ</div><div class="line">list_to_atom("with_non_supported_char"++[256]).</div><div class="line">% ** exception error: bad argument</div><div class="line">%      in function  list_to_atom/1</div><div class="line">%         called as list_to_atom([119,105,116,104,95,110,111,110,95,115,117,112,112,111,114,</div><div class="line">%                                 116,101,100,95,99,104,97,114,256])</div></pre></td></tr></table></figure>
<p>1、字符值必须是非负整数，范围是0到255。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thurday – ordsets:is_disjoint/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thurday-ordsets-is-disjoint-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/ordsets.html#is_disjoint-2" target="_blank" rel="external">ordsets:is_disjoint/2</a>.</p>
<p>在日常的编码中，你应该会碰到这样的问题，如何判断一个给定的列表，它的元素不在另一个列表里出现。</p>
<a id="more"></a>
<p>你的第一个直觉可能写出的代码像如下这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">not</span><span class="params">( lists:any(<span class="keyword">fun</span>(Item) -&gt; lists:member(Item, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]) <span class="keyword">end</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span>.</span></div><div class="line">% <span class="title">true</span></div></pre></td></tr></table></figure>
<p>如果你更多地在数学的范畴里定义你的问题，你可以从集合方向上开始思考，那么这个问题会更清晰。当你开始在集合的方向上思考，你会意识到你可以检查两个集合的交集是否是空集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ordsets:intersection([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]) =:= [].</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这样不仅更加简洁，而且更加明确你需要检查的是什么。</p>
<p>实际上，当你通过判断两个列表是否是不相交的，你可以做的更好。下面我们开始看看 ordsets:is_disjoint/2 。</p>
<p>ordsets:is_disjoint/2 接收两个列表做为入参，当两个列表没有共同的元素的时候函数返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>因为 ordsets:is_disjoint/2 是对两个列表进行判断，所以我们没必要先调用所谓的 ordsets:disjoint/2 来确定列表元素是唯一的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>如果任何一个入参是空列表，则 ordsets:is_disjoint/2 返回的结果都是说这两个列表是不相交的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([], []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>另外，如果你很好奇，想看看用 timer:tc/3 来测量 ordsets:is_disjoint/2 的运行时间，那么我们可以看到，只要 Erlang 知道了两个列表是不相交的，它就立马返回false，如果你记得我们前面的文章 <a href="http://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">Erlang Thursday on timer:tc/3</a> ，你就知道它的返回值是一个元组，元组的第一个元素就是代表被测量函数运行时间，其单位是微秒。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(ordsets, is_disjoint, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>), lists:seq(<span class="number">2000000</span>, <span class="number">3000000</span>)]).</div><div class="line"><span class="comment">% &#123;19032,true&#125;</span></div><div class="line">timer:tc(ordsets, is_disjoint, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>), lists:seq(<span class="number">1</span>, <span class="number">3000000</span>)]).</div><div class="line"><span class="comment">% &#123;2,false&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-ordsets-is_disjoint-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-ordsets-is_disjoint-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:flatmap/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-lists-flatmap-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#flatmap-2" target="_blank" rel="external">lists:flatmap/2</a>.</p>
<p>选择这个函数来讲是因为这个星期早些时候我做的一些 <a href="http://elixir-lang.org/" target="_blank" rel="external">Elixir</a> 练习，在这些练习中我使用 Enum.flat_map/2 函数而它却不是像我期待的那样起作用，这个情况让我很困惑。</p>
<a id="more"></a>
<p>于是我回到Erlang来研究 lists:flatmap/2 的执行情况，然后在完全了解了该函数在Erlang里没有正确执行的原因后，我终于明白了这个函数的运行模式，同时我也意识到原来我对这个函数有错误的认识，所以是时候回来说清楚 lists:flatmap/2 实际上做了些什么。</p>
<p>不知何故，我曾误以为 lists:flatmap/2 就是接收一个任意嵌套深度的列表做为入参，并将他们的扁平化后每个元素都应用在map函数上，就相当于下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X * X <span class="keyword">end</span>, lists:flatten([<span class="number">1</span>, [[<span class="number">2</span>, [<span class="number">3</span>]], <span class="number">4</span>]])).</div><div class="line"><span class="comment">% [1,4,9,16]</span></div></pre></td></tr></table></figure>
<p>即使更近一步阅读 Ruby 文档，甚至在尝试 Ruby 的 flat_map 函数后，很显然我依然完全不理解它上如何工作的，所以是时候仔细阅读 Erlang 文档了。</p>
<p>Erlang文档说明 lists:flatmap/2 第一个入参是一个函数，这个入参函数接收一个类型A的元素然后返回一个由类型B的元素组成的列表；lists:flatmap/2 的第二个入参是一个由类型A的元素组成的列表。</p>
<p>我已经困惑于它到底是如何工作的，而且文档也没说明，直到我看到文档的一部分描述了 lists:flatmap/2 的工作原理入下面的定义一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">flatmap</span><span class="params">(Fun, List1)</span> -&gt;</span></div><div class="line">    append(map(Fun, List1)).</div></pre></td></tr></table></figure>
<p>这个定义一下子让我明白了 lists:flatmap/2 到底是如何执行的。以前在我的脑海里，我认为首先是扁平化列表，然后在将各个列表元素应用于map函数上，但是实际上，它首先将各个列表元素应用于map函数上，然后再简单地扁平化，而且仅仅是做了一个层级的扁平化。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lists:flatmap(<span class="keyword">fun</span>(&#123;Item, Count&#125;) -&gt;</div><div class="line">                  lists:duplicate(Count, Item)</div><div class="line">              <span class="keyword">end</span>,</div><div class="line">              [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;'C', <span class="number">3</span>&#125;, &#123;'_d_', <span class="number">4</span>&#125;]).</div><div class="line"><span class="comment">% [a,b,b,'C','C','C','_d_','_d_','_d_','_d_']</span></div></pre></td></tr></table></figure>
<p>而如果我们将相同的数据先传给map函数，然后再将其结果传给append函数，我们会得到相同的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:append(</div><div class="line">    lists:map(<span class="keyword">fun</span>(&#123;Item, Count&#125;) -&gt;</div><div class="line">                  lists:duplicate(Count, Item)</div><div class="line">              <span class="keyword">end</span>,</div><div class="line">              [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;'C', <span class="number">3</span>&#125;, &#123;'_d_', <span class="number">4</span>&#125;])).</div><div class="line"><span class="comment">% [a,b,b,'C','C','C','_d_','_d_','_d_','_d_']</span></div></pre></td></tr></table></figure>
<p>同时我们更进一步了解到，lists:flatmap/2 甚至不将列表扁平化，而只是简单地将map函数返回的列表链接起来。如下面的例子，最后的结果仍然是一个嵌套的列表结构，而不是只有一个层级的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatmap(<span class="keyword">fun</span>(X) -&gt; [X, [X]] <span class="keyword">end</span>, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,[a],b,[b],c,,d,[d]]</span></div></pre></td></tr></table></figure>
<p>希望本文能让你不要陷入我曾经的困惑。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-flatmap-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-flatmap-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – calendar:local_time_to_universal_time_dst/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/17/erlang-thursday-calendar-local-time-to-universal-time-dst-1/</url>
      <content type="html"><![CDATA[<p>（译者注：本文里的例子结果在中国时区是不同的）</p>
<p>为了纪念本周末的时间变化，今天的 Erlang Thursday 要讲的函数是  <a href="http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time_dst-1" target="_blank" rel="external">calendar:local_time_to_universal_time_dst/1</a>.</p>
<a id="more"></a>
<p>为了更好地理解 calendar:local_time_to_universal_time_dst/1 是做什么的，我们将用它和 <a href="http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time-1" target="_blank" rel="external">calendar:local_time_to_universal_time/1</a> 进行比较。</p>
<p>即将到来的星期日我们将在临晨两点把时钟拨快一个小时，那么让我们来看看在临晨一点五十九分的时候UTC时间是多少？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">1</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,3,8&#125;,&#123;7,59,59&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>现在让我们看看当日临晨两点的时候 calendar:local_time_to_universal_time/1 返回的UTC时间是多少，实际上当日临晨两点我们根本没有到达过，因为我们直接将时间向前拨快了到临晨三点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,3,8&#125;,&#123;8,0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>但是当我们深入函数库里，我们看到也有另外一个函数 calendar:local_time_to_universal_time_dst/1. calendar:local_time_to_universal_time_dst/1 返回值是一个由时间元组组成的列表，让我们开始看看为什么这很重要。</p>
<p>此时，让我调用 calendar:local_time_to_universal_time_dst/1 并传入当日临晨两点作为参数，然后我们看到的结果是什么呢。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>一个空列表！</p>
<p>如果你花一点时间来想一想，这是有道理的，因为临晨两点根本就没发生过，所以就没有UTC时间和它对应上。</p>
<p>那么当我们跳到临晨三点我们看到什么呢？我们将得到早上八点UTC时间，这仅仅是在临晨一点五十九分五十九秒的一秒之后的UTC时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,3,8&#125;,&#123;8,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>为了涵盖本周末的情况，让我们来看看在今年晚些时候也就是11月1日将时钟拨慢一小时会发生什么。</p>
<p>从一个基准时间开始，让我们看看零点五十九分五十九秒（译者注：原文是12:59:59AM，应该是作者手误）是多少UTC时间，我们知道这个时间我们将仅遇到一次。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,11,1&#125;,&#123;5,59,59&#125;&#125;</span></div><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;5,59,59&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>而且即使时间的变化发生在临晨两点，我们仍然只是遇到一次，因为我们第一次直接移动到临晨一点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;8,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>所以零点五十九分五十九秒，我们得到UTC时间五点五十九分五十九秒，而两点，我们得到UTC时间是八点。现在到了棘手的部分，凌晨一点。</p>
<p>临晨一点是一个奇怪的场景，当日晚上我们将度过两个临晨一点。那么让我们看看Erlang在这种情况下做了什么。</p>
<p>首先，我们看看在临晨一点的时候我们调用 calendar:local_time_to_universal_time 得到的UTC时间是多少。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,11,1&#125;,&#123;6,0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我们得到UTC时间是六点。我们从UTC时间五点五十九分五十九秒移动到UTC时间六点；这是合理的，直到我们开始怀疑我们第二次遇到临晨一点。</p>
<p>现在，让我们看看在临晨一点的时候我们调用 calendar:local_time_to_universal_time_dst/1 会得到什么UTC时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;6,0,0&#125;&#125;,&#123;&#123;2015,11,1&#125;,&#123;7,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>我们得到由两个UTC时间组成的列表，一个是我们第一次遇到临晨一点时的UTC时间六点，另一个是我们第二次遇到临晨一点的UTC时间七点。这个返回两个UTC时间的情况也在临晨一点内的每秒钟出现。（译者注：原文是every time，译者认为应该是every second）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;6,59,59&#125;&#125;,&#123;&#123;2015,11,1&#125;,&#123;7,59,59&#125;&#125;]</span></div></pre></td></tr></table></figure>
<p>通过返回没有元素、一个元素或者两个元素的列表，Erlang提供给你最精确的信息为你所用，同时让你做出希望如何处理时间的明智的决定，而不是为你做出一些决定即使它们不符合你的系统需要。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-local_time_to_universal_time_dst-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-local_time_to_universal_time_dst-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – dict:merge/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-dict-merge-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/dict.html#merge-3" target="_blank" rel="external">dict:merge/3</a>.</p>
<p>dict:merge/3 有三个入参，第一个入参是一个合并函数，它在发生键冲突的时候被调用，第二和第三个入参都是字典。</p>
<a id="more"></a>
<p>合并函数用键作为第一个入参，第一个字典对应的值作为第二个入参，第二个字典来对于的值作为第三个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, Value2) -&gt; [Value1, Value2] <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x,5,7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div><div class="line"></div><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, Value2) -&gt; Value1 * Value2 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|35]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>传给dict:merge/3的合并函数仅在发生冲突的时候才被调用。如下代码例子，合并函数体里有一个exit的调用，只要合并函数备调用就将导致进程的结束。（译者注：此处的代码并没有触发合并函数的调用，因为两个字典没有相同的键）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, _Value1, _Value2) -&gt; exit(merge_happened) <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果你想让合并函数将第二个字典覆盖第一个字典，那么合并函数在出现键冲突的时候只需要返回第二个字典里的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, _Value1, Value2) -&gt; Value2 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果你想保持第一个字典里的所有键和值，仅仅是将那些不在第一个字典里而在第二个字典里的键和值加进来，合并函数只需要返回第一个字典的相关值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, _Value2) -&gt; Value1 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|5]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>另外，大家可以关注Erlang 17.0中引入的新数据类型Maps。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-dict-merge-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-dict-merge-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – string:join/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-string-join-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/string.html#join-2" target="_blank" rel="external">string:join/2</a>.</p>
<p>string:join/2 有两个入参，第一个是由字符串为元素组成的列表，第二个是一个当作分隔符的字符串，输出是由分隔符将各个字符串串起来组成的字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">91</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">""</span>).</div><div class="line"><span class="string">"abc"</span></div><div class="line"><span class="number">92</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"-"</span>).</div><div class="line"><span class="string">"a-b-c"</span></div></pre></td></tr></table></figure>
<p>分隔符字符串可以是任意长度的字符串，也不必仅仅是单个字符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">93</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"___"</span>).</div><div class="line"><span class="string">"a___b___c"</span></div><div class="line"><span class="number">94</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">" "</span>).</div><div class="line"><span class="string">"a b c"</span></div></pre></td></tr></table></figure>
<p>而且任何字符串，字符列表，或者甚至是整数列表，都可以用作分隔符字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], [$A]).</div><div class="line"><span class="string">"aAbAc"</span></div><div class="line">string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], [<span class="number">52</span>]).</div><div class="line"><span class="string">"a4b4c"</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-string-join-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-string-join-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – string:tokens/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-string-tokens-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是  <a href="http://www.erlang.org/doc/man/string.html#tokens-2" target="_blank" rel="external">string:tokens/2</a>.</p>
<p>string:tokens/2 第一个入参是一个字符串，第二入参是一个分割字符列表，返回值是被分割后的字符串列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"foo"</span>, <span class="string">""</span>).</div><div class="line"><span class="comment">% ["foo"]</span></div><div class="line">string:tokens(<span class="string">"banana"</span>, <span class="string">"a"</span>).</div><div class="line"><span class="comment">% ["b","n","n"]</span></div><div class="line">string:tokens(<span class="string">"It was the best of times, it was the worst of times"</span>, <span class="string">" "</span>).</div><div class="line"><span class="comment">% ["It","was","the","best","of","times,","it","was","the",</span></div><div class="line"><span class="comment">%  "worst","of","times"]</span></div></pre></td></tr></table></figure>
<p>当连续的分割字符出现在字符串里，它们将被当做一个分割字符，并且没有空字符串返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"s"</span>).</div><div class="line"><span class="comment">% ["Mi","i","ippi"]</span></div><div class="line"><span class="number">65</span>&gt; string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"sp"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"is"</span>).</div><div class="line"><span class="comment">% ["M","pp"]</span></div></pre></td></tr></table></figure>
<p>传个 string:tokens/2 的分割字符列表的字符顺序无关紧要，可以按任意顺序指定。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"ps"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div><div class="line"><span class="number">65</span>&gt; string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"sp"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div></pre></td></tr></table></figure>
<p>同时由于分隔符列表只是简单的一个分割字符串列表，我们可以不是传递一个字符串，而是把字符的整数值组成的列表当做一个列表传给函数，因为一个整数值的列表和字符串是一样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$s.</div><div class="line"><span class="comment">% 115</span></div><div class="line">$p.</div><div class="line"><span class="comment">% 112</span></div><div class="line">[<span class="number">115</span>, <span class="number">112</span>].</div><div class="line"><span class="comment">% "sp"</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, [<span class="number">115</span>]).</div><div class="line"><span class="comment">% ["Mi","i","ippi"]</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, [<span class="number">115</span>, <span class="number">112</span>]).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-string-tokens-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-string-tokens-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:dropwhile/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-lists-dropwhile-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#dropwhile-2" target="_blank" rel="external">lists:dropwhile/2</a> 。</p>
<p>lists:dropwhile/2 接收一个断言函数和一个列表作为入参并且返回一个列表。从入参列表第一个元素开始逐个代入断言函数，如果断言函数返回值为true，则拿掉该元素，当遇到第一个使得判断函数返回值为false的元素，则停止继续判断。剩下的元素组成的列表作为结果返回。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:dropwhile(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,4]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [-1,0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [-2,-1,0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]).</div><div class="line"><span class="comment">% [0,-1,-2,-3,-4,-5]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; <span class="literal">true</span> <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; <span class="literal">false</span> <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [hello,'World',foo,1,3,bar,4]</span></div></pre></td></tr></table></figure>
<p>不像 <a href="http://www.proctor-it.com/erlang-thursday-lists-filter-2" target="_blank" rel="external">lists:filter/2</a>，lists:dropwhile/2 在断言函数返回false的时候就立即停止检查入参列表。这就意味着那些代入断言函数将返回true的元素仍然可以出现在返回列表里，只要它们排在那个使得断言函数返回false的元素之后。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:dropwhile(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,bar,4]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="keyword">not</span> is_atom(X) <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,4]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% [0,1,-5,3,7]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt;= <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% [0,1,3,7]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-dropwhile-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-dropwhile-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:filter/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/16/erlang-thursday-lists-filter-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是  <a href="http://www.erlang.org/doc/man/lists.html#filter-2" target="_blank" rel="external">lists:filter/2</a>.</p>
<p>lists:filter/2有两个入参：一个断言函数和一个被遍历的列表。它的返回值是是一个列表，其元素是入参列表的元素应用于断言函数返回值是true的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> =:= <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, a, <span class="number">3</span>, &#123;a, b&#125;, 'World', foo]).</div><div class="line"><span class="comment">% [a,'World',foo]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">3</span>, foo, -<span class="number">13</span>, <span class="number">43</span>]).</div><div class="line"><span class="comment">% [1,foo,43]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="literal">false</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="literal">true</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-filter-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-filter-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – httpc:request/1 and httpc:request/4]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-httpc-request-1-and-httpc-request-4/</url>
      <content type="html"><![CDATA[<p>今天的 Erlang Thursday 讲的是 <a href="http://www.erlang.org/doc/man/httpc.html#request-1" target="_blank" rel="external">httpc:request/1</a> 和 <a href="http://www.erlang.org/doc/man/httpc.html#request-4" target="_blank" rel="external">httpc:request/4</a> 。httpc模块是erlang的HTTP1.1 客户端，request函数是erlang的功能强大的web请求工具。</p>
<p>要使用httpc模块，我们必需先确保 inets 已经启动。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inets:start().</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>httpc:requst/1 接收一个入参，就是一个RUL，它是一个erlang字符串，也就是你需要访问的地址。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(<span class="string">"http://www.example.com"</span>).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 02:57:06 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 02:57:06 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>httpc:request/1 和 httpc:request/4 功能是一样的， 相当于 httpc:request(get, {Url, []}, [], []) 这样被调用一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], []).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:04:31 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 03:04:31 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我们可以指定我们请求的头部内容。比如，我们想得到在瑞典的DuckDuckGo主页来纪念Erlang由由爱立信创建。为了实现这个功能，我们增加一个元组{“Accept-Language”, “sv”}到请求的头部列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://duckduckgo.com/"</span>, [&#123;<span class="string">"Accept-Language"</span>, <span class="string">"sv"</span>&#125;]&#125;, [], []).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=1"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"connection","keep-alive"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:19:29 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""54bfe2a8-1488""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","nginx"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","5256"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html; charset=UTF-8"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 22 Jan 2015 03:19:30 GMT"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!DOCTYPE html&gt;n&lt;!--[if IEMobile 7 ]&gt; &lt;html lang="sv_SE" class="no-js iem7"&gt; ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>httpc:request/4 的第三个入参是一个HTTP选项元组组成的列表。比如，你必需设置一个返回超时来避免从一个不可靠的或者一个不能及时返回的慢网站等待结果，请求代码需要回撤并稍后再尝试从而避免触发服务拒绝的攻击后果。下面的例子，我指定一个超时时间为0，单位是毫秒，来确保上述描述的目的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://erlang.org/"</span>, []&#125;, [&#123;timeout, <span class="number">0</span>&#125;], []).</div><div class="line">&#123;error,&#123;failed_connect,[&#123;to_address,&#123;<span class="string">"erlang.org"</span>,<span class="number">80</span>&#125;&#125;,</div><div class="line">                        &#123;inet,[inet],timeout&#125;]&#125;&#125;</div></pre></td></tr></table></figure>
<p>httpc:request/4 的最后一个入参是一个选项列表，它们是Erlang这端如何工作的选项。比如，你想异步请求，并在它完成后收到一条消息，这样你需要指定元组{sync, false}作为选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;ok, RequestId&#125; = httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], [&#123;sync, false&#125;]).</div><div class="line"><span class="comment">% &#123;ok,#Ref&lt;0.0.0.179&gt;&#125;</span></div><div class="line"><span class="keyword">receive</span> &#123;http, &#123;RequestId, Result&#125;&#125; -&gt; Result <span class="keyword">after</span> <span class="number">500</span> -&gt; error <span class="keyword">end</span>.</div><div class="line"><span class="comment">% &#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%  [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"date","Thu, 22 Jan 2015 03:08:41 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%   &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"expires","Thu, 29 Jan 2015 03:08:41 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%  &lt;&lt;"&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta "...&gt;&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>或者如果你想返回结果用Erlang二进制而不是Erlang字符串，你可以这么指定选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], [&#123;body_format, binary&#125;]).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:58:55 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 03:58:55 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      &lt;&lt;"&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta "...&gt;&gt;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>这篇文章仅仅是描述了你可以用httpc:request/4 来做一些很简单的事情。我强烈建议你阅读Erlang官方文档的<a href="http://www.erlang.org/doc/man/httpc.html" target="_blank" rel="external">httpc模块</a>部分。更多的例子和信息也可以阅读 <a href="http://www.erlang.org/doc/apps/inets/inets_services.html" target="_blank" rel="external">Erlang inets User Guide</a>，和 <a href="http://www.erlang.org/doc/apps/inets/http_client.html" target="_blank" rel="external">HTTP Client</a> 章节。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-httpc-request-1-and-httpc-request-4/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-httpc-request-1-and-httpc-request-4/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – erlang:apply/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-erlang-apply-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲 <a href="http://www.erlang.org/doc/man/erlang.html#apply-3" target="_blank" rel="external">erlang:apply/3</a>.</p>
<p>在函数式语言里，我们喜欢将函数当做第一等公民看待将它在程序中传递。但是有些时候，我们并不知道我们将要调用哪一个函数，从而导致我们不确定函数的参数是什么。如果我们知道要调用哪个函数，我们只需像这样 Fun(Arg1, Arg2, …, ArgN) 来调用，但是如果我们遇到有不同参数数量的场景就没法这么干了。怎么办？还是让我们进入今天的主题：erlang:apply/3 。</p>
<a id="more"></a>
<p>erlang:apply/3，三个入参分别是模块名、函数名、一个要传给函数的实参组成的列表。传给erlang:apply/3的函数必需也是被导出的，否则将有错误发生。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">erlang:apply(lists, max, [[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">1</span>]]).</div><div class="line"><span class="comment">% 11</span></div><div class="line">erlang:apply(lists, merge, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">erlang:apply(lists, merge, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div></pre></td></tr></table></figure>
<p>Erlang的官方文档特别指出，erlang:apply/3仅仅是在我们不完全清楚函数的参数数量的时候来使用。否则我们只需按平常的函数调用来做，即使以匿名函数的方式来传递。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">fun</span> lists:max/<span class="number">1</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>erlang模块也包括另一个版本 erlang:apply/2 ，第一个入参是一个函数，第二个人才是这个函数的实参的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erlang:apply(<span class="keyword">fun</span> lists:merge/<span class="number">2</span>, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div></pre></td></tr></table></figure>
<p>erlang:apply/2 和 erlang:apply/3 并不是我们的通常用法，它在一些特殊场合，它是必要的，比如上星期的 <a href="http://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">timer:tc</a> 。虽然我们将很少用到它，但是了解它对我们也有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-apply-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-apply-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - timer:tc/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-timer-tc-3/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday要讲的函数是 <a href="http://www.erlang.org/doc/man/timer.html#tc-3" target="_blank" rel="external">timer:tc/3</a>.</p>
<p>我相信我们所有人写测量目标代码执行耗时的代码都是先获取当前时间，接着执行目标代码，再获取当前时间，最后将前后两个时间的差作为目标代码的执行耗时。在Erlang里，按这种方式来写的话将像下面这样：</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Time1 = now().</div><div class="line"><span class="comment">% &#123;1420,519186,111375&#125;</span></div><div class="line">timer:sleep(<span class="number">4000</span>).  <span class="comment">% Do something</span></div><div class="line"><span class="comment">% ok</span></div><div class="line">Time2 = now().</div><div class="line"><span class="comment">% &#123;1420,519190,118280&#125;</span></div><div class="line">timer:now_diff(Time2, Time1).</div><div class="line"><span class="comment">% 4006905</span></div></pre></td></tr></table></figure>
<p>我们可以注意到这么一个现象：因为now()函数返回一个元组格式的时间戳，所以我们不能将两个元组相减来得到时间差，就像我们在其他语言里能够将两个时间相减；因此我们必需使用 <a href="http://www.erlang.org/doc/man/timer.html#now_diff-2" target="_blank" rel="external">timer:now_diff/2</a> 。</p>
<p>作为一个好的“工程师”，我们知道因为我们必需在应用的不同地方做一些事情，那么我们可以在一个地方创建我们自己的函数让这个函数去做这些事情。</p>
<p>难过的是（意思是我们不需要这么做了）：聪明的Erlang语言团队已经为我们做了这个事情并且以timer:tc/3这个函数的方式提供给我们用。</p>
<p>timer:tc/3接收模块名，函数名以及一个参数列表作为入参。因为我们通常要得到我们调用的函数的结果，另外还有时长，这个结果就是一个元组，其中第一个元素是时长，它的单位是微妙，另一个元素是传给timer:tc/3的第二个参数（它是一个函数）的执行结果。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(timer, sleep, [<span class="number">4000</span>]).</div><div class="line"><span class="comment">% &#123;4003097,ok&#125;</span></div><div class="line">timer:tc(lists, foldl, [<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)]).</div><div class="line"><span class="comment">% &#123;5099481,2000001000000&#125;</span></div></pre></td></tr></table></figure>
<p>另外还有timer:tc/1，它仅接收一个函数并执行它；还有timer:tc/2，它接收一个函数和一个入参列表，然后执行它。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(<span class="keyword">fun</span>() -&gt; lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% &#123;5709293,2000001000000&#125;</span></div><div class="line">timer:tc(<span class="keyword">fun</span> lists:foldl/<span class="number">3</span>, [<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)]).</div><div class="line"><span class="comment">% &#123;5766480,2000001000000&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-timer-tc-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:any/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-any-2/</url>
      <content type="html"><![CDATA[<p>今天的 Erlang Thursday 要讲的函数是 <a href="http://www.erlang.org/doc/man/lists.html#any-2" target="_blank" rel="external">lists:any/2</a>.</p>
<p>lists:any/2 接收一个断言函数作为第一个入参，一个将被遍历的列表作为第二个入参。如果这个断言函数对于任意一个给定列表的元素返回 true 的话lists:any/2 返回 true ，否则， lists:any/2 返回 false 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lists:any(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:any(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:any(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">3</span>, <span class="number">4</span>, a, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:any(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:any(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>lists:any/2 是个急性子，只要它发现某个元素使得断言函数返回true，它就立即返回true，并且忽略剩下的列表元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(lists, any, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;248410,false&#125;</span></div><div class="line">timer:tc(lists, any, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">0</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;13,true&#125;</span></div></pre></td></tr></table></figure>
<p>lists模块也包含 lists:all/2 函数，它和 lists:any/2 有点类似，不过它是通过断言函数检查每一个列表的元素，如果都返回true，则它就返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:all(<span class="keyword">fun</span> erlang:is_number/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:all(<span class="keyword">fun</span> erlang:is_number/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>lists:all/2 也是一个急性子，一旦某个列表元素使得断言函数返回false，它就立即返回false，并且忽略后续的列表元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(lists, all, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">0</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;235276,true&#125;</span></div><div class="line">timer:tc(lists, all, [<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, lists:seq(<span class="number">2</span>, <span class="number">200000</span>, <span class="number">2</span>)]).</div><div class="line"><span class="comment">% &#123;14,false&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-any-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-any-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:partition/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-partition-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#partition-2" target="_blank" rel="external">lists:partition/2</a>.</p>
<p>lists:partition/2 接收两个入参，第一个入参是一个断言函数，它将被调用对列表里的每个元素进行处理然后返回一个布尔值。第二个入参是一个将被分隔的列表。</p>
<p>lists:parition/2 返回一个两元素的元组，这个元组的第一个元素是一个列表，这个列表的元素是断言函数返回真值所对应的元素组成；元组第二个元素也是一个列表，它是断言函数返回false所对应的元素组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lists:partition(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% &#123;[1,3,5,7],[2,4,6]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span>(X) -&gt; X <span class="keyword">rem</span> <span class="number">3</span> == <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% &#123;[3,6],[1,2,4,5,7]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [a, <span class="number">1</span>, [b, c], 'B', <span class="keyword">fun</span> lists:sum/<span class="number">1</span>]).</div><div class="line"><span class="comment">% &#123;[a,'B'],[1,[b,c],#Fun&lt;lists.sum.1&gt;]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [a, <span class="number">1</span>, &#123;b, [z]&#125;, 'B', <span class="keyword">fun</span> lists:sum/<span class="number">1</span>]).</div><div class="line"><span class="comment">% &#123;[a,'B'],[1,&#123;b,[z]&#125;,#Fun&lt;lists.sum.1&gt;]&#125;</span></div><div class="line">lists:partition(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, []).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-partition-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-partition-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:zip/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-zip-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的函数是 <a href="http://www.erlang.org/doc/man/lists.html#zip-2" target="_blank" rel="external">lists:zip/2</a>.</p>
<p>lists:zip/2 返回一个由两元素元组组成的列表，其中两元素元组是由两个入参列表位置相对应的元素组成。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:zip([a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [&#123;a,1&#125;,&#123;b,2&#125;,&#123;c,3&#125;,&#123;d,4&#125;]</span></div><div class="line">lists:zip([a, b, c, d], [&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">3</span>, <span class="number">7</span>&#125;, &#123;<span class="number">4</span>, <span class="number">11</span>&#125;]).</div><div class="line"><span class="comment">% [&#123;a,&#123;1,3&#125;&#125;,&#123;b,&#123;2,5&#125;&#125;,&#123;c,&#123;3,7&#125;&#125;,&#123;d,&#123;4,11&#125;&#125;]</span></div><div class="line">lists:zip([a, b], [<span class="keyword">fun</span> lists:map/<span class="number">3</span>, <span class="keyword">fun</span> lists:foldl/<span class="number">3</span>]).</div><div class="line"><span class="comment">% [&#123;a,#Fun&lt;lists.map.3&gt;&#125;,&#123;b,#Fun&lt;lists.foldl.3&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>如果两个入参列表的长度不同，将抛出一个函数子句不匹配（function clause match）的异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:zip([a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:zip([d],[]) (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in function  lists:zip/2 (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in call from lists:zip/2 (lists.erl, line 385)</span></div><div class="line">lists:zip([a, b, c], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:zip([],[4]) (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in function  lists:zip/2 (lists.erl, line 385)</span></div><div class="line"><span class="comment">%      in call from lists:zip/2 (lists.erl, line 385)</span></div></pre></td></tr></table></figure>
<p>也有接收3个入参版本的zip函数：lists:zip3/3，它的功能和 lists:zip/2 一样，只是入参为3个列表而不是2个列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:zip3([a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">"alpha"</span>, <span class="string">"bravo"</span>, <span class="string">"charlie"</span>, <span class="string">"delta"</span>]).</div><div class="line"><span class="comment">% [&#123;a,1,"alpha"&#125;,&#123;b,2,"bravo"&#125;,&#123;c,3,"charlie"&#125;,&#123;d,4,"delta"&#125;]</span></div></pre></td></tr></table></figure>
<p>如果你想用不同的方式来组合列表中的元素，你可以用 <a href="http://www.erlang.org/doc/man/lists.html#zipwith-3" target="_blank" rel="external">lists:zipwith/3</a> 或者 <a href="http://www.erlang.org/doc/man/lists.html#zipwith3-4" target="_blank" rel="external">lists:zipwith3/4</a>，它们的第一个入参是一个接收两个入参的组合函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lists:zipwith(<span class="keyword">fun</span>(X, Y) -&gt; X * Y <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [2,6,12,20]</span></div><div class="line">lists:zipwith(<span class="keyword">fun</span>(X, Y) -&gt; X + Y <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [3,5,7,9]</span></div><div class="line">lists:zipwith3(<span class="keyword">fun</span>(X, Y, Z) -&gt; X * Y * Z <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [8,18,24,20]</span></div><div class="line">lists:zipwith3(<span class="keyword">fun</span>(X, Y, Z) -&gt; &#123;&#123;X, Y&#125;, Z&#125; <span class="keyword">end</span>, [a, b, c, d], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">"alpha"</span>, <span class="string">"bravo"</span>, <span class="string">"charlie"</span>, <span class="string">"delta"</span>]).</div><div class="line"><span class="comment">% [&#123;&#123;a,1&#125;,"alpha"&#125;,</span></div><div class="line"><span class="comment">%  &#123;&#123;b,2&#125;,"bravo"&#125;,</span></div><div class="line"><span class="comment">%  &#123;&#123;c,3&#125;,"charlie"&#125;,</span></div><div class="line"><span class="comment">%  &#123;&#123;d,4&#125;,"delta"&#125;]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-zip-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-zip-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:foldl/3 and lists:foldr/3]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-foldl-3-and-lists-foldr-3/</url>
      <content type="html"><![CDATA[<p>今天Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#foldl-3" target="_blank" rel="external">lists:foldl/3</a> 和 <a href="http://www.erlang.org/doc/man/lists.html#foldr-3" target="_blank" rel="external">lists:foldr/3</a> 。</p>
<p>lists:foldl/3 是Erlang版的 reduce 函数。 lists:foldl/3 接收三个入参：一个函数，一个初始的累加器，一个列表，输出一个单一的值。</p>
<a id="more"></a>
<p>foldl的第一个入参是一个接收两个参数的函数，一个是当前循环到的列表元素，另一个是积累的值。这个函数的输出值作为循环到下一个列表元素的时候的累加器，或者当循环结束的时候作为foldl函数的输出值。</p>
<p>foldl的第二个入参是一个累加器的初始值。与其他一些语言不同，在其他语言里这个累加器的初始值是可选的，而且常常是使用循环列表的第一个元素作为默认值，但是在Erlang里，累加器的初始值必需作为lists:foldl/3和lists:foldr/3两个函数的入参。</p>
<p>第三个入参，也就是最后一个入参是将被循环遍历的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Sum) -&gt; Sum + X <span class="keyword">end</span>, <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 15</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Product) -&gt; Product * X <span class="keyword">end</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 120</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]) <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 1 2 3 4 5 ok</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]), Accum <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 1 2 3 4 5 void</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; Accum + X <span class="keyword">end</span>, <span class="number">1</span>, []).</div><div class="line"><span class="comment">% 1</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Result) -&gt; lists:umerge(Result, X) <span class="keyword">end</span>, [], [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>], [<span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>]]).</div><div class="line"><span class="comment">% [1,2,3,5,8,11,13,17]</span></div></pre></td></tr></table></figure>
<p>在Erlang的lists模块里也包含foldr/3函数，它是从左到右（译者注：应该是从右到左，可能是作者手误）遍历列表或者说是从最后一个元素到第一个元素遍历列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:foldr(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]), Accum <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 5 4 3 2 1 void</span></div><div class="line">lists:foldr(<span class="keyword">fun</span>(X, Accum) -&gt; Accum + X <span class="keyword">end</span>, <span class="number">1</span>, []).</div><div class="line"><span class="comment">% 1</span></div></pre></td></tr></table></figure>
<p>Erlang文档里指出foldl/3通常比foldr/3更好，因为foldl/3是尾递归，而foldr/3不是。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday - lists:map/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-map-2/</url>
      <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是函数 <a href="http://www.erlang.org/doc/man/lists.html#map-2" target="_blank" rel="external">lists:map/2</a> 。</p>
<p>lists:map/2 接收两个入参，一个是接收一个入参的函数，我们称它为“mapping”函数，另一个是一个Erlang term组成的列表。lists:map/2 的结果是一个列表，这个列表是由入参的列表的每个元素应用于“mapping”函数得到结果组成的。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X + <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X * X <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,4,9,16]</span></div></pre></td></tr></table></figure>
<p>因为字符串在Erlang里就是整数列表，所以你也可以将map函数应用在字符串上。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X - <span class="number">1</span> <span class="keyword">end</span>, <span class="string">"IBM"</span>).</div><div class="line"><span class="comment">% "HAL"</span></div></pre></td></tr></table></figure>
<h1 id="Erlang里的函数"><a href="#Erlang里的函数" class="headerlink" title="Erlang里的函数"></a>Erlang里的函数</h1><p>如果你仔细观察上面第一个例子，你会发现第一个入参我们传递的是一个 fun(X) -&gt; X + 1 end. 这是Erlang的匿名函数的语法。 一个匿名函数的格式如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">fun</span><span class="params">(Args1)</span> O<span class="title">ptionalGuardClause1</span> -&gt;</span></div><div class="line">        Expression1, Expression2;</div><div class="line">   (Args2) OptionalGuardClause2 -&gt;</div><div class="line">        Expression3, Expression4;</div><div class="line">   (Args3) OptionalGuardClause3 -&gt;</div><div class="line">        Expression5, Expression6;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们可以像普通函数一样使用匿名函数，除了在17.0以前的版本不能递归调用一个匿名函数外，所以我们可以将一个有多个子句的匿名函数传给lists:map/2 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) <span class="keyword">when</span> is_atom(X) -&gt; atom; (X) -&gt; nil <span class="keyword">end</span>, [<span class="number">1</span>, x, &#123;x&#125;, [], 'B']).</div><div class="line">[nil,atom,nil,nil,atom]</div></pre></td></tr></table></figure>
<h1 id="传递命名函数给lists-map-2"><a href="#传递命名函数给lists-map-2" class="headerlink" title="传递命名函数给lists:map/2"></a>传递命名函数给lists:map/2</h1><p>虽然一些场合我们用匿名函数，但是更多时候为了清晰明了，我们还是想用命名函数。我们可以通过函数的限定名称方式来传递一个命名函数给lists:map/2，采用的格式是，在module:function_name/arity 前面加上 fun 。下面的例子用math:log10/1和erlang:is_atom/1两个函数来演示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> math:log10/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>]).</div><div class="line">[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>]</div><div class="line">lists:map(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, x, &#123;x&#125;, [], 'B']).</div><div class="line">[<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-map-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-map-2/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:flatten/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-flatten-1/</url>
      <content type="html"><![CDATA[<p>Erlang Thursday今天要讲的函数是 lists:flatten/1。</p>
<p>lists:flatten/1 函数将一个任意深度的由Erlang的term组成的列表展平为一个“扁平”的列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:flatten([]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:flatten([a, b, c]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:flatten([a, b, [<span class="number">1</span>, [x, y], <span class="number">3</span>], c]).</div><div class="line"><span class="comment">% [a,b,1,x,y,3,c]</span></div><div class="line">lists:flatten([a, b, [<span class="number">1</span>, [x, &#123;some, tuple&#125;], <span class="number">3</span>], c]).</div><div class="line"><span class="comment">% [a,b,1,x,&#123;some,tuple&#125;,3,c]</span></div></pre></td></tr></table></figure>
<p>注意！它会把所有的列表都展平，比如下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, <span class="string">"foo"</span>, b]).</div><div class="line"><span class="comment">% [a,102,111,111,b]</span></div></pre></td></tr></table></figure>
<p>上面的例子，你得到的结果有整数在列表里，因为字符串实际上在底层就是一个整数列表，所以你得到的是字符串“foo”里f和o的ASCII字符码。</p>
<p>如果你要保留字符串的格式，你必须使用二进制格式的字符串，如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, &lt;&lt;<span class="string">"foo"</span>&gt;&gt;, b]).</div><div class="line"><span class="comment">% [a,&lt;&lt;"foo"&gt;&gt;,b]</span></div></pre></td></tr></table></figure>
<p>作为一个奖励，还有一个lists:flatten/2 函数，它将一个列表展平，并且接收另外一个入参 Tail，这个入参将附加在展平列表的后面从而形成一个新的列表，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, [<span class="number">1</span>, [b, [<span class="number">2</span>]]]], [x, y, z]).</div><div class="line"><span class="comment">% [a,1,b,2,x,y,z]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-flatten-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-flatten-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:max/1]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-max-1/</url>
      <content type="html"><![CDATA[<p>今天我们来学习 lists:max/1。</p>
<p>lists:max/1 接收一个入参，这个入参是一个最少有一个元素的列表，并且它返回这个列表里最大值的元素。这个列表可以由任何Erlang term组成：</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="number">1</span>, <span class="number">39</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">27</span>, <span class="number">52</span>, <span class="number">16</span>]).</div><div class="line"><span class="comment">% 63</span></div><div class="line">lists:max([q, w, a, r, c, f, m, b]).</div><div class="line"><span class="comment">% w</span></div><div class="line">lists:max([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]]).</div><div class="line"><span class="comment">% [1,2,4]</span></div></pre></td></tr></table></figure>
<p>Erlang在不同类型的term之间有着截然不同的大小顺序，</p>
<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string<br>传给lists:max/1函数的列表可以由任意类型的term组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a]).</div><div class="line"><span class="comment">% a</span></div><div class="line">lists:max([<span class="number">1</span>, a, [foo, bar], &#123;baz&#125;]).</div><div class="line"><span class="comment">% [foo,bar]</span></div></pre></td></tr></table></figure>
<p>因为在Erlang中字符串实际上是数字列表，所以我们甚至可以比较字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"snafu"</span>]).</div><div class="line"><span class="string">"snafu"</span></div></pre></td></tr></table></figure>
<p>如果你传入一个空列表给lists:max/1函数，一个 “no function clause matching”的错误将产生，因为该函数需要一个至少有一个元素的列表作为入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:max([]).</div><div class="line">** exception error: no function clause matching lists:max([]) (lists.erl, line <span class="number">326</span>)</div></pre></td></tr></table></figure>
<p>请您告诉我在以后的Erlang Thursday系列文章里，哪些是您喜欢的Erlang函数，甚至只是你想看到的函数？</p>
<p>如果您想比较Erlang的max函数和Ruby的max方法，别忘了看看上周的Ruby Tuesday系列文章： <a href="http://www.proctor-it.com/ruby-tuesday-enumerable-max/" target="_blank" rel="external">Ruby Tuesday on Enumerable#max</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-max-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-max-1/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:seq]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-seq/</url>
      <content type="html"><![CDATA[<p>Erlang Thursday系列文章的下一个目标是详细描述那些与Ruby Tuesday系列文章里着重阐述的方法所相对应的Erlang函数。我希望通过每个星期与Ruby Tuesday配合的Erlang Thursday系列文章能使得读者渐渐不再对Erlang陌生；我也希望通过这种方式建立一个共同讨论的渠道来使得读者不再认为Erlang是令人生畏的一门语言。我很想知道您对我这个目标如何才能更好地让读者接受和理解的一些想法。<br><a id="more"></a><br>因为这周我在<a href="https://www.proctor-it.com/ruby-tuesday-ranges/" target="_blank" rel="external">Ruby Tuesday</a>里谈到了Ruby的Range方法，那么今天我要讲的Erlang函数就是lists:seq/2和lists:seq/3。</p>
<p>如果你还记得上周<a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">Erlang Thursday</a>里的Erlang扫盲小知识里讲到的，在函数名字后面的数字表示是这个函数的arity，也就是入参的个数。</p>
<p>函数 lists:seq/2 接受两个整数入参，一个表示起始整数，一个表示结束整数，它产生一个包括这两个入参的整数列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% [1]</span></div></pre></td></tr></table></figure>
<p>有三个入参的lists:seq函数引入一个增量作为第三个参数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).</div><div class="line"><span class="comment">% [1,4,7,10]</span></div></pre></td></tr></table></figure>
<p>这个增量值可以是负数，这样就允许从一个整数减少低至另一个整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">20</span>, <span class="number">10</span>, -<span class="number">1</span>).</div><div class="line"><span class="comment">% [20,19,18,17,16,15,14,13,12,11,10]</span></div><div class="line">lists:seq(<span class="number">20</span>, <span class="number">10</span>, -<span class="number">5</span>).</div><div class="line"><span class="comment">% [20,15,10]</span></div></pre></td></tr></table></figure>
<p>如果给了不合适的起始和结束入参，lists:seq 函数不像Rang Range那样返回一个空集合，它会抛出一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">10</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:seq(10,1) (lists.erl, line 241)</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div><div class="line">lists:seq(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-seq/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-seq/</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Erlang Thursday – lists:member/2]]></title>
      <url>http://szpzs.oschina.io/2016/09/15/erlang-thursday-lists-member-2/</url>
      <content type="html"><![CDATA[<p>为了和每周的 <a href="http://www.proctor-it.com/ruby-tuesday-enumerableinclude/" target="_blank" rel="external">Ruby Tuesday</a> 系列文章中关于Enumerable#include?函数来个跨界对比，我决定着重介绍 Erlang 中相同类型的函数，lists:member/2。</p>
<a id="more"></a>
<p>首先给不熟悉Erlang的同学们补充一下知识：lists:member/2 表达的意思是在lists模块里有个名字叫member的函数，它有两个参数。Arity这个词的意思表示这个函数接受的入参的个数。在Erlang中，模块很重要，因为它是所有函数赖以生存的容器－－另外也是因为模块在Erlang里是代码重新装载的单元－－为了重新载入某个方法的新版本，必需指定具体模块。</p>
<p>总而言之，模块lists的函数member接受两个入参：一个是被查找的元素，它是Erlang的一种由任意数据类型组成的数据，另一个是被检索的由Erlang的各种类型数据组成的列表；如果被查找的元素在列表里被找到，则返回true。一个Erlang的term是任意Erlang数据类型组成的数据。</p>
<p>为了方便大家运行，下面的表达式是通用的写法，返回值则加上了%符号，这个符号是Erlang注释符号，这样就方便大家直接拷贝下面的表达式然后复制到Erlang的shell上运行。</p>
<p>这个函数能够很方便地判断一个数字是否在一个由数字组成的列表里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:member(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:member(<span class="number">13</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>或者判断一个原子是否在一个由原子组成的列表里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:member(c, [a, b, c, d]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(q, [a, b, c, d]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>或者由更复杂的term组成的列表，比如元组，或者包含列表的元组：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:member(&#123;d, <span class="number">4</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;, &#123;d, <span class="number">4</span>&#125;]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(&#123;'Foo', [bar, baz]&#125;, [a, <span class="number">1</span>, &#123;'Foo', [bar, baz]&#125;]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(&#123;fu, [bar, baz]&#125;, [a, <span class="number">1</span>, &#123;'Foo', [bar, baz]&#125;]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>甚至是判断一个整数或字符是否在一个字符串里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:member($a, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(<span class="number">97</span>, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member($A, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>如果你仔细观察，你会发现，在Erlang里字符串实际上是由整数组成的列表。</p>
<p>希望这是一个有趣的Ruby和Erlang的比较；同时如果你对它不熟悉的话，能让你更了解Erlang。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-member/</a></p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
