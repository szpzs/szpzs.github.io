<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.github.io/"/>
  <updated>2016-09-19T13:37:23.000Z</updated>
  <id>http://szpzs.github.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang Thursday – user_default</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-user-default/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-user-default/</id>
    <published>2016-09-19T13:30:25.000Z</published>
    <updated>2016-09-19T13:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们来看看user_default模块。</p>
<p>我是在想验证当我在erl shell中调用 c/1 和 l/1 的函数的版本的时候偶然发现这个模块的，然后研究 <a href="http://www.erlang.org/doc/man/shell_default.html" target="_blank" rel="external">shell_default</a> 的文档。</p>
<a id="more"></a>
<p>文档中提到，如果我们想让一些函数在shell里直接可用，我们可以生成一个名字为user_default的模块，然后在自己的 .erlang 文件里指定该模块的路径，这样的话user_default模块里的导出函数就可以直接在shell里可用了。</p>
<p>既然我手上有一个 fizzbuzz 的例子，那么让我们开始按文档的说明生成一个user_default模块证明我们可以让它正常工作。我们将把它放在我们home目录的tmp目录里。</p>
<p>~/tmp/user_default.erl</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(user_default).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>在我们的home目录下新建一个 .erlang 文件，添加如下内容，指明我们刚刚创建的user_default文件的路径。</p>
<p>～/.erlang<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code:load_abs(<span class="string">"tmp/user_default"</span>).</div></pre></td></tr></table></figure></p>
<p>如果你已经有一个 .erlang 文件，那么在这个文件的第一行必须是 <a href="http://www.erlang.org/doc/man/code.html#load_abs-1" target="_blank" rel="external">code:load_abs/1</a> 函数，其参数为 user_default 模块。</p>
<p>确定上述两个文件都保存好了，然后打开erlang shell来尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line">** exception error: undefined shell command fizzbuzz/<span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>然而并没有像文档里讲的那样起作用。我意识到，我们用的是 load_abs 函数，并且 user_default 是一个新模块，这个错误可能是因为没有文件可装载。让我们用erlc编译这个模块，然后再尝试。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd tmp/</div><div class="line">$ erlc user_default.erl</div><div class="line">$ ls user_default.*</div><div class="line">user_default.beam user_default.erl</div><div class="line">$ cd ..</div></pre></td></tr></table></figure>
<p>我们现在有一个BEAM文件在~/tmp目录里，所以让我们再次启动Erlang shell并尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">Fizz</div><div class="line"><span class="number">4</span></div><div class="line">Buzz</div><div class="line">Fizz</div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Fizz</div><div class="line">Buzz</div><div class="line"><span class="number">11</span></div><div class="line">Fizz</div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">14</span></div><div class="line">FizzBuzz</div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">17</span></div><div class="line">Fizz</div><div class="line"><span class="number">19</span></div><div class="line">Buzz</div><div class="line">ok</div><div class="line"><span class="number">2</span>&gt;</div></pre></td></tr></table></figure>
<p>终于正常工作了！我们现在可以在shell里不需要指定模块名而直接调用 fizzbuzz/1 。</p>
<p>更多的关于 .erlang 文件的信息可以阅读 <a href="http://www.erlang.org/documentation/doc-5.1/doc/getting_started/getting_started.html#1.7" target="_blank" rel="external">Erlang中关于配置部分的文档</a> 。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-user_default/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-user_default/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们来看看user_default模块。&lt;/p&gt;
&lt;p&gt;我是在想验证当我在erl shell中调用 c/1 和 l/1 的函数的版本的时候偶然发现这个模块的，然后研究 &lt;a href=&quot;http://www.erlang.org/doc/man/shell_default.html&quot;&gt;shell_default&lt;/a&gt; 的文档。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="user_default" scheme="http://szpzs.github.io/categories/Erlang/user-default/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="user_default" scheme="http://szpzs.github.io/tags/user-default/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:i/0</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-c-i-0/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-c-i-0/</id>
    <published>2016-09-19T13:24:00.000Z</published>
    <updated>2016-09-19T13:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续讲c模块的另一个函数 <a href="http://erlang.org/doc/man/c.html#i-0" target="_blank" rel="external">c:i/0</a> 。</p>
<p>c:i/0 输出系统的信息，展示本节点的所有进程信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">c:i().</div><div class="line"><span class="comment">% Pid                   Initial Call                          Heap     Reds Msgs</span></div><div class="line"><span class="comment">% Registered            Current Function                     Stack</span></div><div class="line"><span class="comment">% &lt;0.0.0&gt;               otp_ring0:start/2                      987     4987    0</span></div><div class="line"><span class="comment">% init                  init:loop/1                              2</span></div><div class="line"><span class="comment">% &lt;0.3.0&gt;               erlang:apply/2                        6772   823443    0</span></div><div class="line"><span class="comment">% erl_prim_loader       erl_prim_loader:loop/3                   6</span></div><div class="line"><span class="comment">% &lt;0.6.0&gt;               gen_event:init_it/6                    376      220    0</span></div><div class="line"><span class="comment">% error_logger          gen_event:fetch_msg/5                    8</span></div><div class="line"><span class="comment">% &lt;0.7.0&gt;               erlang:apply/2                        1598      463    0</span></div><div class="line"><span class="comment">% application_controlle gen_server:loop/6                        7</span></div><div class="line"><span class="comment">% &lt;0.9.0&gt;               application_master:init/4              376       44    0</span></div><div class="line"><span class="comment">%                       application_master:main_loop/2           6</span></div><div class="line"><span class="comment">% &lt;0.10.0&gt;              application_master:start_it/4          233       69    0</span></div><div class="line"><span class="comment">%                       application_master:loop_it/4             5</span></div><div class="line"><span class="comment">% &lt;0.11.0&gt;              supervisor:kernel/1                   4185    49109    0</span></div><div class="line"><span class="comment">% kernel_sup            gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.12.0&gt;              rpc:init/1                             233       35    0</span></div><div class="line"><span class="comment">% rex                   gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.13.0&gt;              global:init/1                          233       51    0</span></div><div class="line"><span class="comment">% global_name_server    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.14.0&gt;              erlang:apply/2                         233       19    0</span></div><div class="line"><span class="comment">%                       global:loop_the_locker/1                 5</span></div><div class="line"><span class="comment">% &lt;0.15.0&gt;              erlang:apply/2                         233        3    0</span></div><div class="line"><span class="comment">%                       global:loop_the_registrar/0              2</span></div><div class="line"><span class="comment">% &lt;0.16.0&gt;              inet_db:init/1                         233      206    0</span></div><div class="line"><span class="comment">% inet_db               gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.17.0&gt;              global_group:init/1                    233       59    0</span></div><div class="line"><span class="comment">% global_group          gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.18.0&gt;              file_server:init/1                    2586     2562    0</span></div><div class="line"><span class="comment">% file_server_2         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.19.0&gt;              erlang:apply/2                        2586   155919    0</span></div><div class="line"><span class="comment">% code_server           code_server:loop/1                       3</span></div><div class="line"><span class="comment">% &lt;0.20.0&gt;              supervisor_bridge:standard_error/      233       41    0</span></div><div class="line"><span class="comment">% standard_error_sup    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.21.0&gt;              erlang:apply/2                         233        9    0</span></div><div class="line"><span class="comment">% standard_error        standard_error:server_loop/1             2</span></div><div class="line"><span class="comment">% &lt;0.22.0&gt;              supervisor_bridge:user_sup/1           610       87    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.23.0&gt;              erlang:apply/2                         233       24    0</span></div><div class="line"><span class="comment">% user                  user:server_loop/2                       5</span></div><div class="line"><span class="comment">% &lt;0.24.0&gt;              kernel_config:init/1                   233      286    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.25.0&gt;              supervisor:kernel/1                    233       58    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.29.0&gt;              kjell_profile:init/1                   987    27100    0</span></div><div class="line"><span class="comment">% kjell_profile         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.30.0&gt;              kjell_extension:init/1                2586     3903    0</span></div><div class="line"><span class="comment">% kjell_extension       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.45.0&gt;              k_user_drv:server/2                    987     2218    0</span></div><div class="line"><span class="comment">% user_drv              k_user_drv:server_loop/5                 8</span></div><div class="line"><span class="comment">% &lt;0.46.0&gt;              k_group:server/3                       987    14541    0</span></div><div class="line"><span class="comment">%                       k_group:server_loop/3                    4</span></div><div class="line"><span class="comment">% &lt;0.47.0&gt;              erlang:apply/2                       28690     4406    0</span></div><div class="line"><span class="comment">%                       kjell:shell_rep/4                       17</span></div><div class="line"><span class="comment">% &lt;0.48.0&gt;              erlang:apply/2                        1598    20585    0</span></div><div class="line"><span class="comment">%                       c:pinfo/1                               49</span></div><div class="line"><span class="comment">% Total                                                      58707  1110447    0</span></div><div class="line"><span class="comment">%                                                              237</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个函数返回进程的id，进程的初始化函数即启动进程的函数，进程堆的大小，进程的规约数，进程消息队列里的消息数，进程的注册名字，进程当前所处的函数，以及进程的栈大小。</p>
<p>c:i/0 的输出也包括堆大小、规约数，消息队列大小以及栈大小的各项数据的总和。</p>
<p>c模块也提供 c:ni/0 函数，它展示所有联通的节点的系统信息。</p>
<p>从该函数输出的进程信息来看，我们可以找到几个和 <a href="https://karlll.github.io/kjell/" target="_blank" rel="external">kjell</a> 相关的进程，kjell是我用来替换 erl shell的，它易于查找进程的信息。</p>
<p>查看一个kjell相关的进程，我们可以获得其pid，然后通过调用 <a href="http://erlang.org/doc/man/c.html#i-3" target="_blank" rel="external">c:i/3</a> 展示进程的信息来深入观察该进程，我们可以用pid的3个整数做为此函数的入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c:i(<span class="number">0</span>, <span class="number">47</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% [&#123;current_function,&#123;kjell,shell_rep,4&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;status,waiting&#125;,</span></div><div class="line"><span class="comment">%  &#123;message_queue_len,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;messages,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;links,[&lt;0.48.0&gt;,&lt;0.46.0&gt;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;dictionary,[&#123;&#123;result,1&#125;,ok&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;command,1&#125;,[&#123;call,1,&#123;remote,1,&#123;atom,1,c&#125;,&#123;atom,1,i&#125;&#125;,[]&#125;]&#125;,</span></div><div class="line"><span class="comment">%               &#123;evaluator,&lt;0.48.0&gt;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;trap_exit,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;error_handler,error_handler&#125;,</span></div><div class="line"><span class="comment">%  &#123;priority,normal&#125;,</span></div><div class="line"><span class="comment">%  &#123;group_leader,&lt;0.46.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;total_heap_size,46421&#125;,</span></div><div class="line"><span class="comment">%  &#123;heap_size,28690&#125;,</span></div><div class="line"><span class="comment">%  &#123;stack_size,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;reductions,4479&#125;,</span></div><div class="line"><span class="comment">%  &#123;garbage_collection,[&#123;min_bin_vheap_size,46422&#125;,</span></div><div class="line"><span class="comment">%                       &#123;min_heap_size,233&#125;,</span></div><div class="line"><span class="comment">%                       &#123;fullsweep_after,65535&#125;,</span></div><div class="line"><span class="comment">%                       &#123;minor_gcs,2&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;suspending,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们查看指定的进程的信息，我们可以看到它的链接进程，消息和消息队列长度，堆栈的信息，以及其他各种可能有用的相关设置。</p>
<p>同样，这几个函数也没有observer那样有漂亮的界面，不过它们在你无法直接通过一个终端来访问节点的时候可以派上用场，比如在一个跳板机上工作；它们能给你一个好的方式使得你能知道你的erlang节点的运行情况。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-i-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-i-0/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续讲c模块的另一个函数 &lt;a href=&quot;http://erlang.org/doc/man/c.html#i-0&quot;&gt;c:i/0&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;c:i/0 输出系统的信息，展示本节点的所有进程信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="i" scheme="http://szpzs.github.io/tags/i/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:regs/0</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-c-regs-0/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-c-regs-0/</id>
    <published>2016-09-19T12:58:00.000Z</published>
    <updated>2016-09-19T13:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看看c模块并研究 <a href="http://erlang.org/doc/man/c.html#regs-0" target="_blank" rel="external">c:regs/0</a>.</p>
<p>c:regs/0 输出当前节点上注册的进程的信息，比如进程的名字，进程的id，执行规约数，以及其他信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  121202    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  156994    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                  92    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.28.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                 1219    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>尽管这个函数的输出没有observer函数提供的图形界面漂亮，但是它是一个有用的工具，在你无法运行observer函数来获得图形界面的时候能够帮助你得到这些进程是什么进程以及这些进程在做什么。</p>
<p>c模块还提供了一个 c:nregs/0 函数，它展示本节点以及与本节点联通的所有节点的所有注册进程的信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">node().</div><div class="line">% 'foo@127.0.0.1'</div><div class="line">nodes().</div><div class="line">% ['bar@127.0.0.1']</div><div class="line">c:nregs().</div><div class="line">%</div><div class="line">% ** Registered procs on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;0.19.0&gt;     auth:init/1                        880    0</div><div class="line">% code_server           &lt;0.25.0&gt;     erlang:apply/2                  122302    0</div><div class="line">% erl_epmd              &lt;0.18.0&gt;     erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163458    0</div><div class="line">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                264    0</div><div class="line">% file_server_2         &lt;0.24.0&gt;     file_server:init/1                  92    0</div><div class="line">% global_group          &lt;0.23.0&gt;     global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;0.13.0&gt;     global:init/1                      339    0</div><div class="line">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     255    0</div><div class="line">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 5405    0</div><div class="line">% kernel_safe_sup       &lt;0.34.0&gt;     supervisor:kernel/1                 58    0</div><div class="line">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;0.20.0&gt;     net_kernel:init/1                  792    0</div><div class="line">% net_sup               &lt;0.17.0&gt;     supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</div><div class="line">% standard_error        &lt;0.27.0&gt;     erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;0.26.0&gt;     supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;0.30.0&gt;     group:server/3                      36    0</div><div class="line">% user_drv              &lt;0.29.0&gt;     user_drv:server/2                 1661    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">%</div><div class="line">% ** Registered procs on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;6108.7.0&gt;   erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;6108.19.0&gt;  auth:init/1                        880    0</div><div class="line">% code_server           &lt;6108.25.0&gt;  erlang:apply/2                  124588    0</div><div class="line">% erl_epmd              &lt;6108.18.0&gt;  erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;6108.3.0&gt;   erlang:apply/2                  164400    0</div><div class="line">% error_logger          &lt;6108.6.0&gt;   gen_event:init_it/6                301    0</div><div class="line">% file_server_2         &lt;6108.24.0&gt;  file_server:init/1                  92    0</div><div class="line">% global_group          &lt;6108.23.0&gt;  global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;6108.13.0&gt;  global:init/1                      341    0</div><div class="line">% inet_db               &lt;6108.16.0&gt;  inet_db:init/1                     255    0</div><div class="line">% inet_gethost_native   &lt;6108.42.0&gt;  inet_gethost_native:serve           83    0</div><div class="line">% inet_gethost_native_s &lt;6108.41.0&gt;  supervisor_bridge:inet_ge           41    0</div><div class="line">% init                  &lt;6108.0.0&gt;   otp_ring0:start/2                 5515    0</div><div class="line">% kernel_safe_sup       &lt;6108.34.0&gt;  supervisor:kernel/1                127    0</div><div class="line">% kernel_sup            &lt;6108.11.0&gt;  supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;6108.20.0&gt;  net_kernel:init/1                  796    0</div><div class="line">% net_sup               &lt;6108.17.0&gt;  supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;6108.12.0&gt;  rpc:init/1                        1302    0</div><div class="line">% standard_error        &lt;6108.27.0&gt;  erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;6108.26.0&gt;  supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;6108.30.0&gt;  group:server/3                      36    0</div><div class="line">% user_drv              &lt;6108.29.0&gt;  user_drv:server/2                 2801    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">% ok</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-regs-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-regs-0/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续看看c模块并研究 &lt;a href=&quot;http://erlang.org/doc/man/c.html#regs-0&quot;&gt;c:regs/0&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:regs/0 输出当前节点上注册的进程的信息，比如进程的名字，进程的id，执行规约数，以及其他信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="regs" scheme="http://szpzs.github.io/tags/regs/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday Bonus – Functional fizzbuzz</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-bonus-functional-fizzbuzz/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-bonus-functional-fizzbuzz/</id>
    <published>2016-09-19T07:50:40.000Z</published>
    <updated>2016-09-19T07:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday红包。</p>
<p>过去的这个周末我读了文章  <a href="http://comp-phil.blogspot.com/2015/08/bro-do-you-even-fizzbuzz.html" target="_blank" rel="external">Bro, Do You Even FizzBuzz?!?</a> ，它阐述如何在Clojure里不用取模运算符来解决 FizzBuzz 问题。</p>
<a id="more"></a>
<p>在以同样的算法用Ruby来解决这个问题并发布<a href="http://www.proctor-it.com/ruby-tuesday-functional-fizzbuzz/" target="_blank" rel="external">博客</a>后，我想我应该将这个问题用Erlang也来解决，同时也看看有何不同。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(fizzbuzz)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([fizzbuzz/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Results = do_fizzbuzz(N),</div><div class="line">    lists:foreach(<span class="keyword">fun</span>(X) -&gt; io:format(<span class="string">"~p~n"</span>, [X]) <span class="keyword">end</span>, Results).</div><div class="line"></div><div class="line"><span class="function"><span class="title">do_fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Fizzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">"fizz"</span>], N),</div><div class="line">    Buzzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"buzz"</span>], N),</div><div class="line">    FizzBuzzes = lists:zipwith(<span class="keyword">fun</span> lists:append/<span class="number">2</span>, Fizzes, Buzzes),</div><div class="line">    Numbers = lists:seq(<span class="number">1</span>, N),</div><div class="line">    lists:zipwith(fun translate/2, Numbers, FizzBuzzes).</div><div class="line"></div><div class="line"><span class="function"><span class="title">cycle</span><span class="params">(List, N)</span> -&gt;</span></div><div class="line">    lists:sublist(lists:append(lists:duplicate(N, List)), N).</div><div class="line"></div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(Number, <span class="string">""</span>)</span> -&gt;</span></div><div class="line">    integer_to_list(Number);</div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(_, Translation)</span> -&gt;</span></div><div class="line">    Translation.</div></pre></td></tr></table></figure>
<p>在Erlang的解决方案里有几个点要注意。</p>
<p>首先，Erlang没有任何懒列表或序列的直接概念，也没有 cycle 函数，所以我只能临时凑合着调用 lists:duplicate, lists:append 和 lists:sublist 来处理一个列表，从而循环处理原列表来生成一个有N个元素的列表。虽然这个做法不是最高效的方式，但是它是可行的。</p>
<p>其次，lists:zipwith 的能力对于一些管道的想法有帮助，因为我们可以处理这些链在一起的元素，而不是必须在不同的步骤中去处理它们。</p>
<p>第三，我们不用case语句，而是用一个有guard分支的函数来决定一个翻译存在与否，如果是是否用这个翻译，如果不是是否用这个数字。</p>
<p>我希望这起到抛砖引玉的作用，也希望听到你怎样更高效的方案，或者除了用一般的有guard分支来检查剩余元素的模式匹配的其他方法来解决FizzBuzz问题。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家一个Erlang Thursday红包。&lt;/p&gt;
&lt;p&gt;过去的这个周末我读了文章  &lt;a href=&quot;http://comp-phil.blogspot.com/2015/08/bro-do-you-even-fizzbuzz.html&quot;&gt;Bro, Do You Even FizzBuzz?!?&lt;/a&gt; ，它阐述如何在Clojure里不用取模运算符来解决 FizzBuzz 问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="Functional" scheme="http://szpzs.github.io/categories/Erlang/Functional/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="fizzbuzz" scheme="http://szpzs.github.io/tags/fizzbuzz/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:m/1</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-c-m-1/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-c-m-1/</id>
    <published>2016-09-19T07:47:15.000Z</published>
    <updated>2016-09-19T07:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续研究c模块，讲的函数是 <a href="http://erlang.org/doc/man/c.html#m-1" target="_blank" rel="external">c:m/1</a>.</p>
<p>c:m/1 入参是一个表示模块名字的原子，返回值是这个模块的信息。它打印出来的信息包括编译的日期、时间和编译选项，还有装载的目标（BEAM）文件以及这个模块中导出函数组成的列表。</p>
<a id="more"></a>
<p>我们来看看erlang中的string模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">c:m(string).</div><div class="line"><span class="comment">% Module string compiled: Date: November 28 2014, Time: 06.47</span></div><div class="line"><span class="comment">% Compiler options:  [&#123;outdir,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../ebin"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../include"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../../kernel/include"&#125;,</span></div><div class="line"><span class="comment">%                     warnings_as_errors,debug_info]</span></div><div class="line"><span class="comment">% Object file: /usr/local/Cellar/erlang/17.3.4/lib/erlang/lib/stdlib-2.2/ebin/string.beam</span></div><div class="line"><span class="comment">% Exports:</span></div><div class="line"><span class="comment">% centre/2                      rstr/2</span></div><div class="line"><span class="comment">% centre/3                      span/2</span></div><div class="line"><span class="comment">% chars/3                       str/2</span></div><div class="line"><span class="comment">% chars/2                       strip/1</span></div><div class="line"><span class="comment">% chr/2                         strip/2</span></div><div class="line"><span class="comment">% concat/2                      strip/3</span></div><div class="line"><span class="comment">% copies/2                      sub_string/2</span></div><div class="line"><span class="comment">% cspan/2                       sub_string/3</span></div><div class="line"><span class="comment">% equal/2                       sub_word/2</span></div><div class="line"><span class="comment">% join/2                        sub_word/3</span></div><div class="line"><span class="comment">% left/2                        substr/2</span></div><div class="line"><span class="comment">% left/3                        substr/3</span></div><div class="line"><span class="comment">% len/1                         to_float/1</span></div><div class="line"><span class="comment">% module_info/0                 to_integer/1</span></div><div class="line"><span class="comment">% module_info/1                 to_lower/1</span></div><div class="line"><span class="comment">% rchr/2                        to_upper/1</span></div><div class="line"><span class="comment">% right/2                       tokens/2</span></div><div class="line"><span class="comment">% right/3                       words/1</span></div><div class="line"><span class="comment">%                               words/2</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个模块是2014年11月28日在我的机器上编译的，还看到 warnings_as_errors 和 debug_info 这两个编译选项打开了，还有beam文件的路径以及string模块所有导出的不同函数。</p>
<p>接着我们看看在erlang shell里编译的模块。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">c(fizzbuzz).</div><div class="line">% &#123;ok,fizzbuzz&#125;</div><div class="line">c:m(fizzbuzz).</div><div class="line">% Module fizzbuzz compiled: Date: August 5 2015, Time: 22.14</div><div class="line">% Compiler options:  []</div><div class="line">% Object file: /Users/proctor/tmp/fizzbuzz.beam</div><div class="line">% Exports:</div><div class="line">%          fizzbuzz/1</div><div class="line">%          module_info/0</div><div class="line">%          module_info/1</div><div class="line">% ok</div></pre></td></tr></table></figure>
<p>c:m(fizzubzz)的输出显示fizzbuzz被编译了，并且是从我的用户目录下的tmp目录装载的，同时还有一个导出函数fizzbuzz/1 和在每个模块都有的两个版本导出函数module_info。</p>
<p>今天讲的这个函数不是你每天都可能用的函数，不过了解它对你调试和检查你的erlang应用很有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-m-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-m-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续研究c模块，讲的函数是 &lt;a href=&quot;http://erlang.org/doc/man/c.html#m-1&quot;&gt;c:m/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:m/1 入参是一个表示模块名字的原子，返回值是这个模块的信息。它打印出来的信息包括编译的日期、时间和编译选项，还有装载的目标（BEAM）文件以及这个模块中导出函数组成的列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="xm" scheme="http://szpzs.github.io/tags/xm/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:xm/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-c-xm-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-c-xm-1/</id>
    <published>2016-09-18T12:26:16.000Z</published>
    <updated>2016-09-18T12:29:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 <a href="http://erlang.org/doc/man/c.html#xm-1" target="_blank" rel="external">c:xm/1</a>.</p>
<p>c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。</p>
<a id="more"></a>
<p>首先让我们检查一下erlang模块，看看它是否有废弃的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c:xm(erlang).</div><div class="line"><span class="comment">% [&#123;deprecated,[]&#125;,&#123;undefined,[]&#125;,&#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是没有调用废弃的函数，没有未定义的函数，也没有未被使用的函数在erlang模块里。注：上述结果我是在Erlang 17.3.4 下得到的，根据你使用不同的erlang版本，你可能得到不一样的结果，因为 erlang:now/0 在18.0版本里已经是废弃的函数。（译者注：这句话有点费解，官网对 c:xm/1 对解析是：This function finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1. ）</p>
<p>为了找到符合这样标准的现存模块，我查看 Erlang 17.0 的 <a href="http://erlang.org/download/otp_src_17.0.readme" target="_blank" rel="external">README</a> 来搜索 deprecated 这个词。 找到如下这句：</p>
<p>pg 模块已经废弃，它将在Erlang/OTP 18中被删除。</p>
<p>那么让我们把这个模块名传给 c:xm/1 看看有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c:xm(pg).</div><div class="line"><span class="comment">% [&#123;deprecated,[&#123;&#123;pg,create,1&#125;,&#123;pg,master,1&#125;&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;pg,create,2&#125;,&#123;pg,master,1&#125;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;undefined,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>我们可以看到我们得到了pg模块里有关废弃的函数信息。</p>
<p>虽然你在日常工作中需要使用这个函数的几率很低，因为erlang相关的工具通常都非常注意这些方面，这足够引起人们的好奇，看起来调用这个函数似乎很值得，尤其如果那个时间Erlang代码的编译是Erlang内部完成的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-xm-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-xm-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 &lt;a href=&quot;http://erlang.org/doc/man/c.html#xm-1&quot;&gt;c:xm/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="xm" scheme="http://szpzs.github.io/tags/xm/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:is_subset/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/</id>
    <published>2016-09-18T12:22:01.000Z</published>
    <updated>2016-09-18T12:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#is_subset-2" target="_blank" rel="external">ordsets:is_subset/2</a>.</p>
<p>ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">10</span>)).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">SetB = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)).</div><div class="line"><span class="comment">% [2,4,6,8,10]</span></div><div class="line">SetC = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>)).</div><div class="line"><span class="comment">% [1,4,7,10,13]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:is_subset(SetB, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetB).</div><div class="line"><span class="comment">% false</span></div><div class="line">ordsets:is_subset(SetC, SetA).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>有几个事实要跟不熟悉集合理论的同学讲讲。首先，空集合是所有集合的子集；其次，一个集合是它自己的子集；最后，如果集合B是集合A的超集，则集合A是集合B的子集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ordsets:is_subset(EmptySet, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetB).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetC).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, EmptySet).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetA).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#is_subset-2&quot;&gt;ordsets:is_subset/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="is_subset" scheme="http://szpzs.github.io/tags/is-subset/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:subtract/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-subtract-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-subtract-2/</id>
    <published>2016-09-18T12:18:09.000Z</published>
    <updated>2016-09-18T12:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#subtract-2" target="_blank" rel="external">ordsets:subtract/2</a>.</p>
<p>ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">OrderedSetA = ordsets:from_list([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">OrderedSetB = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">OrderedSetC = ordsets:from_list([<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">16</span>, -<span class="number">16</span>]).</div><div class="line"><span class="comment">% [-16,-4,-2,2,4,16]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetA, OrderedSetB).</div><div class="line"><span class="comment">% [4]</span></div><div class="line">ordsets:subtract(OrderedSetA, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">ordsets:subtract(OrderedSetB, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">ordsets:subtract(EmptySet, OrderedSetA).</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetB, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5,8,13]</span></div></pre></td></tr></table></figure>
<p>请注意，ordsets:subtract/2 的入参顺序是不可换的，这一点和 ordsets:union/2 或者 ordsets:intersection/2 不一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:subtract(OrderedSetA, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">ordsets:subtract(OrderedSetC, OrderedSetA).</div><div class="line"><span class="comment">% [-16,-4,-2,16]</span></div></pre></td></tr></table></figure>
<p>如果你不是一直跟读Erlang Thursday的话，我再次友情提醒你，虽然Erlang用列表来表示有序集合，但是并不意味着列表是有序集合。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="subtract" scheme="http://szpzs.github.io/tags/subtract/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday Bonus! Performace of erlang:length/1 on a list</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</id>
    <published>2016-09-18T12:12:46.000Z</published>
    <updated>2016-09-18T12:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday福利。</p>
<p>上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：</p>
<p>有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？</p>
<a id="more"></a>
<p>我可以百分之九九确定Erlang必须每次都要遍历列表来计算其长度，因为它用链接列表类的数据结构来构造它的列表，但是我不确定是否有一些聪明的实现方法是我没有意识到，这些方法能提高获取列表长度到速度。</p>
<p>在写今天的Erlang Thursday的时候，我意识到，我应该用 timer:tc 函数，通过它来展示需要多长时间来获取不同列表的长度来证明 erlang:length/1 函数的执行情况。</p>
<p>为了纪念这个问题，也为了在下一次会议的时候能回忆其它，我在这里记录相关内容。我们要明白，timer:tc 函数返回的结果里第一个元素是被测量函数执行的微秒时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10</span>)]).</div><div class="line">&#123;<span class="number">2</span>,<span class="number">10</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000</span>)]).</div><div class="line">&#123;<span class="number">5</span>,<span class="number">1000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000</span>)]).</div><div class="line">&#123;<span class="number">41</span>,<span class="number">10000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000</span>)]).</div><div class="line">&#123;<span class="number">134</span>,<span class="number">100000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>)]).</div><div class="line">&#123;<span class="number">1918</span>,<span class="number">1000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000000</span>)]).</div><div class="line">&#123;<span class="number">25139</span>,<span class="number">10000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000000</span>)]).</div><div class="line">&#123;<span class="number">1368691</span>,<span class="number">100000000</span>&#125;</div></pre></td></tr></table></figure>
<p>在链接列表有大概1000元素以后，我们可以看到计算其长度的时间线性增长，尽管不是真正对所有节点做遍历，但是在算法复杂度（大O）上看是相同复杂度级别。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家一个Erlang Thursday福利。&lt;/p&gt;
&lt;p&gt;上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：&lt;/p&gt;
&lt;p&gt;有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/categories/Erlang/erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/tags/erlang/"/>
    
      <category term="length" scheme="http://szpzs.github.io/tags/length/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:intersection/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-intersection-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-intersection-2/</id>
    <published>2016-09-18T12:08:06.000Z</published>
    <updated>2016-09-18T12:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看ordsets模块并且讲讲 <a href="http://erlang.org/doc/man/ordsets.html#intersection-2" target="_blank" rel="external">ordsets:intersection/2</a> 。</p>
<p>ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OrderedSet1 = ordsets:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>]</div><div class="line">OrderedSet2 = ordsets:from_list([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet1, OrderedSet2).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet2, OrderedSet1).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>因为 ordsets:intersection/2 在集合中找共同的元素，就向上面的例子一样，入参的顺序是可以交换的，不管两个入参的有序集合的参数顺序如何，我们得到的结果是一样的。</p>
<p>如果没有共同的元素，则结果是一个空的有序集合（其实就是一个空列表，上周的文章 <a href="http://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">ordsets:union/2</a> 里强调了用一个列表来当做一个有序集合是危险的）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Evens = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</div><div class="line">Odds = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>]</div><div class="line">ordsets:intersection(OrderedSet2, ordsets:new()).</div><div class="line">[]</div><div class="line">ordsets:intersection(Evens, Odds).</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>Erlang也提供了 <a href="http://erlang.org/doc/man/ordsets.html#intersection-1" target="_blank" rel="external">ordsets:intersection/1</a> 函数，它的入参是一个由多个有序集合为元素组成的列表，它返回的结果是列表里所有的有序集合的交集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">OrderedSet3 = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</div><div class="line">ordsets:intersection([Evens, Odds, OrderedSet1]).</div><div class="line">[]</div><div class="line">ordsets:intersection([Odds, OrderedSet2, OrderedSet1]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection([Evens, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">2</span>]</div><div class="line">ordsets:intersection([Odds, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续看ordsets模块并且讲讲 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#intersection-2&quot;&gt;ordsets:intersection/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="intersection" scheme="http://szpzs.github.io/tags/intersection/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:union/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-union-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-union-2/</id>
    <published>2016-09-18T11:55:20.000Z</published>
    <updated>2016-09-18T12:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#union-2" target="_blank" rel="external">ordsets:union/2</a> 。</p>
<p>ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">SetB = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">SetC = ordsets:from_list([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]).</div><div class="line"><span class="comment">% [1,3,4,5,9]</span></div><div class="line">SetD = ordsets:from_list([a, b, c, d, e]).</div><div class="line"><span class="comment">% [a,b,c,d,e]</span></div><div class="line">UnionAB = ordsets:union(SetA, SetB).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">UnionAC = ordsets:union(SetA, SetC).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div></pre></td></tr></table></figure>
<p>因为Erlang里的字符串实际上是字符列表，我们可以从字符串产生有序集合，然后通过这个函数得到两个字符串里不重复的字符并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:from_list(<span class="string">"Kermit"</span>).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list([<span class="number">75</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">116</span>]).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list(<span class="string">"Mississippi"</span>).</div><div class="line"><span class="comment">% "Mips"</span></div><div class="line">ordsets:union(ordsets:from_list(<span class="string">"Kermit"</span>), ordsets:from_list(<span class="string">"Mississippi"</span>)).</div><div class="line"><span class="comment">% "KMeimprst"</span></div></pre></td></tr></table></figure>
<p>ordsets模块也包含 <a href="http://erlang.org/doc/man/ordsets.html#union-1" target="_blank" rel="external">ordsets:union/1</a> ，它的入参是一个由有序集合组成的列表，它返回的是列表里所有有序集合的并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UnionAC = ordsets:union([SetA, SetC]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABC = ordsets:union([SetB, SetC, SetA]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABCD = ordsets:union([SetB, SetC, SetA, SetD]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9,a,b,c,d,e]</span></div><div class="line">UnionCD = ordsets:union([SetC, SetD]).</div><div class="line"><span class="comment">% [1,3,4,5,9,a,b,c,d,e]</span></div></pre></td></tr></table></figure>
<p>警告：有序集合的表现形式虽然只是一个列表，但是如果你传递一个普通列表给 ordsets:union/2 ，你将得不到你预期的结果，因为这个函数要求每个有序集合里的元素是真正的有序并且是一个集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c,1]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-union-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#union-2&quot;&gt;ordsets:union/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="union" scheme="http://szpzs.github.io/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thrusday – queue:out/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thrusday-queue-out-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thrusday-queue-out-1/</id>
    <published>2016-09-18T11:49:21.000Z</published>
    <updated>2016-09-18T11:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的的是queue模块原生API中的  <a href="http://erlang.org/doc/man/queue.html#out-1" target="_blank" rel="external">queue:out/1</a> 函数。</p>
<p>queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。</p>
<a id="more"></a>
<p>“是什么让这个函数这么厉害？”，你可能会这么问我。</p>
<p>这应该是这个函数由元组、标签元组组成，它的不可变性，它的宽容性，以及我们最终看到它返回结果的事实，所有这些使得我希望更多的队列实现都有像这样的一个API。</p>
<p>首先应该由很多次我自己或别人的过往经历中，在尝试弹出队列第一个元素的时候忘了检查这个队列是否是空的，从而造成一个很不友好的运行时错误。</p>
<p>queue:out/1 恰恰相反，当你给它的入参是一个空队列的时候，它并不触发一个错误，而是返回一个标签元组来告诉你，你传入的队列是空的，另外它还返回一个空队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:out(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们的入参是一个非空队列，queue:out/1 返回一个两元素元组。第一个元素是一个标签元组，它告诉我们，我们得到了一个值以及入参队列的头部元素，第二个元素，我们得到了入参队列移除头部元素后剩下的元素组成的队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([a, b, c, d]).</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">&#123;&#123;value, Head&#125;, NewQueue&#125; = queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">Head.</div><div class="line"><span class="comment">% a</span></div><div class="line">NewQueue.</div><div class="line"><span class="comment">% &#123;[d],[b,c]&#125;</span></div><div class="line">queue:head(NewQueue).</div><div class="line"><span class="comment">% b</span></div></pre></td></tr></table></figure>
<p>当我们在跨语言条件下谈论队列的理论上的概念时，“pop”这个概念做了两个事情，返回队列的头部元素，同时修改队列将其头部元素删除。</p>
<p>由于Erlang的队列是不可改变的，那么你仔细想想几分钟，你就会感觉到 queue:out/1 这个函数的妙处了，它也做了“pop”概念中的两件事情，就是返回队列头部，同时返回一个删除了头部元素的新的队列。</p>
<p>Erlang的queue模块也提供了函数 <a href="http://erlang.org/doc/man/queue.html#out_r-1" target="_blank" rel="external">queue:out_r/1</a> ，它的行为和 queue:out/1 基本一样，不一样的是它操作的是队列的尾部元素而不是队列的头部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:out_r(queue:from_list([a, b, c, d])).</div><div class="line"><span class="comment">% &#123;&#123;value,d&#125;,&#123;,[a,b]&#125;&#125;</span></div><div class="line">queue:out_r(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我希望你和我一样发现 queue:out/1 方便好用。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thrusday-queue-out-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thrusday-queue-out-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的的是queue模块原生API中的  &lt;a href=&quot;http://erlang.org/doc/man/queue.html#out-1&quot;&gt;queue:out/1&lt;/a&gt; 函数。&lt;/p&gt;
&lt;p&gt;queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="out" scheme="http://szpzs.github.io/tags/out/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:split/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-split-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-split-2/</id>
    <published>2016-09-18T11:45:36.000Z</published>
    <updated>2016-09-18T12:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲queue模块的原生API：<a href="http://erlang.org/doc/man/queue.html#split-2" target="_blank" rel="external">queue:split/2</a> 。</p>
<p>queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([a, <span class="number">1</span>, b, <span class="number">2</span>, c, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:split(<span class="number">4</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[2],[a,1,b]&#125;,&#123;[4,3],&#125;&#125;</span></div><div class="line">queue:split(<span class="number">0</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[]&#125;,&#123;[4,3,c],[a,1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">1</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[a]&#125;,&#123;[4,3,c],[1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">7</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[4,3,c],[a,1,b,2]&#125;,&#123;[],[]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">15</span>, QueueOne).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:split/2</span></div><div class="line"><span class="comment">%         called as queue:split(15,&#123;[4,3,c],[a,1,b,2]&#125;)</span></div><div class="line">&#123;SplitFirst, SplitSecond&#125; = queue:split(<span class="number">3</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[b,1],[a]&#125;,&#123;[4,3,c],[2]&#125;&#125;</span></div><div class="line">SplitFirst.</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">SplitSecond.</div><div class="line"><span class="comment">% &#123;[4,3,c],[2]&#125;</span></div><div class="line">queue:peek(SplitFirst).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(SplitSecond).</div><div class="line"><span class="comment">% &#123;value,2&#125;</span></div></pre></td></tr></table></figure>
<p>Erlang也提供一个 <a href="http://erlang.org/doc/man/queue.html#join-2" target="_blank" rel="external">queue:join/2</a> 函数，它有两个入参，入参类型都是队列，函数返回值是一个新的队列，新队列是由第二个入参队列添加到第一个入参队列后面形成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:join(SplitFirst, SplitSecond).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:join(SplitSecond, SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[2,c,3,4,a]&#125;</span></div><div class="line">queue:join(queue:new(), SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">queue:join(queue:new(), queue:new()).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-split-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-split-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲queue模块的原生API：&lt;a href=&quot;http://erlang.org/doc/man/queue.html#split-2&quot;&gt;queue:split/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="split" scheme="http://szpzs.github.io/tags/split/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:peek/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-peek-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-peek-1/</id>
    <published>2016-09-18T11:39:35.000Z</published>
    <updated>2016-09-18T11:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 <a href="http://erlang.org/doc/man/queue.html#peek-1" target="_blank" rel="external">queue:peek/1</a> 。</p>
<p>queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:peek(QueueOne).</div><div class="line"><span class="comment">% &#123;value,1&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>queue:peek/1 绝对不会修改入参队列，所以我们可以再一次调用上述例子，或者像下面例子一样多次调用，而我们的入参队列不会被修改。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueTwo = queue:from_list([a, b, c, d, e, f]).</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div></pre></td></tr></table></figure>
<p>不像上一篇文章里我们看到的 <a href="http://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">queue:head/1</a> ，我们可以安全地在入参队列为空的情况下调用 queue:peek/1 函数，而不是获得一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:head/1</span></div><div class="line"><span class="comment">%         called as queue:head(&#123;[],[]&#125;)</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>Erlang的 queue 模块也包含函数 <a href="http://erlang.org/doc/man/queue.html#peek_r-1" target="_blank" rel="external">queue:peek_r/1</a> ，它返回入参队列的尾部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">queue:peek_r(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,f&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue.</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-peek-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-peek-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 &lt;a href=&quot;http://erlang.org/doc/man/queue.html#peek-1&quot;&gt;queue:peek/1&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="peek" scheme="http://szpzs.github.io/tags/peek/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:tail/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-tail-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-tail-1/</id>
    <published>2016-09-18T11:31:31.000Z</published>
    <updated>2016-09-18T11:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 <a href="http://erlang.org/doc/man/queue.html#tail-1" target="_blank" rel="external">queue:tail/1</a>.</p>
<p>queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">Tail = queue:tail(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Tail).</div><div class="line"><span class="comment">% 2</span></div><div class="line">queue:to_list(Tail).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>我们可以看到上述调用 queue:tail/1 的例子不像其它语言一样是一个破坏性操作，它完全保留了原始的入参队列的完整性。</p>
<p>做为将一个队列做为双端来处理的Okasaki API的一部分，queue:tail/1 有一个对应的函数 <a href="http://erlang.org/doc/man/queue.html#liat-1" target="_blank" rel="external">queue:liat/1</a> ，这个函数返回移除入参队列的最后一个元素后形成的新队列。queue:liat/1 也有一个别名函数，就是Okasaki API的 <a href="http://erlang.org/doc/man/queue.html#init-1" target="_blank" rel="external">queue:init/1</a>.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:liat(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">queue:init(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Erlang官方文档也指出有一个别名函数 queue:lait/1 ，大家最好不要用它，因为它的拼写是错误的。</p>
<p>因为我们是要深入细节然后看看我们能学到什么，那么让我们一起来到目前为止我们接触到的不同的tail函数在接收一个空队列为入参会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:tail(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop/1</span></div><div class="line"><span class="comment">%         called as queue:drop(&#123;[],[]&#125;)</span></div><div class="line">queue:liat(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div><div class="line">queue:init(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>当我们分别调用 <a href="http://erlang.org/doc/man/queue.html#drop-1" target="_blank" rel="external">queue:tail/1</a> 和 <a href="http://erlang.org/doc/man/queue.html#drop_r-1" target="_blank" rel="external">queue:liat/1</a> 的时候，看起来像我们在调用 queue:drop/1 和 queue:drop_r/1 得到的异常错误一样。</p>
<p>当我们用一个有若干元素的队列做为入参来调用 queue:drop/1 和 queue:drop_r/1 ，然后看看的执行情况，看起来 queue:tail/1 就是 queue:drop/1 的别名函数，而 queue:list/1 和 queue:init/1 就是 queue:drop_r/1 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:drop(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">queue:drop_r(Queue).</div><div class="line">&#123;[<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-tail-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-tail-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 &lt;a href=&quot;http://erlang.org/doc/man/queue.html#tail-1&quot;&gt;queue:tail/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="tail" scheme="http://szpzs.github.io/tags/tail/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:head/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-queue-head-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-queue-head-1/</id>
    <published>2016-09-17T08:44:16.000Z</published>
    <updated>2016-09-17T08:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看<a href="http://erlang.org/doc/man/queue.html#head-1" target="_blank" rel="external">queue:head/1</a>.</p>
<p>queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Queue).</div><div class="line"><span class="comment">% 1</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>上述例子显示，queue:head/1 函数没有修改原来的队列，而仅是返回它的第一个元素。</p>
<p>因为 queue:head/1 仅仅是返回队列头部能找到的值，而且不是一个标签元组，如果我们尝试从一个空的队列获取它的头部元素则会抛出一个错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">%** exception error: empty</span></div><div class="line"><span class="comment">%     in function  queue:head/1</span></div><div class="line"><span class="comment">%        called as queue:head(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>为了安全起见，让我们不在一个空队列上运行该函数而造成抛出异常，queue模块也定义了一个函数 queue:is_empty/1 ，你可以用它来检查一个队列是否为空。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:is_empty(EmptyQueue).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>像 queue:cons/2 和Okazaki API的其它函数一样，模块里也有一个函数<a href="http://erlang.org/doc/man/queue.html#daeh-1" target="_blank" rel="external">queue:dash</a> （head单词倒过来写），它从队列获取最后一个元素，它也是 <a href="http://erlang.org/doc/man/queue.html#last-1" target="_blank" rel="external">queue:last/1</a> 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:daeh(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:last(Queue).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>如果你调用 queue:dash/1 和 queue:last/1 的时候用空队列做入参也会引起错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:daeh(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:last(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>如果我们仔细看 queue:dash/1 和 queue:last/1 引起的错误，我们看到这个错误来自扩展API的 queue:get_r/1 。如果我们仔细看 queue:get_r/1 的执行情况，他看起来像 queue:tail/1 和 queue:dash/1 ，而这两个函数真的仅是 <a href="http://erlang.org/doc/man/queue.html#get_r-1" target="_blank" rel="external">queue:get_r/1</a> 别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:get_r(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-head-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看&lt;a href=&quot;http://erlang.org/doc/man/queue.html#head-1&quot;&gt;queue:head/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="head" scheme="http://szpzs.github.io/tags/head/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:cons/2</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-queue-cons-2/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-queue-cons-2/</id>
    <published>2016-09-17T08:39:51.000Z</published>
    <updated>2016-09-17T08:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们稍微深入一下queue模块，我们讲讲来自Okazaki的API：<a href="http://www.erlang.org/doc/man/queue.html#cons-2" target="_blank" rel="external">queue:cons/2</a> 。</p>
<p>queue:cons/2 有两个入参，一个是元素，一个是队列，它执行后返回一个元素加在队列头部形成的新队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">7</span>, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[7]&#125;</span></div><div class="line">queue:cons(<span class="number">3</span>, queue:cons(<span class="number">7</span>, queue:new())).</div><div class="line"><span class="comment">% &#123;[7],[3]&#125;</span></div><div class="line">queue:cons(nil, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[nil]&#125;</span></div><div class="line">queue:cons(<span class="number">5</span>, queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>])).</div><div class="line"><span class="comment">% &#123;[21],[5,7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们传入一个列表给 queue:cons/2 ，我们看到它出错，表明它想要一个队列，而不会隐式地将一个列表转成一个队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:in_r/2</span></div><div class="line"><span class="comment">%         called as queue:in_r(5,[1,2,3,4])</span></div></pre></td></tr></table></figure>
<p>因为队列被设置成一个双端队列，Okasaki API 也提供了一个对应的函数 <a href="http://www.erlang.org/doc/man/queue.html#snoc-2" target="_blank" rel="external">queque:snoc/2</a> ，它将元素加在传入的队列的尾部。注意，queue:snoc/2 和 queue:cons/2 两个函数的两个入参的顺序也是相反的；queue:snoc/2 的第一个入参上一个队列，而要加在它尾部的元素做为第二个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:snoc(queue:new(), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:snoc(queue:new(), <span class="number">7</span>), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5,21],[7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-cons-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-cons-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们稍微深入一下queue模块，我们讲讲来自Okazaki的API：&lt;a href=&quot;http://www.erlang.org/doc/man/queue.html#cons-2&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="cons" scheme="http://szpzs.github.io/tags/cons/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – filelib:is_file/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-filelib-is-file-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-filelib-is-file-1/</id>
    <published>2016-09-17T08:35:45.000Z</published>
    <updated>2016-09-17T08:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/filelib.html#is_file-1" target="_blank" rel="external">filelib:is_file/1</a>.</p>
<p>filelib:is_file/1 入参是一个表示文件名的字符串，它根据这个文件名所指的是否是文件或目录而返回true或者false。</p>
<p>这个函数在你正在需要从一个配置文件读取内容并且在尝试处理前确认这个文件或目录是否存在的时候有用，以便你可以在退出前得到一个友好的错误信息而不仅是引起一个系统错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(<span class="string">"foo"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"junk"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tmp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tempmp"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"temp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/bin"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/var"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/vars"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"."</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">".."</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>filelib:is_file/1 的入参也可以是一个原子，或者甚至也可以是一个嵌套的列表来表示一个文件名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(foo).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(junk).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file([<span class="string">"/usr"</span>, ['/local', '/bin']]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/filelib.html#is_file-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;filelib:is_file/1&lt;/a&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="filelib" scheme="http://szpzs.github.io/categories/Erlang/filelib/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="filelib" scheme="http://szpzs.github.io/tags/filelib/"/>
    
      <category term="is_file" scheme="http://szpzs.github.io/tags/is-file/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:iso_week_number/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/</id>
    <published>2016-09-17T07:49:18.000Z</published>
    <updated>2016-09-17T07:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#iso_week_number-1" target="_blank" rel="external">calendar:iso_week_number/1</a>.</p>
<p>calendar:iso_week_number/1 接收一个日期元组做为入参，然后返回一个由年份和周数字组成的元组。年份是入参里的年份，而周数字是一个1到53的整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">04</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">19</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">03</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">18</span>&#125;</div></pre></td></tr></table></figure>
<p>如果我们拿本周做为一个例子，我们可以看到本周是从星期一（五月四日）开始，而前一个星期天（五月三日）是属于上一个星期的。</p>
<p>我们看到一月一日是这一年的第一周，这没什么奇怪，而2015年的十二月三十一日是这一年的第53周。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">1</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">53</span>&#125;</div></pre></td></tr></table></figure>
<p>一开始听到一年有53周我们会很惊讶，因为几乎每个人都认为一年只有52周，直到你意识到有些十二月三十一日有时候是处于一周的开始，所以造成了它处在第53周，而它仅仅是这周的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#iso_week_number-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calendar:iso
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="iso_week_number" scheme="http://szpzs.github.io/tags/iso-week-number/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:is_leap_year/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/</id>
    <published>2016-09-17T07:43:16.000Z</published>
    <updated>2016-09-17T07:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#is_leap_year-1" target="_blank" rel="external">calendar:is_leap_year/1</a>.</p>
<p>calendar:is_leap_year/1 接收一个非负整数表示的年份，如果这个年份是闰年，则返回true，否则返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(<span class="number">2015</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2012</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">2017</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2000</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">1900</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">0</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>有了这个Erlang核心库的内置函数，意味着你不需要编写代码或者甚至不需要查找规则来记住如何判断某个年份到底是不是闰年。</p>
<p>如果你传递一个负数来表示年份，Erlang将抛出一个异常，因为没有一个函数分支能匹配用负数来表示的年份。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(-<span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-1) (calendar.erl, line 183)</span></div><div class="line">calendar:is_leap_year(-<span class="number">4</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-4) (calendar.erl, line 183)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#is_leap_year-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calendar:is_lea
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="is_leap_year" scheme="http://szpzs.github.io/tags/is-leap-year/"/>
    
  </entry>
  
</feed>
