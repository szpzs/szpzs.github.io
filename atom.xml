<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2017-02-10T13:38:31.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elixir入门教程－协议</title>
    <link href="http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/"/>
    <id>http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/</id>
    <published>2017-02-10T13:36:51.000Z</published>
    <updated>2017-02-10T13:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">协议和结构体</a></li>
<li><a href="#part-two">实现Any</a><br> 2.1. <a href="#part-two-one">派生</a><br> 2.3. <a href="#part-two-two">回退到Any</a></li>
<li><a href="#part-three">内建协议</a></li>
<li><a href="#part-four">协议整合</a></li>
</ol>
<p>协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。</p>
<p>在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。</p>
<p>虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。</p>
<a id="more"></a>
<p>协议的定义看起来像下面这样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">"Calculates the size (and not the length!) of a data structure"</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Size协议期望有一个接受一个入参（我们想要知道大小的数据结构）叫做size的函数被实现。我们现在可以为一些数据结构实现这个协议，这些数据结构应该有一个合适的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> BitString <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(string), <span class="symbol">do:</span> byte_size(string)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Map <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(map), <span class="symbol">do:</span> map_size(map)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Tuple <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(tuple), <span class="symbol">do:</span> tuple_size(tuple)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们没有为列表实现Size协议，因为列表没有预先计算好的“大小”信息，并且列表的长度必须要被计算出来（用 length/1）。</p>
<p>现在我们有了协议定义和实现，我们可以开始使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(<span class="string">"foo"</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; Size.size(&#123;<span class="symbol">:ok</span>, <span class="string">"hello"</span>&#125;)</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; Size.size(%&#123;<span class="symbol">label:</span> <span class="string">"some label"</span>&#125;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>传入一个没有实现协议的数据类型将会引起一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>为所有Elixir数据类型实现协议是可能的：</p>
<ul>
<li>Atom</li>
<li>BitString</li>
<li>Float</li>
<li>Function</li>
<li>Integer</li>
<li>List</li>
<li>Map</li>
<li>PID</li>
<li>Port</li>
<li>Reference</li>
<li>Tuple</li>
</ul>
<h1 id="协议和结构体"><a href="#协议和结构体" class="headerlink" title="协议和结构体"></a><span id="part-one">协议和结构体</span></h1><p>Elixir的可扩展性的能力来自当协议和结构一起使用时。</p>
<p>在上一章，我们已经学到，虽然结构体底层是映射，但是它没有和映射共享协议实现。例如，<a href="https://hexdocs.pm/elixir/MapSet.html" target="_blank" rel="external">MapSet</a> （基于映射的集合）被实现为结构体。让我们尝试应用Size协议于MapSet上：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(%&#123;&#125;)</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; set = %MapSet&#123;&#125; = MapSet.new</div><div class="line"><span class="comment">#MapSet&lt;[]&gt;</span></div><div class="line">iex&gt; Size.size(set)</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> <span class="comment">#MapSet&lt;[]&gt;</span></div></pre></td></tr></table></figure>
<p>结构体没有和映射共享协议实现，而是需要它自己的协议实现。因为MapSet有它自己的预先计算大小并且可以通过MapSet.size/1访问，我们可以为它定义一个Size协议的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> MapSet <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(set), <span class="symbol">do:</span> MapSet.size(set)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果需要，你可以拿出你自己结构大小的语义。你不仅可以用结构体来构建更健壮的数据类型，比如像队列，而且可以为这个数据类型实现所有相关的协议，比如 Enumerable 和 可能的 Size。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> User <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(_user), <span class="symbol">do:</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="实现Any"><a href="#实现Any" class="headerlink" title="实现Any"></a><span id="part-two">实现Any</span></h1><p>手工为所有类型实现协议可能很快就变得重复和单调乏味。在这种情况下，Elixir提供了两种选择：我们可以明确地为我们的类型派生协议的实现或自动为所有类型实现协议。在这两种情况下，我们需要为Any实现协议。</p>
<h2 id="派生"><a href="#派生" class="headerlink" title="派生"></a><span id="part-two-one">派生</span></h2><p>Elixir允许我们基于Any的实现派生一个协议实现。让我们先实现Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述的实现可以说是不合理的。例如，说一个PID或一个整数的大小为零。</p>
<p>然而，我们应该很好地处理这个Any的实现。为了使用这个实现，我们应该需要告诉我们的结构体明确地派生于这个Size协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">OtherUser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@derive</span> [Size]</div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当派生的时候，Elixir将基于为Any提供的实现为OtherUser实现Size协议。</p>
<h2 id="回退到Any"><a href="#回退到Any" class="headerlink" title="回退到Any"></a><span id="part-two-two">回退到Any</span></h2><p>当找不到实现的时候，对于 @derive 的另外一个选择就是明确地告诉协议退回到Any。这可以在协议定义里通过设置@fallback_to_any为true来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@fallback_to_any</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>正如我们在前一节所说，为Any所做的Size实现不能应用到所有数据类型。这就是为什么@fallback_to_any是一个可选项的原因之一。对于大多数协议来说，当没有实现的时候抛出一个错误是正确的行为。也就是说，假设像上一节一样我们已经实现了Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>那么现在所有数据类型（包括结构体），如果它没有实现Size协议，则被认为大小为0。</p>
<p>派生和回退到Any哪一个技术最好，这要依赖于使用场景。但是，Elixir开发者喜欢明确的而不是推断的。你可以看到许多库倾向于 @derive 方法。</p>
<h1 id="内建协议"><a href="#内建协议" class="headerlink" title="内建协议"></a><span id="part-three">内建协议</span></h1><p>Elixir内建了一些协议。前面的章节里，我们讨论过的Enum模块，它提供了许多函数处理任意数据结构，这个模块就实现了 Enumerable 协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span></div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.reduce <span class="number">1</span>..<span class="number">3</span>, <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span></div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>另一个有用的例子是String.Chars协议，它指明如何用字符转换一个数据结构为一个字符串。它通过to_string函数暴露出来：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_string <span class="symbol">:hello</span></div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>注意到Elixir字符串插入是调用to_string函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"age: <span class="subst">#&#123;<span class="number">25</span>&#125;</span>"</span></div><div class="line"><span class="string">"age: 25"</span></div></pre></td></tr></table></figure>
<p>上面的例子可以正常运行是因为数字数据类型实现了String.Chars协议。如果传递一个元组，则会导致一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;tuple&#125;</span>"</span></div><div class="line">** (Protocol.UndefinedError) protocol String.Chars <span class="keyword">not</span> implemented <span class="keyword">for</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p>当需要“打印”一个更复杂的数据结构的时候，我们可以用基于Inspect协议的inspect函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;inspect tuple&#125;</span>"</span></div><div class="line"><span class="string">"tuple: &#123;1, 2, 3&#125;"</span></div></pre></td></tr></table></figure>
<p>Inspect协议被用来转换任何数据结构为一个易于阅读的文本。像IEx这样的工具就是用它来打印的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">name:</span> <span class="string">"john"</span>, <span class="symbol">age:</span> <span class="number">27</span>&#125;</div></pre></td></tr></table></figure>
<p>记住，按照惯例，每当被检查的价值以#开头，它是代表这是非有Elixir的语法的数据结构。这意味着inspect协议是不可逆的，因为以这种方式信息可能会丢失：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; inspect &amp;(&amp;<span class="number">1</span>+<span class="number">2</span>)</div><div class="line"><span class="string">"#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;"</span></div></pre></td></tr></table></figure>
<p>Elixir还有其他协议，不过本文讲最常用的这几个。</p>
<h1 id="协议整合"><a href="#协议整合" class="headerlink" title="协议整合"></a><span id="part-four">协议整合</span></h1><p>当处理Elixir项目的时候，使用Mix构建工具，你可以看到如下的输出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Consolidated String.Chars</div><div class="line">Consolidated Collectable</div><div class="line">Consolidated List.Chars</div><div class="line">Consolidated IEx.Info</div><div class="line">Consolidated Enumerable</div><div class="line">Consolidated Inspect</div></pre></td></tr></table></figure>
<p>这些是Elixir自带的所有协议并且它们被整合。因为一个协议可以派发消息到任何数据类型，如果对于给定的类型的实现存在，则协议一定检查每一个调用。这可能非常消耗资源。</p>
<p>但是，在我们的项目使用像Mix这样的工具被编译后，我们知道所有被定义的模块，包括协议和他们的实现。用这个方法，协议可以被合并到一个非常简单快速的派发模块。</p>
<p>从Elixir v1.2开始，对于所有项目，协议合并都自动发生。我们将在<strong>Mix和OTP指引</strong>里构建我们的项目。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/protocols.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/protocols.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;协议和结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;实现Any&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;派生&lt;/a&gt;&lt;br&gt; 2.3. &lt;a href=&quot;#part-two-two&quot;&gt;回退到Any&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;内建协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;协议整合&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。&lt;/p&gt;
&lt;p&gt;在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。&lt;/p&gt;
&lt;p&gt;虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/categories/Elixir/protocol/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－结构体</title>
    <link href="http://szpzs.oschina.io/2017/02/09/elixir-getting-started-structs/"/>
    <id>http://szpzs.oschina.io/2017/02/09/elixir-getting-started-structs/</id>
    <published>2017-02-09T14:13:18.000Z</published>
    <updated>2017-02-09T14:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">定义结构体</a></li>
<li><a href="#part-two">访问和修改结构体</a></li>
<li><a href="#part-three">结构体的底层是裸映射</a></li>
<li><a href="#part-four">默认值和所需的键</a></li>
</ol>
<p>在第七章我们学了映射：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">iex&gt; map[<span class="symbol">:a</span>]</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; %&#123;map | <span class="symbol">a:</span> <span class="number">3</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">3</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>结构体是构建于映射之上的扩展，它提供了编译时检查和默认值。</p>
<a id="more"></a>
<h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a><span id="part-one">定义结构体</span></h1><p>要定义结构体，就要使用 defstruct 结构</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   defstruct <span class="symbol">name:</span> <span class="string">"John"</span>, <span class="symbol">age:</span> <span class="number">27</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>defstruct 用关键字列表定义结构体有什么字段以及它们的默认值。</p>
<p>结构体的名字就是它们被定义所在的模块的名字。上面例子中，我们定义了一个名字为User的结构体。</p>
<p>我们现在可以用与创建映射相似的语法来创建 User 结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; %User&#123;<span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div></pre></td></tr></table></figure>
<p>结构体提供编译时检查来保证只有通过 defstruct 定义的字段（包括所有被定义的字段）才被允许存在它里面：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;<span class="symbol">oops:</span> <span class="symbol">:field</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:oops</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="访问和修改结构体"><a href="#访问和修改结构体" class="headerlink" title="访问和修改结构体"></a><span id="part-two">访问和修改结构体</span></h1><p>当我们讨论映射的时候，我们展示了我们如何访问和修改映射的字段。同样的技术（和同样的语法）也应用在结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; john = %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; john.name</div><div class="line"><span class="string">"John"</span></div><div class="line">iex&gt; meg = %&#123;john | <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">iex&gt; %&#123;meg | <span class="symbol">oops:</span> <span class="symbol">:field</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:oops</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div></pre></td></tr></table></figure>
<p>当使用修改语法（|）的时候，Erlang虚拟机意识到没有新的键将加入结构体，准许底层的映射在内存里共享它们的结构。上述例子里，john 和 meg 共享内存里相同的键结构。</p>
<p>结构也可以用于模式匹配，既为匹配上的特定键的值以及确保匹配的值是一个同一类型的结构的匹配值。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;<span class="symbol">name:</span> name&#125; = john</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; name</div><div class="line"><span class="string">"John"</span></div><div class="line">iex&gt; %User&#123;&#125; = %&#123;&#125;</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> %&#123;&#125;</div></pre></td></tr></table></figure>
<h1 id="结构体的底层是裸映射"><a href="#结构体的底层是裸映射" class="headerlink" title="结构体的底层是裸映射"></a><span id="part-three">结构体的底层是裸映射</span></h1><p>上面的例子里，模式匹配可以运作是因为结构体的底层是有固定字段集合的裸映射。作为映射，结构体存储了一个名字为 __struct__ 的“特别的”字段，它持有结构体的名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_map(john)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; john.__struct_<span class="number">_</span></div><div class="line">User</div></pre></td></tr></table></figure>
<p>注意：我们称结构体为裸映射是因为为映射实现的协议没有任何一个可用于结构体。例如，你既不能枚举也不能访问一个结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; john = %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; john[<span class="symbol">:name</span>]</div><div class="line">** (UndefinedFunctionError) function User.fetch/<span class="number">2</span> is undefined (User does <span class="keyword">not</span> implement the Access behaviour)</div><div class="line">             User.fetch(%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;, <span class="symbol">:name</span>)</div><div class="line">iex&gt; Enum.each john, <span class="keyword">fn</span>(&#123;field, value&#125;) -&gt; IO.puts(value) <span class="keyword">end</span></div><div class="line">** (Protocol.UndefinedError) protocol Enumerable <span class="keyword">not</span> implemented <span class="keyword">for</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div></pre></td></tr></table></figure>
<p>然后，因为结构体就是映射，它们可以应用于Map模块的函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; kurt = Map.put(%User&#123;&#125;, <span class="symbol">:name</span>, <span class="string">"Kurt"</span>)</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Kurt"</span>&#125;</div><div class="line">iex&gt; Map.merge(kurt, %User&#123;<span class="symbol">name:</span> <span class="string">"Takashi"</span>&#125;)</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Takashi"</span>&#125;</div><div class="line">iex&gt; Map.keys(john)</div><div class="line">[<span class="symbol">:__struct__</span>, <span class="symbol">:age</span>, <span class="symbol">:name</span>]</div></pre></td></tr></table></figure>
<p>结构和协议为Elixir开发者提供了最重要的特征之一：数据多态性。这是我们下一章将要探索的。</p>
<h1 id="默认值和所需的键"><a href="#默认值和所需的键" class="headerlink" title="默认值和所需的键"></a><span id="part-four">默认值和所需的键</span></h1><p>如果在定义结构体的时候你没有指定一个键的默认值，则nil将被当做它的默认值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Product</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   defstruct [<span class="symbol">:name</span>]</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; %Product&#123;&#125;</div><div class="line">%Product&#123;<span class="symbol">name:</span> <span class="keyword">nil</span>&#125;</div></pre></td></tr></table></figure>
<p>你也可以强制在创建结构体的时候某些键必需被指定：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Car</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="variable">@enforce_keys</span> [<span class="symbol">:make</span>]</div><div class="line">...&gt;   defstruct [<span class="symbol">:model</span>, <span class="symbol">:make</span>]</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; %Car&#123;&#125;</div><div class="line">** (ArgumentError) the following keys must also be given <span class="keyword">when</span> building struct <span class="symbol">Car:</span> [<span class="symbol">:make</span>]</div><div class="line">    expanding <span class="symbol">struct:</span> Car.__struct_<span class="number">_</span>/<span class="number">1</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/structs.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/structs.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;定义结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;访问和修改结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;结构体的底层是裸映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;默认值和所需的键&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在第七章我们学了映射：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; map = %&amp;#123;&lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;b:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;b:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; map[&lt;span class=&quot;symbol&quot;&gt;:a&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; %&amp;#123;map | &lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;b:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结构体是构建于映射之上的扩展，它提供了编译时检查和默认值。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="struct" scheme="http://szpzs.oschina.io/categories/Elixir/struct/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="struct" scheme="http://szpzs.oschina.io/tags/struct/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－模块属性</title>
    <link href="http://szpzs.oschina.io/2017/02/09/elixir-getting-started-module-attributes/"/>
    <id>http://szpzs.oschina.io/2017/02/09/elixir-getting-started-module-attributes/</id>
    <published>2017-02-09T12:45:15.000Z</published>
    <updated>2017-02-09T12:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">作为注释</a></li>
<li><a href="#part-two">作为常量</a></li>
<li><a href="#part-three">作为临时存储</a></li>
</ol>
<p>在Elixir里，模块属性服务于三个目标：</p>
<ul>
<li>它们常常用一些信息来注释模块被用户或Erlang虚拟机使用。</li>
<li>它们用作常量。</li>
<li>它们被用于编译期间临时模块存储。</li>
</ul>
<p>让我们一个一个地来仔细看看这三个方面。</p>
<a id="more"></a>
<h1 id="作为注释"><a href="#作为注释" class="headerlink" title="作为注释"></a><span id="part-one">作为注释</span></h1><p>Elixr从Erlang那里带来了模块属性这个概念。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@vsn</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在上面的例子里，我们显式地设置模块的版本属性。@vsn 被Erlang虚拟机的代码重装载机制用来检查模块是否已经更新。如果没有指定版本，版本被设置为模块函数的MD5码校验和。</p>
<p>Elixir有一些保留的属性。下面介绍几个最常用的：</p>
<ul>
<li>@moduledoc - 为当前模块提供文档。</li>
<li>@doc - 为紧跟该属性的函数或宏提供文档。</li>
<li>@behaviour - （注意英式拼写）用于指定一个OTP或用户自定义的行为。</li>
<li>@before_compile - 提供一个模块被编译前将被调用的钩子。这使得在编译前确切地注入函数到模块里成为可能。</li>
</ul>
<p>@moduledoc 和 @doc 是到目前为止用得最多的属性，我们希望你大量使用它们。Elixir把文档当做一等公民并且提供许多函数访问文档。你可以参阅<a href="https://hexdocs.pm/elixir/writing-documentation.html" target="_blank" rel="external">我们官方文档里的关于在Elixir里写文档</a>这篇文章来获得更多信息。</p>
<p>我们回到前面章节里定义的Math模块，增加一些文档然后保存到math.ex文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Provides math-related functions.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      iex&gt; Math.sum(1, 2)</div><div class="line">      3</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Calculates the sum of two numbers.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b), <span class="symbol">do:</span> a + b</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Elixir推荐用Markdown加上heredoc来写易于阅读的文档。Heredocs是多行字符串，它们起始都是三个双引号，并且保持内部文本的格式。我们可以从IEx里直接访问任何已经编译的文档：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ elixirc math.ex</div><div class="line">$ iex</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; h Math <span class="comment"># Access the docs for the module Math</span></div><div class="line">...</div><div class="line">iex&gt; h Math.sum <span class="comment"># Access the docs for the sum function</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们也提供了一个叫<a href="https://github.com/elixir-lang/ex_doc" target="_blank" rel="external">ExDoc</a>的工具来将文档生成HTML页面。</p>
<p>你可以查阅Module模块的文档来得到一个所支持属性的完整列表。Elixir也用属性来定义 <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html" target="_blank" rel="external">typespec</a> 。</p>
<p>本部分覆盖了内置的属性。但是，属性也能被开发者使用或者被库扩展来支持自定义行为。</p>
<h1 id="作为常量"><a href="#作为常量" class="headerlink" title="作为常量"></a><span id="part-two">作为常量</span></h1><p>Elixir开发者将经常使用模块属性作为常量。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@initial_state</span> %&#123;<span class="symbol">host:</span> <span class="string">"147.0.0.1"</span>, <span class="symbol">port:</span> <span class="number">3456</span>&#125;</div><div class="line">  IO.inspect <span class="variable">@initial_state</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：和Erlang不同，用户定义的属性默认不存储在模块里。属性的值只是在编译的时候存在。开发者可以通过调用 Module.register_attribute/3 设置一个属性来使得行为更接近Erlang。</p>
</blockquote>
<p>试图访问没有定义的属性将打印一个警告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@unknown</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="symbol">warning:</span> undefined <span class="keyword">module</span> attribute <span class="variable">@unknown</span>, please remove access to <span class="variable">@unknown</span> <span class="keyword">or</span> explicitly set it before access</div></pre></td></tr></table></figure>
<p>最后，属性也可以在函数里被读取：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@my_data</span> <span class="number">14</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">first_data</span></span>, <span class="symbol">do:</span> <span class="variable">@my_data</span></div><div class="line">  <span class="variable">@my_data</span> <span class="number">13</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">second_data</span></span>, <span class="symbol">do:</span> <span class="variable">@my_data</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyServer.first_data <span class="comment">#=&gt; 14</span></div><div class="line">MyServer.second_data <span class="comment">#=&gt; 13</span></div></pre></td></tr></table></figure>
<p>每次在函数里读取一个属性，获取到的是这个属性值的当前快照。换句话说，该值在编译时读取，而不是在运行时读取。正如我们将要看到的，这也使得在模块编译时用作存储的属性非常有用。</p>
<h1 id="作为临时存储"><a href="#作为临时存储" class="headerlink" title="作为临时存储"></a><span id="part-three">作为临时存储</span></h1><p>Elixir组织里有一个项目：<a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a>，它就是要建立Elixir中web库和框架的共同基础。</p>
<p>Plug库也允许开发者定义他们自己的能在web服务器里运行的插件：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyPlug</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Plug.Builder</div><div class="line"></div><div class="line">  plug <span class="symbol">:set_header</span></div><div class="line">  plug <span class="symbol">:send_ok</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_header</span></span>(conn, _opts) <span class="keyword">do</span></div><div class="line">    put_resp_header(conn, <span class="string">"x-header"</span>, <span class="string">"set"</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">send_ok</span></span>(conn, _opts) <span class="keyword">do</span></div><div class="line">    send(conn, <span class="number">200</span>, <span class="string">"ok"</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts <span class="string">"Running MyPlug with Cowboy on http://localhost:4000"</span></div><div class="line">Plug.Adapters.Cowboy.http MyPlug, []</div></pre></td></tr></table></figure>
<p>在上面的例子里，我们已经用 plug/1 宏来链接当有web请求的时候将被调用的那些函数。在内部，每次你调用 plug/1，Plug库存储给定的参数到一个 @plugs 属性里。仅在模块被编译前，Plug运行一个回调来定义一个函数（call/2）处理HTTP请求。这个函数将按顺序运行@plugs属性里的所有插件。</p>
<p>为了理解底层的代码，我们需要宏，所以我们将在元编程指导里对这个模式进行回顾。但是此刻我们关注的是如何用模块属性作为存储来允许开发者创建DLS（领域特定语言）。</p>
<p>另一个例子来自<a href="https://hexdocs.pm/ex_unit/" target="_blank" rel="external">ExUnit框架</a>，它用模块属性来作为注释和存储：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line"></div><div class="line">  <span class="variable">@tag</span> <span class="symbol">:external</span></div><div class="line">  test <span class="string">"contacts external service"</span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在ExUnit里标签被用来注释测试用例。标签后续可以用来过滤测试用例。例如，你可以避免在你的本机上运行外部测试用例，因为它们缓慢并且依赖其他服务，尽管在你的构建系统里它们仍然是可用的。</p>
<p>我希望这部分内容让你大概了解Elixir如何支持元编程，以及当进行元编程的时候模块属性如何扮演一个重要角色。</p>
<p>在后面的章节，我们将探索结构和协议，然后再探索异常处理和其他结构，比如印记和列表解析。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/module-attributes.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/module-attributes.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;作为注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;作为常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;作为临时存储&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir里，模块属性服务于三个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们常常用一些信息来注释模块被用户或Erlang虚拟机使用。&lt;/li&gt;
&lt;li&gt;它们用作常量。&lt;/li&gt;
&lt;li&gt;它们被用于编译期间临时模块存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们一个一个地来仔细看看这三个方面。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="module-attribute" scheme="http://szpzs.oschina.io/categories/Elixir/module-attribute/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="module-attribute" scheme="http://szpzs.oschina.io/tags/module-attribute/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－alias、require、和import</title>
    <link href="http://szpzs.oschina.io/2017/02/08/elixir-getting-started-alias-require-and-import/"/>
    <id>http://szpzs.oschina.io/2017/02/08/elixir-getting-started-alias-require-and-import/</id>
    <published>2017-02-08T07:33:12.000Z</published>
    <updated>2017-02-08T07:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">alias</a></li>
<li><a href="#part-two">require</a></li>
<li><a href="#part-three">import</a></li>
<li><a href="#part-four">use</a></li>
<li><a href="#part-five">理解alias</a></li>
<li><a href="#part-six">模块嵌套</a></li>
<li><a href="#part-seven">多重 alias/import/require/use</a></li>
</ol>
<p>为了便于软件重用，Elixir提供了三个指令（alias、require和import）外加一个叫做use的宏。如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 别名一个模块则它可以被叫做Bar而不是Foo.Bar</span></div><div class="line"><span class="keyword">alias</span> Foo.Bar, <span class="symbol">as:</span> Bar</div><div class="line"></div><div class="line"><span class="comment"># 确认这个模块是编译好的并且可用的（常常使用于宏）</span></div><div class="line">require Foo</div><div class="line"></div><div class="line"><span class="comment"># 从Foo导入函数，所以它们被调用可以不需要 Foo. 这个前缀</span></div><div class="line">import Foo</div><div class="line"></div><div class="line"><span class="comment"># 调用Foo里作为一个扩展点定义的代码。</span></div><div class="line"><span class="keyword">use</span> Foo</div></pre></td></tr></table></figure>
<p>我们现在将详细地探讨它们。记住前三个被叫做指令因为它们有作用范围，而use是一个常见的扩展点。</p>
<a id="more"></a>
<h1 id="alias"><a href="#alias" class="headerlink" title="alias"></a><span id="part-one">alias</span></h1><p>alias允许你给任何给定的模块设置别名。</p>
<p>假设一个模块使用 Math.List 里实现的一个特殊列表。alias 指令允许在模块定义里只使用List来指代Math.List：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Stats</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">alias</span> Math.List, <span class="symbol">as:</span> List</div><div class="line">  <span class="comment"># 在模块的后续的定义里，List将展开为Math.List。</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>原来的List依然可以通过完全限定名Elixir.List在模块Stats里访问。</p>
<blockquote>
<p>注意：定义在Elixir里所有的模块定义在Elixir命名空间里。但是，为了方便，当引用它们的时候你可以省略“Elixir.”。</p>
</blockquote>
<p>别名常被用来定义快捷方式。实际上，调用 alias 而不用 :as 选项，则自动将别名设置为模块名的最后一部分，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> Math.List</div></pre></td></tr></table></figure>
<p>和如下的代码是一样的效果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> Math.List, <span class="symbol">as:</span> List</div></pre></td></tr></table></figure>
<p>注意：alias 是有作用范围的，它允许你在特定的函数里设置别名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    <span class="keyword">alias</span> Math.List</div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minus</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的例子里，因为我们在 plus/2 里调用 alias ，别名将只在 plus/2 里有效，minus/2 将一点也不受影响。</p>
<h1 id="require"><a href="#require" class="headerlink" title="require"></a><span id="part-two">require</span></h1><p>Elixir提供宏作为元编程（写代码来生成代码）的一种机制。</p>
<p>宏是一段代码，它在代码编译的时候被执行和展开。这意味着，为了使用宏，我们需要保证在编译期间它的模块和实现是可用的。这可以用 require 指令来完成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Integer.is_odd(<span class="number">3</span>)</div><div class="line">** (UndefinedFunctionError) function Integer.is_odd/<span class="number">1</span> is undefined <span class="keyword">or</span> private. However there is a macro with the same name <span class="keyword">and</span> arity. Be sure to require Integer if you intend to invoke this macro</div><div class="line">iex&gt; require Integer</div><div class="line">Integer</div><div class="line">iex&gt; Integer.is_odd(<span class="number">3</span>)</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>在Elixir里，Integer.is_odd/1 被定义成为一个宏，所以它可以被用来作为一个卫语句。也就是说，为了调用 Integer.is_odd/1 ，我们首先需要 require Integer模块。</p>
<p>总而言之，一个模块在使用前是不需要被 require 的，除非是我们想要使得模块里的宏可用。尝试调用一个没有被装载的宏将引起一个错误。注意，像 alias 指令，require 也是有作用范围的。我们将在后面的章节更深入地讨论宏。</p>
<h1 id="import"><a href="#import" class="headerlink" title="import"></a><span id="part-three">import</span></h1><p>在任何时候我们想不用完全限定名称而方便地访问其他模块的函数或宏，我们就用 import 。例如，如果我们想用 List 里的 duplicate/2 几次，我们可以 import 它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; import List, <span class="symbol">only:</span> [<span class="symbol">duplicate:</span> <span class="number">2</span>]</div><div class="line">List</div><div class="line">iex&gt; duplicate <span class="symbol">:ok</span>, <span class="number">3</span></div><div class="line">[<span class="symbol">:ok</span>, <span class="symbol">:ok</span>, <span class="symbol">:ok</span>]</div></pre></td></tr></table></figure>
<p>在这个例子里，我们仅从List里导入函数duplicate（只有两个入参）。虽然 :only 是可选的，但是为了避免将给定模块的所有函数都导入到命名空间里，这个用法是被推荐使用的。:except 也可以作为选项被设置，它的作用是为了导入一个模块里 <em>除了</em> 一些函数外其他所有函数。</p>
<p>import 也支持把 :macros 和 :functions 给 :only 选项。例如，导入模块的所有宏，可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Integer, <span class="symbol">only:</span> <span class="symbol">:macros</span></div></pre></td></tr></table></figure>
<p>或者导入模块的所有函数，你可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Integer, <span class="symbol">only:</span> <span class="symbol">:functions</span></div></pre></td></tr></table></figure>
<p>注意：import也是有作用范围的。这意味着我们可以在函数定义里导入特定的宏和函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">some_function</span></span> <span class="keyword">do</span></div><div class="line">    import List, <span class="symbol">only:</span> [<span class="symbol">duplicate:</span> <span class="number">2</span>]</div><div class="line">    duplicate(<span class="symbol">:ok</span>, <span class="number">10</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述例子，被导入的 List.duplicate/2 只在特定的函数里才可见。duplicate/2 在这个模块（就这个问题而言，在任何其他模块）里的任何其他函数都不可用。</p>
<p>注意：<em>import</em> 一个模块自动就 <em>require</em> 它了</p>
<h1 id="use"><a href="#use" class="headerlink" title="use"></a><span id="part-four">use</span></h1><p>虽然不是指令，use却是与require紧密相关的一个宏，它允许你在当前上下文里使用一个模块。这个 use 宏常常被开发者用来把外部功能带入当前作用范围，经常是模块。</p>
<p>例如，为了用 ExUnit 框架写测试，开发者应该使用 ExUnit.Case 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">AssertionTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"always pass"</span> <span class="keyword">do</span></div><div class="line">    assert <span class="keyword">true</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>背后的原理是，use require 给定的模块然后在它上面调用 __using/1__ 回调函数来允许这个模块注入一些代码到当前上下文。通常来说，如下的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Feature, <span class="symbol">option:</span> <span class="symbol">:value</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>被编译成如下样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  require Feature</div><div class="line">  Feature.__using_<span class="number">_</span>(<span class="symbol">option:</span> <span class="symbol">:value</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="理解alias"><a href="#理解alias" class="headerlink" title="理解alias"></a><span id="part-five">理解alias</span></h1><p>到此，你可能想知道：Elixir的别名到底是什么？它是如何表示的？</p>
<p>Elixir里的一个别名是一个大写开头的标识符（像String，Keyword，等等），在编译的时候它被转换成一个原子。例如，String 这个别名默认情况下被转换为 :”Elixir.String” ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_atom(String)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; to_string(String)</div><div class="line"><span class="string">"Elixir.String"</span></div><div class="line">iex&gt; <span class="symbol">:<span class="string">"Elixir.String"</span></span> == String</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>通过用 alias/2 指令，我们改变了别名所要转换成的原子。</p>
<p>别名转换为原子是因为在Erlang虚拟机里（也是Elixir里）模块总是用原子来表示。例如，如下就是我们用来调用Erlang模块的机制：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:lists</span>.flatten([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<h1 id="模块嵌套"><a href="#模块嵌套" class="headerlink" title="模块嵌套"></a><span id="part-six">模块嵌套</span></h1><p>现在我们已经讨论了别名，我们可以讨论嵌套和它在Elixir里是如何运作的。考虑一下如下例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Foo</span></span> <span class="keyword">do</span></div><div class="line">  <span class="class"><span class="keyword">defmodule</span> <span class="title">Bar</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的例子将定义两个模块：Foo 和 Foo.Bar 。第二个模块可以在Foo里以Bar来访问只要它们在相同的作用范围里。上面的代码和下面的代码完全一样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Elixir</span></span>.Foo <span class="keyword">do</span></div><div class="line">  <span class="class"><span class="keyword">defmodule</span> <span class="title">Elixir</span></span>.Foo.Bar <span class="keyword">do</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="keyword">alias</span> Elixir.Foo.Bar, <span class="symbol">as:</span> Bar</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果，以后，Bar 模块被移到Foo模块定义的外面，它必须用完全限定名称（Foo.Bar）引用或者一个别名必须用前面讨论过的alias指令来设置。</p>
<p>注意：在Elixir里，你不必在定义Foo.Bar模块前必须要定义Foo模块，因为Elixir转换所有模块名字为原子。你可以定义任意嵌套的模块而不需要定义链上的任何模块（比如，定义Foo.Bar.Baz而没有先定义Foo或Foo.Bar）。</p>
<p>正如我们将在后面章节看到的，别名在宏里也扮演了一个至关重要的角色，来保证宏的整洁。</p>
<h1 id="多重-alias-import-require-use"><a href="#多重-alias-import-require-use" class="headerlink" title="多重 alias/import/require/use"></a><span id="part-seven">多重 alias/import/require/use</span></h1><p>从Elixir v1.2开始，一次 alias、 import 或 require 多个模块是可能的。当我们开始嵌套模块这是特别有用的，当构建Elixir的应用程序时这是很常见的。例如，假设你有一个应用，所有模块都嵌套在MyApp下，你可以如下面例子一样一次性为MyApp.Foo，MyApp.Bar 和 MyApp.Baz指定别名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> MyApp.&#123;Foo, Bar, Baz&#125;</div></pre></td></tr></table></figure>
<p>我们已经完成了我们的Elixir模块之旅。最后一个主题是模块属性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/alias-require-and-import.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/alias-require-and-import.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;alias&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;require&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;import&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;use&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;理解alias&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;模块嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;多重 alias/import/require/use&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了便于软件重用，Elixir提供了三个指令（alias、require和import）外加一个叫做use的宏。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 别名一个模块则它可以被叫做Bar而不是Foo.Bar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;alias&lt;/span&gt; Foo.Bar, &lt;span class=&quot;symbol&quot;&gt;as:&lt;/span&gt; Bar&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 确认这个模块是编译好的并且可用的（常常使用于宏）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;require Foo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 从Foo导入函数，所以它们被调用可以不需要 Foo. 这个前缀&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import Foo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 调用Foo里作为一个扩展点定义的代码。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; Foo&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们现在将详细地探讨它们。记住前三个被叫做指令因为它们有作用范围，而use是一个常见的扩展点。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="alias require import" scheme="http://szpzs.oschina.io/categories/Elixir/alias-require-import/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="alias" scheme="http://szpzs.oschina.io/tags/alias/"/>
    
      <category term="require" scheme="http://szpzs.oschina.io/tags/require/"/>
    
      <category term="import" scheme="http://szpzs.oschina.io/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－IO和文件系统</title>
    <link href="http://szpzs.oschina.io/2017/02/07/elixir-getting-started-io-and-the-file-system/"/>
    <id>http://szpzs.oschina.io/2017/02/07/elixir-getting-started-io-and-the-file-system/</id>
    <published>2017-02-07T13:24:28.000Z</published>
    <updated>2017-02-07T13:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">IO模块</a></li>
<li><a href="#part-two">File模块</a></li>
<li><a href="#part-three">Path模块</a></li>
<li><a href="#part-four">进程和组领导</a></li>
<li><a href="#part-five">iodata和chardata</a></li>
</ol>
<p>本章是对输入/输出机制和文件系统相关的任务以及相关模块，比如：<a href="https://hexdocs.pm/elixir/IO.html" target="_blank" rel="external">IO</a>、<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File</a>和<a href="https://hexdocs.pm/elixir/Path.html" target="_blank" rel="external">Path</a>的快速介绍。</p>
<p>我们原本计划这章在本系列教程中更早地出现。然而，我们注意到 IO 系统提供一个非常好的机会来阐明Elixir和VM的一些哲学和奇特之处。</p>
<a id="more"></a>
<h1 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a><span id="part-one">IO模块</span></h1><p>IO模块是Elixir里读写标准输入输出（:stdio）、标准错误（:stderr）、文件和其他IO设备的主要机制。这个模块的使用方式非常简单：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">"hello world"</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.gets <span class="string">"yes or no? "</span></div><div class="line">yes <span class="keyword">or</span> no? yes</div><div class="line"><span class="string">"yes\n"</span></div></pre></td></tr></table></figure>
<p>默认情况下，IO模块的函数从标准输入读数据并往标准输出写数据。我们可以改变这个默认方式，例如，通过传递 :stderr 作为一个入参（来写数据到标准错误）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="symbol">:stderr</span>, <span class="string">"hello world"</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<h1 id="File模块"><a href="#File模块" class="headerlink" title="File模块"></a><span id="part-two">File模块</span></h1><p>File模块包含函数允许我们打开文件当做IO文件。默认地，文件以二进制模式打开，这些文件就需要开发者使用IO模式的特定函数 IO.binread/2 和 IO.binwrite/2 来读写。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"hello"</span>, [<span class="symbol">:write</span>]</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.47.0&gt;&#125;</span></div><div class="line">iex&gt; IO.binwrite file, <span class="string">"world"</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.close file</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>文件也可以用 :utf8 编码方式打开，这就告诉File模块解析从文件读取的字节为UTF-8编码的字节。</p>
<p>除了打开、读写文件的函数，File模块还有许多处理文件系统的函数。那些函数命名方式和Unix的函数相对应。例如，File.rm/1 可以用来删除文件，File.mkdir/1 用来创建目录，File.mkdir_p/1 用来创建目录和它所有的父目录。甚至还有 File.cp_r/2 和 File.rm_rf/1 ，分别递归地拷贝和删除文件和目录（即也复制和删除目录的内容）。</p>
<p>你可能也注意到了File模块里的函数有两种类型：一种是“正常”的，另一种是尾部有一个!号的。例如，上面例子里当我们读”hello”文件的时候，我们使用 File.read/1 。相应地，我们可以用File.read!/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; File.read! <span class="string">"hello"</span></div><div class="line"><span class="string">"world"</span></div><div class="line">iex&gt; File.read <span class="string">"unknown"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:enoent</span>&#125;</div><div class="line">iex&gt; File.read! <span class="string">"unknown"</span></div><div class="line">** (File.Error) could <span class="keyword">not</span> read file <span class="string">"unknown"</span>: no such file <span class="keyword">or</span> directory</div></pre></td></tr></table></figure>
<p>注意：带叹号的版本返回文件的内容而不是元组，而如果有任何错误，这个函数就抛出一个错误。</p>
<p>当你想要用模式匹配处理不同的输出的时候，不带叹号的版本是首选：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> File.read(file) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, body&#125;      -&gt; <span class="comment"># do something with the `body`</span></div><div class="line">  &#123;<span class="symbol">:error</span>, reason&#125; -&gt; <span class="comment"># handle the error caused by `reason`</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>但是，如果你期望文件就在那里，带叹号版本更加有用，因为它抛出有意义的错误。避免这样写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, body&#125; = File.read(file)</div></pre></td></tr></table></figure>
<p>因为，一旦有错误，File.read/1 将返回 {:error, reason} 而且模式匹配将失败。你将仍然得到你想要的结果（一个抛出的错误），但是消息却是关于没有匹配上的模式（因此，错误实际上是什么就显得很神秘）。</p>
<p>因此，如果你不想处理错误结果，就优先使用 File.read!/1 。</p>
<h1 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a><span id="part-three">Path模块</span></h1><p>File模块里的绝大多数函数都期望用路径做入参。最常见的是，这些路径将是普通二进制数据。Path模块提供处理这样路径的工具：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Path.join(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</div><div class="line"><span class="string">"foo/bar"</span></div><div class="line">iex&gt; Path.expand(<span class="string">"~/hello"</span>)</div><div class="line"><span class="string">"/Users/jose/hello"</span></div></pre></td></tr></table></figure>
<p>使用Path模块的函数，而不是直接操纵字符串是首选，因为Path模块透明地处理不同的操作系统之间的差异。最后，记住当在Windows执行文件操作的时候，Elixir将自动将斜线（/）转成反斜线（\）。</p>
<p>到此，我们已经讲完了Elixir提供的处理IO和与文件系统交互的主要模块。下面的部分，我们将讨论关于IO的一些高级话题。这些部分不是写Elixir代码所必需的，因此可以略过它们，不过它们对VM里IO系统是如何实现的以及其他特性提供了一个好的概貌。</p>
<h1 id="进程和组领导"><a href="#进程和组领导" class="headerlink" title="进程和组领导"></a><span id="part-four">进程和组领导</span></h1><p>你可能已经注意到 File.open/2 返回一个元组 {:ok, pid} ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"hello"</span>, [<span class="symbol">:write</span>]</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.47.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>之所以是如此，是因为IO模块实际上是和进程打交道（参见<a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">11章</a>）。当你写 IO.write(pid, binary) 的时候，IO模块将发送一个消息给被pid标识的进程，消息里同时带着期望的操作。让我们看看如果我们用我们自己的进程会发生什么：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = spawn <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;  receive <span class="symbol">do:</span> (msg -&gt; IO.inspect msg)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.57.0&gt;</span></div><div class="line">iex&gt; IO.write(pid, <span class="string">"hello"</span>)</div><div class="line">&#123;<span class="symbol">:io_request</span>, <span class="comment">#PID&lt;0.41.0&gt;, #Reference&lt;0.0.8.91&gt;,</span></div><div class="line"> &#123;<span class="symbol">:put_chars</span>, <span class="symbol">:unicode</span>, <span class="string">"hello"</span>&#125;&#125;</div><div class="line">** (ErlangError) erlang <span class="symbol">error:</span> <span class="symbol">:terminated</span></div></pre></td></tr></table></figure>
<p>上述例子中，在 IO.write/2 后，我们可以看到IO模块发送的请求（四元素元组）被打印出来。紧跟其后，我们看到了失败，因为IO模块所期望的结果我们没有支持。</p>
<p><a href="https://hexdocs.pm/elixir/StringIO.html" target="_blank" rel="external">StringIO</a>模块提供了基于字符串之上的IO设备消息的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = StringIO.open(<span class="string">"hello"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; IO.read(pid, <span class="number">2</span>)</div><div class="line"><span class="string">"he"</span></div></pre></td></tr></table></figure>
<p>通过用进程模型化IO设备，Erlang虚拟机允许同一个网络里的不同节点互访文件进程来在不同节点间读写文件。在所有IO设备中，有一个对所有进程都很特别，就是：<strong>组领导</strong>。</p>
<p>当你写数据给 :stdio 的时候，你实际上是发消息给组领导，由它写数据给标注输出文件描述符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="symbol">:stdio</span>, <span class="string">"hello"</span></div><div class="line">hello</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.puts Process.group_leader, <span class="string">"hello"</span></div><div class="line">hello</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>每个进程都可以配置组领导，组领导在不同的情况下使用。例如，当在一个远程终端上执行代码，它保证远程节点上的消息被重定向并打印在触发请求的终端上。</p>
<h1 id="iodata和chardata"><a href="#iodata和chardata" class="headerlink" title="iodata和chardata"></a><span id="part-five">iodata和chardata</span></h1><p>在上面所有的例子里，当写数据到文件的时候，我们使用二进制数据。在“二进制数据、字符串和字符列表”那一章，我们提到字符串是怎样由二进制数据构成而字符列表unicode代码点的列表。</p>
<p>IO模块和File模块里的函数也允许列表作为入参。不仅如此，它们也运行混合列表，列表里包含整数和二进制数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">'hello world'</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.puts [<span class="string">'hello'</span>, ?\s, <span class="string">"world"</span>]</div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然而，在IO操作中使用列表需要一些注意。一个列表可能表示一串二进制数据或者一串字符，而到底使用哪一个依赖于IO设备的编码。如果一个文件没有指定编码方式打开，它被期望是原始模式，则IO模块里以 bin* 开头的函数就必须被使用。这些函数期望一个 iodata 作为入参，也就是，它们期望一个表示字节和二进制数据的整数列表被传入。</p>
<p>另一方面，:stdio 和以 :utf8 编码打开的文件将用其余的IO模块中的函数处理。这些函数期望一个 char_data 作为入参，也就是，一个字符或者字符串列表。</p>
<p>虽然这是一个微妙的区别，你只需要担心这些细节，如果你打算传递列表给这些函数。二进制数据已经由底层字节表示，因此它们的表示总是“原始”的。</p>
<p>到此我们结束了IO设备和IO相关功能之旅。我们已经学了四个Elixir模块：<a href="https://hexdocs.pm/elixir/IO.html" target="_blank" rel="external">IO</a>、<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File</a>、<a href="https://hexdocs.pm/elixir/Path.html" target="_blank" rel="external">Path</a>和<a href="https://hexdocs.pm/elixir/StringIO.html" target="_blank" rel="external">StringIO</a>，也学了Erlang虚拟机如何用进程来处理底层IO机制以及如何使用 chardata  和 iodata 来进行IO操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/io-and-the-file-system.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;IO模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;File模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Path模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;进程和组领导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;iodata和chardata&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是对输入/输出机制和文件系统相关的任务以及相关模块，比如：&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;IO&lt;/a&gt;、&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;File&lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;Path&lt;/a&gt;的快速介绍。&lt;/p&gt;
&lt;p&gt;我们原本计划这章在本系列教程中更早地出现。然而，我们注意到 IO 系统提供一个非常好的机会来阐明Elixir和VM的一些哲学和奇特之处。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="io" scheme="http://szpzs.oschina.io/categories/Elixir/io/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="io" scheme="http://szpzs.oschina.io/tags/io/"/>
    
      <category term="file system" scheme="http://szpzs.oschina.io/tags/file-system/"/>
    
      <category term="Path" scheme="http://szpzs.oschina.io/tags/Path/"/>
    
      <category term="StringIO" scheme="http://szpzs.oschina.io/tags/StringIO/"/>
    
      <category term="group leader" scheme="http://szpzs.oschina.io/tags/group-leader/"/>
    
      <category term="iodata" scheme="http://szpzs.oschina.io/tags/iodata/"/>
    
      <category term="chardata" scheme="http://szpzs.oschina.io/tags/chardata/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－进程</title>
    <link href="http://szpzs.oschina.io/2017/02/06/elixir-getting-started-processes/"/>
    <id>http://szpzs.oschina.io/2017/02/06/elixir-getting-started-processes/</id>
    <published>2017-02-06T14:46:57.000Z</published>
    <updated>2017-02-06T14:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">创建进程</a></li>
<li><a href="#part-two">发送和接收消息</a></li>
<li><a href="#part-three">链接</a></li>
<li><a href="#part-four">任务</a></li>
<li><a href="#part-five">状态</a></li>
</ol>
<p>在Elixir，所有代码运行在进程里。进程彼此间隔离，彼此间并发运行，并且通过消息传递来交流。进程不仅是Elixir的并发基础，它也为构建分布式和容错程序提供手段。</p>
<p>Elixir的进程不应该和操作系统的进程混淆。Elixir的进程就内存和CPU的消耗来说是极其轻量的（不同于许多其他编程语言中的线程）。正因如此，成千上万的进程同时运行是很平常的。</p>
<p>在本章里，我们将学习关于创建新进程的基本结构以及进程间收发消息。</p>
<a id="more"></a>
<h1 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a><span id="part-one">创建进程</span></h1><p>创建新进程的基本机制是自动导入的 spawn/1  函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; <span class="number">1</span> + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.43.0&gt;</span></div></pre></td></tr></table></figure>
<p>spawn/1 的入参是一个函数，这个函数将在另一个进程里执行。</p>
<p>注意 spawn/1 返回一个PID（进程标识符）。像如上的例子，你产生的过程很可能是死的。被创建的进程将执行给定的函数，并且在函数结束后退出。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = spawn <span class="keyword">fn</span> -&gt; <span class="number">1</span> + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.44.0&gt;</span></div><div class="line">iex&gt; Process.alive?(pid)</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：你将很可能获得一个不同于我们这个例子里获得的进程标识符。</p>
</blockquote>
<p>我们可以调用 self/0 来获取当前进程的PID：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">self</span>()</div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line">iex&gt; Process.alive?(<span class="keyword">self</span>())</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>当我们能够发送和接收消息时，进程变得更加有趣。</p>
<h1 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a><span id="part-two">发送和接收消息</span></h1><p>我们可以用 send/2 发送消息给一个进程并且可以用 receive/1 接收消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; send <span class="keyword">self</span>(), &#123;<span class="symbol">:hello</span>, <span class="string">"world"</span>&#125;</div><div class="line">&#123;<span class="symbol">:hello</span>, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, msg&#125; -&gt; msg</div><div class="line">...&gt;   &#123;<span class="symbol">:world</span>, msg&#125; -&gt; <span class="string">"won't match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>当一条消息发送给一个进程，这个消息存储在进程的邮箱里。receive/1 语句块遍历当前邮箱来查找任何匹配给定模式的消息。receive/1 支持卫语句和许多分支，就如 case/2 一样。</p>
<p>发送消息的进程不会阻塞在 send/2 上，它只是将消息放入接收者的邮箱然后继续执行后面的语句。特别是，进程可以给自己发送消息。在上面的例子里，当 receive 语句块获得执行的时候，发送者进程可能已经死掉了。</p>
<p>如果没有邮箱里的消息匹配任何模式，则当前进程将等待一直到一个匹配的消息到来。超时也可以被指定：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, msg&#125;  -&gt; msg</div><div class="line">...&gt; after</div><div class="line">...&gt;   <span class="number">1_000</span> -&gt; <span class="string">"nothing after 1s"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"nothing after 1s"</span></div></pre></td></tr></table></figure>
<p>当你已经期待的消息已经在邮箱里的时候，可以将超时设置为0。</p>
<p>让我们把这些放在一起并在进程间发送消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; parent = <span class="keyword">self</span>()</div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; send(parent, &#123;<span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;) <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.48.0&gt;</span></div><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, pid&#125; -&gt; <span class="string">"Got hello from <span class="subst">#&#123;inspect pid&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got hello from #PID&lt;0.48.0&gt;"</span></div></pre></td></tr></table></figure>
<p>当在使用shell的时候，你可能发现帮助函数 flush/0 非常有用。它刷新并打印邮箱里的所有消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; send <span class="keyword">self</span>(), <span class="symbol">:hello</span></div><div class="line"><span class="symbol">:hello</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:hello</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><span id="part-three">链接</span></h1><p>在Elixir里最通用的创建进程的方式实际上是用 spawn_link/1 函数。在我们展示 spawn_link/1 的例子之前，让我们尝试看看当一个进程失败的时候会发生什么：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.58.0&gt;</span></div><div class="line"></div><div class="line">[error] Process <span class="comment">#PID&lt;0.58.00&gt; raised an exception</span></div><div class="line">** (RuntimeError) oops</div><div class="line">    <span class="symbol">:erlang</span>.apply/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>它只是记录一个错误，而创建者依然运行。这是因为进程间是隔离的。如果我们想一个进程的失败会传递给另一个进程，我们应该将它们链接在一起。这可以用 spawn_link/1 来做到：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn_link <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line"></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.41.0&gt;) an exception was raised:</span></div><div class="line">    ** (RuntimeError) oops</div><div class="line">        <span class="symbol">:erlang</span>.apply/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>当在shell里发生一个失败，shell自动地捕获这个失败并以合适的格式展现出来。为了理解在我们的代码里到底将发生什么，让我们在一个文件里使用 spawn_link/1 ，并运行它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># spawn.exs</span></div><div class="line">spawn_link <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">receive <span class="keyword">do</span></div><div class="line">  <span class="symbol">:hello</span> -&gt; <span class="string">"let's wait until the process fails"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ elixir spawn.exs</div><div class="line"></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.47.0&gt;) an exception was raised:</span></div><div class="line">    ** (RuntimeError) oops</div><div class="line">        spawn.exs:1: anonymous fn/0 <span class="keyword">in</span> :elixir_compiler_0.__FILE__/1</div></pre></td></tr></table></figure>
<p>这一次，进程失败并且把它的父进程也搞垮了，因为它们是链接的。链接也可以通过调用 Process.link/1 来手工做到。我们建议你看一下 Process 模块来研究进程提供的其他功能。</p>
<p>当构建容错系统的时候，进程和链接扮演重要角色。在Elixir的应用里，我们经常链接我们的进程到一个监督者，当一个进程死掉的时候，这个监督者可以检测到，并且在那个地方启动一个新进程。这是唯一可能的，因为进程是隔离的，默认情况下不共享任何东西。并且因为进程是隔离的，因此没有方法在一个进程失败的时候崩溃或破坏另一个进程的状态。</p>
<p>其他语言需要我们捕获和处理异常，而在Elixir里，我们实际上是乐于让进程失败，因为我们期望监督者正确地重新启动我们的系统。当我们写Elixir程序的时候，“快速失败”是一种常见的哲学！</p>
<p>在Elixir里，spawn/1 和 spawn_link/1 是创建进程的基本命令。虽然目前为止我们只使用了它们两个，但是绝大多数时候我们将使用构建于它们之上的抽象。让我们看看这些抽象中最常用的一个，它叫做任务。</p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a><span id="part-four">任务</span></h1><p>任务构建在创建进程函数之上，以提供更好的错误报告和内省：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex(<span class="number">1</span>)&gt; Task.start <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.55.0&gt;&#125;</span></div><div class="line"></div><div class="line"><span class="number">15</span><span class="symbol">:</span><span class="number">22</span><span class="symbol">:</span><span class="number">33.046</span> [error] Task <span class="comment">#PID&lt;0.55.0&gt; started from #PID&lt;0.53.0&gt; terminating</span></div><div class="line">** (RuntimeError) oops</div><div class="line">    (elixir) lib/task/supervised.<span class="symbol">ex:</span><span class="number">74</span>: Task.Supervised.do_apply/<span class="number">2</span></div><div class="line">    (stdlib) proc_lib.<span class="symbol">erl:</span><span class="number">239</span>: <span class="symbol">:proc_lib</span>.init_p_do_apply/<span class="number">3</span></div><div class="line"><span class="symbol">Function:</span> <span class="comment">#Function&lt;20.90072148/0 in :erl_eval.expr/5&gt;</span></div><div class="line">    <span class="symbol">Args:</span> []</div></pre></td></tr></table></figure>
<p>我们用 Task.start/1 和 Task.start_link/1 替代 spawn/1 和 spawn_link/1 ，它们返回 {:ok, pid} ，而不只是PID。这就是为什么使得任务被用在监督树里。而且Task提供像 Task.async/1 和 Task.await/1 这样的便捷的函数以及易于分布式的功能。</p>
<p>我们将在 <strong>Mix 和 OTP 指导</strong> 里探索这些功能，现在记住使用 Task 来获得更好的错误报告就足够了。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a><span id="part-five">状态</span></h1><p>到目前为止，我们的教程还没有讨论过状态。如果你正在构建一个需要状态的应用，例如，保存你的应用配置，或者你需要分析一个文件并且保存在内存里，那么你需要保存它在哪里？</p>
<p>对于这个问题，进程是最通用的回答。我们可以写无限循环的，维护状态的，并且收发消息的进程。作为一个例子，让我们写一个模块，它开始一个新进程，这个进程像一个键值对存储一样工作，这个模块在名字为kv.exs的文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Task.start_link(<span class="keyword">fn</span> -&gt; loop(%&#123;&#125;) <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">loop</span></span>(map) <span class="keyword">do</span></div><div class="line">    receive <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:get</span>, key, caller&#125; -&gt;</div><div class="line">        send caller, Map.get(map, key)</div><div class="line">        loop(map)</div><div class="line">      &#123;<span class="symbol">:put</span>, key, value&#125; -&gt;</div><div class="line">        loop(Map.put(map, key, value))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：start_link 函数启动一个新进程来运行 loop/1 函数，这个函数以一个空的映射为入参。loop/1 函数然后等待消息，并且为每个消息执行适当的操作。如果是一个 :get 消息，它发送一个消息回去给调用者并再次调用 loop/1 ，接着等待新的消息。而 :put 消息的话，实际上用一个新版本的映射作为入参调用 loop/1 ，这个新版本的映射存储了给定的键和值。</p>
<p>让我们通过运行 iex kv.exs 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.62.0&gt;&#125;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="keyword">nil</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>首先，进程的映射没有键，那么发送一个 :get 消息给它然后刷新当前进程的邮箱将返回 nil ，让我发送一个 :put 消息来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; send pid, &#123;<span class="symbol">:put</span>, <span class="symbol">:hello</span>, <span class="symbol">:world</span>&#125;</div><div class="line">&#123;<span class="symbol">:put</span>, <span class="symbol">:hello</span>, <span class="symbol">:world</span>&#125;</div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:world</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>注意进程如何保持状态，并且我们通过给进程发送消息来获取和修改这个状态。实际上，任何进程只要知道上面例子的pid都能够给这个pid发送消息并且操作它的进程。</p>
<p>注册这个pid并给它一个名字也是可以的，并且允许所有知道它名字的进程都可以给它发送消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; Process.register(pid, <span class="symbol">:kv</span>)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; send <span class="symbol">:kv</span>, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:world</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>在Elixir应用里用进程来维护状态和名字注册是非常通用的模式。但是，绝大多数时候，我们不需要像上面例子一样来手工实现那些模式，而是使用Elixir自带的许多抽象之一就可以。例如，Elixir提供了 <a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">代理者</a> ，它是以状态为基础的简单抽象：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; Agent.update(pid, <span class="keyword">fn</span> map -&gt; Map.put(map, <span class="symbol">:hello</span>, <span class="symbol">:world</span>) <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Agent.get(pid, <span class="keyword">fn</span> map -&gt; Map.get(map, <span class="symbol">:hello</span>) <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:world</span></div></pre></td></tr></table></figure>
<p>一个 :name 选项一个可以传给 Agent.start_link/2 ，这样它将被自动注册。除了代理者，Elixir提供了一个API来构建通用服务（叫做 GenServer），任务，以及其他更多事务，这些全部由下面的进程驱动。这些，连同监督树，将在 <strong>Mix 和 OTP 指导</strong>（这个指导将从开始到结束构建一个完整的Elixir应用） 里更详细地探讨。</p>
<p>接下来，让我们探索Elixir的I/O世界。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/processes.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;创建进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;发送和接收消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;状态&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir，所有代码运行在进程里。进程彼此间隔离，彼此间并发运行，并且通过消息传递来交流。进程不仅是Elixir的并发基础，它也为构建分布式和容错程序提供手段。&lt;/p&gt;
&lt;p&gt;Elixir的进程不应该和操作系统的进程混淆。Elixir的进程就内存和CPU的消耗来说是极其轻量的（不同于许多其他编程语言中的线程）。正因如此，成千上万的进程同时运行是很平常的。&lt;/p&gt;
&lt;p&gt;在本章里，我们将学习关于创建新进程的基本结构以及进程间收发消息。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Elixir/process/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－枚举类型和流</title>
    <link href="http://szpzs.oschina.io/2017/02/05/elixir-getting-started-enumerables-and-streams/"/>
    <id>http://szpzs.oschina.io/2017/02/05/elixir-getting-started-enumerables-and-streams/</id>
    <published>2017-02-05T02:50:23.000Z</published>
    <updated>2017-02-05T02:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">枚举类型</a></li>
<li><a href="#part-two">积极 vs 懒惰</a></li>
<li><a href="#part-three">管道运算符</a></li>
<li><a href="#part-four">流</a></li>
</ol>
<a id="more"></a>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><span id="part-one">枚举类型</span></h1><p>Elixir提供了枚举类型的概念以及<a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="external">Enum模块</a>来处理它们。我们已经学了两个枚举类型：list 和 map 。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span> x -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.map(%&#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>&#125;, <span class="keyword">fn</span> &#123;k, v&#125; -&gt; k * v <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">12</span>]</div></pre></td></tr></table></figure>
<p>Enum模块提供了大量的函数来转换、排序、分组、过滤枚举数据以及从枚举数据里获取元素。它是程序员在他们的Elixir代码里经常使用的模块之一。</p>
<p>Elixir也提供了范围这种数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)</div><div class="line">[2, 4, 6]</div><div class="line">iex&gt; Enum.reduce(1..3, 0, &amp;+/2)</div><div class="line">6</div></pre></td></tr></table></figure>
<p>Enum模块里的函数正如它的名字所示，它们被限制只能枚举数据结构的值。对于特殊的操作，比如插入和修改特定的元素，你可能需要根据特定的数据类型使用相应的模块。例如，如果你要在列表的给定位置插入一个元素，你应该使用List模块里的List.insert_at/3函数，因为它插入一个值到一个范围数据里是没意义的。</p>
<p>我们说Enum模块里的函数是多态的，是因为它们可以处理多种数据类型。尤其是，Enum模块里的函数可以处理任何实现了<a href="https://hexdocs.pm/elixir/Enumerable.html" target="_blank" rel="external">Enumerable协议</a>的数据。我们将在后续的章节讨论协议；现在我们将学习叫做流的特殊枚举类型。</p>
<h1 id="积极-VS-懒惰"><a href="#积极-VS-懒惰" class="headerlink" title="积极 VS 懒惰"></a><span id="part-two">积极 VS 懒惰</span></h1><p>Enum模块里的所有函数都是积极的。许多函数都期盼一个枚举类型数据然后返回一个列表。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; odd? = &amp;(rem(&amp;<span class="number">1</span>, <span class="number">2</span>) != <span class="number">0</span>)</div><div class="line"><span class="comment">#Function&lt;6.80484245/1 in :erl_eval.expr/5&gt;</span></div><div class="line">iex&gt; Enum.filter(<span class="number">1</span>..<span class="number">3</span>, odd?)</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>这意味着，当用Enum进行多个操作的时候，每个操作都将生成一个中间列表一直到我们最后得到结果。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Enum.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Enum.filter(odd?) |&gt; Enum.sum</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>上面的例子是一个管道操作。我们从一个范围数据开始，然后将它的每个元素乘于3。第一个操作将创建和返回一个有10万元素的列表。接着我们保留这个列表里的所有奇数元素并生成一个新的有5万元素的列表，最后我们统计这些元素的和。</p>
<h1 id="管道运算符"><a href="#管道运算符" class="headerlink" title="管道运算符"></a><span id="part-three">管道运算符</span></h1><p>上面例子使用的 |&gt; 符号是管道运算符：它获取它左边表达式的输出然后将这个输出作为第一个参数传给它右边的函数。它和Unix的 | 管道操作符相似。其目的是突出数据被一系列函数变换。为了看清楚它是如何使得代码更简洁的，我们来看看上述例子不用 |&gt; 运算符来写的样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.sum(Enum.filter(Enum.map(<span class="number">1</span>..<span class="number">100_000</span>, &amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)), odd?))</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>请阅读相关<a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" target="_blank" rel="external">文档</a>来深入理解管道运算符。</p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a><span id="part-four">流</span></h1><p>作为Enum的替代物，Elixir提供了支持懒操作的<a href="https://hexdocs.pm/elixir/Stream.html" target="_blank" rel="external">Stream模块</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Stream.filter(odd?) |&gt; Enum.sum</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>流是懒惰的，可组合的枚举数据类型。</p>
<p>在上述例子里，1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) 返回一个数据类型，实际上就是一个流，它表示在范围数据 1..100_000上的映射计算：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>))</div><div class="line"><span class="comment">#Stream&lt;[enum: 1..100000, funs: [#Function&lt;34.16982430/1 in Stream.map/2&gt;]]&gt;</span></div></pre></td></tr></table></figure>
<p>而且，它们是可组合的，因为我们可以用管道操作来组合多个流：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Stream.filter(odd?)</div><div class="line"><span class="comment">#Stream&lt;[enum: 1..100000, funs: [...]]&gt;</span></div></pre></td></tr></table></figure>
<p>流不是生成中间表，而是建立一系列计算，只有当我们传递底层的流给Enum模块，这些计算才被执行。当处理大的、可能是无限的集合数据时，流非常有用。</p>
<p>Stream模块里的许多函数接收任何枚举数据作为入参，并且返回一个流作为结果。它也提供函数来创建流。例如，Stream.cycle/1 可以通过无限循环给定的枚举数据来创建一个流。小心：不要在这样的流上调用像 Enum.map/2 这样的函数，因为它们会无限循环下去：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = Stream.cycle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">#Function&lt;15.16982430/2 in Stream.cycle/1&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">10</span>)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>另一方面，Stream.unfold/2 可以被用来从一个给定的初始值来创建流：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = Stream.unfold(<span class="string">"hełło"</span>, &amp;String.next_codepoint/<span class="number">1</span>)</div><div class="line"><span class="comment">#Function&lt;39.75994740/2 in Stream.unfold/2&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">3</span>)</div><div class="line">[<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"ł"</span>]</div></pre></td></tr></table></figure>
<p>另一个有趣的函数是 stream.resource/3，它可被用来包裹资源，从而保证资源即使在失败的情况下也可以在枚举之前被正确地打开和在后续被关闭。例如，我们可以用它来流式一个文件：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = File.stream!(<span class="string">"path/to/file"</span>)</div><div class="line"><span class="comment">#Function&lt;18.16982430/2 in Stream.resource/3&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>上面的例子将获取你选在的文件的前10行。这意味着，流在处理大文件或者像网络资源这样的慢资源上非常有用。</p>
<p>Enum和Stream模块里的函数数量可能让你一开始觉得很难，不过通过各种案例，你将会熟悉它们。尤其是，首先要专注在Enum模块，只在需要懒操作的特别场景，例如处理慢资源或者大的、可能无限的集合数据的时候才转向Stream模块。</p>
<p>下一章，我们将看看Elixir的一个核心特性：进程，它将允许我们以简单和可理解的方式来写并发、并行和分布式程序。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/enumerables-and-streams.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/enumerables-and-streams.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;枚举类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;积极 vs 懒惰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;管道运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;流&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="enumerable stream" scheme="http://szpzs.oschina.io/categories/Elixir/enumerable-stream/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="enumerable" scheme="http://szpzs.oschina.io/tags/enumerable/"/>
    
      <category term="stream" scheme="http://szpzs.oschina.io/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－递归</title>
    <link href="http://szpzs.oschina.io/2017/02/04/elixir-getting-started-recursion/"/>
    <id>http://szpzs.oschina.io/2017/02/04/elixir-getting-started-recursion/</id>
    <published>2017-02-04T10:15:23.000Z</published>
    <updated>2017-02-05T02:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">用递归实现循环</a></li>
<li><a href="#part-two">reduce 和 map 算法</a></li>
</ol>
<a id="more"></a>
<h1 id="用递归实现循环"><a href="#用递归实现循环" class="headerlink" title="用递归实现循环"></a><span id="part-one">用递归实现循环</span></h1><p>由于不可修改的特性，Elixir里的循环（如任何其他函数式语言原因）和命令式语言的写法不同。例如，在命令式语言，如C里，循环的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>); i++) &#123;</div><div class="line">  <span class="built_in">array</span>[i] = <span class="built_in">array</span>[i] * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述例子里，我们修改数组和变量i。在Elixir里修改变量值是不可能的。相反，函数式语言依赖于递归：一个函数被递归地调用，直到一个条件符合了才停止递归动作继续进行。在这个过程里面，没有数据被修改。思考一下下面的例子，打印一个字符串任意次数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Recursion</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_multiple_times</span></span>(msg, n) <span class="keyword">when</span> n &lt;= <span class="number">1</span> <span class="keyword">do</span></div><div class="line">    IO.puts msg</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_multiple_times</span></span>(msg, n) <span class="keyword">do</span></div><div class="line">    IO.puts msg</div><div class="line">    print_multiple_times(msg, n - <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Recursion.print_multiple_times(<span class="string">"Hello!"</span>, <span class="number">3</span>)</div><div class="line"><span class="comment"># Hello!</span></div><div class="line"><span class="comment"># Hello!</span></div><div class="line"><span class="comment"># Hello!</span></div></pre></td></tr></table></figure>
<p>和case语句相似，一个函数可能有多个分支。当传递给函数的参数匹配某个分支的参数模式，并且这个分支的卫语句结果为true，那么这个特定的分支将被执行。</p>
<p>当上述例子里的 print_multiple_times/2 函数刚开始被调用的时候，参数 n 等于3。</p>
<p>第一个分支有一个卫语句，它说，“当且仅当n小于等于1的时候使用这个分支”。因为一开始的时候n等于3，这个条件不成立，则Elixir处理下一个分支定义。</p>
<p>第二个分支定义匹配这个模式并且没有卫语句，因此它将被执行。它首先打印我们的 msg 变量，然后传递 n - 1 （2）作为第二个入参并调用自己。</p>
<p>我们的 msg 变量被打印并且 print_multiple_times/2 被再次调用，这次第二个入参为1。因为n现在为1，print_multiple_times/2 的第一个分支定义的卫语句结果为true，那么我们执行这个特定的分支定义。msg被打印，并且没有其他需要执行的。</p>
<p>我们这样定义 print_multiple_times/2 ，不管传递的第二个参数是什么数值，它可能触发我们第一个分支（也就是基准条件），或者它出发我们第二个分支，它将确保我们离我们的基准条件更近一步。</p>
<h1 id="reduce-和-map-算法"><a href="#reduce-和-map-算法" class="headerlink" title="reduce 和 map 算法"></a><span id="part-two">reduce 和 map 算法</span></h1><p>现在让我们看看我们如何利用递归的能力来对数字列表进行求和：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum_list</span></span>([head | tail], accumulator) <span class="keyword">do</span></div><div class="line">    sum_list(tail, head + accumulator)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum_list</span></span>([], accumulator) <span class="keyword">do</span></div><div class="line">    accumulator</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>) <span class="comment">#=&gt; 6</span></div></pre></td></tr></table></figure>
<p>我们用列表[1, 2, 3]和初始值0作为入参来调用 sum_list 。我们将尝试每一个分支直到我们找到一个分支，根据模式匹配规则它匹配了。在这个场景下，列表[1, 2, 3]匹配了[head | tail]，它绑定了head为1，tail为[2, 3]，accumulator为0。</p>
<p>然后，我们将列表的头元素加到累加器里：head + accumulator，并且传递列表尾部作为第一个参数，再次递归地调用 sum_list 。这个列表尾部再一次匹配 [head | tail]，这个情况一直到列表为空为止。参见如下演示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum_list [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span></div><div class="line">sum_list [<span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span></div><div class="line">sum_list [<span class="number">3</span>], <span class="number">3</span></div><div class="line">sum_list [], <span class="number">6</span></div></pre></td></tr></table></figure>
<p>当列表为空，它将匹配最后一个分支，然后返回最后结果为6。</p>
<p>将列表分解为一个值的过程称为归约算法，是函数编程的核心。</p>
<p>如果我们想将我们列表的所有元素值都翻倍，我们该如何做呢？</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double_each</span></span>([head | tail]) <span class="keyword">do</span></div><div class="line">    [head * <span class="number">2</span> | double_each(tail)]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double_each</span></span>([]) <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex math.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.double_each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#=&gt; [2, 4, 6]</span></div></pre></td></tr></table></figure>
<p>在这里我们用递归遍历列表，将其每个元素值翻倍，并且返回一个新的列表。获取列表并在其上映射的过程称为映射算法。</p>
<p>递归和尾调用是Elixir里重要的部分并且也是通常用来创建循环的方法。然后，当你在Elixir里编程，你将几乎很少像上面例子那样使用递归来操作列表。</p>
<p>我们将在下一章看到的 <a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="external">Enum模块</a> 已经提供了许多操作列表的便捷方式。例如，上述例子可以按如下方式来写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span>)</div><div class="line"><span class="number">6</span></div><div class="line">iex&gt; Enum.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>或者使用捕获语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.reduce([1, 2, 3], 0, &amp;+/2)</div><div class="line">6</div><div class="line">iex&gt; Enum.map([1, 2, 3], &amp;(&amp;1 * 2))</div><div class="line">[2, 4, 6]</div></pre></td></tr></table></figure>
<p>让我们更深入地了解可枚举的数据类型：Enumerable，以及它的懒惰对应数据类型：Steam。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/recursion.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/recursion.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;用递归实现循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;reduce 和 map 算法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="recursion" scheme="http://szpzs.oschina.io/categories/Elixir/recursion/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="recursion" scheme="http://szpzs.oschina.io/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－模块</title>
    <link href="http://szpzs.oschina.io/2017/02/03/elixir-getting-started-modules/"/>
    <id>http://szpzs.oschina.io/2017/02/03/elixir-getting-started-modules/</id>
    <published>2017-02-03T14:51:07.000Z</published>
    <updated>2017-02-03T14:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">编译</a></li>
<li><a href="#part-two">脚本模式</a></li>
<li><a href="#part-three">命名函数</a></li>
<li><a href="#part-four">函数捕获</a></li>
<li><a href="#part-five">默认参数</a></li>
</ol>
<p>在Elixir里我们将几个函数到模块里。在前面的章节里我们已经使用了许多不用的模块，比如<a href="https://hexdocs.pm/elixir/String.html" target="_blank" rel="external">String模块</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.length(<span class="string">"hello"</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>为了在Elixir里创建我们自己的模块，我们使用 defmodule 模块。我们使用 def 宏来定义模块里的函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">...&gt;     a + b</div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"></div><div class="line">iex&gt; Math.sum(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>下面几个部分，我们的例子变得更长，在shell里将可能难以输入。现在是时候我们学习如何编译Elixir代码以及如何运行Elixir脚本。</p>
<a id="more"></a>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a><span id="part-one">编译</span></h1><p>大多数时候，将模块写入文件是很方便的，因此它们可以被编译和重用。让我们假设我们有一个名字为 math.ex 的文件，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个文件可以用 elixirc 来编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixirc math.ex</div></pre></td></tr></table></figure>
<p>这将生成一个名字为 Elixir.Math.beam 的文件，它包含了定义的模块的字节码。如果我们再次启动 iex ，我们的模块定义将有效（被提供，即 iex 和字节码文件相同的目录里启动）。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.sum(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>Elixir项目通常被组织成三个目录里：</p>
<ul>
<li>ebin - 包含被编译的字节码。</li>
<li>lib - 包含elixir代码（通常是 .ex 文件）。</li>
<li>test - 包含测试文件（通常是 .exs  文件）。</li>
</ul>
<p>当工作在实际项目上时，构建工具（mix）将负责编译和为你设置合适的路径。为了学习目的，Elixir也支持脚本模式，它更灵活而且不生成任何编译的文件。</p>
<h1 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a><span id="part-two">脚本模式</span></h1><p>除了Elixir文件后缀 .ex ，Elixir也支持脚本后缀 .exs 文件。Elixir处理这两种文件是用相同的方式，唯一的区别在于意图。.ex 文件意味着被编译，.exs 文件用于脚本。当执行的时候，两中后缀的文件编译并且装载它们的模块到内存里，而只有 .ex  文件以 .beam文件格式写它们的字节码到磁盘上。</p>
<p>例如，我们可以创建一个文件，名为math.exs：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum(<span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>并且如下方式执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir math.exs</div></pre></td></tr></table></figure>
<p>这个文件将被编译进内存并执行，结果为输出 3 。没有字节码生成。在后续的例子里，我们建议你写你的代码到脚本文件里，并且按上述所示执行它们。</p>
<h1 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a><span id="part-three">命名函数</span></h1><p>在模块里，我们可以用 def/2 定义函数，用 defp/2 定义私有函数。用def/2定义的函数可以被从其他模块调用，而私有函数只能本地调用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    do_sum(a, b)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">do_sum</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum(<span class="number">1</span>, <span class="number">2</span>)    <span class="comment">#=&gt; 3</span></div><div class="line">IO.puts Math.do_sum(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">#=&gt; ** (UndefinedFunctionError)</span></div></pre></td></tr></table></figure>
<p>函数定义也支持卫语句和多分支。如果一个函数有几个分支，Elixir将尝试每一个分支直到找到匹配的分支为止。如下的例子是检查给定的数字是否是零的函数的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(<span class="number">0</span>) <span class="keyword">do</span></div><div class="line">    <span class="keyword">true</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(x) <span class="keyword">when</span> is_integer(x) <span class="keyword">do</span></div><div class="line">    <span class="keyword">false</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.zero?(<span class="number">0</span>)         <span class="comment">#=&gt; true</span></div><div class="line">IO.puts Math.zero?(<span class="number">1</span>)         <span class="comment">#=&gt; false</span></div><div class="line">IO.puts Math.zero?([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#=&gt; ** (FunctionClauseError)</span></div><div class="line">IO.puts Math.zero?(<span class="number">0</span>.<span class="number">0</span>)       <span class="comment">#=&gt; ** (FunctionClauseError)</span></div></pre></td></tr></table></figure>
<p>给定的入参如果不能匹配任何一个分支则会引起一个错误。</p>
<p>和结构 if 相似，命名函数支持 do: 和 do/end 块语法，就像<a href="http://elixir-lang.org/getting-started/case-cond-and-if.html#doend-blocks" target="_blank" rel="external">我们学到的 do/end 是为关键字列表格式的便捷语法</a>。例如，我们可以改写上面例子文件 math.exs 为如下样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(<span class="number">0</span>), <span class="symbol">do:</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero?</span></span>(x) <span class="keyword">when</span> is_integer(x), <span class="symbol">do:</span> <span class="keyword">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>它也提供一样的功能。你可以用 do: 于一行代码内，不过应该一直用 do/end 于多行代码。</p>
<h1 id="函数捕获"><a href="#函数捕获" class="headerlink" title="函数捕获"></a><span id="part-four">函数捕获</span></h1><p>在本教程中，我们已经用符号 name/arity 来引用函数。碰巧，这个符号实际上可以用来检索命名函数作为函数类型。启动 iex ，运行上面定义的 math.exs 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex math.exs</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.zero?(0)</div><div class="line">true</div><div class="line">iex&gt; fun = &amp;Math.zero?/1</div><div class="line">&amp;Math.zero?/1</div><div class="line">iex&gt; is_function(fun)</div><div class="line">true</div><div class="line">iex&gt; fun.(0)</div><div class="line">true</div></pre></td></tr></table></figure>
<p>记住Elixir在匿名函数和命名函数之间做了一个区分，就是前者必需在调用的时候在变量名和圆括号之间加一个点号。捕获运算符通过允许命名函数用我们赋予、调用和传递匿名函数的相同方式被赋予变量并当做参数被传递来消除这种差别。</p>
<p>本地或被导入的函数，比如 is_function/1 ，可以不需要模块的方式被捕获：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &amp;is_function/<span class="number">1</span></div><div class="line">&amp;<span class="symbol">:erlang</span>.is_function/<span class="number">1</span></div><div class="line">iex&gt; (&amp;is_function/<span class="number">1</span>).(fun)</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>注意：捕获语法也可以被用来作为创建函数的便捷方式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = &amp;(&amp;<span class="number">1</span> + <span class="number">1</span>)</div><div class="line"><span class="comment">#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;</span></div><div class="line">iex&gt; fun.(<span class="number">1</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>&amp;1表示传入函数的第一个参数。上述 &amp;(&amp;1 + 1) 和 fn x -&gt; x + 1 end 是一样的。上面例子的语法特别适合短函数定义。</p>
<p>如果你想从一个模块里捕获一个函数，你可以这么做 &amp;Module.function() ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = &amp;List.flatten(&amp;<span class="number">1</span>, &amp;<span class="number">2</span>)</div><div class="line">&amp;List.flatten/<span class="number">2</span></div><div class="line">iex&gt; fun.([<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]], [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>&amp;List.flatten(&amp;1, &amp;2) 和 fn(list, tail) -&gt; List.flatten(list, tail) end 写法是一样的，在这个场景，等效于 &amp;List.flatten/2 。你可以在 <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;/1" target="_blank" rel="external">Kernel.SpecialForms 文档</a>里读到更多关于捕获运算符 &amp; 的内容。</p>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a><span id="part-five">默认参数</span></h1><p>Elixir里的命名函数也支持默认参数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Concat</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, sep \\ <span class="string">" "</span>) <span class="keyword">do</span></div><div class="line">    a &lt;&gt; sep &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>)      <span class="comment">#=&gt; Hello world</span></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>, <span class="string">"_"</span>) <span class="comment">#=&gt; Hello_world</span></div></pre></td></tr></table></figure>
<p>任何表达式都允许作为默认值，不过它在函数定义里不会被运算。每次函数调用而且任何它的默认值必须要用的时候，默认值的表达式将被运算：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">DefaultTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dowork</span></span>(x \\ <span class="string">"hello"</span>) <span class="keyword">do</span></div><div class="line">    x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; DefaultTest.dowork</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; DefaultTest.dowork <span class="number">123</span></div><div class="line"><span class="number">123</span></div><div class="line">iex&gt; DefaultTest.dowork</div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>如果一个有默认值函数有多个分支，它需要创建一个函数头（没有函数体）来声明默认值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Concat</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b \\ <span class="keyword">nil</span>, sep \\ <span class="string">" "</span>)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, _sep) <span class="keyword">when</span> is_nil(b) <span class="keyword">do</span></div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, sep) <span class="keyword">do</span></div><div class="line">    a &lt;&gt; sep &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>)      <span class="comment">#=&gt; Hello world</span></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>, <span class="string">"world"</span>, <span class="string">"_"</span>) <span class="comment">#=&gt; Hello_world</span></div><div class="line">IO.puts Concat.join(<span class="string">"Hello"</span>)               <span class="comment">#=&gt; Hello</span></div></pre></td></tr></table></figure>
<p>当使用默认值的时候，必须要小心避免重叠函数定义。如下例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Concat</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"***First join"</span></div><div class="line">    a &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(a, b, sep \\ <span class="string">" "</span>) <span class="keyword">do</span></div><div class="line">    IO.puts <span class="string">"***Second join"</span></div><div class="line">    a &lt;&gt; sep &lt;&gt; b</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果我们把上述代码保存在 “concat.ex” 文件中并编译它，Elixir将输出如下警告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">warning:</span> this clause cannot match because a previous clause at line <span class="number">2</span> always matches</div></pre></td></tr></table></figure>
<p>编译器告诉我们，用两个参数来调用 join 函数将总是选择 join 函数的第一个定义，而它的第二个定义将只在传入三个参数的时候才被调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex concat.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Concat.join <span class="string">"Hello"</span>, <span class="string">"world"</span></div><div class="line">***First join</div><div class="line"><span class="string">"Helloworld"</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Concat.join <span class="string">"Hello"</span>, <span class="string">"world"</span>, <span class="string">"_"</span></div><div class="line">***Second join</div><div class="line"><span class="string">"Hello_world"</span></div></pre></td></tr></table></figure>
<p>简短的模块知识介绍到此结束。下一章，我们将学习如何用命名函数来递归；探索Elixir的词汇指令，这些指令可以用来从其他模块导入函数；讨论模块属性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/modules.html#" target="_blank" rel="external">http://elixir-lang.org/getting-started/modules.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;脚本模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;命名函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;函数捕获&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;默认参数&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir里我们将几个函数到模块里。在前面的章节里我们已经使用了许多不用的模块，比如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;String模块&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; String.length(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了在Elixir里创建我们自己的模块，我们使用 defmodule 模块。我们使用 def 宏来定义模块里的函数。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defmodule&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Math&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;/span&gt;(a, b) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;     a + b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; Math.sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面几个部分，我们的例子变得更长，在shell里将可能难以输入。现在是时候我们学习如何编译Elixir代码以及如何运行Elixir脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="module" scheme="http://szpzs.oschina.io/categories/Elixir/module/"/>
    
    
      <category term="map" scheme="http://szpzs.oschina.io/tags/map/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="module" scheme="http://szpzs.oschina.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－Keywords和maps</title>
    <link href="http://szpzs.oschina.io/2017/02/02/elixir-getting-started-keywords-and-maps/"/>
    <id>http://szpzs.oschina.io/2017/02/02/elixir-getting-started-keywords-and-maps/</id>
    <published>2017-02-02T05:01:31.000Z</published>
    <updated>2017-02-02T05:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">关键字列表</a></li>
<li><a href="#part-two">映射</a></li>
<li><a href="#part-three">嵌套数据结构</a></li>
</ol>
<p>到目前为止，我们还没讨论过任何关联数据结构，即该数据结构是将一个值（或者多个值）和一个键关联起来。不同的语言对这种数据结构的称呼不一样，比如：字典、哈希、关联数组，等等。</p>
<p>Elixir里有两种主要的关联数据结构：关键字列表和映射。现在让我们来学习它们！</p>
<a id="more"></a>
<h1 id="关键字列表"><a href="#关键字列表" class="headerlink" title="关键字列表"></a><span id="part-one">关键字列表</span></h1><p>在许多函数式语言里，通常使用两个元素的元组组成的列表来表示一个键值对数据结构。在Elixir里，当我们有一个元组组成的列表，并且元组的第一个元素（即键）是原子，则我们叫这个列表是关键字列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [&#123;:a, <span class="number">1</span>&#125;, &#123;:b, <span class="number">2</span>&#125;]</div><div class="line">[a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">iex&gt; list == [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>正如上述所示，Elixir支持一种特殊的语法来定义这样的列表：[key: value]。它在底层是表示上述例子的元组组成的列表。既然关键字列表是列表，我们可以使用列表的所有可用操作。例如，我们可以使用  ++ 增加一个值到关键字列表里。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list ++ [c: <span class="number">3</span>]</div><div class="line">[a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>]</div><div class="line">iex&gt; [a: <span class="number">0</span>] ++ list</div><div class="line">[a: <span class="number">0</span>, a: <span class="number">1</span>, b: <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>注意：加到前面的值将被首先查询到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; new_list = [a: <span class="number">0</span>] ++ list</div><div class="line">[a: <span class="number">0</span>, a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">iex&gt; new_list[:a]</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>关键字列表很重要，因为它有三个特别的特性：</p>
<ul>
<li>键必须是原子。</li>
<li>键的顺序由开发者指定。</li>
<li>键可以重复出现。</li>
</ul>
<p>例如，Ecto库 使用这些特性来提供一个写数据库查询的优雅领域特定语言：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">query</span> = from w in Weather,</div><div class="line">      where: w.prcp &gt; <span class="number">0</span>,</div><div class="line">      where: w.temp &lt; <span class="number">20</span>,</div><div class="line">     select: w</div></pre></td></tr></table></figure>
<p>这些特性使得关键字列表成为Elixir里传递选项给函数的默认机制。在第5章，我们讨论 if/2 宏的时候，我们提到下述语法是被支持的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">false</span>, do: :this, else: :that</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>do: 和 else: 对是关键字列表！实际上，上述的调用等价于下面的调用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span>(<span class="literal">false</span>, [do: :this, else: :that])</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>也和下面的调用相同：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span>(<span class="literal">false</span>, [&#123;:do, :this&#125;, &#123;:else, :that&#125;])</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>通常，当关键字列表是函数的最后一个参数的时候，方括号是可省略的。</p>
<p>虽然我们可以在关键字列表上进行模式匹配，但是实际操作中很少用，因为在列表上进行模式匹配需要列表的元素数量和它们的顺序匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; [a: a] = [a: <span class="number">1</span>]</div><div class="line">[a: <span class="number">1</span>]</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; [a: a] = [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">iex&gt; [b: b, a: a] = [a: <span class="number">1</span>, b: <span class="number">2</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [a: <span class="number">1</span>, b: <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>为了操作关键字列表，Elixir提供了<a href="https://hexdocs.pm/elixir/Keyword.html" target="_blank" rel="external">Keyword模块</a>。记住，关键字列表就是列表，因此它们和列表一样提供了线性性能特性。列表越长，就要花越多的时间查找到一个键、计算元素个数，诸如此类的。因为这个原因，关键字列表在Elixir里主要用来传递可选值。如果你需要存储许多项数据或者要保证一个键只对应一个值，那么你应该用映射。</p>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a><span id="part-two">映射</span></h1><p>在Elixir里，任何时候你需要键值对存储，则映射就是你所要的数据结构。映射使用 %{} 语法来创建：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line">iex&gt; map[<span class="symbol">:a</span>]</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; map[<span class="number">2</span>]</div><div class="line"><span class="symbol">:b</span></div><div class="line">iex&gt; map[<span class="symbol">:c</span>]</div><div class="line"><span class="keyword">nil</span></div></pre></td></tr></table></figure>
<p>与关键字列表比较，我们已经可以看到有两个不同：</p>
<ul>
<li>映射允许任何值作为键。</li>
<li>映射的键不遵循任何顺序。</li>
</ul>
<p>与关键字列表相反，映射非常有用于模式匹配。当一个映射用在一个模式中，它将总是匹配上一个给定值的子集：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; %&#123;&#125; = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line">iex&gt; %&#123;<span class="symbol">:a</span> =&gt; a&#125; = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; %&#123;<span class="symbol">:c</span> =&gt; c&#125; = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> %&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>如上所述，一个映射一定匹配，只要模式里的键存在于给定的映射里。因此，一个空映射匹配所有映射。</p>
<p>当访问、匹配和增加映射的键时，变量可以被使用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; n = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; map = %&#123;n =&gt; <span class="symbol">:one</span>&#125;</div><div class="line">%&#123;<span class="number">1</span> =&gt; <span class="symbol">:one</span>&#125;</div><div class="line">iex&gt; map[n]</div><div class="line"><span class="symbol">:one</span></div><div class="line">iex&gt; %&#123;^n =&gt; <span class="symbol">:one</span>&#125; = %&#123;<span class="number">1</span> =&gt; <span class="symbol">:one</span>, <span class="number">2</span> =&gt; <span class="symbol">:two</span>, <span class="number">3</span> =&gt; <span class="symbol">:three</span>&#125;</div><div class="line">%&#123;<span class="number">1</span> =&gt; <span class="symbol">:one</span>, <span class="number">2</span> =&gt; <span class="symbol">:two</span>, <span class="number">3</span> =&gt; <span class="symbol">:three</span>&#125;</div></pre></td></tr></table></figure>
<p><a href="https://hexdocs.pm/elixir/Map.html" target="_blank" rel="external">Map模块</a>提供和Keyword模块相似的API来便于操作映射：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Map.get(%&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;, <span class="symbol">:a</span>)</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; Map.to_list(%&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;)</div><div class="line">[&#123;<span class="number">2</span>, <span class="symbol">:b</span>&#125;, &#123;<span class="symbol">:a</span>, <span class="number">1</span>&#125;]</div></pre></td></tr></table></figure>
<p>当映射中的所有键都是原子时，您可以使用关键字语法来提高便捷程度：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>映射另一个有趣的特性是提供它们自己的语法来修改和访问原子键：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="symbol">:b</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line"></div><div class="line">iex&gt; map.a</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; map.c</div><div class="line">** (KeyError) key <span class="symbol">:c</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div><div class="line"></div><div class="line">iex&gt; %&#123;map | <span class="symbol">:a</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">iex&gt; %&#123;map | <span class="symbol">:c</span> =&gt; <span class="number">3</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:c</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %&#123;<span class="number">2</span> =&gt; <span class="symbol">:b</span>, <span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>上述访问和修改语法需要给定的键存在。例如，访问和修改 :c 键失败，因为映射里没有这个键。</p>
<p>当处理映射的时候，Elixir开发者一贯喜欢用 map.field 语法和模式匹配来替代 Map 模块里的函数，因为它们形成了一种断言式的编程风格。<a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/" target="_blank" rel="external">这篇博客</a> 提供了解释和例子，如何在Elixir里通过写断言代码获得更简洁和更快的软件。</p>
<blockquote>
<p>注意：映射是最近才引入Erlang虚拟机的，并且仅从Elixir v1.2开始，它们才有能力高效处理上百万键。因此，如果你使用较老的Elixir版本（v1.0或v1.1），并且你需要最少支持数百个键，那么你可以考虑使用<a href="https://hexdocs.pm/elixir/HashDict.html" target="_blank" rel="external">HashDict模块</a>。</p>
</blockquote>
<h1 id="嵌套数据结构"><a href="#嵌套数据结构" class="headerlink" title="嵌套数据结构"></a><span id="part-three">嵌套数据结构</span></h1><p>我们常常有映射中有映射，或者甚至在映射里有关键字列表，等等。Elixir通过 put_in/2 和 update_in/2 提供了操作嵌套数据结构的便利，以及你可以在命令式语言里发现其他宏也提供这样的遍历而同时保持这个语言的不可修改的特性。</p>
<p>假设你有如下的结构：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; users = [</div><div class="line">  <span class="symbol">john:</span> %&#123;<span class="symbol">name:</span> <span class="string">"John"</span>, <span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>]&#125;,</div><div class="line">  <span class="symbol">mary:</span> %&#123;<span class="symbol">name:</span> <span class="string">"Mary"</span>, <span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>, <span class="string">"Clojure"</span>]&#125;</div><div class="line">]</div><div class="line">[<span class="symbol">john:</span> %&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>], <span class="symbol">name:</span> <span class="string">"John"</span>&#125;,</div><div class="line"> <span class="symbol">mary:</span> %&#123;<span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>, <span class="string">"Clojure"</span>], <span class="symbol">name:</span> <span class="string">"Mary"</span>&#125;]</div></pre></td></tr></table></figure>
<p>我们有一个用户的关键字列表，它的每一个值是一个映射，这个映射包含名字，年龄和用户喜欢的编程语言组成的列表。如果我们想访问约翰的年龄，我们可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; users[<span class="symbol">:john</span>].age</div><div class="line"><span class="number">27</span></div></pre></td></tr></table></figure>
<p>我们也可以用相同的语法来修改这个值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; users = put_in users[<span class="symbol">:john</span>].age, <span class="number">31</span></div><div class="line">[<span class="symbol">john:</span> %&#123;<span class="symbol">age:</span> <span class="number">31</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>], <span class="symbol">name:</span> <span class="string">"John"</span>&#125;,</div><div class="line"> <span class="symbol">mary:</span> %&#123;<span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>, <span class="string">"Clojure"</span>], <span class="symbol">name:</span> <span class="string">"Mary"</span>&#125;]</div></pre></td></tr></table></figure>
<p>update_in/2 宏也相似，不过它允许我们传递一个函数来控制如何修改值。例如，让我们从玛丽的编程语言列表里删除掉Clojure：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; users = update_in users[<span class="symbol">:mary</span>].languages, &amp;List.delete(&amp;<span class="number">1</span>, <span class="string">"Clojure"</span>)</div><div class="line">[<span class="symbol">john:</span> %&#123;<span class="symbol">age:</span> <span class="number">31</span>, <span class="symbol">languages:</span> [<span class="string">"Erlang"</span>, <span class="string">"Ruby"</span>, <span class="string">"Elixir"</span>], <span class="symbol">name:</span> <span class="string">"John"</span>&#125;,</div><div class="line"> <span class="symbol">mary:</span> %&#123;<span class="symbol">age:</span> <span class="number">29</span>, <span class="symbol">languages:</span> [<span class="string">"Elixir"</span>, <span class="string">"F#"</span>], <span class="symbol">name:</span> <span class="string">"Mary"</span>&#125;]</div></pre></td></tr></table></figure>
<p>关于 put_in/2 和 update_in/2 还有很多需要学习的，包括 get_and_update_in/2 这个函数允许我们一次性获取一个值并且修改数据结构。也有 put_in/3，update_in/3 和 get_and_update_in/3 这些函数，它们允许动态访问数据结构。请在 <a href="https://hexdocs.pm/elixir/Kernel.html" target="_blank" rel="external">Kernel模块</a>里仔细阅读它们各自的文档来深入理解它们的作用。</p>
<p>到此我们结束了Elixir里关联数据结构的介绍。你将发现，给定关键字列表和映射，你将总会有适用的工具来解决Elixir里需要关联数据结构的问题。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/keywords-and-maps.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/keywords-and-maps.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;关键字列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;嵌套数据结构&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到目前为止，我们还没讨论过任何关联数据结构，即该数据结构是将一个值（或者多个值）和一个键关联起来。不同的语言对这种数据结构的称呼不一样，比如：字典、哈希、关联数组，等等。&lt;/p&gt;
&lt;p&gt;Elixir里有两种主要的关联数据结构：关键字列表和映射。现在让我们来学习它们！&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="keyword list-map" scheme="http://szpzs.oschina.io/categories/Elixir/keyword-list-map/"/>
    
    
      <category term="map" scheme="http://szpzs.oschina.io/tags/map/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="keyword list" scheme="http://szpzs.oschina.io/tags/keyword-list/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－二进制数据，字符串 和 字符列表</title>
    <link href="http://szpzs.oschina.io/2017/02/01/elixir-getting-started-binaries-strings-and-char-lists/"/>
    <id>http://szpzs.oschina.io/2017/02/01/elixir-getting-started-binaries-strings-and-char-lists/</id>
    <published>2017-02-01T11:43:38.000Z</published>
    <updated>2017-02-01T11:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">UTF-8和Unicode</a></li>
<li><a href="#part-two">二进制数据（和位串）</a></li>
<li><a href="#part-three">字符列表</a></li>
</ol>
<p>在“基本类型”那一章，我们学到了字符串以及使用 is_binary/1 函数来检查它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; string = <span class="string">"hello"</span></div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; is_binary(string)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>在本章，我们将理解二进制数据是什么；它们如何和字符串联系在一起；在Elixir里，被单引号括起来的值，比如 ‘like this’，是什么。</p>
<a id="more"></a>
<h1 id="UTF-8和Unicode"><a href="#UTF-8和Unicode" class="headerlink" title="UTF-8和Unicode"></a><span id="part-one">UTF-8和Unicode</span></h1><p>一个字符串是一个用UTF-8编码的二进制数据。为了确切理解我们的意思，我们需要理解字节和代码点之间的区别。</p>
<p>Unicode标准给我们所知的许多字符赋予了代码点。比如，字母 a 有代码点 97，而字母 ł 有代码点322。当将字符串 “hełło” 写到磁盘上时，我们需要将它的代码点转换为若干字节。如果我们采用的规则是，一个字节表示一个代码点，那么我们将无法写字符串 “hełło” ，因为它使用了代码点322来表示字母 ł ，而一个字节只能表示 0 到 255的数字。理所当然地，你要正确地在屏幕上读出字符串 “hełło” ，它必须被以某种方式表达出来。这就是编码应用之处了。</p>
<p>用字节的方式来表达代码点的时候，我们需要以某种方式编码它们。Elixir选择UTF-8编码作为它主要的和默认的编码。当我们说一个字符串是一个UTF-8编码的二进制数据，我们的意思是一个字符串是以一种方式，比如指定的UTF-8编码，来组织的表达某些代码点的一块二进制数据。</p>
<p>因为我们有字母，像 ł 被赋予代码点322，所以我们的确需要多于一个字节来表达它们。这就是为什么我们看到的 byte_size/1 和 String.length/1 之间有区别：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; string = <span class="string">"hełło"</span></div><div class="line"><span class="string">"hełło"</span></div><div class="line">iex&gt; byte_size(string)</div><div class="line"><span class="number">7</span></div><div class="line">iex&gt; String.length(string)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>byte_size/1 计算的是底层的字节数，而 String.length/1 计算的是字符数。</p>
<blockquote>
<p>注意：如果你用的是Windows，你的终端可能不是默认用UTF-8编码。你可以在运行iex（iex.bat）前通过运行 chcp 65001 来改变你当前会话的编码。</p>
</blockquote>
<p>UTF-8需要一个字节来表达字符 h，e 和 o ，但是需要两个字节表达字符 ł 。在Elixir里，你可以用 ? 来获得一个字符的代码点：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ?a</div><div class="line"><span class="number">97</span></div><div class="line">iex&gt; ?ł</div><div class="line"><span class="number">322</span></div></pre></td></tr></table></figure>
<p>你也可以用String模块里的函数将一个字符串分割为独立字符串组成的列表，其中每一个字符串是长度为一。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.codepoints(<span class="string">"hełło"</span>)</div><div class="line">[<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"ł"</span>, <span class="string">"ł"</span>, <span class="string">"o"</span>]</div></pre></td></tr></table></figure>
<p>你将看到Elixir已经非常好地支持字符串操作。它也支持许多Unicode操作。实际上，Elixir通过了<a href="http://mortoray.com/2013/11/27/the-string-type-is-broken/" target="_blank" rel="external">“The string type is broken”</a>里的所有测试。</p>
<p>然后，字符串只是本文的一部分内容。如果一个字符串是一个二进制数据，并且我们也对它使用了is_binary/1函数，那么Elixir必须有一个底层类型来支持字符串。它的确是这么做的！下面我们来谈谈二进制数据。</p>
<h1 id="二进制数据（和位串）"><a href="#二进制数据（和位串）" class="headerlink" title="二进制数据（和位串）"></a><span id="part-two">二进制数据（和位串）</span></h1><p>在Elixir里，你可以用&lt;&lt;&gt;&gt;来定义一个二进制数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">iex&gt; byte_size(&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>一个二进制数据是一个字节的序列。这些字节可以用任何方式来组织，甚至这些字节序列不是有效的字符串：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.valid?(&lt;&lt;<span class="number">239</span>, <span class="number">191</span>, <span class="number">191</span>&gt;&gt;)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>字符串的串联操作实际上是二进制数据的串联操作：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>&gt;&gt; &lt;&gt; &lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>在Elixir里的一个通用技巧是将空字节&lt;<0>&gt;串联在一个字符串后以便看看它内部的二进制表示：</0></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hełło"</span> &lt;&gt; &lt;&lt;<span class="number">0</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">104</span>, <span class="number">101</span>, <span class="number">197</span>, <span class="number">130</span>, <span class="number">197</span>, <span class="number">130</span>, <span class="number">111</span>, <span class="number">0</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>赋给一个二进制数据的每一个数字都表示一个字节，由此它的值最大是255。二进制数据允许给定修饰语来存储大于255的数字，或者转换一个代码点为它的UTF-8编码表示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">255</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">255</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span>&gt;&gt; # truncated</div><div class="line">&lt;&lt;<span class="number">0</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: size(<span class="number">16</span>)&gt;&gt; # use <span class="number">16</span> bits (<span class="number">2</span> bytes) to store the number</div><div class="line">&lt;&lt;<span class="number">1</span>, <span class="number">0</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: utf8&gt;&gt; # the number is a code point</div><div class="line"><span class="string">"Ā"</span></div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: utf8, <span class="number">0</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">196</span>, <span class="number">128</span>, <span class="number">0</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>如果一个字节有8位，那么我们只给它一位会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">1</span>::size(<span class="number">1</span>)&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">2</span> :: size(<span class="number">1</span>)&gt;&gt; # truncated</div><div class="line">&lt;&lt;<span class="number">0</span>::size(<span class="number">1</span>)&gt;&gt;</div><div class="line">iex&gt; is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; is_bitstring(&lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; bit_size(&lt;&lt; <span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>结果是这个值不再是一个二进制数据，而是一个位串 – 一些位。所以一个二进制数据是一个位串，它的位的数量被8整除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt;  is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">16</span>)&gt;&gt;)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt;  is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">15</span>)&gt;&gt;)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>我们也可以在二进制数据或位串上进行模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&gt;</div><div class="line">iex&gt; x</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>注意：在二进制模式中的每一个元素都被期望刚好匹配8位。如果我们想要匹配一个未知大小的二进制数据，在模式的尾部通过使用二进制数据修饰语是可能做到的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x :: binary&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">iex&gt; x</div><div class="line">&lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>相似的结果可以用字符串串联符&lt;&gt;来实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"he"</span> &lt;&gt; rest = <span class="string">"hello"</span></div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; rest</div><div class="line"><span class="string">"llo"</span></div></pre></td></tr></table></figure>
<p>关于二进制数据或位串的构造器&lt;&lt;&gt;&gt;的完整指导可以在<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1" target="_blank" rel="external">Elixir官方文档</a>里找到。到此，我们结束了位串，二进制数据和字符串之旅。字符串是UTF-8编码的二进制数据；二进制数据是位串，它的位的数量被8整除。虽然这表明Elixir提供了处理位和字节的灵活性，不过你的99%的时间将用来处理二进制数据，并且使用 is_binary/1 和 byte_size/1 函数。</p>
<h1 id="字符列表"><a href="#字符列表" class="headerlink" title="字符列表"></a><span id="part-three">字符列表</span></h1><p>一个字符列表就是一个代码点列表。字符列表可以用单引号括起来的字符字面值创建：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; 'hełło'</div><div class="line">[<span class="number">104</span>, <span class="number">101</span>, <span class="number">322</span>, <span class="number">322</span>, <span class="number">111</span>]</div><div class="line">iex&gt; is_list 'hełło'</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; 'hello'</div><div class="line">'hello'</div><div class="line">iex&gt; List.first('hello')</div><div class="line"><span class="number">104</span></div></pre></td></tr></table></figure>
<p>你可以看到，不是包含字节，一个字符列表包含单引号之间的字符的代码点（注意：默认情况下如果任何整数值在ASCII范围外，则IEx将只是输出代码点）。那么，双引号表示字符串（即二进制数据），单引号表示字符列表（即列表）。</p>
<p>在实践中，字符列表主要用于与Erlang交互的时候，特别是不接受二进制数据作为参数的旧库。你可以用 to_charlist/1 和 to_string/1 函数来转换字符列表为字符串或者反之将字符串转换为字符列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_charlist <span class="string">"hełło"</span></div><div class="line">[<span class="number">104</span>, <span class="number">101</span>, <span class="number">322</span>, <span class="number">322</span>, <span class="number">111</span>]</div><div class="line">iex&gt; to_string 'hełło'</div><div class="line"><span class="string">"hełło"</span></div><div class="line">iex&gt; to_string :hello</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; to_string <span class="number">1</span></div><div class="line"><span class="string">"1"</span></div></pre></td></tr></table></figure>
<p>注意：这些函数是多态的。它们不仅可以转换字符列表为字符串，也可以转换整数为字符串，转换原子为字符串，等等。</p>
<p>介绍完二进制数据，字符串和字符列表，接下来是时候讲讲键值对数据结构了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;UTF-8和Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;二进制数据（和位串）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;字符列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在“基本类型”那一章，我们学到了字符串以及使用 is_binary/1 函数来检查它：&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; string = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; is_binary(string)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在本章，我们将理解二进制数据是什么；它们如何和字符串联系在一起；在Elixir里，被单引号括起来的值，比如 ‘like this’，是什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="binary-string-char list" scheme="http://szpzs.oschina.io/categories/Elixir/binary-string-char-list/"/>
    
    
      <category term="string" scheme="http://szpzs.oschina.io/tags/string/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="binary" scheme="http://szpzs.oschina.io/tags/binary/"/>
    
      <category term="char list" scheme="http://szpzs.oschina.io/tags/char-list/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－case，cond 和 if</title>
    <link href="http://szpzs.oschina.io/2017/01/31/elixir-getting-started-case-cond-and-if/"/>
    <id>http://szpzs.oschina.io/2017/01/31/elixir-getting-started-case-cond-and-if/</id>
    <published>2017-01-31T11:35:56.000Z</published>
    <updated>2017-01-31T11:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">case</a></li>
<li><a href="#part-two">卫语句里的表达式</a></li>
<li><a href="#part-three">cond</a></li>
<li><a href="#part-four">if 和 unless</a></li>
<li><a href="#part-five">do/end 块</a></li>
</ol>
<p>在本章，我们将学习 case，cond 和 if 这几个控制流结构。</p>
<a id="more"></a>
<h1 id="case"><a href="#case" class="headerlink" title="case"></a><span id="part-one">case</span></h1><p>case允许我们将一个值和许多模式进行比较直到我们找到一个匹配的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; do</div><div class="line">...&gt;   &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; -&gt;</div><div class="line">...&gt;     <span class="string">"This clause won't match"</span></div><div class="line">...&gt;   &#123;<span class="number">1</span>, x, <span class="number">3</span>&#125; -&gt;</div><div class="line">...&gt;     <span class="string">"This clause will match and bind x to 2 in this clause"</span></div><div class="line">...&gt;   _ -&gt;</div><div class="line">...&gt;     <span class="string">"This clause would match any value"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This clause will match and bind x to 2 in this clause"</span></div></pre></td></tr></table></figure>
<p>如果你想模式匹配已经存在的变量，你需要使用 ^ 运算符：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="keyword">case</span> <span class="number">10</span> do</div><div class="line">...&gt;   ^x -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt;   _  -&gt; <span class="string">"Will match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Will match"</span></div></pre></td></tr></table></figure>
<p>分支语句也允许用卫语句来指定额外的条件：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; do</div><div class="line">...&gt;   &#123;<span class="number">1</span>, x, <span class="number">3</span>&#125; <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Will match"</span></div><div class="line">...&gt;   _ -&gt;</div><div class="line">...&gt;     <span class="string">"Would match, if guard condition were not satisfied"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Will match"</span></div></pre></td></tr></table></figure>
<p>上例中第一个分支语句仅在x大于零的时候才被匹配上。</p>
<h1 id="卫语句里的表达式"><a href="#卫语句里的表达式" class="headerlink" title="卫语句里的表达式"></a><span id="part-two">卫语句里的表达式</span></h1><p>Elixir默认导入和允许下述表达式在卫语句里：</p>
<ul>
<li>比较运算符（==，!=，===，!==，&gt;， &gt;=， &lt;， &lt;=）</li>
<li>布尔运算符（and，or，not）</li>
<li>算术运算符（+， -， *， /）</li>
<li>一元算术运算符（+， -）</li>
<li>二进制数据串联运算符 &lt;&gt;</li>
<li>in 运算符，只要它右边是一个范围或者一个列表</li>
<li><p>所有下述类型检查函数：</p>
<pre><code>* is_atom/1
* is_binary/1
* is_bitstring/1
* is_boolean/1
* is_float/1
* is_function/1
* is_function/2
* is_integer/1
* is_list/1
* is_map/1
* is_nil/1
* is_number/1
* is_pid/1
* is_port/1
* is_reference/1
* is_tuple/1
</code></pre></li>
<li><p>加上下面的函数</p>
<pre><code>* abs(number)
* binary_part(binary, start, length)
* bit_size(bitstring)
* byte_size(bitstring)
* div(integer, integer)
* elem(tuple, n)
* hd(list)
* length(list)
* map_size(map)
* node()
* node(pid | ref | port)
* rem(integer, integer)
* round(number)
* self()
* tl(list)
* trunc(number)
* tuple_size(tuple)
</code></pre></li>
</ul>
<p>另外，用户可以定义他们自己的卫语句。例如，Bitwise模块定义作为函数和运算符的卫语句：bnot，~~~，band，&amp;&amp;&amp;，bor，|||，bxor，^^^，bsl，&lt;&lt;&lt;，bsr，&gt;&gt;&gt;。</p>
<p>注意，虽然布尔运算符，比如：and，or 和 not 运行在卫语句里使用，但是更加通用的运算符 &amp;&amp;，|| 和 ! 却不被允许在卫语句里使用。</p>
<p>切记：卫语句里的错误不会被抛出，而是使得卫语句失败：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; hd(<span class="number">1</span>)</div><div class="line">** (ArgumentError) argument error</div><div class="line">iex&gt; <span class="keyword">case</span> <span class="number">1</span> do</div><div class="line">...&gt;   x <span class="keyword">when</span> hd(x) -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt;   x -&gt; <span class="string">"Got #&#123;x&#125;"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got 1"</span></div></pre></td></tr></table></figure>
<p>如果没有一个分支匹配，则有错误抛出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> :ok do</div><div class="line">...&gt;   :error -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CaseClauseError) no <span class="keyword">case</span> clause matching: :ok</div></pre></td></tr></table></figure>
<p>注意：匿名函数也可以有多个分支和卫语句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; f = fn</div><div class="line">...&gt;   x, y <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt; x + y</div><div class="line">...&gt;   x, y -&gt; x * y</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">12.71889879</span>/<span class="number">2</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; f.(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line"><span class="number">4</span></div><div class="line">iex&gt; f.(-<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">-3</div></pre></td></tr></table></figure>
<p>匿名函数每个分支的入参格式必须相同，否则有错误抛出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; f2 = fn</div><div class="line">...&gt;   x, y <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt; x + y</div><div class="line">...&gt;   x, y, z -&gt; x * y + z</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) iex:<span class="number">1</span>: cannot mix clauses with different arities in function definition</div></pre></td></tr></table></figure>
<h1 id="cond"><a href="#cond" class="headerlink" title="cond"></a><span id="part-three">cond</span></h1><p>当你要匹配不同的值的时候，case语句有用。然而，在许多情况中，我们想要检查不同的条件并且找到第一个为true的条件。在这样的场景下，可以使用cond：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This will not be true"</span></div><div class="line">...&gt;   <span class="number">2</span> * <span class="number">2</span> == <span class="number">3</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Nor this"</span></div><div class="line">...&gt;   <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> -&gt;</div><div class="line">...&gt;     <span class="string">"But this will"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"But this will"</span></div></pre></td></tr></table></figure>
<p>这和许多命令式语言里的 else if 分支等效（虽然不常在这里使用的方法）。</p>
<p>如果没有一个条件返回true，则一个错误（CondClauseError）被抛出。因为这个原因，增加一个最后条件，它等于true，这个条件将总是可以匹配到，这样的做法可能是必要的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This is never true"</span></div><div class="line">...&gt;   <span class="number">2</span> * <span class="number">2</span> == <span class="number">3</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Nor this"</span></div><div class="line">...&gt;   <span class="literal">true</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This is always true (equivalent to else)"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This is always true (equivalent to else)"</span></div></pre></td></tr></table></figure>
<p>最后，要注意：cond认为除nil和false外，任何值都是true：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   hd([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) -&gt;</div><div class="line">...&gt;     <span class="string">"1 is considered as true"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"1 is considered as true"</span></div></pre></td></tr></table></figure>
<h1 id="if-和-unless"><a href="#if-和-unless" class="headerlink" title="if 和 unless"></a><span id="part-four">if 和 unless</span></h1><p>除了case和cond，Elixir也提供宏：if/2 和 unless/2 ，它们在你需要仅仅检查一个条件的时候很有用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;   <span class="string">"This works!"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This works!"</span></div><div class="line">iex&gt; unless <span class="literal">true</span> do</div><div class="line">...&gt;   <span class="string">"This will never be seen"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">nil</div></pre></td></tr></table></figure>
<p>如果给予if/2的条件返回false或nil，则do/end之间的语句不会被执行，并且if/2的整体返回值是nil。unless/2的情况则相反。</p>
<p>它们也支持else块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> nil do</div><div class="line">...&gt;   <span class="string">"This won't be seen"</span></div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="string">"This will"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This will"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：一个关于if/2和unless/2的有趣的注意事项是在Elixir里它们被实现为宏；它们不像在其他语言那样是一个特殊的语言结构。你可以参阅官方文档和<a href="https://hexdocs.pm/elixir/Kernel.html" target="_blank" rel="external">Kernel模块的文档</a>中if/2的说明。Kernel模块里也定义了像+/2这样的运算符和像is_function/2这样的函数，这些函数都默认地被自动导入并在你的代码中可用。</p>
</blockquote>
<h1 id="do-end块"><a href="#do-end块" class="headerlink" title="do/end块"></a><span id="part-five">do/end块</span></h1><p>到此，我们已经学了四种控制结构：case、cond、if 和 unless ，它们都包裹在 do/end 块里。我们也可以像下面这样写 if 控制结构：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span>, do: <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>注意上面的例子在 true 和 do: 之间有一个逗号，这是因为它使用了Elixir的正规语法，每个参数用逗号分割。我们说这个语法是用<em>关键字列表</em>。我们也可以传递 else 使用关键字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">false</span>, do: :this, else: :that</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>do/end是构建于关键字上的语法便利措施。这就是为什么在前面的参数和语句块之间不需要逗号。它的确非常有用，因为当写代码块的时候它删除了冗余。下面的例子是等效的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;   a = <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt;   a + <span class="number">10</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">13</span></div><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span>, do: (</div><div class="line">...&gt;   a = <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt;   a + <span class="number">10</span></div><div class="line">...&gt; )</div><div class="line"><span class="number">13</span></div></pre></td></tr></table></figure>
<p>有一件事要记住，当你使用do/end的时候，它们总是和最外层函数调用绑定的。例如，下面的表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) undefined function: is_number/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>将被解析为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number(<span class="keyword">if</span> <span class="literal">true</span>) do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) undefined function: is_number/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>这将导致一个未定义函数错误，因为这个调用传递两个参数，而 is_number/2 并不存在。if true 表达式在这里是无效的，因为它需要代码块；而因为 is_number/2 的参数个数不匹配，Elixir根本就没有调用到它。</p>
<p>增加明确的括号就足以绑定代码块到 if ：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number(<span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>关键字列表Elixir里扮演很重要的角色，并且在许多函数和宏里普遍存在。在后续的章节里我们将进一步探索它们。接下来，我们讨论“二进制、字符串和字符列表”。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/case-cond-and-if.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/case-cond-and-if.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;case&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;卫语句里的表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;cond&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;if 和 unless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;do/end 块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本章，我们将学习 case，cond 和 if 这几个控制流结构。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="control flow structure" scheme="http://szpzs.oschina.io/categories/Elixir/control-flow-structure/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="control flow structure" scheme="http://szpzs.oschina.io/tags/control-flow-structure/"/>
    
      <category term="case" scheme="http://szpzs.oschina.io/tags/case/"/>
    
      <category term="cond" scheme="http://szpzs.oschina.io/tags/cond/"/>
    
      <category term="if" scheme="http://szpzs.oschina.io/tags/if/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－模式匹配</title>
    <link href="http://szpzs.oschina.io/2017/01/30/elixir-getting-started-pattern-matching/"/>
    <id>http://szpzs.oschina.io/2017/01/30/elixir-getting-started-pattern-matching/</id>
    <published>2017-01-30T11:31:59.000Z</published>
    <updated>2017-01-30T11:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">匹配运算符</a></li>
<li><a href="#part-two">模式匹配</a></li>
<li><a href="#part-three">pin运算符</a></li>
</ol>
<p>在本章，我们将展示给大家 = 运算符在Elixir里如何实际上是一个匹配运算符的以及如何用它来模式匹配数据结构里的数据。最后，我们将学习pin运算符 ^，它被用来访问变量之前被绑定的值。</p>
<a id="more"></a>
<h1 id="匹配运算符"><a href="#匹配运算符" class="headerlink" title="匹配运算符"></a><span id="part-one">匹配运算符</span></h1><p>我们已经用过几次 = 运算符在Elixir里给变量赋值：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; x</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>在Elixir里，= 运算符实际上被称为<em>匹配运算符</em>。让我们来看看究竟：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> = x</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="number">2</span> = x</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们注意到 1 = x 是一个有效表达式，而它匹配的原因是因为左右两边都等于1。当两边不匹配的时候，一个MatchError错误抛出。</p>
<p>变量被赋值的时候只能够处于 = 运算符的左边：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> = unknown</div><div class="line">** (CompileError) iex:<span class="number">1</span>: undefined function unknown/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>因为之前没有定义unknown变量，Elixir就假设你是想尝试调用 unknown/0 这个函数，但是这样的函数并不存在。</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a><span id="part-two">模式匹配</span></h1><p>匹配运算符不仅是用来匹配简单的值，而且对于解构更复杂的数据类型也是有用的。例如，我们可以在元组上进行模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = &#123;:hello, <span class="string">"world"</span>, <span class="number">42</span>&#125;</div><div class="line">&#123;:hello, <span class="string">"world"</span>, <span class="number">42</span>&#125;</div><div class="line">iex&gt; a</div><div class="line">:hello</div><div class="line">iex&gt; b</div><div class="line"><span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>在两边不匹配的情况下模式匹配将出错。例如下面的例子，当元组有不同的大小的时候：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = &#123;:hello, <span class="string">"world"</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;:hello, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>或者两边的数据类型不一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = [:hello, <span class="string">"world"</span>, <span class="number">42</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [:hello, <span class="string">"world"</span>, <span class="number">42</span>]</div></pre></td></tr></table></figure>
<p>更有趣地是，我们可以在指定的值上进行匹配。比如下面的例子就断言当右边是一个以原子 :ok 开始的元组的时候左边才和右边匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;:ok, result&#125; = &#123;:ok, <span class="number">13</span>&#125;</div><div class="line">&#123;:ok, <span class="number">13</span>&#125;</div><div class="line">iex&gt; result</div><div class="line"><span class="number">13</span></div><div class="line"></div><div class="line">iex&gt; &#123;:ok, result&#125; = &#123;:error, :oops&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;:error, :oops&#125;</div></pre></td></tr></table></figure>
<p>我们也可以在列表上模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>列表也支持匹配它的头部和尾部：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; [head | tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; head</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; tail</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>像 hd/1 和 tl/1 函数一样，我们不能用一个头部和尾部的模式来匹配一个空列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; [h | t] = []</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: []</div></pre></td></tr></table></figure>
<p>[head | tail] 格式不仅用在模式匹配而且也可以用在给列表加元素上：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; [<span class="number">0</span> | list]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>模式匹配允许开发者很容易地解构诸如元组和列表这样的数据类型。正如我们将在接下来的章节看到的，这是Elixir递归的基础之一，并且也应用于像map和二进制数据等其他类型。</p>
<h1 id="pin运算符"><a href="#pin运算符" class="headerlink" title="pin运算符"></a><span id="part-three">pin运算符</span></h1><p>Elixir的变量可以重新绑定：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; x = <span class="number">2</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>当你想模式匹配已经存在的变量的值而不是重新绑定这个变量的时候，pin运算符 ^ 就有用处了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; ^x = <span class="number">2</span></div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: <span class="number">2</span></div><div class="line">iex&gt; &#123;y, ^x&#125; = &#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">iex&gt; y</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; &#123;y, ^x&#125; = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>因为我们已经将1赋值给变量x，上述最后一个表达式也可以写成下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;y, <span class="number">1</span>&#125; = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>如果一个变量在一个模式里出现了不止一次，则所有对它的引用都应该绑定到相同的模式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;x, x&#125; = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">iex&gt; &#123;x, x&#125; = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>在一些场景里，你不关心模式里的某个特别的值。通用的做法是将这些值绑定到下划线，_ 。例如，如果仅是列表头部是我们需要的，我们可以将尾部赋给下划线：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [h | _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; h</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>变量 _ 在这里很特别，它永远不会被读取。如果尝试取读取它，会得到一个 未绑定变量 的错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; _</div><div class="line">** (CompileError) iex:<span class="number">1</span>: unbound variable _</div></pre></td></tr></table></figure>
<p>虽然模式匹配允许我们构建非常有用的结构，但是它的用法是有限制的。例如，你不能在匹配的左边调用函数。下面的例子就是无效的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; length([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]) = <span class="number">3</span></div><div class="line">** (CompileError) iex:<span class="number">1</span>: illegal pattern</div></pre></td></tr></table></figure>
<p>到此就完成了我们的模式匹配介绍。正如我们将在下一章看到的，模式匹配在Elixir的许多语言构造里是非常普遍的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="">http://elixir-lang.org/getting-started/pattern-matching.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;匹配运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;模式匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;pin运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本章，我们将展示给大家 = 运算符在Elixir里如何实际上是一个匹配运算符的以及如何用它来模式匹配数据结构里的数据。最后，我们将学习pin运算符 ^，它被用来访问变量之前被绑定的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="pattern match" scheme="http://szpzs.oschina.io/categories/Elixir/pattern-match/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="pattern match" scheme="http://szpzs.oschina.io/tags/pattern-match/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－基本运算符</title>
    <link href="http://szpzs.oschina.io/2017/01/29/elixir-getting-started-basic-operators/"/>
    <id>http://szpzs.oschina.io/2017/01/29/elixir-getting-started-basic-operators/</id>
    <published>2017-01-29T12:18:48.000Z</published>
    <updated>2017-01-29T12:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://elixir-lang.org/getting-started/basic-types.html" target="_blank" rel="external">前面的章节</a>，我们看到Elixir提供了 +，-，*，/ 4个算术运算符，另外还有整数的除法和取余的两个函数 div/2 和 rem/2 。</p>
<a id="more"></a>
<p>Elixir也提供了 ++ 和 - - 来操作列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ++ [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -- [<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>用 &lt;&gt; 把两个字符串串联起来：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"foo"</span> &lt;&gt; <span class="string">"bar"</span></div><div class="line"><span class="string">"foobar"</span></div></pre></td></tr></table></figure>
<p>Elixir也提供三个布尔运算符：or，and 和 not 。这些运算符严格要求布尔类型数据（true或false）作为它的第一个参数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="literal">false</span> or is_atom(:example)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>如果参数不是布尔型数据则会引起异常：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> <span class="keyword">and</span> <span class="literal">true</span></div><div class="line">** (ArgumentError) argument error: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>or和and都是短路运算符。如果左边不足以决定结果则它们才会执行右边的表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">false</span> <span class="keyword">and</span> raise(<span class="string">"This error will never be raised"</span>)</div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; <span class="literal">true</span> or raise(<span class="string">"This error will never be raised"</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你是Erlang开发者，Elixir的 and 和 or 的确和Erlang里的 andalso 和 orelse 运算符相互映射影射。</p>
</blockquote>
<p>除了这几个布尔运算符，Elixir还提供可以接收任何类型参数的 || ，&amp;&amp; 和 ！。对于这几个运算符，除了 false 和 nil 其他所有值都被认为是true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># or</div><div class="line">iex&gt; <span class="number">1</span> || <span class="literal">true</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="literal">false</span> || <span class="number">11</span></div><div class="line"><span class="number">11</span></div><div class="line"></div><div class="line"># <span class="keyword">and</span></div><div class="line">iex&gt; nil &amp;&amp; <span class="number">13</span></div><div class="line">nil</div><div class="line">iex&gt; <span class="literal">true</span> &amp;&amp; <span class="number">17</span></div><div class="line"><span class="number">17</span></div><div class="line"></div><div class="line"># !</div><div class="line">iex&gt; !<span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; !<span class="number">1</span></div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; !nil</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>根据经验，当你想要布尔值的时候就用and，or 和 not。如果有任何参数是非布尔值，则用&amp;&amp;，|| 和 ！。</p>
<p>Elixir也提供 ==，!=，===，!==，&lt;=，&gt;=，&lt; 和 &gt; 作为比较运算符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> == <span class="number">1</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> != <span class="number">2</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> &lt; <span class="number">2</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>== 和 === 不同之处在于，后者在比较整数和浮点数的时候更严格。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> == <span class="number">1.0</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> === <span class="number">1.0</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>在Elixir里，我们可以比较两个不同的数据类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> &lt; :atom</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们可以比较不同数据类型的原因是出于实用主义的考虑。排序算法不需要担心不同数据类型之间的排序问题。全部的排序顺序定义如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring</div></pre></td></tr></table></figure>
<p>你完全不需要记住这个顺序，只需要知道有这个顺序存在就足够了。</p>
<p>有关运算符（和排序）的参考信息，请查阅 <a href="http://elixir-lang.org/docs/master/elixir/operators.html" target="_blank" rel="external">运算符手册页面</a> 。</p>
<p>在下一章，我们将讨论一些基础函数，数据类型转换以及一些控制流。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/basic-operators.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/basic-operators.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://elixir-lang.org/getting-started/basic-types.html&quot;&gt;前面的章节&lt;/a&gt;，我们看到Elixir提供了 +，-，*，/ 4个算术运算符，另外还有整数的除法和取余的两个函数 div/2 和 rem/2 。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="basic operator" scheme="http://szpzs.oschina.io/categories/Elixir/basic-operator/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="basic operator" scheme="http://szpzs.oschina.io/tags/basic-operator/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－基本类型</title>
    <link href="http://szpzs.oschina.io/2017/01/28/elixir-getting-started-basic-types/"/>
    <id>http://szpzs.oschina.io/2017/01/28/elixir-getting-started-basic-types/</id>
    <published>2017-01-28T14:33:44.000Z</published>
    <updated>2017-01-28T14:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">基本算术运算</a></li>
<li><a href="#part-two">布尔类型</a></li>
<li><a href="#part-three">原子</a></li>
<li><a href="#part-four">字符串</a></li>
<li><a href="#part-five">匿名函数</a></li>
<li><a href="#part-six">(链接) 列表</a></li>
<li><a href="#part-seven">元组</a></li>
<li><a href="#part-eight">列表还是元组？</a></li>
</ol>
<a id="more"></a>
<p>本章我们将学习更多Elixir的基本数据类型：整数、浮点数、布尔值、原子、字符串、列表和元组。一些基本类型数据如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>          # 整数</div><div class="line">iex&gt; <span class="number">0</span>x1F       # 整数</div><div class="line">iex&gt; <span class="number">1.0</span>        # 浮点数</div><div class="line">iex&gt; <span class="literal">true</span>       # 布尔值</div><div class="line">iex&gt; :atom      # 原子 / 符号</div><div class="line">iex&gt; <span class="string">"elixir"</span>   # 字符串</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  # 列表</div><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  # 元组</div></pre></td></tr></table></figure>
<h1 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a><span id="part-one">基本算术运算</span></h1><p>打开 iex 输入如下表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; <span class="number">5</span> * <span class="number">5</span></div><div class="line"><span class="number">25</span></div><div class="line">iex&gt; <span class="number">10</span> / <span class="number">2</span></div><div class="line"><span class="number">5.0</span></div></pre></td></tr></table></figure>
<p>我们注意到 10 / 2 返回了一个浮点数5.0而不是整数5。这是正常的。在Elixir里，运算符 / 总是返回浮点数。如果你想要做整数除法或者想得到除法的余数，你可以调用 div 和 rem 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">div</span>(<span class="number">10</span>, <span class="number">2</span>)</div><div class="line"><span class="number">5</span></div><div class="line">iex&gt; <span class="keyword">div</span> <span class="number">10</span>, <span class="number">2</span></div><div class="line"><span class="number">5</span></div><div class="line">iex&gt; <span class="keyword">rem</span> <span class="number">10</span>, <span class="number">3</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>注意！Elixir允许你在调用一个命名函数时候省略圆括号。这个特性使得当你写声明和控制流结构的时候由更加简洁的语法。</p>
<p>Elixir也支持快捷符号来输入二进制、八进制以及十六进制数字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">0</span>b1010</div><div class="line"><span class="number">10</span></div><div class="line">iex&gt; <span class="number">0</span>o777</div><div class="line"><span class="number">511</span></div><div class="line">iex&gt; <span class="number">0</span>x1F</div><div class="line"><span class="number">31</span></div></pre></td></tr></table></figure>
<p>浮点数最少要求小数点后有一位数字，并且也支持用e符号表达式表示指数数字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1.0</span></div><div class="line"><span class="number">1.0</span></div><div class="line">iex&gt; <span class="number">1.0e-10</span></div><div class="line"><span class="number">1.0e-10</span></div></pre></td></tr></table></figure>
<p>在Elixir里浮点数是64位双精度。</p>
<p>你可以调用 round 函数获得与给定的浮点数最接近的整数，或者调用 trunc 函数获得一个浮点数的整数部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; round(<span class="number">3.58</span>)</div><div class="line"><span class="number">4</span></div><div class="line">iex&gt; trunc(<span class="number">3.58</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<h2 id="识别函数"><a href="#识别函数" class="headerlink" title="识别函数"></a>识别函数</h2><p>Elixir里的函数是通过它的名字和函数参数个数来区分的。函数的arity指的是函数的参数个数。从这一点上，我们将在整个文档里使用的函数的名称和它的参数个数来描述函数。round/1 确定函数的名字是round，参数个数是1，而 round/2 确定一个不同（其实是不存在的）的函数，相同的名字，参数个数是2。</p>
<h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><span id="part-two">布尔类型</span></h1><p>Elixir支持 true 和 false 为布尔值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="literal">true</span> == <span class="literal">false</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>Elixir提供很多断言函数来检查一个值的类型。例如，is_boolean/2 函数可以用来检查一个值是不是布尔类型。</p>
<p>注：Elixir的函数是通过函数名和参数个数（即arity）来区分的。因此，is_boolean/1 表示函数名是is_boolean而且有一个入参。is_boolean/2 （其实并不存在这个函数）表示有相同的函数名却有不同的arity的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_boolean(<span class="literal">true</span>)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_boolean(<span class="number">1</span>)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>如果入参是一个整数、一个浮点数或者其他数字，你也可以分别用 is_integer/1，is_float/1或is_number/1来检查。</p>
<blockquote>
<p>注：在任何时候，你可以在shell里输入 h() 来打印如何使用shell的信息。这个 h 帮助者也可以用来访问任何函数的文档。例如，输入 h is_integer/1 将打印 is_integer/1 函数的文档。它也可以运用在操作符和其他结构上（试一下 h ==/2）。</p>
</blockquote>
<h1 id="原子"><a href="#原子" class="headerlink" title="原子"></a><span id="part-three">原子</span></h1><p>原子是常量，它们名字就是它们自己的值。其他语言里叫这种数据类型为符号：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; :hello</div><div class="line">:hello</div><div class="line">iex&gt; :hello == :world</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>布尔值 true 和 false 实际上是原子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span> == :<span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_atom(<span class="literal">false</span>)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_boolean(:<span class="literal">false</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span id="part-four">字符串</span></h1><p>在Elixir里，字符串被包裹在两个双引号中，并且它们被用UTF-8来编码的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hellö"</span></div><div class="line"><span class="string">"hellö"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你在Windows中，你的终端可能默认就不用UTF-8编码。你可以通过在输入IEx前运行chcp 56001来改变当前会话的编码。</p>
</blockquote>
<p>Elixir也支持字符串插入：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hellö #&#123;:world&#125;"</span></div><div class="line"><span class="string">"hellö world"</span></div></pre></td></tr></table></figure>
<p>字符串内可以有换行符。你可以用转义字符引入它们。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; "hello</div><div class="line">...&gt; world"</div><div class="line">"hello\nworld"</div><div class="line">iex&gt; "hello\nworld"</div><div class="line">"hello\nworld"</div></pre></td></tr></table></figure>
<p>你可以用IO模块内的函数IO.puts/1来打印一个字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">"hello\nworld"</span></div><div class="line">hello</div><div class="line">world</div><div class="line">:ok</div></pre></td></tr></table></figure>
<p>注意：IO.puts/1函数在打印字符串后返回原子 :ok 作为结果。</p>
<p>在Elixir内部字符串是用一组字节组成的二进制数据来表示的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_binary(<span class="string">"hellö"</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们也可以获得一个字符串内的字节数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; byte_size(<span class="string">"hellö"</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们注意到上述例子的字符串的字节数是6，即使它只有5个字符。这是因为字符 “ö” 用UTF-8来编码的时候占用了两个字节。我们可以通过用String.length/1函数来基于字符数获得字符串的实际长度。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.length(<span class="string">"hellö"</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p><a href="https://hexdocs.pm/elixir/String.html" target="_blank" rel="external">String模块</a>包含了一些操作以Unicode标准定义的字符串的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.upcase(<span class="string">"hellö"</span>)</div><div class="line"><span class="string">"HELLÖ"</span></div></pre></td></tr></table></figure>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><span id="part-five">匿名函数</span></h1><p>匿名函数可以在行内被创建，并且它是被关键字fn和end界定的函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; add = fn a, b -&gt; a + b <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">12.71889879</span>/<span class="number">2</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; add.(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; is_function(add)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_function(add, <span class="number">2</span>) #检查add是否是一个有两个参数的函数</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_function(add, <span class="number">1</span>) #检查add是否是一个有一个参数的函数</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>函数在Elixir里是“一等公民”，这意味着它跟整数和字符串一样可以被当作参数传给其他函数。上述例子，我们把持有函数的变量add传给函数is_function/1，得到了正确的结果 true。我们也能够通过调用is_function/2来检查这个函数的参数个数。</p>
<p>注意：在变量和圆括号之间的 点 号（.）在调用一个匿名函数的时候是必须存在的。这个点号确定在调用匿名函数add和命名函数add/2的时候没有歧义。在这个意义上，Elixir使匿名函数和函数名之间有明显的区别。我们将在<a href="http://elixir-lang.org/getting-started/modules.html" target="_blank" rel="external">第八章</a>来看看那些区别。</p>
<p>匿名函数都是闭包，因此它可以访问那些和函数定义在一个范围内的变量。让我们定义一个新的匿名函数，它使用我们前面已经定义的匿名函数的变量add：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; double = fn a -&gt; add.(a, a) <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">6.71889879</span>/<span class="number">1</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; double.(<span class="number">2</span>)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>记住：一个变量在一个函数里被赋值不会影响它周围的环境：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">42</span></div><div class="line"><span class="number">42</span></div><div class="line">iex&gt; (fn -&gt; x = <span class="number">0</span> <span class="keyword">end</span>).()</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; x</div><div class="line"><span class="number">42</span></div></pre></td></tr></table></figure>
<h1 id="（链接）列表"><a href="#（链接）列表" class="headerlink" title="（链接）列表"></a><span id="part-six">（链接）列表</span></h1><p>Elixir用方括号来指定一个若干值组成的列表。这些值可以是任何类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">3</span>]</div><div class="line">iex&gt; length [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>两个列表可以用 ++/2 和 - -/2 操作符来串联和相减：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ++ [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">false</span>, <span class="number">3</span>, <span class="literal">true</span>] -- [<span class="literal">true</span>, <span class="literal">false</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">true</span>]</div></pre></td></tr></table></figure>
<p>在本教材中，我们将谈论很多关于列表的头部和尾部的事情。头部是一个列表的第一个元素而尾部则是剩下的部分。它们可以用函数 hd/1 和 tl/1 来获取。让我们将一个列表赋给一个变量然后获取它的头部和尾部：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; hd(list)</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; tl(list)</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>尝试获取一个空列表的头部或尾部会发生一个错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; hd []</div><div class="line">** (ArgumentError) argument error</div></pre></td></tr></table></figure>
<p>有时候你创建一个列表，返回来的是一个用单引号括起来的值。比如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</div><div class="line">'\v\f\r'</div><div class="line">iex&gt; [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]</div><div class="line">'hello'</div></pre></td></tr></table></figure>
<p>当Elixir遇到一个由可打印的ASCII码组成的列表，Elixir将把它当作字符列表打印出来（字面上的字符列表）。当和Erlang代码交互的时候字符列表十分常见。任何时候，当你在Elixir里遇到一个值而你不能十分确定它的类型的时候，你可以用 i/1 函数来获得它的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; i 'hello'</div><div class="line">Term</div><div class="line">  'hello'</div><div class="line">Data type</div><div class="line">  List</div><div class="line">Description</div><div class="line">  ...</div><div class="line">Raw representation</div><div class="line">  [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]</div><div class="line">Reference modules</div><div class="line">  List</div></pre></td></tr></table></figure>
<p>记住：单引号括住的值和双引号括住的值在Elixir里是不想等的，因为它们表示不同的类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; 'hello' == <span class="string">"hello"</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>单引号的是字符列表，双引号的是字符串。我们将在“<a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" target="_blank" rel="external">二进制，字符串和字符列表</a>”章节中详细讨论它们。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a><span id="part-seven">元组</span></h1><p>Elixir用大括号来定义元组。和列表一样，元组可以持有任何类型的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; tuple_size &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>元组会连续将元素存储在内存中。这意味着通过索引访问一个元组的元素或获取元组的大小是一个快速的操作。索引从零开始：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; elem(tuple, <span class="number">1</span>)</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; tuple_size(tuple)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>用函数 put_elem/3 放置一个元素到一个元组的指定的索引位置也是可能的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; put_elem(tuple, <span class="number">1</span>, <span class="string">"world"</span>)</div><div class="line">&#123;:ok, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; tuple</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div></pre></td></tr></table></figure>
<p>注意：put_elem/3 返回了一个新的元组。原来存储在tuple变量里的元组没有被修改，因为Elixir的数据类型是不可修改的。由于是不可修改的，Elixir代码更容易推导，因为你永远不用担心是否有特别的代码正在某处修改你的数据结构。</p>
<h1 id="列表还是元组"><a href="#列表还是元组" class="headerlink" title="列表还是元组"></a><span id="part-eight">列表还是元组</span></h1><p>列表和元组有何不同？</p>
<p>列表在内存中就如链接列表，意味着列表中的每一个元素持有它的值和指向后继元素的指针，如此一直到列表的尾部。我们称每一个值和指针对是一个 cons cell：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span> | [<span class="number">2</span> | [<span class="number">3</span> | []]]]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>这意味着访问列表的长度是一个线性操作：我们需要遍历整改列表来计算它的长度。只要我们在列表前面加元素则更新列表是快速的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">0</span> | list]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>相反，元组在内存中连续存储。这意味着获取元组的长度和通过索引获取元素是快速的。然而，元组的修改或增加是昂贵的操作，因为它需要在内存中拷贝整个元组。</p>
<p>这些性能特性决定了两类数据结构的用法。元组的一种非常通用的使用场景是用它们从函数返回额外的信息。例如：File.read/1 是一个可以用来读取文件内容的函数，而它返回的是元组：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read(<span class="string">"path/to/existing/file"</span>)</div><div class="line">&#123;:ok, <span class="string">"... contents ..."</span>&#125;</div><div class="line">iex&gt; File.read(<span class="string">"path/to/unknown/file"</span>)</div><div class="line">&#123;:error, :enoent&#125;</div></pre></td></tr></table></figure>
<p>如果传给File.read/1的路径存在，它返回一个元组，第一个元素是原子 :ok，第一个元素是文件内容。否则，它返回一个由原子 :error 和错误描述组成的元组。</p>
<p>大多数时候，Elixir会引导你做正确的事情。例如，有一个函数 elem/2 用来访问元组元素的，而对于列表则没有对应的内建函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; elem(tuple, <span class="number">1</span>)</div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>当计算一个数据结构的元素个数的时候，Elixir也遵从一个简单的规则：如果这个操作是在常数时间内的（即是该值是预先计算的）则这个函数命名为szie；或者，如果这个操作是线性的（即是计算长度随着输入数据的增长而越来越慢）则这个函数命名为length。为便于记忆，“长度”和“线性”都是“l”字母开始的。</p>
<p>例如，我们目前已经用过4个计算函数：byte_size/1 （计算字符串的字节数），tuple_size/1 （计算元组大小），length/1 （计算列表长度）以及 String.length/1（计算字符串的字符个数）。也就是说，我们用 byte_size 来获取字符串的字节数是廉价操作，但是用 String.length 获取unicode字符的个数可能是昂贵的操作因为整个字符串需要被遍历。</p>
<p>Elixir也提供 Port，Reference和PID作为数据类型（它们通常用于进程间通信），当我们讨论进程的时候将快速浏览它们一下。接下来，让我们看看在我们基本类型上的一些基本操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/basic-types.html#identifying-functions" target="_blank" rel="external">http://elixir-lang.org/getting-started/basic-types.html#identifying-functions</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;基本算术运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;布尔类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;原子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;匿名函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;(链接) 列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;元组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-eight&quot;&gt;列表还是元组？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="basic type" scheme="http://szpzs.oschina.io/categories/Elixir/basic-type/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="basic type" scheme="http://szpzs.oschina.io/tags/basic-type/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－介绍</title>
    <link href="http://szpzs.oschina.io/2017/01/27/elixir-getting-started-introduction/"/>
    <id>http://szpzs.oschina.io/2017/01/27/elixir-getting-started-introduction/</id>
    <published>2017-01-27T12:31:52.000Z</published>
    <updated>2017-01-27T12:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎你的到来！</p>
<p>本教程我们将教你Elixir的基础，语言的语法，如何定义模块，如何处理常见的数据结构和更多的特点。本章将聚焦在确保Elixir已经安装并且你能够成功地运行Elixir的交互Shell，即IEx。</p>
<a id="more"></a>
<p>我们的必要条件是：</p>
<ul>
<li>Elixir － 版本至少是1.4.0</li>
<li>Erlang － 版本至少是18.0</li>
</ul>
<p>让我们开始吧！</p>
<blockquote>
<p>如果你在本教程或本网站上发现任何错误，<a href="https://github.com/elixir-lang/elixir-lang.github.com" target="_blank" rel="external">请报告这个bug或者发一个pull requst到我们的问题跟踪里</a>。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果你还没有安装好Elixir，请到我们的<a href="http://elixir-lang.org/install.html" target="_blank" rel="external">安装指南</a>页面。一旦你安装好Elixir，你就能够运行  elixir –version 来得到当前Elixir的版本。</p>
<h1 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h1><p>当你安装Elixir，你将有三个新的可执行文件：iex，elixir和elixirc。如果你是从源码编译Elixir或者使用预先打包好的版本，你可以在bin目录里找到这三个可执行文件。</p>
<p>现在，让我们运行iex（如果你在Windows下则运行iex.bat），它代表交互式Elixir。在交互模式，我们能够输入任何Elixir表达式并且得到它的结果。让我们用一些基本表达式来热身。</p>
<p>运行iex并输入如下的表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex&gt; <span class="number">40</span> + <span class="number">2</span></div><div class="line"><span class="number">42</span></div><div class="line">iex&gt; <span class="string">"hello"</span> &lt;&gt; <span class="string">" world"</span></div><div class="line"><span class="string">"hello world"</span></div></pre></td></tr></table></figure>
<p>看来我们准备好了！我们从下下一章开始将在接下来的章节里大量使用交互shell来进一步熟悉这门语言的构造和基本类型。</p>
<blockquote>
<p>注意：如果你使用的是Windows，你也可以尝试 iex.bat - -werl 根据你正在用的控制台来提供更好的体验。</p>
</blockquote>
<h1 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h1><p>初步熟悉这门语言后，你可能想尝试写简单的程序，这个任务可以通过把下述Elixir代码放到一个文件里来完成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IO.puts “Hello world from Elixir<span class="string">"</span></div></pre></td></tr></table></figure>
<p>保存文件为simple.exs并且用elixir执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">elixir simple.exs</div><div class="line">Hello world from Elixir</div></pre></td></tr></table></figure>
<p>后续我们将学习如何编译Elixir代码（<a href="http://elixir-lang.org/getting-started/modules.html" target="_blank" rel="external">在第八章</a>）并且如何使用Mix构建工具（在<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix&amp;OTP guide</a>）。现在，让我们进入到<a href="http://elixir-lang.org/getting-started/basic-types.html" target="_blank" rel="external">第二章</a>。</p>
<h1 id="如何问问题"><a href="#如何问问题" class="headerlink" title="如何问问题"></a>如何问问题</h1><p>在本教程的学习过程中，有一些疑问是很常见的，毕竟，这是学习过程的一部分！有很多地方你可以请教他们来更多地了解Elixir：</p>
<ul>
<li><a href="irc://irc.freenode.net/elixir-lang" target="_blank" rel="external">#elixir-lang on freenode IRC</a></li>
<li><a href="https://elixir-slackin.herokuapp.com/" target="_blank" rel="external">Elixir on Slack</a></li>
<li><a href="http://elixirforum.com/" target="_blank" rel="external">Elixir Forum</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/elixir" target="_blank" rel="external">elixir tag on StackOverflow</a></li>
</ul>
<p>当问问题的时候，记住两个技巧：</p>
<ul>
<li>不是问“在Elixir里如何去做X”，而是问“在Elixir里怎样去解决Y”。换句话说，不要问如何实现一个特定的解决方案，而是描述手头上的问题。描述一个问题的时候给予更多的上下文信息以及更少的对一个正确答案的偏见。</li>
<li>如果事情并不如预想的那样，请在你的报告里尽可能多地提供相关信息，比如：你的Elixir版本，代码片段和错误信息以及错误堆栈。使用像Gist这样的网站发布这些信息。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/introduction.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎你的到来！&lt;/p&gt;
&lt;p&gt;本教程我们将教你Elixir的基础，语言的语法，如何定义模块，如何处理常见的数据结构和更多的特点。本章将聚焦在确保Elixir已经安装并且你能够成功地运行Elixir的交互Shell，即IEx。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="introduction" scheme="http://szpzs.oschina.io/categories/Elixir/introduction/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="introduction" scheme="http://szpzs.oschina.io/tags/introduction/"/>
    
  </entry>
  
  <entry>
    <title>监控Erlang的原子</title>
    <link href="http://szpzs.oschina.io/2017/01/25/about-erlang-atoms/"/>
    <id>http://szpzs.oschina.io/2017/01/25/about-erlang-atoms/</id>
    <published>2017-01-25T13:46:29.000Z</published>
    <updated>2017-01-25T14:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你是Erlang用户，你很可能知道<a href="http://learnyousomeerlang.com/starting-out-for-real" target="_blank" rel="external">原子是什么</a>。你也有很高的机会知道在Erlang里关于原子的<a href="http://erlang.org/doc/efficiency_guide/commoncaveats.html#id61937" target="_blank" rel="external">警告</a>：</p>
<blockquote>
<p>原子是不进行垃圾回收的。一旦原子被创建，它就不会被删除。如果原子的数量达到限制值（默认是1,048,576），模拟器就会终止。</p>
</blockquote>
<a id="more"></a>
<p>原子的文本存储在原子表里（每个元素对应唯一一个原子），而且这些数据是不会被垃圾回收的。这个原子表的条目数对应一个可配置的限制值。达到这个限制值（比如动态地不停地生成原子）可以造成Erlang虚拟机崩溃。</p>
<p>原子很棒，但是一定要小心使用它们。动态创建原子（比如通过list_to_atom/1函数）必须要不惜代价避免。毕竟，这是list_to_existing_atom/1函数为什么存在的理由。如果你想知道什么时候应该使用原子，什么时候使用其他东西，你可能喜欢<a href="http://erlang.org/pipermail/erlang-questions/2015-October/086366.html" target="_blank" rel="external">Erlang问题邮件列表里的这个贴子</a>，其中包括Richard A. O’Keefe 和 Joe Armstrong 的回答。既然太多原子可以引起我们的系统非正常崩溃，<strong>那么在运行的生产系统中关注原子表的条目的数量是非常重要的</strong>。但是我们该如何做呢？</p>
<p>在当前的OTP版本（在我写本文的时候是19.2），只有关于原子表使用内存的信息能通过erlang:memory/1函数来获取给予用户。实际上有两个相似的参数可以使用。我们先看第一个：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; erlang:memory(atom).</div><div class="line"><span class="number">202481</span></div></pre></td></tr></table></figure>
<p>这个函数返回原子表自己使用的内存加上那个时点预留给原子字符串的内存。预留给原子字符串的内存以块形式增长。返回值是以字节为单元来表示。</p>
<p>让我们看第二个：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; erlang:memory(atom_used).</div><div class="line"><span class="number">187410</span></div></pre></td></tr></table></figure>
<p>这个函数返回原子表自己使用的内存加上原子字符串空间实际使用的内存。它的返回值也是以字节为单元来表示。谢谢<a href="https://github.com/mikpe" target="_blank" rel="external">Mikael</a>为我确认这个两个函数的不同之处。</p>
<p>但是，我们如何利用这一信息呢？了解原子表分配内存是一回事，但<strong>我们真的很想知道有多少原子在我们的生产系统中</strong>，而且我们是否接近臭名昭著的1百万原子表条目数限制。在经过查阅官方文档之后，我确信这些信息不会暴露给用户。在这一点上，我的同事<a href="https://github.com/dszoboszlay" target="_blank" rel="external">Daniel</a>建议，可以将这个信息从erlang:system_info/1函数的二进制输出提取出来：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; erlang:system_info(info).</div><div class="line">&lt;&lt;<span class="string">"=memory\ntotal: 13227160\nprocesses: 4383720\nprocesses_used: 4383496\nsystem: 8843440\natom: 202481\natom_used: 187410\nbi"</span>...&gt;&gt;</div></pre></td></tr></table></figure>
<p>上述输出被Erlang shell截断了，因此让我们用更加好看的格式打印它的输出（如下的输出示例被截断了）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; io:put_chars(erlang:system_info(info)).</div><div class="line">=memory</div><div class="line">total: <span class="number">13287200</span></div><div class="line">processes: <span class="number">4394640</span></div><div class="line">processes_used: <span class="number">4394416</span></div><div class="line">system: <span class="number">8892560</span></div><div class="line">[...]</div><div class="line">=index_table:atom_tab</div><div class="line">size: <span class="number">8192</span></div><div class="line">limit: <span class="number">1048576</span></div><div class="line">entries: <span class="number">7227</span></div><div class="line">=hash_table:module_code</div><div class="line">[...]</div></pre></td></tr></table></figure>
<p>的确，我们需要的信息就这里面。让我们实现一个简单的助手模块来提取它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(atom_table)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([count/<span class="number">0</span>])</span>.</div><div class="line"><span class="function"><span class="title">count</span><span class="params">()</span> -&gt;</span></div><div class="line">  Info = erlang:system_info(info),</div><div class="line">  Chunks = binary:split(Info, &lt;&lt;<span class="string">"="</span>&gt;&gt;, [global]),</div><div class="line">  [TabInfo] = [X || &lt;&lt;<span class="string">"index_table:atom_tab"</span>, X/binary&gt;&gt; &lt;- Chunks],</div><div class="line">  Lines = binary:split(TabInfo, &lt;&lt;<span class="string">"\n"</span>&gt;&gt;, [global]),</div><div class="line">  Chunks2 = [binary:split(L, &lt;&lt;<span class="string">": "</span>&gt;&gt;) || L &lt;- Lines, L =/= &lt;&lt;&gt;&gt;],</div><div class="line">  binary_to_integer(proplists:get_value(&lt;&lt;<span class="string">"entries"</span>&gt;&gt;, Chunks2)).</div></pre></td></tr></table></figure>
<p>接着我们看看我们的助手的作用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; atom_table:count().</div><div class="line"><span class="number">7085</span></div></pre></td></tr></table></figure>
<p>不是最好的API，但至少我们得到了我们需要的信息。幸运的是，<a href="https://github.com/mikpe" target="_blank" rel="external">Mikael</a>向OTP团队提交了一个<a href="https://github.com/erlang/otp/pull/1286" target="_blank" rel="external">Pull Request</a>，其中包括一个新的API以更好的方式找回我们的小宝贝信息。这个Pull Request最近已经被接受，这就意味着从OTP 20开始，我们将能够用下面的API来获取关于原子使用的数量的信息：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erlang:system_info(atom_count).</div></pre></td></tr></table></figure>
<p>好极了，不是吗？</p>
<p>现在，我们有我们所需要的指标，我们可以设置一个周期性的工作，将我们的生产系统中的原子数发送到我们最喜欢的监控系统，并且如果一个预定义的阈值被超过则引起一个报警。我会用很低的阈值（即小于50%），因为即使在一个巨大的Erlang系统是不大可能看到几十万个原子的，而且达到那么高的数字可能就暴露一些原子动态生成的问题。如果真是这样的情况，我们需要尽快报警。</p>
<p>现在让我们创建一个新的原子，然后再用我们的助手一次：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; roberto.</div><div class="line">roberto</div><div class="line"><span class="number">3</span>&gt; atom_table:count().</div><div class="line"><span class="number">7134</span></div></pre></td></tr></table></figure>
<p>等一等！我们只是创建了一个原子。为什么原子数量从7085跳到7134了？</p>
<p>在运行中的Erlang系统里，原子随时都会被创建。例如，可能一个进程在没有见过的模块中对一个函数执行完全限定的函数调用。这将导致模块加载到系统中，并且一堆原子被添加到原子表。毕竟，模块名是原子，函数名等等也是原子。</p>
<p>现在让我们假设我们的系统原子泄露。我们怎样才能知道哪些原子在产生？有几个方法从一个运行的Erlang系统中获取原子列表，不过我最喜欢的方法是<a href="http://stackoverflow.com/questions/13480462/erlang-can-i-get-a-list-of-all-currently-registered-atoms" target="_blank" rel="external">legoscia在StackOverflow给出的</a>。这个方法真的很邪乎，它使用了外部数据格式的非官方公布特性。</p>
<p><img src="/images/about-erlang-atoms-1.jpeg" style="border:0;"></p>
<p>比如我们可以利用从Stack Overflow获取的代码读取系统中原子的列表，稍等一会儿，然后再次运行它，看两次结果的差异。我们甚至不需要在生产中运行这样的代码，因为本地工作站或测试系统足以发现意外产生这些原子的背后的根本原因。</p>
<p>如果我们发现原子是动态生成的，我们可能想确保它不再发生。在这种情况下，我推荐使用像 Erlang 风格的审阅工具：<a href="https://github.com/inaka/elvis" target="_blank" rel="external">Elvis</a>，我的同事<a href="https://github.com/jfacorro" target="_blank" rel="external">Juan</a>是它的主要贡献者。。</p>
<p>那么你有什么问题吗？有没有其他的你跟踪的Erlang指标（或者你想跟踪）很难获取或另有隐情？请在评论中让我们知道。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@robertoaloi/about-erlang-atoms-a24603a4a6e8#.cm9ha79v7" target="_blank" rel="external">https://medium.com/@robertoaloi/about-erlang-atoms-a24603a4a6e8#.cm9ha79v7</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你是Erlang用户，你很可能知道&lt;a href=&quot;http://learnyousomeerlang.com/starting-out-for-real&quot;&gt;原子是什么&lt;/a&gt;。你也有很高的机会知道在Erlang里关于原子的&lt;a href=&quot;http://erlang.org/doc/efficiency_guide/commoncaveats.html#id61937&quot;&gt;警告&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原子是不进行垃圾回收的。一旦原子被创建，它就不会被删除。如果原子的数量达到限制值（默认是1,048,576），模拟器就会终止。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/categories/Erlang/Atom/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>用Erlang进行分布式计算 -- 第二篇</title>
    <link href="http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-2/"/>
    <id>http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-2/</id>
    <published>2017-01-23T06:01:59.000Z</published>
    <updated>2017-01-23T06:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章里，我们已经看到如何连接一个远程节点并且运行Erlang里内建的模块。本文我们将学习如何可以运行我们自己的模块来做一些任务。例如我们将从远程节点获取分配给它们网络接口的ip地址。</p>
<a id="more"></a>
<p>我们的模块看起来像如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">% 文件名应该是 ourmodule.erl</div><div class="line">-module(ourmodule).</div><div class="line">-export([ getip/0 ]).</div><div class="line">getip()-&gt;</div><div class="line">    % 这是用于Mac终端的</div><div class="line">    % B = os:cmd('ifconfig $2 | grep \"inet \" | awk -F\' \' \'&#123;print    $2&#125;\' | awk \'&#123;print $1&#125;\''),</div><div class="line">    % 这是用于Linux终端的</div><div class="line">    B = os:cmd('ifconfig $2 | grep \"inet \" | awk -F\' \' \'&#123;print $2&#125;\' | awk \'&#123;print $1&#125;\' | awk -F \':\' \'&#123;print $2&#125;\''),</div><div class="line">    io:format("node: ~s ~n ~s ", [node(), B]),</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>保存这份代码为<strong>ourmodule.erl</strong>。</p>
<p>现在让我们来编译我们的模块。首先我们必须去到我们模块存放的目录。然后打开Erlang shell并且编译它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c(ourmodule). %%% 输出是: &#123;ok,ourmodule&#125;</div></pre></td></tr></table></figure>
<p>编译后，我们在同一个目录里将有一个 <strong>ourmodule.beam</strong> 文件，它是这个模块的erlang可执行文件。然后我们必须拷贝这个 <strong>ourmodule.beam</strong> 文件到远程节点。现在从相同的目录（远程节点上该文件存放的目录）让我们打开一个Erlang shell：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name cloud@remote-host -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>做完这些。这些就是我们在远程节点需要做的所有工作。</p>
<p>现在从你的主（也就是本地）节点执行如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpc:call('cloud@remote-host', ourmodule, getip, []).</div><div class="line"><span class="comment">% 输出是 : 将有节点名和一些ip地址的列表</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% node: cloud@remote-host</span></div><div class="line"><span class="comment">% 127.0.0.1</span></div><div class="line"><span class="comment">% 192.168.1.45</span></div><div class="line"><span class="comment">% ok.</span></div></pre></td></tr></table></figure>
<p>这是一个简单例子，就是我们如何可以在分布式Erlang环境里运行我们自己的模块。我们可以通过增加更多函数来做其他任务，或者我们可以只是为我们的目的写新的模块，然后我们可以分布可执行文件到不同的节点并远程执行它们。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@smirazzakee/distributed-computing-using-erlang-2-c57f3242a2e0#.acwcop39g" target="_blank" rel="external">https://medium.com/@smirazzakee/distributed-computing-using-erlang-2-c57f3242a2e0#.acwcop39g</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇文章里，我们已经看到如何连接一个远程节点并且运行Erlang里内建的模块。本文我们将学习如何可以运行我们自己的模块来做一些任务。例如我们将从远程节点获取分配给它们网络接口的ip地址。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/categories/Erlang/Distributed-Systems/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/tags/Distributed-Systems/"/>
    
  </entry>
  
  <entry>
    <title>用Erlang进行分布式计算 -- 第一篇</title>
    <link href="http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-1/"/>
    <id>http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-1/</id>
    <published>2017-01-23T05:30:17.000Z</published>
    <updated>2017-01-23T05:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文我们将看看Erlang里的分布式系统是如何运作的。</p>
<p>Erlang是一种函数式语言，其最被大家所熟知的是分布式和并发计算。</p>
<a id="more"></a>
<p>一般Erlang程序运行在节点上（<strong>节点名默认是nonode@nohost</strong>）。</p>
<p>在一个分布式系统里，节点间彼此交互。本文我们将用两个节点：<strong>sakib@localhost</strong> 和 <strong>cloud@remote-host</strong> 。</p>
<p>节点<strong>sakib@localhost</strong>运行在我本地系统，节点<strong>cloud@remote-host</strong>运行在远程服务器上。<strong>remote-host</strong>是我的远程服务器的主机名。</p>
<p>连接到远程节点，节点名的后缀（节点名@符号后的部分）和主机名相同是很重要。</p>
<p>现在如下所示打开本地系统的Erlang的shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name sakib@localhost -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>并且如下所示打开远程服务器的Erlang的shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name cloud@remote-host -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>两个节点的cookie必须一样，或者稍后你可以设置节点的cookie。如果远程节点的cookie没有设置，那么本地节点的cookie将被用来连接远程节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 给指定的节点设置cookie</span></div><div class="line">erlang:set_cookie('cloud@remote-host', '<span class="number">12345</span>').</div><div class="line"><span class="comment">% 第一个参数是节点名，第二参数是cookie</span></div><div class="line"><span class="comment">% 连接远程节点</span></div><div class="line">net_kernel:connect_node('cloud@remote-host').</div></pre></td></tr></table></figure>
<p>如果响应是true，则连接建立；如果响应是false，则连接失败。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">% 列出已经连接的节点列表</div><div class="line">nodes().</div><div class="line">% 输出是 : ['cloud@remote-host']</div><div class="line">% 因为我们现在仅仅连接了一个远程节点</div></pre></td></tr></table></figure>
<p>现在我们可以用<strong>RPC</strong>来运行远程节点的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpc:call('cloud@remote-host', os, cmd, [whoami]).</div></pre></td></tr></table></figure>
<p>rpc:call()函数有4个入参。</p>
<p>第一个是节点名，第二个是模块名，第三个是函数名，第四个是函数的入参。</p>
<p>上述例子是我们运行<strong>os</strong>模块里的<strong>cmd()</strong>函数，入参是<strong>whoami</strong>。它将返回远程系统的当前用户名。<strong>os</strong>是Erlang的内建模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 使用multicall函数 (跨所有连接的节点执行rpc调用)</span></div><div class="line">rpc:multicall(nodes(), os, cmd, [whoami]).</div><div class="line"><span class="comment">% 与远程节点断开连接</span></div><div class="line">erlang:disconnect_node('cloud@remote-host').</div></pre></td></tr></table></figure>
<p>用同样的方式我们可以将不同的任务分布到不同的节点来处理，然后在主节点上获取结果。这就是在Erlang里一个分布式系统的运作方式。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@sakibsami/distributed-computing-using-erlang-1-cdd051a77c85#.maaswacq4" target="_blank" rel="external">https://medium.com/@sakibsami/distributed-computing-using-erlang-1-cdd051a77c85#.maaswacq4</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文我们将看看Erlang里的分布式系统是如何运作的。&lt;/p&gt;
&lt;p&gt;Erlang是一种函数式语言，其最被大家所熟知的是分布式和并发计算。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/categories/Erlang/Distributed-Systems/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/tags/Distributed-Systems/"/>
    
  </entry>
  
  <entry>
    <title>耗尽弹药时你不能爆炸！</title>
    <link href="http://szpzs.oschina.io/2017/01/13/running-out-of-ammo/"/>
    <id>http://szpzs.oschina.io/2017/01/13/running-out-of-ammo/</id>
    <published>2017-01-13T02:16:13.000Z</published>
    <updated>2017-01-13T02:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文（和<a href="https://medium.com/erlang-battleground/beyond-the-limits-of-an-ets-cdd79fa8300c#.tsfdkduyd" target="_blank" rel="external">上一篇文章</a>一样）也是受我在哥伦比亚卡利的学生的好奇心所启发。这次的问题是：什么时候并且为什么 bang（!）（即消息发送）操作符失败？</p>
<a id="more"></a>
<p><img src="/images/running-out-of-ammo-1.jpeg" style="border:0;"></p>
<h1 id="有时候你有无限的子弹"><a href="#有时候你有无限的子弹" class="headerlink" title="有时候你有无限的子弹"></a>有时候你有无限的子弹</h1><p>那些天我和我的学生讨论的是Erlang的一个核心概念：消息传递。Erlang中消息传递是用发送操作符（即 ！，也叫做bang）来完成的。这次我给他们介绍bang，我用一个Pid放在它的左边。就像这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; Pid = self().</div><div class="line">&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">2</span>&gt; Pid ! &#123;a, message&#125;.</div><div class="line">&#123;a,message&#125;</div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下（当表达式的左边是一个Pid），bang从来不失败。即使Pid表示的是一个死亡进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">4</span>&gt; erlang:is_process_alive(Pid).</div><div class="line"><span class="literal">false</span></div><div class="line"><span class="number">5</span>&gt; Pid ! &#123;another, message&#125;.</div><div class="line">&#123;another,message&#125;</div><div class="line"><span class="number">6</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="有时候你就是不能开枪"><a href="#有时候你就是不能开枪" class="headerlink" title="有时候你就是不能开枪"></a>有时候你就是不能开枪</h1><p>但是Pid并不是在bang左边唯一有效的表达式，你也可以用原子和元组放在bang的左边，例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">7</span>&gt; my ! &#123;third, message&#125;.</div><div class="line">&#123;third,message&#125;</div><div class="line"><span class="number">8</span>&gt; &#123;my, node()&#125; ! &#123;fourth, message&#125;.</div><div class="line">&#123;fourth,message&#125;</div><div class="line"><span class="number">9</span>&gt; flush().</div><div class="line">Shell got &#123;third,message&#125;</div><div class="line">Shell got &#123;fourth,message&#125;</div><div class="line">ok</div><div class="line"><span class="number">10</span>&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下，如果没有进程被注册为这个名字，bang操作可能失败：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>&gt; no_proc ! &#123;fifth, message&#125;.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as no_proc ! &#123;fifth,message&#125;</div><div class="line"><span class="number">11</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="去读官方文档吧！"><a href="#去读官方文档吧！" class="headerlink" title="去读官方文档吧！"></a>去读官方文档吧！</h1><p>所有问题在<a href="http://erlang.org/doc/reference_manual/expressions.html#id80833" target="_blank" rel="external">官方文档</a>里都有清晰的说明。</p>
<blockquote>
<p>Expr1的计算结果必须是一个pid、一个注册的名字（原子），或者是一个格式为{Name, Node}的元组。Name是一个原子而Node是一个节点名字，也是一个原子。</p>
<p>如果Expr1的计算结果是一个名字，但是这个名字没有注册，则一个badarg运行时错误发生。</p>
<p>发送消息给一个pid永远都不会失败，即使这个pid指的是一个不存在的进程。</p>
<p>也就是说，如果Expr1的计算结果是一个格式为{Name, Node}元组（或者是另外一个节点的pid），分布式消息发送也永远不会失败。</p>
</blockquote>
<p><img src="/images/running-out-of-ammo-2.gif" style="border:0;"></p>
<h1 id="是的，不过…"><a href="#是的，不过…" class="headerlink" title="是的，不过…"></a>是的，不过…</h1><p>现在，我们不能只是满足了解这点知识。</p>
<p>正如你可能猜到的，我们没有那样做。我们问自己：</p>
<blockquote>
<p>当没有进程用相关名字注册，而如果发送消息给这个名字时，会抛出badarg错误：<br>1、一个进程可以用一个名字注册，但它却是不存在的？换句话说：bang操作失败意味着这个进程不存在？<br>2、我如何在用<strong>bang</strong>操作前检查是否有进程用相关名字注册。</p>
</blockquote>
<h2 id="问题1：我能注册已经死亡的进程吗？"><a href="#问题1：我能注册已经死亡的进程吗？" class="headerlink" title="问题1：我能注册已经死亡的进程吗？"></a>问题1：我能注册已经死亡的进程吗？</h2><p>为回答问题1，我们必须先检查一些事情。一个进程可以死掉并且还能用一个名字注册吗？我们用两种方法来尝试：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; Pid = self().</div><div class="line">&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">2</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">3</span>&gt; register(my, Pid).</div><div class="line">** exception error: bad argument</div><div class="line">     in function  register/<span class="number">2</span></div><div class="line">        called as register(my,&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;)</div><div class="line"><span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>首先我们尝试一个已经死亡的进程作为入参来调用erlang:register/2函数，结果我们失败了。然后我们尝试注册一个进程，接着杀掉它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">5</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">6</span>&gt; my ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as my ! message</div><div class="line"><span class="number">7</span>&gt;</div></pre></td></tr></table></figure>
<p>还是失败了。不过这次的失败是因为进程已经死亡了还是因为发送消息的时候它没有被注册？这就带我们进入问题2…</p>
<h2 id="问题2：我怎么能够阻止bagarg错误发生？"><a href="#问题2：我怎么能够阻止bagarg错误发生？" class="headerlink" title="问题2：我怎么能够阻止bagarg错误发生？"></a>问题2：我怎么能够阻止bagarg错误发生？</h2><p>现在，我如何可以找出实际在对某个名字使用bang操作之前是否有一个用这个名字注册的进程？</p>
<p>快速而且非常精确的答案是：你做不到。因为Erlang的并发本质，在你检测进程是否存在的时候和你发送消息的时候这两个时间点之间，这个进程可能已经死掉了（或者一个新的进程使用了相同的名字来注册）。</p>
<p>尽管如此，还是有一个方法来只是检查在你的节点上是否有一个用某个名字注册的进程，并找到那个进程是哪个进程来作为奖赏：<a href="http://erlang.org/doc/man/erlang.html#whereis-1" target="_blank" rel="external">whereis/1</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span>&gt; whereis(my).</div><div class="line">undefined</div><div class="line"><span class="number">8</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">9</span>&gt; whereis(my).</div><div class="line">&lt;<span class="number">0.75</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">10</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">11</span>&gt; whereis(my).</div><div class="line">undefined</div><div class="line"><span class="number">12</span>&gt;</div></pre></td></tr></table></figure>
<p>如果whereis/1返回undefined，你就知道在你的节点里没有用那个名字注册的进程。但是，如上所述，您不应该编写像如下的代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> whereis(my) <span class="keyword">of</span></div><div class="line">  undefined -&gt; do_nothing;</div><div class="line">  APid -&gt; APid ! message</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你那是正在给自己购买了去竞争条件之地的票。你所需要的就如下代码所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> my ! message</div><div class="line"><span class="keyword">catch</span></div><div class="line">  _:badarg -&gt; do_nothing</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><img src="/images/running-out-of-ammo-3.gif" style="border:0;"></p>
<h1 id="但是我们讨厌-try…catch！"><a href="#但是我们讨厌-try…catch！" class="headerlink" title="但是我们讨厌 try…catch！"></a>但是我们讨厌 try…catch！</h1><p>如果你真的不喜欢像上面那样用try…catch来处理每一个消息，这里有一个小技巧。还记得前面官方文档说过的吗？</p>
<blockquote>
<p>也就是说，如果Expr1的计算结果是一个格式为{Name, Node}元组（或者是另外一个节点的pid），分布式消息发送也永远不会失败。</p>
</blockquote>
<p>考虑到这一点，看看你能做些什么来替代上面的做法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">12</span>&gt; my ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as my ! message</div><div class="line"><span class="number">13</span>&gt; &#123;my, node()&#125; ! message.</div><div class="line">message</div><div class="line"><span class="number">14</span>&gt;</div></pre></td></tr></table></figure>
<p>使用元组语法，其中用到了你自己所在节点的名称，如果那个叫做my的进程存在的话，你就正在有效地发送消息给它；而如果这个进程不存在，则会丢弃这些消息。如果你用Pid来替换元组的话，也是这个结果。</p>
<p><img src="/images/running-out-of-ammo-4.gif" style="border:0;"></p>
<h1 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h1><p>我想用我们在卡利发现的另一个比较酷的事情来结束本文。当谈论这些事情的时候，我们并不真正地了解bang操作在Erlang虚拟机内部的运作过程，只是考虑bang操作失败的情况，我们尝试想像Erlang虚拟机内部如何运行。</p>
<h2 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h2><p>首先来考虑这个问题：当bang操作失败的时候，它总是报badarg错误。当你用一个没有注册为进程名字的原子的时候，它会失败，但是你用其他东西，它也会失败。看如下例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; x ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as x ! message</div><div class="line"><span class="number">2</span>&gt; <span class="string">"a list"</span> ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as <span class="string">"a list"</span> ! message</div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>用一点想象力，我们可能会认为，当你使用一个原子，Erlang虚拟机转换原子为Pid，然后在其上执行bang操作的原始版。如果它未能把原子转换成Pid，那么当然badarg错误就发生。换句话说，看起来Erlang VM在将下面的语句…</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; x ! message.</div></pre></td></tr></table></figure>
<p>改为如下的语句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; whereis(x) ! message.</div></pre></td></tr></table></figure>
<p>那么，当whereis 返回 undefined, bang操作失败。</p>
<h2 id="等一等"><a href="#等一等" class="headerlink" title="等一等"></a>等一等</h2><p>哦，不错。但是undefined也是一个原子啊。Erlang虚拟机为何在那里不陷入一个无限的递归循环呢？嗯，它可能有一个处理undefined的特殊分支。在这个分支里，它可以避免把undefined当做其他任何原子来处理。但是，那么，如果我注册一个进程的名字为undefined呢？</p>
<p><img src="/images/running-out-of-ammo-5.jpeg" style="border:0;"></p>
<p>让我们来试试，好吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; register(undefined, self()).</div><div class="line">** exception error: bad argument</div><div class="line">     in function  register/<span class="number">2</span></div><div class="line">        called as register(undefined,&lt;<span class="number">0.69</span>.<span class="number">0</span>&gt;)</div><div class="line"><span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>好吧，我们做不到。实际上<a href="http://erlang.org/doc/man/erlang.html#register-2" target="_blank" rel="external">官方文档</a>说的很清楚。</p>
<blockquote>
<p>badarg<br>如果 RegName 是原子undefined.</p>
</blockquote>
<p>干得不错，Erlang/OTP团队。干得不错，真的！</p>
<p><img src="/images/running-out-of-ammo-6.gif" style="border:0;"></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2#.sm8fbhd9q" target="_blank" rel="external">https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2#.sm8fbhd9q</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文（和&lt;a href=&quot;https://medium.com/erlang-battleground/beyond-the-limits-of-an-ets-cdd79fa8300c#.tsfdkduyd&quot;&gt;上一篇文章&lt;/a&gt;一样）也是受我在哥伦比亚卡利的学生的好奇心所启发。这次的问题是：什么时候并且为什么 bang（!）（即消息发送）操作符失败？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="bang" scheme="http://szpzs.oschina.io/categories/Erlang/bang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="bang" scheme="http://szpzs.oschina.io/tags/bang/"/>
    
      <category term="erlang:register/2" scheme="http://szpzs.oschina.io/tags/erlang-register-2/"/>
    
      <category term="whereis/1" scheme="http://szpzs.oschina.io/tags/whereis-1/"/>
    
      <category term="undefined" scheme="http://szpzs.oschina.io/tags/undefined/"/>
    
      <category term="try catch" scheme="http://szpzs.oschina.io/tags/try-catch/"/>
    
  </entry>
  
</feed>
