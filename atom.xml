<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.github.io/"/>
  <updated>2016-09-17T07:51:48.000Z</updated>
  <id>http://szpzs.github.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang Thursday – calendar:iso_week_number/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/</id>
    <published>2016-09-17T07:49:18.000Z</published>
    <updated>2016-09-17T07:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#iso_week_number-1" target="_blank" rel="external">calendar:iso_week_number/1</a>.</p>
<p>calendar:iso_week_number/1 接收一个日期元组做为入参，然后返回一个由年份和周数字组成的元组。年份是入参里的年份，而周数字是一个1到53的整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">04</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">19</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">03</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">18</span>&#125;</div></pre></td></tr></table></figure>
<p>如果我们拿本周做为一个例子，我们可以看到本周是从星期一（五月四日）开始，而前一个星期天（五月三日）是属于上一个星期的。</p>
<p>我们看到一月一日是这一年的第一周，这没什么奇怪，而2015年的十二月三十一日是这一年的第53周。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">1</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">53</span>&#125;</div></pre></td></tr></table></figure>
<p>一开始听到一年有53周我们会很惊讶，因为几乎每个人都认为一年只有52周，直到你意识到有些十二月三十一日有时候是处于一周的开始，所以造成了它处在第53周，而它仅仅是这周的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#iso_week_number-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calendar:iso
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="iso_week_number" scheme="http://szpzs.github.io/tags/iso-week-number/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:is_leap_year/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/</id>
    <published>2016-09-17T07:43:16.000Z</published>
    <updated>2016-09-17T07:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#is_leap_year-1" target="_blank" rel="external">calendar:is_leap_year/1</a>.</p>
<p>calendar:is_leap_year/1 接收一个非负整数表示的年份，如果这个年份是闰年，则返回true，否则返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(<span class="number">2015</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2012</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">2017</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2000</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">1900</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">0</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>有了这个Erlang核心库的内置函数，意味着你不需要编写代码或者甚至不需要查找规则来记住如何判断某个年份到底是不是闰年。</p>
<p>如果你传递一个负数来表示年份，Erlang将抛出一个异常，因为没有一个函数分支能匹配用负数来表示的年份。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(-<span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-1) (calendar.erl, line 183)</span></div><div class="line">calendar:is_leap_year(-<span class="number">4</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-4) (calendar.erl, line 183)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#is_leap_year-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calendar:is_lea
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="is_leap_year" scheme="http://szpzs.github.io/tags/is-leap-year/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:valid_date/3</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-valid-date-3/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-valid-date-3/</id>
    <published>2016-09-17T07:38:52.000Z</published>
    <updated>2016-09-17T07:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#valid_date-3" target="_blank" rel="external">calendar:valid_date/3</a>.</p>
<p>本来这次我是想讲函数 calendar:time_difference/3 ，但是当我详细看了 <a href="http://www.erlang.org/doc/man/calendar.html" target="_blank" rel="external">calendar</a> 模块的官方文档后，发现文档里已经说这个函数被淘汰了，所以今天我讲 calendar:valid_date/3 。</p>
<a id="more"></a>
<p>calendar:valid_date/3 的入参分别是一个表示年份的整数、一个表示月份的整数以及一个表示日的整数。如果传入的日期是有效的，则 calendar:valid_date/3 返回原子true，如果传入的日期是无效的，则 calendar:valid_date/3 返回原子false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">30</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2012</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">17</span>, <span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>我们也可以快速地检查一下本篇文章发布的日期也是有效日期。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在让我们看看入参中有0或负整数情况会怎么样？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(-<span class="number">1</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, -<span class="number">7</span>, <span class="number">21</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">7</span>, -<span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>正如人们所希望的，除非你要经常处理公元前的日期，不然的话有一个负数的日期是无效的。</p>
<p>Erlang也提供了函数 calendar:valid_date/1 ，它的入参是由年、月、日三个整数组成的元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>&#125;).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#valid_date-3&quot;&gt;calendar:valid_date/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本来这次我是想讲函数 calendar:time_difference/3 ，但是当我详细看了 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html&quot;&gt;calendar&lt;/a&gt; 模块的官方文档后，发现文档里已经说这个函数被淘汰了，所以今天我讲 calendar:valid_date/3 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="valid_date" scheme="http://szpzs.github.io/tags/valid-date/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:date_to_gregorian_days/3</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-date-to-gregorian-days-3/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-date-to-gregorian-days-3/</id>
    <published>2016-09-17T07:33:21.000Z</published>
    <updated>2016-09-17T07:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#date_to_gregorian_days-3" target="_blank" rel="external">calendar:date_to_gregorian_days/3</a>.</p>
<p>正如我们上星期在 <a href="http://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">Erlang Thursday calendar:day_of_the_week/3</a> 中讲到的，当我们看到一些错误消息的时候，我们看到错误来自于 calendar:date_to_gregorian_days/3。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>在上星期那篇文章里我保证我们下次将深入了解 calendar:date_to_gregorian_days/3 ，所以现在让我们来完成这个任务。</p>
<p>calendar:date_to_gregorian_days/3 有三个入参，一个代表年份的非负整数，一个代表月份的从1到12的整数，一个代表某月第几日的从1到31的整数，该函数返回的值是从公元元年1月1日截止到入参日期的天数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 366</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 719528</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 730484</span></div></pre></td></tr></table></figure>
<p>还有一个只接收一个入参的版本 calendar:date_to_gregorian_days/1，它的入参是由年、月、日三个整数组成元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>&#125;).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 366</span></div></pre></td></tr></table></figure>
<p>如果我们传给 calendar:date_to_gregorian_days/1 无效的日期，我们就会在错误消息里看到它正在调用 calendar:date_to_gregorian_days/3 。所以它是一个不错的辅助函数，不破坏我们的模式匹配。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;).</div><div class="line">** exception error: no function clause matching calendar:date_to_gregorian_days(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>) (calendar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#date_to_gregorian_days-3&quot;&gt;calendar:date_to_gregorian_days/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;正如我们上星期在 &lt;a href=&quot;http://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/&quot;&gt;Erlang Thursday calendar:day_of_the_week/3&lt;/a&gt; 中讲到的，当我们看到一些错误消息的时候，我们看到错误来自于 calendar:date_to_gregorian_days/3。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:day_of_the_week/3</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-day-of-the-week-3/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-day-of-the-week-3/</id>
    <published>2016-09-17T07:27:44.000Z</published>
    <updated>2016-09-17T07:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#day_of_the_week-3" target="_blank" rel="external">calendar:day_of_the_week/3</a>.</p>
<p>calendar:day_of_the_week/3 允许你传入年、月、日然后得到这个日子在一个星期里是第几天。</p>
<a id="more"></a>
<p>第一个入参表示年份而且必须是非负整数。第二个入参是月份而且必须是1到12的整数（包括1和12），它表示公历的12个月份，1表示1月份。最后一个入参是第几日，必须是1到31（包括1和31）的整数。</p>
<p>calendar:day_of_the_week/3 返回一个1到7（包括1和7）的整数值，1表示星期一，7表示星期日。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 1</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 5</span></div><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 6</span></div></pre></td></tr></table></figure>
<p>本篇文章的发布日期是2015年4月9日，把它传给 calendar:day_of_the_week/3 ，得到返回值是4，正好表示星期四，也就是本系列文章发布的日子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>).</div><div class="line"><span class="comment">% 4</span></div></pre></td></tr></table></figure>
<p>还有一个 calendar:day_of_the_week/1 函数，它和上面的函数功能和参数要求基本一样，只是它只接收一个入参，这个入参是由年、月、日组成的三元素元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>为了帮助大家认识 calendar:day_of_the_week/3 函数返回的错误消息，让我们看看，当我们给该函数传递无效日期，我们会得到什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>如果你仔细看这些错误消息，你会看到 calendar:day_of_the_week/3 调用了 calendar:date_to_gregorian_days/3 ，我们将在下个星期的Erlang Thursday来介绍它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#day_of_the_week-3&quot;&gt;calendar:day_of_the_week/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;calendar:day_of_the_week/3 允许你传入年、月、日然后得到这个日子在一个星期里是第几天。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="day_of_the_week" scheme="http://szpzs.github.io/tags/day-of-the-week/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thurday – lists:delete/2</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thurday-lists-delete-2/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thurday-lists-delete-2/</id>
    <published>2016-09-17T07:21:28.000Z</published>
    <updated>2016-09-17T07:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#delete-2" target="_blank" rel="external">lists:delete/2</a> 。</p>
<p>lists:delete/2 接收一个Erlang term作为它的第一个入参，它将把该term从第二个入参－－一个列表里删除掉。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [8,7,6,5,4,3,2]</span></div><div class="line">lists:delete(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,5,8]</span></div><div class="line">lists:delete(<span class="number">72</span>, <span class="string">"Hello World!"</span>).</div><div class="line"><span class="comment">% "ello World!"</span></div><div class="line">lists:delete(d, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:delete(<span class="number">4</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:delete(&#123;b, <span class="number">2</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% [&#123;a,1&#125;,&#123;c,3&#125;]</span></div><div class="line">lists:delete([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]).</div><div class="line"><span class="comment">% [[4,5,6],[7,8,9]]</span></div></pre></td></tr></table></figure>
<p>注意：lists:delete/2 仅仅是将第一个在列表里发现的term删掉，而其他任何在列表里同样的term它不会删除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8]</span></div></pre></td></tr></table></figure>
<p>因为 lists:delete/2 是一个非常简单就能讲清楚用法的函数，这样这篇文章将可能非常短，所以我想在下面我们展示一下如何自己来写一个非常简单(1) 的 lists:delete/2 实现是非常值得的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>让我们一起看看我们的delete函数在被调用的时候是如何执行的？</p>
<p>my_lists:delete/2 是一个友好的API函数，它仅仅是调用一个“私有”函数（没有导出的函数）－－ delete/3，所以调用者不需要担心那个我们传递的已经检查了的一个空列表作为初始值的累加器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div></pre></td></tr></table></figure>
<p>delete/3函数的第一个分支用模式匹配来检查我们想要删除掉元素是否也是需要检查的列表的第一个元素。如果模式匹配成果，我们会看到第一个元素被删除！接着我们就能停止处理列表并返回的结果，而这个结果是由我们已经检查过的元素组成列表的反转列表和那些剩下的我们还没有检查的元素组成的列表一起构成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div></pre></td></tr></table></figure>
<p>第二个分支“知道”我们想删除掉元素和剩下的列表的第一个元素不匹配。它是怎么“知道”的？因为如果它们匹配，第一个分支将模式匹配成功而第二个分支将得不到执行的机会。因为我们找不到元素需要被删除，我们通过将元素加到被检查过的元素组成的列表头部，并且继续调用 delete/3 。我们通过在被检查过的元素组成的列表头部加上元素形成新的被检查过元素组成的列表的做法就是为什么我们在第一分支和第三分支需要反转被检查元素组成的列表的原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div></pre></td></tr></table></figure>
<p>第三个也是最后一个 delete/3 函数的分支已经搜索到列表的结尾并且没有发现相同的元素，所以我们只是将被检查过的元素组成的列表反转后返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>这就是你自己的简单(1)版 lists:delete/2 的实现。</p>
<p>1、简单的意思是因为这个版本没有进行性能优化，或者没有做彻底的是否完全符合 lists:delete/2 规范的测试。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-lists-delete-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-lists-delete-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#delete-2&quot;&gt;lists:delete/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;lists:delete/2 接收一个Erlang term作为它的第一个入参，它将把该term从第二个入参－－一个列表里删除掉。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="delete" scheme="http://szpzs.github.io/tags/delete/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – erlang:list_to_atom/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-erlang-list-to-atom-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-erlang-list-to-atom-1/</id>
    <published>2016-09-17T07:15:31.000Z</published>
    <updated>2016-09-17T07:20:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erlang.html#list_to_atom-1" target="_blank" rel="external">erlang:list_to_atom/1</a>.</p>
<p>erlang:list_to_atom/1 的入参是一个字符串，返回的是一个Erlang的原子。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>)</span>.</span></div><div class="line">% <span class="title">foo</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo"</span>)</span>.</div><div class="line">% <span class="title">'Foo'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo_bar"</span>)</span>.</div><div class="line">% <span class="title">'Foo_bar'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo_bar"</span>)</span>.</div><div class="line">% <span class="title">foo_bar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>++<span class="string">"bar"</span>)</span>.</div><div class="line">% <span class="title">foobar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Erlang"</span>)</span>.</div><div class="line">% <span class="title">'Erlang'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Elixir"</span>)</span>.</div><div class="line">% <span class="title">'Elixir'</span></div></pre></td></tr></table></figure>
<p>这个函数在你必须要基于从外部系统读到的字符串，比如解析一个CSV类型的头部，生成键或标识符的时候有用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> erlang:list_to_atom/<span class="number">1</span>,      	     string:tokens(<span class="string">"firstName,lastName,age,gender,preferredName,dateOfBirth"</span>, <span class="string">","</span>)).</div><div class="line"><span class="comment">% [firstName,lastName,age,gender,preferredName,dateOfBirth]</span></div></pre></td></tr></table></figure>
<p>当你用 erlang:list_to_atom/1 将从外部系统获取的字符串转换成原子的时候一定要小心，因为它只能处理值为256以下的字符。任何字符值在256（注1）以下的字符串都能正常地用该函数转成一个原子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">list_to_atom("Joe, Mike, and Robert").</div><div class="line">% 'Joe, Mike, and Robert'</div><div class="line">list_to_atom("it's").</div><div class="line">% 'it's'</div><div class="line">list_to_atom("heyn").</div><div class="line">% 'heyn'</div><div class="line">list_to_atom("with_supported_char"++[255]).</div><div class="line">% with_supported_charÿ</div><div class="line">list_to_atom("with_non_supported_char"++[256]).</div><div class="line">% ** exception error: bad argument</div><div class="line">%      in function  list_to_atom/1</div><div class="line">%         called as list_to_atom([119,105,116,104,95,110,111,110,95,115,117,112,112,111,114,</div><div class="line">%                                 116,101,100,95,99,104,97,114,256])</div></pre></td></tr></table></figure>
<p>1、字符值必须是非负整数，范围是0到255。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#list_to_atom-1&quot;&gt;erlang:list_to_atom/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;erlang:list_to_atom/1 的入参是一个字符串，返回的是一个Erlang的原子。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/categories/Erlang/erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/tags/erlang/"/>
    
      <category term="list_to_atom" scheme="http://szpzs.github.io/tags/list-to-atom/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thurday – ordsets:is_disjoint/2</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thurday-ordsets-is-disjoint-2/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thurday-ordsets-is-disjoint-2/</id>
    <published>2016-09-17T07:04:57.000Z</published>
    <updated>2016-09-17T07:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/ordsets.html#is_disjoint-2" target="_blank" rel="external">ordsets:is_disjoint/2</a>.</p>
<p>在日常的编码中，你应该会碰到这样的问题，如何判断一个给定的列表，它的元素不在另一个列表里出现。</p>
<a id="more"></a>
<p>你的第一个直觉可能写出的代码像如下这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">not</span><span class="params">( lists:any(<span class="keyword">fun</span>(Item) -&gt; lists:member(Item, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]) <span class="keyword">end</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span>.</span></div><div class="line">% <span class="title">true</span></div></pre></td></tr></table></figure>
<p>如果你更多地在数学的范畴里定义你的问题，你可以从集合方向上开始思考，那么这个问题会更清晰。当你开始在集合的方向上思考，你会意识到你可以检查两个集合的交集是否是空集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ordsets:intersection([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]) =:= [].</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这样不仅更加简洁，而且更加明确你需要检查的是什么。</p>
<p>实际上，当你通过判断两个列表是否是不相交的，你可以做的更好。下面我们开始看看 ordsets:is_disjoint/2 。</p>
<p>ordsets:is_disjoint/2 接收两个列表做为入参，当两个列表没有共同的元素的时候函数返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>因为 ordsets:is_disjoint/2 是对两个列表进行判断，所以我们没必要先调用所谓的 ordsets:disjoint/2 来确定列表元素是唯一的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>如果任何一个入参是空列表，则 ordsets:is_disjoint/2 返回的结果都是说这两个列表是不相交的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ordsets:is_disjoint([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_disjoint([], []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>另外，如果你很好奇，想看看用 timer:tc/3 来测量 ordsets:is_disjoint/2 的运行时间，那么我们可以看到，只要 Erlang 知道了两个列表是不相交的，它就立马返回false，如果你记得我们前面的文章 <a href="http://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">Erlang Thursday on timer:tc/3</a> ，你就知道它的返回值是一个元组，元组的第一个元素就是代表被测量函数运行时间，其单位是微秒。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(ordsets, is_disjoint, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>), lists:seq(<span class="number">2000000</span>, <span class="number">3000000</span>)]).</div><div class="line"><span class="comment">% &#123;19032,true&#125;</span></div><div class="line">timer:tc(ordsets, is_disjoint, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>), lists:seq(<span class="number">1</span>, <span class="number">3000000</span>)]).</div><div class="line"><span class="comment">% &#123;2,false&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-ordsets-is_disjoint-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-ordsets-is_disjoint-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/ordsets.html#is_disjoint-2&quot;&gt;ordsets:is_disjoint/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;在日常的编码中，你应该会碰到这样的问题，如何判断一个给定的列表，它的元素不在另一个列表里出现。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:flatmap/2</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-lists-flatmap-2/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-lists-flatmap-2/</id>
    <published>2016-09-17T06:56:00.000Z</published>
    <updated>2016-09-17T07:07:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#flatmap-2" target="_blank" rel="external">lists:flatmap/2</a>.</p>
<p>选择这个函数来讲是因为这个星期早些时候我做的一些 <a href="http://elixir-lang.org/" target="_blank" rel="external">Elixir</a> 练习，在这些练习中我使用 Enum.flat_map/2 函数而它却不是像我期待的那样起作用，这个情况让我很困惑。</p>
<a id="more"></a>
<p>于是我回到Erlang来研究 lists:flatmap/2 的执行情况，然后在完全了解了该函数在Erlang里没有正确执行的原因后，我终于明白了这个函数的运行模式，同时我也意识到原来我对这个函数有错误的认识，所以是时候回来说清楚 lists:flatmap/2 实际上做了些什么。</p>
<p>不知何故，我曾误以为 lists:flatmap/2 就是接收一个任意嵌套深度的列表做为入参，并将他们的扁平化后每个元素都应用在map函数上，就相当于下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X * X <span class="keyword">end</span>, lists:flatten([<span class="number">1</span>, [[<span class="number">2</span>, [<span class="number">3</span>]], <span class="number">4</span>]])).</div><div class="line"><span class="comment">% [1,4,9,16]</span></div></pre></td></tr></table></figure>
<p>即使更近一步阅读 Ruby 文档，甚至在尝试 Ruby 的 flat_map 函数后，很显然我依然完全不理解它上如何工作的，所以是时候仔细阅读 Erlang 文档了。</p>
<p>Erlang文档说明 lists:flatmap/2 第一个入参是一个函数，这个入参函数接收一个类型A的元素然后返回一个由类型B的元素组成的列表；lists:flatmap/2 的第二个入参是一个由类型A的元素组成的列表。</p>
<p>我已经困惑于它到底是如何工作的，而且文档也没说明，直到我看到文档的一部分描述了 lists:flatmap/2 的工作原理入下面的定义一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">flatmap</span><span class="params">(Fun, List1)</span> -&gt;</span></div><div class="line">    append(map(Fun, List1)).</div></pre></td></tr></table></figure>
<p>这个定义一下子让我明白了 lists:flatmap/2 到底是如何执行的。以前在我的脑海里，我认为首先是扁平化列表，然后在将各个列表元素应用于map函数上，但是实际上，它首先将各个列表元素应用于map函数上，然后再简单地扁平化，而且仅仅是做了一个层级的扁平化。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lists:flatmap(<span class="keyword">fun</span>(&#123;Item, Count&#125;) -&gt;</div><div class="line">                  lists:duplicate(Count, Item)</div><div class="line">              <span class="keyword">end</span>,</div><div class="line">              [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;'C', <span class="number">3</span>&#125;, &#123;'_d_', <span class="number">4</span>&#125;]).</div><div class="line"><span class="comment">% [a,b,b,'C','C','C','_d_','_d_','_d_','_d_']</span></div></pre></td></tr></table></figure>
<p>而如果我们将相同的数据先传给map函数，然后再将其结果传给append函数，我们会得到相同的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:append(</div><div class="line">    lists:map(<span class="keyword">fun</span>(&#123;Item, Count&#125;) -&gt;</div><div class="line">                  lists:duplicate(Count, Item)</div><div class="line">              <span class="keyword">end</span>,</div><div class="line">              [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;'C', <span class="number">3</span>&#125;, &#123;'_d_', <span class="number">4</span>&#125;])).</div><div class="line"><span class="comment">% [a,b,b,'C','C','C','_d_','_d_','_d_','_d_']</span></div></pre></td></tr></table></figure>
<p>同时我们更进一步了解到，lists:flatmap/2 甚至不将列表扁平化，而只是简单地将map函数返回的列表链接起来。如下面的例子，最后的结果仍然是一个嵌套的列表结构，而不是只有一个层级的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatmap(<span class="keyword">fun</span>(X) -&gt; [X, [X]] <span class="keyword">end</span>, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,[a],b,[b],c,,d,[d]]</span></div></pre></td></tr></table></figure>
<p>希望本文能让你不要陷入我曾经的困惑。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-flatmap-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-flatmap-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#flatmap-2&quot;&gt;lists:flatmap/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;选择这个函数来讲是因为这个星期早些时候我做的一些 &lt;a href=&quot;http://elixir-lang.org/&quot;&gt;Elixir&lt;/a&gt; 练习，在这些练习中我使用 Enum.flat_map/2 函数而它却不是像我期待的那样起作用，这个情况让我很困惑。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="flatmap" scheme="http://szpzs.github.io/tags/flatmap/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:local_time_to_universal_time_dst/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-local-time-to-universal-time-dst-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-local-time-to-universal-time-dst-1/</id>
    <published>2016-09-17T06:38:49.000Z</published>
    <updated>2016-09-17T07:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>（译者注：本文里的例子结果在中国时区是不同的）</p>
<p>为了纪念本周末的时间变化，今天的 Erlang Thursday 要讲的函数是  <a href="http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time_dst-1" target="_blank" rel="external">calendar:local_time_to_universal_time_dst/1</a>.</p>
<a id="more"></a>
<p>为了更好地理解 calendar:local_time_to_universal_time_dst/1 是做什么的，我们将用它和 <a href="http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time-1" target="_blank" rel="external">calendar:local_time_to_universal_time/1</a> 进行比较。</p>
<p>即将到来的星期日我们将在临晨两点把时钟拨快一个小时，那么让我们来看看在临晨一点五十九分的时候UTC时间是多少？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">1</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,3,8&#125;,&#123;7,59,59&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>现在让我们看看当日临晨两点的时候 calendar:local_time_to_universal_time/1 返回的UTC时间是多少，实际上当日临晨两点我们根本没有到达过，因为我们直接将时间向前拨快了到临晨三点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,3,8&#125;,&#123;8,0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>但是当我们深入函数库里，我们看到也有另外一个函数 calendar:local_time_to_universal_time_dst/1. calendar:local_time_to_universal_time_dst/1 返回值是一个由时间元组组成的列表，让我们开始看看为什么这很重要。</p>
<p>此时，让我调用 calendar:local_time_to_universal_time_dst/1 并传入当日临晨两点作为参数，然后我们看到的结果是什么呢。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>一个空列表！</p>
<p>如果你花一点时间来想一想，这是有道理的，因为临晨两点根本就没发生过，所以就没有UTC时间和它对应上。</p>
<p>那么当我们跳到临晨三点我们看到什么呢？我们将得到早上八点UTC时间，这仅仅是在临晨一点五十九分五十九秒的一秒之后的UTC时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,3,8&#125;,&#123;8,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>为了涵盖本周末的情况，让我们来看看在今年晚些时候也就是11月1日将时钟拨慢一小时会发生什么。</p>
<p>从一个基准时间开始，让我们看看零点五十九分五十九秒（译者注：原文是12:59:59AM，应该是作者手误）是多少UTC时间，我们知道这个时间我们将仅遇到一次。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,11,1&#125;,&#123;5,59,59&#125;&#125;</span></div><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;5,59,59&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>而且即使时间的变化发生在临晨两点，我们仍然只是遇到一次，因为我们第一次直接移动到临晨一点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;8,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>所以零点五十九分五十九秒，我们得到UTC时间五点五十九分五十九秒，而两点，我们得到UTC时间是八点。现在到了棘手的部分，凌晨一点。</p>
<p>临晨一点是一个奇怪的场景，当日晚上我们将度过两个临晨一点。那么让我们看看Erlang在这种情况下做了什么。</p>
<p>首先，我们看看在临晨一点的时候我们调用 calendar:local_time_to_universal_time 得到的UTC时间是多少。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">00</span>,<span class="number">00</span>&#125;&#125;).</div><div class="line"><span class="comment">% &#123;&#123;2015,11,1&#125;,&#123;6,0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我们得到UTC时间是六点。我们从UTC时间五点五十九分五十九秒移动到UTC时间六点；这是合理的，直到我们开始怀疑我们第二次遇到临晨一点。</p>
<p>现在，让我们看看在临晨一点的时候我们调用 calendar:local_time_to_universal_time_dst/1 会得到什么UTC时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;6,0,0&#125;&#125;,&#123;&#123;2015,11,1&#125;,&#123;7,0,0&#125;&#125;]</span></div><div class="line">`</div></pre></td></tr></table></figure>
<p>我们得到由两个UTC时间组成的列表，一个是我们第一次遇到临晨一点时的UTC时间六点，另一个是我们第二次遇到临晨一点的UTC时间七点。这个返回两个UTC时间的情况也在临晨一点内的每秒钟出现。（译者注：原文是every time，译者认为应该是every second）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:local_time_to_universal_time_dst(&#123;&#123;<span class="number">2015</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">59</span>,<span class="number">59</span>&#125;&#125;).</div><div class="line"><span class="comment">% [&#123;&#123;2015,11,1&#125;,&#123;6,59,59&#125;&#125;,&#123;&#123;2015,11,1&#125;,&#123;7,59,59&#125;&#125;]</span></div></pre></td></tr></table></figure>
<p>通过返回没有元素、一个元素或者两个元素的列表，Erlang提供给你最精确的信息为你所用，同时让你做出希望如何处理时间的明智的决定，而不是为你做出一些决定即使它们不符合你的系统需要。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-local_time_to_universal_time_dst-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-local_time_to_universal_time_dst-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（译者注：本文里的例子结果在中国时区是不同的）&lt;/p&gt;
&lt;p&gt;为了纪念本周末的时间变化，今天的 Erlang Thursday 要讲的函数是  &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#local_time_to_universal_time_dst-1&quot;&gt;calendar:local_time_to_universal_time_dst/1&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
  </entry>
  
  <entry>
    <title>原子之浅显易懂</title>
    <link href="http://szpzs.github.io/2016/09/17/eli5-atoms/"/>
    <id>http://szpzs.github.io/2016/09/17/eli5-atoms/</id>
    <published>2016-09-17T05:36:59.000Z</published>
    <updated>2016-09-17T06:54:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img alt="Atom Table" src="/images/eli5-atom-tab.png" style="border: 0;"><br><a id="more"></a><br>原子表是一个全局表，它将原子内部值（一个整数值）映射到一个字符串。同时也有一个反向到查询表，它将一个字符串映射到一个原子内部值。原子表有一个固定的记录条数上限：1048576。如果它一旦到达了这个上限，当前节点将崩溃 －－ 这就是为什么在运行时动态创建原子是很危险的做法。原子表的记录条数上限可以通过给erl命令指定 +t 标签来设置。</p>
<p>原子是在运行时不能改变它的值的一个符号。当一个新的原子被创建，它得到一个唯一的值来给当前节点来使用。原子在系统内部仅仅是指向原子表对应记录索引的整数值。这就是为什么原子的操作如此廉价的原因。</p>
<p>BEAM装载器例程读取原子值并且在原子表里查询它们。它将它们的整数值标记为原子<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>来替代原子名称。然后代码只是操作这些立即数而不是它们的名称。</p>
<p>这些内部值不能当做整数（通过网络或磁盘）离开节点。这是因为其他节点对于相通的原子有不同的内部值。因此当原子离开当前节点的时候都被转换为字符串。这会影响到BEAM文件，外部pid，外部port，Mnesia或DETS里的原子等等。这就是为什么一些开发者更喜欢给数据库字段名使用短原子名称的原因 －－ 它们将以字符串的形式出现在数据库数据中。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img alt=&quot;Atom Table&quot; src=&quot;/images/eli5-atom-tab.png&quot; style=&quot;border: 0;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.github.io/categories/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.github.io/categories/BEAM/Atom/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.github.io/tags/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.github.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>BEAM虚拟机之浅显易懂</title>
    <link href="http://szpzs.github.io/2016/09/16/eli5-vm/"/>
    <id>http://szpzs.github.io/2016/09/16/eli5-vm/</id>
    <published>2016-09-16T14:11:05.000Z</published>
    <updated>2016-09-17T06:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。</p>
<a id="more"></a>
<h2 id="寄存器和调用"><a href="#寄存器和调用" class="headerlink" title="寄存器和调用"></a>寄存器和调用</h2><p>作为一个寄存器虚拟机就意味着在函数调用的时候不是通过栈而是用寄存器来传递参数。它们与我们所理解的CPU架构中的寄存器不一样，而只是一个Erlang数据结构的值所组成的数组。这样的寄存器有1024个，但是有这么多入参的函数几乎不存在，所以通常虚拟机仅仅使用了前面3到10个寄存器。</p>
<p>例如，当调用一个有三个入参的函数的时候，寄存器x0，x1和x2分别被设置为三个入参值。如果我们需要进行递归调用，我们将不得不改写寄存器并丢失它们的原始值。在这种情况下，我们将需要保存旧的值到栈中。除了栈帧外没有动态栈分配，这是由编译器决定的。</p>
<p>每一个进程有自己的寄存器集。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>BEAM指令集包含大约158个基本指令，它们中的大部分可以通过调用 erlc -S yourfile.erl 生成汇编文件来查看到。每一个指令有零或多个参数。不同的技巧用来在便携方式和紧凑方式编码参数。例如，代码中的位置定位（也叫做标签）是用它们的索引来编码的，并且代码装载器后续会把它们翻译成内存地址。</p>
<p>在BEAM代码装载过程中，一些混合的操作码被更快的操作码替换。这个优化的技巧叫做超级指令。对于每一个操作码，在beam_emu.c文件中都有一个C标签对应的一段代码。一个C标签组成的数组存储在同一个虚拟机循环例程的尾部并且被当作查询表来使用。</p>
<p>请参见：<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-file.html" target="_blank" rel="external">BEAM文件格式</a>。<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-instructions.html" target="_blank" rel="external">BEAM指令代码</a>。</p>
<h2 id="线程虚拟机循环"><a href="#线程虚拟机循环" class="headerlink" title="线程虚拟机循环"></a>线程虚拟机循环</h2><p>装载操作码被标签地址替换后，紧跟着它们的是参数。例如，操作码 ＃1，一个来自标签数组第一索引元素被置于在代码内存。</p>
<p>这种方式很容易跳转到处理下一个操作码的 C 代码中的某个位置。只需要读一个 void* 指针并执行一个goto *p 的动作。此功能是C和C++编译器的一个扩展。这种类型的虚拟机循环称为直接线程调度虚拟机循环。</p>
<p>其他虚拟机循环的类型有：</p>
<ul>
<li>切换调度虚拟机（如果C编译器拒绝支持标签扩展，则这种类型被BEAM虚拟机源使用）。它也比直接线程调度虚拟机慢20%至30%；</li>
<li>直接调用线程</li>
<li><a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html" target="_blank" rel="external">其他</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-vm.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-vm.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。&lt;/p&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.github.io/categories/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.github.io/categories/BEAM/VM/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.github.io/tags/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – dict:merge/3</title>
    <link href="http://szpzs.github.io/2016/09/16/erlang-thursday-dict-merge-3/"/>
    <id>http://szpzs.github.io/2016/09/16/erlang-thursday-dict-merge-3/</id>
    <published>2016-09-16T07:18:40.000Z</published>
    <updated>2016-09-16T15:11:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/dict.html#merge-3" target="_blank" rel="external">dict:merge/3</a>.</p>
<p>dict:merge/3 有三个入参，第一个入参是一个合并函数，它在发生键冲突的时候被调用，第二和第三个入参都是字典。</p>
<a id="more"></a>
<p>合并函数用键作为第一个入参，第一个字典对应的值作为第二个入参，第二个字典来对于的值作为第三个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, Value2) -&gt; [Value1, Value2] <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x,5,7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div><div class="line"></div><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, Value2) -&gt; Value1 * Value2 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|35]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>传给dict:merge/3的合并函数仅在发生冲突的时候才被调用。如下代码例子，合并函数体里有一个exit的调用，只要合并函数备调用就将导致进程的结束。（译者注：此处的代码并没有触发合并函数的调用，因为两个字典没有相同的键）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, _Value1, _Value2) -&gt; exit(merge_happened) <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果你想让合并函数将第二个字典覆盖第一个字典，那么合并函数在出现键冲突的时候只需要返回第二个字典里的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, _Value1, Value2) -&gt; Value2 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|7]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果你想保持第一个字典里的所有键和值，仅仅是将那些不在第一个字典里而在第二个字典里的键和值加进来，合并函数只需要返回第一个字典的相关值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dict:merge(<span class="keyword">fun</span> (_Key, Value1, _Value2) -&gt; Value1 <span class="keyword">end</span>,</div><div class="line">           dict:from_list([&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;x, <span class="number">5</span>&#125;]),</div><div class="line">           dict:from_list([&#123;x, <span class="number">7</span>&#125;, &#123;y, <span class="number">8</span>&#125;, &#123;z, <span class="number">10</span>&#125;])).</div><div class="line"><span class="comment">% &#123;dict,5,16,16,8,80,48,</span></div><div class="line"><span class="comment">%       &#123;[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]&#125;,</span></div><div class="line"><span class="comment">%       &#123;&#123;[],</span></div><div class="line"><span class="comment">%         [[a|1]],</span></div><div class="line"><span class="comment">%         [[b|2]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[],</span></div><div class="line"><span class="comment">%         [[x|5]],</span></div><div class="line"><span class="comment">%         [[y|8]],</span></div><div class="line"><span class="comment">%         [[z|10]],</span></div><div class="line"><span class="comment">%         [],[],[],[],[]&#125;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>另外，大家可以关注Erlang 17.0中引入的新数据类型Maps。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-dict-merge-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-dict-merge-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/dict.html#merge-3&quot;&gt;dict:merge/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;dict:merge/3 有三个入参，第一个入参是一个合并函数，它在发生键冲突的时候被调用，第二和第三个入参都是字典。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="dict" scheme="http://szpzs.github.io/categories/Erlang/dict/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="dict" scheme="http://szpzs.github.io/tags/dict/"/>
    
      <category term="merge" scheme="http://szpzs.github.io/tags/merge/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – string:join/2</title>
    <link href="http://szpzs.github.io/2016/09/16/erlang-thursday-string-join-2/"/>
    <id>http://szpzs.github.io/2016/09/16/erlang-thursday-string-join-2/</id>
    <published>2016-09-16T07:13:58.000Z</published>
    <updated>2016-09-16T15:10:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/string.html#join-2" target="_blank" rel="external">string:join/2</a>.</p>
<p>string:join/2 有两个入参，第一个是由字符串为元素组成的列表，第二个是一个当作分隔符的字符串，输出是由分隔符将各个字符串串起来组成的字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">91</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">""</span>).</div><div class="line"><span class="string">"abc"</span></div><div class="line"><span class="number">92</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"-"</span>).</div><div class="line"><span class="string">"a-b-c"</span></div></pre></td></tr></table></figure>
<p>分隔符字符串可以是任意长度的字符串，也不必仅仅是单个字符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">93</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"___"</span>).</div><div class="line"><span class="string">"a___b___c"</span></div><div class="line"><span class="number">94</span>&gt; string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">" "</span>).</div><div class="line"><span class="string">"a b c"</span></div></pre></td></tr></table></figure>
<p>而且任何字符串，字符列表，或者甚至是整数列表，都可以用作分隔符字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], [$A]).</div><div class="line"><span class="string">"aAbAc"</span></div><div class="line">string:join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], [<span class="number">52</span>]).</div><div class="line"><span class="string">"a4b4c"</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-string-join-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-string-join-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/string.html#join-2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;string:join/2&lt;/a&gt;.&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="join" scheme="http://szpzs.github.io/tags/join/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – string:tokens/2</title>
    <link href="http://szpzs.github.io/2016/09/16/erlang-thursday-string-tokens-2/"/>
    <id>http://szpzs.github.io/2016/09/16/erlang-thursday-string-tokens-2/</id>
    <published>2016-09-16T07:09:40.000Z</published>
    <updated>2016-09-16T15:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是  <a href="http://www.erlang.org/doc/man/string.html#tokens-2" target="_blank" rel="external">string:tokens/2</a>.</p>
<p>string:tokens/2 第一个入参是一个字符串，第二入参是一个分割字符列表，返回值是被分割后的字符串列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"foo"</span>, <span class="string">""</span>).</div><div class="line"><span class="comment">% ["foo"]</span></div><div class="line">string:tokens(<span class="string">"banana"</span>, <span class="string">"a"</span>).</div><div class="line"><span class="comment">% ["b","n","n"]</span></div><div class="line">string:tokens(<span class="string">"It was the best of times, it was the worst of times"</span>, <span class="string">" "</span>).</div><div class="line"><span class="comment">% ["It","was","the","best","of","times,","it","was","the",</span></div><div class="line"><span class="comment">%  "worst","of","times"]</span></div></pre></td></tr></table></figure>
<p>当连续的分割字符出现在字符串里，它们将被当做一个分割字符，并且没有空字符串返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"s"</span>).</div><div class="line"><span class="comment">% ["Mi","i","ippi"]</span></div><div class="line"><span class="number">65</span>&gt; string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"sp"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"is"</span>).</div><div class="line"><span class="comment">% ["M","pp"]</span></div></pre></td></tr></table></figure>
<p>传个 string:tokens/2 的分割字符列表的字符顺序无关紧要，可以按任意顺序指定。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"ps"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div><div class="line"><span class="number">65</span>&gt; string:tokens(<span class="string">"Mississippi"</span>, <span class="string">"sp"</span>).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div></pre></td></tr></table></figure>
<p>同时由于分隔符列表只是简单的一个分割字符串列表，我们可以不是传递一个字符串，而是把字符的整数值组成的列表当做一个列表传给函数，因为一个整数值的列表和字符串是一样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$s.</div><div class="line"><span class="comment">% 115</span></div><div class="line">$p.</div><div class="line"><span class="comment">% 112</span></div><div class="line">[<span class="number">115</span>, <span class="number">112</span>].</div><div class="line"><span class="comment">% "sp"</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, [<span class="number">115</span>]).</div><div class="line"><span class="comment">% ["Mi","i","ippi"]</span></div><div class="line">string:tokens(<span class="string">"Mississippi"</span>, [<span class="number">115</span>, <span class="number">112</span>]).</div><div class="line"><span class="comment">% ["Mi","i","i","i"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-string-tokens-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-string-tokens-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是  &lt;a href=&quot;http://www.erlang.org/doc/man/string.html#tokens-2&quot;&gt;string:tokens/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;string:tokens/2 第一个入参是一个字符串，第二入参是一个分割字符列表，返回值是被分割后的字符串列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="string" scheme="http://szpzs.github.io/categories/Erlang/string/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="string" scheme="http://szpzs.github.io/tags/string/"/>
    
      <category term="tokens" scheme="http://szpzs.github.io/tags/tokens/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:dropwhile/2</title>
    <link href="http://szpzs.github.io/2016/09/16/erlang-thursday-lists-dropwhile-2/"/>
    <id>http://szpzs.github.io/2016/09/16/erlang-thursday-lists-dropwhile-2/</id>
    <published>2016-09-16T07:05:39.000Z</published>
    <updated>2016-09-16T15:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#dropwhile-2" target="_blank" rel="external">lists:dropwhile/2</a> 。</p>
<p>lists:dropwhile/2 接收一个断言函数和一个列表作为入参并且返回一个列表。从入参列表第一个元素开始逐个代入断言函数，如果断言函数返回值为true，则拿掉该元素，当遇到第一个使得判断函数返回值为false的元素，则停止继续判断。剩下的元素组成的列表作为结果返回。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:dropwhile(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,4]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [-1,0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [-2,-1,0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</div><div class="line"><span class="comment">% [0,1,2,3]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]).</div><div class="line"><span class="comment">% [0,-1,-2,-3,-4,-5]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; <span class="literal">true</span> <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; <span class="literal">false</span> <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [hello,'World',foo,1,3,bar,4]</span></div></pre></td></tr></table></figure>
<p>不像 <a href="http://www.proctor-it.com/erlang-thursday-lists-filter-2" target="_blank" rel="external">lists:filter/2</a>，lists:dropwhile/2 在断言函数返回false的时候就立即停止检查入参列表。这就意味着那些代入断言函数将返回true的元素仍然可以出现在返回列表里，只要它们排在那个使得断言函数返回false的元素之后。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:dropwhile(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,bar,4]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="keyword">not</span> is_atom(X) <span class="keyword">end</span>, [hello, 'World', foo, <span class="number">1</span>, <span class="number">3</span>, bar, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,3,4]</span></div><div class="line">lists:dropwhile(<span class="keyword">fun</span> (X) -&gt; X &lt; <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% [0,1,-5,3,7]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt;= <span class="number">0</span> <span class="keyword">end</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>]).</div><div class="line"><span class="comment">% [0,1,3,7]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-dropwhile-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-dropwhile-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#dropwhile-2&quot;&gt;lists:dropwhile/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;lists:dropwhile/2 接收一个断言函数和一个列表作为入参并且返回一个列表。从入参列表第一个元素开始逐个代入断言函数，如果断言函数返回值为true，则拿掉该元素，当遇到第一个使得判断函数返回值为false的元素，则停止继续判断。剩下的元素组成的列表作为结果返回。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="dropwhile" scheme="http://szpzs.github.io/tags/dropwhile/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:filter/2</title>
    <link href="http://szpzs.github.io/2016/09/16/erlang-thursday-lists-filter-2/"/>
    <id>http://szpzs.github.io/2016/09/16/erlang-thursday-lists-filter-2/</id>
    <published>2016-09-16T07:02:23.000Z</published>
    <updated>2016-09-16T15:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是  <a href="http://www.erlang.org/doc/man/lists.html#filter-2" target="_blank" rel="external">lists:filter/2</a>.</p>
<p>lists:filter/2有两个入参：一个断言函数和一个被遍历的列表。它的返回值是是一个列表，其元素是入参列表的元素应用于断言函数返回值是true的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X <span class="keyword">rem</span> <span class="number">2</span> =:= <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, a, <span class="number">3</span>, &#123;a, b&#125;, 'World', foo]).</div><div class="line"><span class="comment">% [a,'World',foo]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">3</span>, foo, -<span class="number">13</span>, <span class="number">43</span>]).</div><div class="line"><span class="comment">% [1,foo,43]</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; X &gt; <span class="number">0</span> <span class="keyword">end</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="literal">false</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:filter(<span class="keyword">fun</span> (X) -&gt; <span class="literal">true</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-filter-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-filter-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是  &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#filter-2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lists:filter/2&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="filter" scheme="http://szpzs.github.io/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – httpc:request/1 and httpc:request/4</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-httpc-request-1-and-httpc-request-4/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-httpc-request-1-and-httpc-request-4/</id>
    <published>2016-09-15T13:52:49.000Z</published>
    <updated>2016-09-16T15:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的 Erlang Thursday 讲的是 <a href="http://www.erlang.org/doc/man/httpc.html#request-1" target="_blank" rel="external">httpc:request/1</a> 和 <a href="http://www.erlang.org/doc/man/httpc.html#request-4" target="_blank" rel="external">httpc:request/4</a> 。httpc模块是erlang的HTTP1.1 客户端，request函数是erlang的功能强大的web请求工具。</p>
<p>要使用httpc模块，我们必需先确保 inets 已经启动。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inets:start().</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>httpc:requst/1 接收一个入参，就是一个RUL，它是一个erlang字符串，也就是你需要访问的地址。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(<span class="string">"http://www.example.com"</span>).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 02:57:06 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 02:57:06 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>httpc:request/1 和 httpc:request/4 功能是一样的， 相当于 httpc:request(get, {Url, []}, [], []) 这样被调用一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], []).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:04:31 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 03:04:31 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我们可以指定我们请求的头部内容。比如，我们想得到在瑞典的DuckDuckGo主页来纪念Erlang由由爱立信创建。为了实现这个功能，我们增加一个元组{“Accept-Language”, “sv”}到请求的头部列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://duckduckgo.com/"</span>, [&#123;<span class="string">"Accept-Language"</span>, <span class="string">"sv"</span>&#125;]&#125;, [], []).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=1"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"connection","keep-alive"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:19:29 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""54bfe2a8-1488""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","nginx"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","5256"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html; charset=UTF-8"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 22 Jan 2015 03:19:30 GMT"&#125;],</span></div><div class="line"><span class="comment">%      "&lt;!DOCTYPE html&gt;n&lt;!--[if IEMobile 7 ]&gt; &lt;html lang="sv_SE" class="no-js iem7"&gt; ..."&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>httpc:request/4 的第三个入参是一个HTTP选项元组组成的列表。比如，你必需设置一个返回超时来避免从一个不可靠的或者一个不能及时返回的慢网站等待结果，请求代码需要回撤并稍后再尝试从而避免触发服务拒绝的攻击后果。下面的例子，我指定一个超时时间为0，单位是毫秒，来确保上述描述的目的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://erlang.org/"</span>, []&#125;, [&#123;timeout, <span class="number">0</span>&#125;], []).</div><div class="line">&#123;error,&#123;failed_connect,[&#123;to_address,&#123;<span class="string">"erlang.org"</span>,<span class="number">80</span>&#125;&#125;,</div><div class="line">                        &#123;inet,[inet],timeout&#125;]&#125;&#125;</div></pre></td></tr></table></figure>
<p>httpc:request/4 的最后一个入参是一个选项列表，它们是Erlang这端如何工作的选项。比如，你想异步请求，并在它完成后收到一条消息，这样你需要指定元组{sync, false}作为选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;ok, RequestId&#125; = httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], [&#123;sync, false&#125;]).</div><div class="line"><span class="comment">% &#123;ok,#Ref&lt;0.0.0.179&gt;&#125;</span></div><div class="line"><span class="keyword">receive</span> &#123;http, &#123;RequestId, Result&#125;&#125; -&gt; Result <span class="keyword">after</span> <span class="number">500</span> -&gt; error <span class="keyword">end</span>.</div><div class="line"><span class="comment">% &#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%  [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"date","Thu, 22 Jan 2015 03:08:41 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%   &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"expires","Thu, 29 Jan 2015 03:08:41 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%   &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%  &lt;&lt;"&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta "...&gt;&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>或者如果你想返回结果用Erlang二进制而不是Erlang字符串，你可以这么指定选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">httpc:request(get, &#123;<span class="string">"http://www.example.com"</span>, []&#125;, [], [&#123;body_format, binary&#125;]).</div><div class="line"><span class="comment">% &#123;ok,&#123;&#123;"HTTP/1.1",200,"OK"&#125;,</span></div><div class="line"><span class="comment">%      [&#123;"cache-control","max-age=604800"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"date","Thu, 22 Jan 2015 03:58:55 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"accept-ranges","bytes"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"etag",""359670651""&#125;,</span></div><div class="line"><span class="comment">%       &#123;"server","ECS (ftw/FBE4)"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-length","1270"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"content-type","text/html"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"expires","Thu, 29 Jan 2015 03:58:55 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"last-modified","Fri, 09 Aug 2013 23:54:35 GMT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-cache","HIT"&#125;,</span></div><div class="line"><span class="comment">%       &#123;"x-ec-custom-error","1"&#125;],</span></div><div class="line"><span class="comment">%      &lt;&lt;"&lt;!doctype html&gt;n&lt;html&gt;n&lt;head&gt;n    &lt;title&gt;Example Domain&lt;/title&gt;nn    &lt;meta "...&gt;&gt;&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>这篇文章仅仅是描述了你可以用httpc:request/4 来做一些很简单的事情。我强烈建议你阅读Erlang官方文档的<a href="http://www.erlang.org/doc/man/httpc.html" target="_blank" rel="external">httpc模块</a>部分。更多的例子和信息也可以阅读 <a href="http://www.erlang.org/doc/apps/inets/inets_services.html" target="_blank" rel="external">Erlang inets User Guide</a>，和 <a href="http://www.erlang.org/doc/apps/inets/http_client.html" target="_blank" rel="external">HTTP Client</a> 章节。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-httpc-request-1-and-httpc-request-4/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-httpc-request-1-and-httpc-request-4/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的 Erlang Thursday 讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/httpc.html#request-1&quot;&gt;httpc:request/1&lt;/a&gt; 和 &lt;a href=&quot;http://www.erlang.org/doc/man/httpc.html#request-4&quot;&gt;httpc:request/4&lt;/a&gt; 。httpc模块是erlang的HTTP1.1 客户端，request函数是erlang的功能强大的web请求工具。&lt;/p&gt;
&lt;p&gt;要使用httpc模块，我们必需先确保 inets 已经启动。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="httpc" scheme="http://szpzs.github.io/categories/Erlang/httpc/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="httpc" scheme="http://szpzs.github.io/tags/httpc/"/>
    
      <category term="request" scheme="http://szpzs.github.io/tags/request/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – erlang:apply/3</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-erlang-apply-3/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-erlang-apply-3/</id>
    <published>2016-09-15T13:46:31.000Z</published>
    <updated>2016-09-16T15:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲 <a href="http://www.erlang.org/doc/man/erlang.html#apply-3" target="_blank" rel="external">erlang:apply/3</a>.</p>
<p>在函数式语言里，我们喜欢将函数当做第一等公民看待将它在程序中传递。但是有些时候，我们并不知道我们将要调用哪一个函数，从而导致我们不确定函数的参数是什么。如果我们知道要调用哪个函数，我们只需像这样 Fun(Arg1, Arg2, …, ArgN) 来调用，但是如果我们遇到有不同参数数量的场景就没法这么干了。怎么办？还是让我们进入今天的主题：erlang:apply/3 。</p>
<a id="more"></a>
<p>erlang:apply/3，三个入参分别是模块名、函数名、一个要传给函数的实参组成的列表。传给erlang:apply/3的函数必需也是被导出的，否则将有错误发生。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">erlang:apply(lists, max, [[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">1</span>]]).</div><div class="line"><span class="comment">% 11</span></div><div class="line">erlang:apply(lists, merge, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">erlang:apply(lists, merge, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div></pre></td></tr></table></figure>
<p>Erlang的官方文档特别指出，erlang:apply/3仅仅是在我们不完全清楚函数的参数数量的时候来使用。否则我们只需按平常的函数调用来做，即使以匿名函数的方式来传递。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">fun</span> lists:max/<span class="number">1</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>erlang模块也包括另一个版本 erlang:apply/2 ，第一个入参是一个函数，第二个人才是这个函数的实参的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erlang:apply(<span class="keyword">fun</span> lists:merge/<span class="number">2</span>, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div></pre></td></tr></table></figure>
<p>erlang:apply/2 和 erlang:apply/3 并不是我们的通常用法，它在一些特殊场合，它是必要的，比如上星期的 <a href="http://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">timer:tc</a> 。虽然我们将很少用到它，但是了解它对我们也有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-apply-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-apply-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#apply-3&quot;&gt;erlang:apply/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;在函数式语言里，我们喜欢将函数当做第一等公民看待将它在程序中传递。但是有些时候，我们并不知道我们将要调用哪一个函数，从而导致我们不确定函数的参数是什么。如果我们知道要调用哪个函数，我们只需像这样 Fun(Arg1, Arg2, …, ArgN) 来调用，但是如果我们遇到有不同参数数量的场景就没法这么干了。怎么办？还是让我们进入今天的主题：erlang:apply/3 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/categories/Erlang/erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/tags/erlang/"/>
    
      <category term="apply" scheme="http://szpzs.github.io/tags/apply/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - timer:tc/3</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-timer-tc-3/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-timer-tc-3/</id>
    <published>2016-09-15T13:42:03.000Z</published>
    <updated>2016-09-16T15:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday要讲的函数是 <a href="http://www.erlang.org/doc/man/timer.html#tc-3" target="_blank" rel="external">timer:tc/3</a>.</p>
<p>我相信我们所有人写测量目标代码执行耗时的代码都是先获取当前时间，接着执行目标代码，再获取当前时间，最后将前后两个时间的差作为目标代码的执行耗时。在Erlang里，按这种方式来写的话将像下面这样：</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Time1 = now().</div><div class="line"><span class="comment">% &#123;1420,519186,111375&#125;</span></div><div class="line">timer:sleep(<span class="number">4000</span>).  <span class="comment">% Do something</span></div><div class="line"><span class="comment">% ok</span></div><div class="line">Time2 = now().</div><div class="line"><span class="comment">% &#123;1420,519190,118280&#125;</span></div><div class="line">timer:now_diff(Time2, Time1).</div><div class="line"><span class="comment">% 4006905</span></div></pre></td></tr></table></figure>
<p>我们可以注意到这么一个现象：因为now()函数返回一个元组格式的时间戳，所以我们不能将两个元组相减来得到时间差，就像我们在其他语言里能够将两个时间相减；因此我们必需使用 <a href="http://www.erlang.org/doc/man/timer.html#now_diff-2" target="_blank" rel="external">timer:now_diff/2</a> 。</p>
<p>作为一个好的“工程师”，我们知道因为我们必需在应用的不同地方做一些事情，那么我们可以在一个地方创建我们自己的函数让这个函数去做这些事情。</p>
<p>难过的是（意思是我们不需要这么做了）：聪明的Erlang语言团队已经为我们做了这个事情并且以timer:tc/3这个函数的方式提供给我们用。</p>
<p>timer:tc/3接收模块名，函数名以及一个参数列表作为入参。因为我们通常要得到我们调用的函数的结果，另外还有时长，这个结果就是一个元组，其中第一个元素是时长，它的单位是微妙，另一个元素是传给timer:tc/3的第二个参数（它是一个函数）的执行结果。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(timer, sleep, [<span class="number">4000</span>]).</div><div class="line"><span class="comment">% &#123;4003097,ok&#125;</span></div><div class="line">timer:tc(lists, foldl, [<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)]).</div><div class="line"><span class="comment">% &#123;5099481,2000001000000&#125;</span></div></pre></td></tr></table></figure>
<p>另外还有timer:tc/1，它仅接收一个函数并执行它；还有timer:tc/2，它接收一个函数和一个入参列表，然后执行它。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">timer:tc(<span class="keyword">fun</span>() -&gt; lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% &#123;5709293,2000001000000&#125;</span></div><div class="line">timer:tc(<span class="keyword">fun</span> lists:foldl/<span class="number">3</span>, [<span class="keyword">fun</span>(X, Accum) -&gt; X + Accum <span class="keyword">end</span>, <span class="number">0</span>, lists:seq(<span class="number">1</span>, <span class="number">2000000</span>)]).</div><div class="line"><span class="comment">% &#123;5766480,2000001000000&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-timer-tc-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-timer-tc-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday要讲的函数是 &lt;a href=&quot;http://www.erlang.org/doc/man/timer.html#tc-3&quot;&gt;timer:tc/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我相信我们所有人写测量目标代码执行耗时的代码都是先获取当前时间，接着执行目标代码，再获取当前时间，最后将前后两个时间的差作为目标代码的执行耗时。在Erlang里，按这种方式来写的话将像下面这样：&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="timer" scheme="http://szpzs.github.io/categories/Erlang/timer/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="timer" scheme="http://szpzs.github.io/tags/timer/"/>
    
      <category term="tc" scheme="http://szpzs.github.io/tags/tc/"/>
    
  </entry>
  
</feed>
