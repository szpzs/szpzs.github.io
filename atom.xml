<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2018-05-24T07:40:15.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为gen_event辩护</title>
    <link href="http://szpzs.oschina.io/2018/05/24/in-defense-of-gen-event/"/>
    <id>http://szpzs.oschina.io/2018/05/24/in-defense-of-gen-event/</id>
    <published>2018-05-24T06:10:09.000Z</published>
    <updated>2018-05-24T07:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>gen_event曾一度引起Erlang和Elixir开发人员的不满。他们已经撰写了许多文章，并就gen_event的各种替代办法举行了一次以上的会议。在这篇文章中，我要说明的是，尽管gen_event存在缺陷，但它仍然是一个非常有用的模块。我也认为它的核心设计最终要比许多人认为的灵活得多。</p>
<a id="more"></a>
<p>某些设计决策会产生灵活的系统。例如，Erlang的异步消息发送和带有超时的同步消息接收为开发人员提供了全面的消息传递行为。如果要同步消息的发送，最好带上一个唯一(reference)引用来发送消息，然后执行receive语句，对这个引用进行接收模式匹配。这基本上就是使用gen_*:call这一类函数调用时内部的实际情况。如果要异步接收消息，则可以使用带有 after 0 的receive语句，在没有匹配的消息的情况下，立即超时。下面是示例代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sync_send</span><span class="params">(Pid, Msg)</span> -&gt;</span></div><div class="line">    Ref = make_ref(),</div><div class="line">    Pid ! &#123;Ref, Msg&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;Ref, Reply&#125; -&gt; Reply</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">async_recv</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        M -&gt; &#123;ok, M&#125;</div><div class="line">    <span class="keyword">after</span></div><div class="line">        <span class="number">0</span> -&gt; none</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>问题：如果Erlang给提供你同步发送和异步接收，你将如何去实现异步发送和同步接收？</p>
<p>Erlang消息传递的核心设计足够灵活，可以表达默认情况下未实现的消息传递语义。 当我们将注意力转向gen_event时，请记住这一点。</p>
<p>对于那些不熟悉gen_event的人来说，它的工作方式或多或少可能像这样：gen_event:start_link启动所谓的事件管理器进程。 当你编写一个实现gen_event行为的模块时，你正在编写所谓的事件处理程序。 事件管理器有一个已安装事件处理程序的列表，每个事件处理程序都有自己的状态。 当进程调用gen_event:notify时，事件管理器将一次调用一个其安装的处理程序（毕竟，事件管理器只是一个进程）。 我会重复重点：事件管理器进程一次执行一个所安装的事件处理程序。 这个设计引发了一些争议，特别是José Valim，他有一篇关于如何用监督者（作为事件管理器）和一堆gen_server（作为事件处理程序）替换gen_event的<a href="http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/" target="_blank" rel="external">博客文章</a>。</p>
<p>我知道我有点怪，但是我认为gen_event的默认行为非常好，并且最终比José建议的并发处理程序的解决方案灵活得多。如果希望并发处理事件，则可以通过安装事件处理程序(将消息转发到现有进程或派生进程以执行事件处理代码)来轻松实现事件的扇出。但是，如果事件的并发处理是默认行为，你将如何实现事件的顺序处理呢？我怀疑你最终会实现一个效率较低的gen_event版本；因为你将发送不必要的消息，这导致效率较低。</p>
<p>问题：如果gen_event在默认情况下并发运行事件处理程序，那么你将如何依次运行处理程序呢？</p>
<p>总之，gen_event很像Erlang的消息传递，它提供了一个灵活的基础，你可以轻松地实现不同的行为。 我很高兴gen_event的存在，并且它被设计为顺序处理事件是默认行为。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/" target="_blank" rel="external">http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gen_event曾一度引起Erlang和Elixir开发人员的不满。他们已经撰写了许多文章，并就gen_event的各种替代办法举行了一次以上的会议。在这篇文章中，我要说明的是，尽管gen_event存在缺陷，但它仍然是一个非常有用的模块。我也认为它的核心设计最终要比许多人认为的灵活得多。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="gen_event" scheme="http://szpzs.oschina.io/categories/Erlang/gen-event/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="gen_event" scheme="http://szpzs.oschina.io/tags/gen-event/"/>
    
      <category term="message passing" scheme="http://szpzs.oschina.io/tags/message-passing/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Starters简介</title>
    <link href="http://szpzs.oschina.io/2018/05/24/spring-boot-starters/"/>
    <id>http://szpzs.oschina.io/2018/05/24/spring-boot-starters/</id>
    <published>2018-05-24T02:46:53.000Z</published>
    <updated>2018-05-24T03:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们将向你介绍Spring Boot Starters，并将讨论Spring Boot Starters的优点和优势。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在启动任何项目(无论是小型项目还是企业级应用程序)之前，其中关键的方面之一是依赖管理，手动为小型应用程序执行依赖管理并不是一项困难的工作，但对于复杂的应用程序，手动管理所有项目依赖并不理想，容易出现许多问题以及浪费时间，而这些时间可以用于项目的其他一些重要方面。</p>
<p>Spring Boot背后的基本原理之一就是解决类似的问题。Spring Boot Starter是一套方便的依赖描述符，可以很容易地包含在任何级别的应用程序中。这些Starters作为Spring相关技术的引导过程，我们 不再需要担心依赖关系，它们将由Spring Boot Starters自动管理。</p>
<p>Starters包含了许多你需要的依赖项，以使项目快速启动和运行，并且具有一致的、被支持的一组管理传递依赖项。</p>
<h1 id="1-为什么我们需要Starters？"><a href="#1-为什么我们需要Starters？" class="headerlink" title="1. 为什么我们需要Starters？"></a>1. 为什么我们需要Starters？</h1><p>当我们用Spring Boot开始开发应用时，我们想到的一个基本问题就是为什么我们需要Spring Boot Starters？ 或者这些Starters在我的应用中如何帮助到我？</p>
<p>如前所述，这些Starters用于引导应用程序，我们需要的只是在应用程序中包括正确的Starters，而Spring Boot将确保所选Starters所需的所有依赖项都在你的classpath中。</p>
<p>为了更清楚地理解它，我们举一个例子，我们想构建一个简单的Spring Web MVC应用程序，我们需要在开始编写我们的Web应用程序代码之前考虑以下几点。</p>
<ul>
<li>正确的Spring MVC依赖</li>
<li>Web技术所需的依赖（例如，我们想要使用Thymeleaf）</li>
<li>我们需要确保所有这些依赖是兼容的</li>
</ul>
<p>使用Spring Boot Starters来引导我们的Spring MVC Web应用程序非常简单，我们需要在我们的pom.xml中包含spring-boot-starter-web 这个starter：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上pom.xml中的条目将确保所有必需的依赖项都应位于classpath中，因此我们都准备好开始开发web应用程序了。</p>
<p>目前，Spring Boot提供的Starters约有50多个，这还不包括第三方的Starters。有关Starters的更新列表，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" title="Spring Boot Starter" target="_blank" rel="external">Spring Boot Starter</a></p>
<p>接下来，我将介绍一些常用的Starters。</p>
<h1 id="2-Web-Starter"><a href="#2-Web-Starter" class="headerlink" title="2. Web Starter"></a>2. Web Starter</h1><p>这是最常用的Spring Boot Starter之一，该Starter将确保创建Spring Web应用程序（包括REST）所需的所有依赖包括在你的calsspath中，它还将添加tomcat-starter作为默认服务器来运行我们的Web应用程序。 要在我们的应用程序中包含Web Starter，请在pom.xml中添加以下条目。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>现在我们可以创建我们的Spring MVC Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@RestController</span></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</div><div class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你运行应用程序并访问<a href="http://localhost:8080/greeting，你应该能够获得&quot;Hello" target="_blank" rel="external">http://localhost:8080/greeting，你应该能够获得&quot;Hello</a> Word”作为响应。我们使用最少的代码创建了一个REST控制器。</p>
<h1 id="3-Data-JPA-Starter"><a href="#3-Data-JPA-Starter" class="headerlink" title="3. Data JPA Starter"></a>3. Data JPA Starter</h1><p>大多数应用程序需要一些持久性机制，而JPA是持久性的标准，Spring Boot Starters带有JPA Starters，你不再需要手动配置这些JPA依赖，而是可以通过在应用程序中添加JPA Starter轻松实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring JPA Starter提供对H2，Derby和Hsqldb的自动支持。让我们看看使用JPA starter创建一个JPA样例应用程序是多么容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String firstName;</div><div class="line">    <span class="keyword">private</span> String lastName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">        <span class="comment">//this.id = id;</span></div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</div><div class="line">                <span class="string">"id="</span> + id +</div><div class="line">                <span class="string">", firstName='"</span> + firstName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", lastName='"</span> + lastName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下是我们的UserRepository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</div><div class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByLastName</span><span class="params">(String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们可以测试我们的代码了，如下是JUnit代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpademoApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Autowired</span></div><div class="line">   UserRepository userRepository;</div><div class="line"></div><div class="line">   <span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        User user = userRepository.save(<span class="keyword">new</span> User(<span class="string">"Demo"</span>,<span class="string">"User"</span>));</div><div class="line">        User searchUser= userRepository.findOne(user.getId());</div><div class="line"></div><div class="line">        assertNotNull(searchUser);</div><div class="line">        assertEquals(user.getFirstName(),searchUser.getFirstName());</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如我们在上面的代码中看到的那样，你不再需要指定那些数据库配置或额外的数据库配置，通过添加JPA starter，我们无需配置或编码即可获得许多开箱即用的功能。</p>
<p>如果需要，你始终可以修改或自定义这些配置。</p>
<h1 id="4-Mail-Starter"><a href="#4-Mail-Starter" class="headerlink" title="4. Mail Starter"></a>4. Mail Starter</h1><p>从应用程序发送电子邮件是非常常见的任务，现在每个应用程序都需要从系统发送电子邮件。Spring Boot Mail starter提供了一种隐藏所有复杂性的简单方法来处理此功能。</p>
<p>我们可以通过在应用程序中添加Mail starter来启用电子邮件支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我正在使用Mailgun作为我的SMTP服务器，以下是添加到我的application. properties文件中的SMTP详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">spring.mail.host=smtp.mailgun.org</div><div class="line">spring.mail.username=postmaster@domain.com</div><div class="line">spring.mail.password=mypassword</div><div class="line">spring.mail.properties.mail.transport.protocol=smtp</div><div class="line">spring.mail.properties.mail.smtp.port=587</div><div class="line">spring.mail.properties.mail.smtp.auth=true</div></pre></td></tr></table></figure>
<p>我们的EmailService类负责发送邮件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaEmailService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaEmailService</span><span class="params">(JavaMailSender mailSender)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mailSender = mailSender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line">        MimeMessagePreparator messagePreparator = mimeMessage -&gt; &#123;</div><div class="line"></div><div class="line">            MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</div><div class="line">            helper.setFrom(<span class="string">"noreply@javadevjournal.com"</span>);</div><div class="line">            helper.setTo(<span class="string">"xxx@gmail.com"</span>);</div><div class="line">            helper.setSubject(<span class="string">"Sample mail subject"</span>);</div><div class="line">            helper.setText(<span class="string">"Test Email"</span>);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        mailSender.send(messagePreparator);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用Spring提供的JavaMailSender来发送电子邮件。 JUnit测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    JavaEmailService javaEmailService;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        javaEmailService.sendEmail();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，只需简单的代码和配置即可发送一封简单的电子邮件，Spring Boot Mail Starter确保所有必需的工具已经到位，以快速开始解决实际问题。</p>
<p>请注意，我们在JavaEmailService bean中使用JavaMailSender - 该bean是由Spring Boot自动创建的。</p>
<h1 id="5-Test-Starter"><a href="#5-Test-Starter" class="headerlink" title="5. Test Starter"></a>5. Test Starter</h1><p>我们通常使用Junit、Mockito或Spring Test来测试我们的应用程序。我们可以通过添加Spring Boot Test starter轻松地将所有这些库包含在我们的应用程序中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot会自动找到我们正确的版本用于我们的应用程序测试。 这是一个JUnit示例测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    JavaEmailService javaEmailService;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        javaEmailService.sendEmail();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这些starter之外，下面还有其他常用的Spring Boot Starter</p>
<ul>
<li>spring-boot-starter-security</li>
<li>spring-boot-starter-web-services</li>
<li>spring-boot-starter-integration</li>
<li>spring-boot-starter-validation</li>
<li>spring-boot-starter-actuator</li>
</ul>
<p>如前所述，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" title="Spring Boot Starter" target="_blank" rel="external">Spring Boot Starter</a>获取Spring Boot提供的Starter的最新列表。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文提供了一个Spring Boot Starters简介，我们讨论了为什么我们需要这些Starter以及他们如何帮助我们快速引导我们的应用程序。 我们探索了一些最常用的Spring Boot Starter。</p>
<p>建议阅读：<br><a href="https://www.javadevjournal.com/spring/introduction-to-spring-boot/" title="Building an Application with Spring Boot" target="_blank" rel="external">使用Spring Boot构建应用程序</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">https://www.javadevjournal.com/spring/spring-boot-starters/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我们将向你介绍Spring Boot Starters，并将讨论Spring Boot Starters的优点和优势。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
      <category term="Spring boot starter" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/Spring-boot-starter/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
      <category term="Spring boot starter" scheme="http://szpzs.oschina.io/tags/Spring-boot-starter/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Boot构建应用程序</title>
    <link href="http://szpzs.oschina.io/2018/05/21/introduction-to-spring-boot/"/>
    <id>http://szpzs.oschina.io/2018/05/21/introduction-to-spring-boot/</id>
    <published>2018-05-21T07:32:25.000Z</published>
    <updated>2018-05-21T07:50:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们将探讨使用Spring Boot构建应用程序。 我们将介绍Spring Boot的不同方面以及使用Spring Boot构建应用程序的不同选项。</p>
<a id="more"></a>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Spring Boot有自己一套的约定，而且约定优于配置。Spring Boot通过用Spring平台自有的约定来消除大部分项目设置，这样新用户和现有用户就可以快速到达他们需要的开发节点。Spring Boot使创建一个以Spring为动力的企业应用程序变得非常容易，而且操作简单。</p>
<h1 id="2-Spring-Boot特性"><a href="#2-Spring-Boot特性" class="headerlink" title="2. Spring Boot特性"></a>2. Spring Boot特性</h1><p>Spring Boot提供以下开箱即用的功能：</p>
<ol>
<li>它通过采用预定义的约定简化了Spring依赖关系（我们将会更详细地讨论它）。</li>
<li>Spring Boot提供了一组预先配置的技术/框架来减少容易出错的配置，因此我们作为开发人员专注于构建业务逻辑而不是考虑项目设置。</li>
<li>你真的不需要为你的项目配置那些大的XML配置。</li>
<li>直接内嵌Tomcat、Jetty 或 Undertow。</li>
<li>提供预定义的Maven POM来简化你的配置。</li>
</ol>
<h1 id="3-创建Spring-Boot项目"><a href="#3-创建Spring-Boot项目" class="headerlink" title="3. 创建Spring Boot项目"></a>3. 创建Spring Boot项目</h1><p>启动一个项目的最主要挑战之一是初始化该项目的配置。我们需要对不同的目录结构进行调用，并且需要确保我们遵循所有行业标准。如果你使用的是Maven，那么你可能已经在使用Maven启动工件，它可以帮助我们更快地完成初始设置。</p>
<p>Spring Initializr是另外一个非常棒的快速启动一个Spring Boot项目的工具。Spring Initializr是一个生成Spring Boo项目的web应用。请记住，它只会生成项目结构，而不会根据你的偏好为你生成任何代码( Maven或Gradle )。如果你正在启动你的项目，我的推荐是使用Spring Initializr。</p>
<p>有几种方式来使用Spring Boot Initializr为你生成项目结构：</p>
<ol>
<li>使用Spring Initializr Web界面</li>
<li>使用Spring Boot CLI工具</li>
<li>使用你的IDE</li>
</ol>
<h2 id="3-1-使用Spring-Initializr-Web界面"><a href="#3-1-使用Spring-Initializr-Web界面" class="headerlink" title="3.1 使用Spring Initializr Web界面"></a>3.1 使用Spring Initializr Web界面</h2><p>这是为你的应用生成项目结构的最简单方式。在你的浏览器打开Spring Initializr Web界面，你将看到一个向导来开始你的配置。</p>
<p><img src="/images/spring-init.png" style="border:0;"></p>
<p>你需要在这个web界面填写一些信息：</p>
<ol>
<li>你要生成哪一类项目（Maven还是Gradle）</li>
<li>你想用什么语言（除了Java，你还可以选择Kotlin或Groovy）</li>
<li>Spring Boot的版本</li>
<li>项目的 GroupID和ArtifactID</li>
<li>选择所需依赖</li>
</ol>
<p>在web界面里选择依赖是一个有趣的功能。基于你选择的依赖，web界面将自动在生成的pom.xml文件中增加 <a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">Spring Boot Starter</a> 依赖。如果你想要更多地控制生成的项目结构，或者不确定要添加到项目中的依赖，请单击“切换到完整版”。</p>
<p><img src="/images/Spring-Full.png" style="border:0;"></p>
<p>使用完整版本界面，你可以选择Java版本，打包模式（比如用于传统部署的war包）以及为项目选择依赖的选项。一旦你点击“生成项目”按钮，Spring Initializr将生成项目，你将下载得到一个zip文件。 你可以在IDE中将解压缩的项目作为基于Maven 或 Gradle的项目导入。</p>
<p>我将不会详细介绍如何在IDE中导入项目。 有关更多详细信息，请参阅相关的IDE文档。</p>
<h2 id="3-2-使用Spring-Boot-CLI"><a href="#3-2-使用Spring-Boot-CLI" class="headerlink" title="3.2 使用Spring Boot CLI"></a>3.2 使用Spring Boot CLI</h2><p>我们也可以使用Srping Boot CLI来生成项目的结构。只要你安装了CLI，就可以打开终端输入spring。如果你正确安装了CLI，输入spring，回车后将看到如下类似的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">localhost:~ javadevjournal$ spring</div><div class="line">usage: spring [--help] [--version]</div><div class="line">       [&lt;args&gt;]</div><div class="line"></div><div class="line">Available commands are:</div><div class="line"></div><div class="line">  run [options]  [--] [args]</div><div class="line">    Run a spring groovy script</div></pre></td></tr></table></figure>
<p>我们可以在spring命令后使用init作为额外的参数来创建一个新的项目。Spring Boot CLI将在其内部使用start.spring.io来为你创建项目结构。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">localhost:~ javadevjournal$ spring init --dependencies=web springboot-demo-project</div><div class="line">Using service at https://start.spring.io</div><div class="line">Project extracted to &apos;/Users/umesh/springboot-demo-project&apos;</div></pre></td></tr></table></figure>
<p>上述命令将创建一个基于Maven的使用spring-boot-starter-web的项目，目录名为springboot-demo-project。这和使用start.spring.io的web界面创建的项目是一样的效果。我们可以传递不同的参数来自定义项目的生成。</p>
<p>比如，我们想创建基于Java 1.7的项目，我们可以传递 --java-version=1.7 作为额外参数给Spring Boot CLI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring init --java-version=1.7  --dependencies=web springboot-demo-project</div></pre></td></tr></table></figure>
<p>当执行上面的命令后，在项目的pom.xml文件里自动增加了Java 1.7相关的信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你不确认Spring init的功能有什么，可以带上标志 --list ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring init --list</div></pre></td></tr></table></figure>
<h1 id="4-查看pom-xml的内容"><a href="#4-查看pom-xml的内容" class="headerlink" title="4. 查看pom.xml的内容"></a>4. 查看pom.xml的内容</h1><p>我们来看看pom.xml文件的内容，来更详细地了解Spring Boot的配置。我将只关注pox.xml里与Spring Boot有关的变化。如下是我们创建样例项目的pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.umeshawasthi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ems<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ems<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Employee Management System outline Spring Boot Features<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- project properties repository --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Spring boot test depedency --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot最主要的特色就是“<a href="https://www.javadevjournal.com/spring/spring-boot-starters/" title="Spring Boot Starters" target="_blank" rel="external">Starters</a>”，它们是增加依赖包到classpath的便捷方式。使用Spring Boot的时候，我们不需要增加jar包或依赖到classpath（如果一个starter不可用了，你可以自己增加所需依赖到classpath，或者创建你自己的starter）。我们仅需要增加正确的“Starters”到我们的pom.xml里，Spring Boot会确保自动增加那些依赖。</p>
<h1 id="5-应用程序入口"><a href="#5-应用程序入口" class="headerlink" title="5. 应用程序入口"></a>5. 应用程序入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmsApplication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">     SpringApplication.run(EmsApplication.class, args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-1-SpringBootApplication注解"><a href="#5-1-SpringBootApplication注解" class="headerlink" title="5.1 @SpringBootApplication注解"></a>5.1 @SpringBootApplication注解</h2><p>我们的主类用了@SpringBootApplication注解。@SpringBootApplication等同于同时使用@Configuration、@EnableAutoConfiguration和@ComponentScan。如果你启动你的项目，建议使用这个注解。使用@SpringBootApplication等同于同时使用如下三个注解：</p>
<ol>
<li><code>@Configuration</code>  作为bean定义的来源。</li>
<li><code>@EnableAutoConfiguration</code>  它使得Spring Boot自动配置应用程序。</li>
<li><code>@ComponentScan</code>  它会自动扫描所有的Spring组件，包括使用了<code>@Configuration</code>注解的类。</li>
</ol>
<h2 id="5-2-主方法"><a href="#5-2-主方法" class="headerlink" title="5.2 主方法"></a>5.2 主方法</h2><p>我们主类的另一个有趣的地方是主方法。它是遵循标准Java工作流程的标准方法。 我们的主类将把控制权交给Spring Boot的 SpringApplication类。 SpringApplication类的run方法将用于引导应用程序。 我们将在后面更深入地观察SpringApplication。</p>
<h1 id="6-Hello-World-控制器"><a href="#6-Hello-World-控制器" class="headerlink" title="6. Hello World 控制器"></a>6. Hello World 控制器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.javadevjournal.demo.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="string">"Hello World!!"</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制器非常简单。它是使用Spring MVC标准注解的Spring MVC控制器。</p>
<h1 id="7-运行应用"><a href="#7-运行应用" class="headerlink" title="7. 运行应用"></a>7. 运行应用</h1><p>是时候运行我们第一个Spring Boot程序了。我们有几种方式来运行我们的Spring Boot程序。</p>
<ol>
<li>如果我们使用IDE, 我们可以用IDE来运行我们Spring Boot程序。</li>
<li>我们可以在项目根目录下用  <code>mvn spring-boot:run</code>  命令来启动我们的第一个Spring Boot程序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> .   ____          _            __ _ _</div><div class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</div><div class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="line"> =========|_|==============|___/=/_/_/_/</div><div class="line"> :: Spring Boot ::        (v1.5.4.RELEASE)</div><div class="line"></div><div class="line">2017-07-08 15:49:50.319  INFO 1238 --- [           main] com.javadevjournal.demo.EmsApplication   : Starting EmsApplication on localhost with</div></pre></td></tr></table></figure>
<p>打开浏览器，输入 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> ，回车，我们将看到 Hello World 。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring Boot为基于Spring的应用程序提供了很好的推动力。在这篇文章中，我们学习了使用Spring Boot构建应用程序的不同选项。设置新项目始终是一项具有挑战性的任务，我们需要确保管理所有依赖，但是使用Spring Boot，这些都变得非常容易，我们能够只用几行代码就能运行第一个web应用程序，而无需过多考虑所需的依赖或程序的部署。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/introduction-to-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/introduction-to-spring-boot/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我们将探讨使用Spring Boot构建应用程序。 我们将介绍Spring Boot的不同方面以及使用Spring Boot构建应用程序的不同选项。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot是什么？</title>
    <link href="http://szpzs.oschina.io/2018/05/18/spring-boot-what-is-spring-boot/"/>
    <id>http://szpzs.oschina.io/2018/05/18/spring-boot-what-is-spring-boot/</id>
    <published>2018-05-18T06:24:59.000Z</published>
    <updated>2018-05-18T12:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这将是更侧重于介绍Spring Boot的短文，我们将讨论“什么是Spring Boot”？ 以及Spring Boot如何帮助构建基于Java的企业应用程序。</p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作为一名Java开发人员，我们很可能已经直接或间接地在工作中使用基于Spring Framework的应用程序。<strong>Spring</strong>有许多方法来配置它的行为，它提供三种方式进行配置，基于XML的配置或基于注解的配置，以及基于Java的配置，而基于Java的配置正在成为新的Spring应用程序的事实标准。尽管这些选项看起来非常好，但大型企业应用程序涉及数百个模块和复杂的业务规则，但这些配置可能会变得非常复杂。 以下是大型应用程序可以带来的一些复杂情况。</p>
<ul>
<li>每个模块有它自己的配置</li>
<li>每个模块有它自己的依赖（第三方依赖）</li>
<li>升级应用（例如从Spring 4.x 升级到Spring 5.x）将会很复杂，因为我们需要确认所有的依赖都正确地升级</li>
<li>如果一些依赖不能正常工作，试图找出根本原因是一个大型应用程序非常复杂和具有挑战性。</li>
</ul>
<p>以上所有问题或多或少都与确保我们拥有一切，然后开发团队才能开始处理实际任务有关。 现在让我们来谈谈另一个情况，我们用它来处理任何基于Spring的应用程序。假设我们要创建一个基于Web的应用程序，下面是我们大多数人常用的常用步骤：</p>
<ul>
<li>使用我们选择的Maven或IDE创建一个Web应用程序。</li>
<li>复制标准的Web应用程序配置（Spring MVC应用程序的web.xml配置）。</li>
<li>根据我们的要求调整以上配置。</li>
<li>配置Spring MVC标准bean，如ViewResolver，MessageSource等。</li>
<li>配置要用于我们的应用程序的数据库属性。</li>
<li>建立数据库层并确保底层数据库连接已经就位，然后才能开始使用它（EntityManagerFactory，TransactionManager等）</li>
</ul>
<p>上面的列表可以根据我们的应用程序的类型显着增长。</p>
<h2 id="1-Spring-Boot是什么？"><a href="#1-Spring-Boot是什么？" class="headerlink" title="1. Spring Boot是什么？"></a>1. Spring Boot是什么？</h2><p>以上所有步骤对我们来说都很重要，但是它们给开发团队增加了很多开销，而不是专注于解决实际的业务问题，最初的时间将被消耗在确保一切都就位后才开始实际的工作。我们可以将Spring Boot视为可以自动完成这些初始任务的工具。Spring Boot对我们所使用的Spring平台有自己的视角，并确保团队可以快速开始解决实际业务问题，而不是花时间在初始配置和设置上。</p>
<p>Spring Boot提供以下开箱即用的功能：</p>
<ol>
<li>它通过采用自己的视角简化了Spring依赖关系（我们将会更详细地讨论它）。</li>
<li>Spring Boot提供了一组预先配置的技术/框架来减少容易出错的配置，因此我们作为开发人员专注于构建业务逻辑而不是考虑项目设置。</li>
<li>你真的不需要为你的项目配置那些大的XML配置。</li>
<li>直接内嵌Tomcat、Jetty 或 Undertow。</li>
<li>提供预定义的Maven POM来简化您的配置。</li>
</ol>
<p>使用Spring Boot，可以轻松管理和处理介绍部分突出显示的问题。在升级过程中，我们不需要手动搜索兼容的jar包，Spring Bug将确保我们的应用程序升级到正确的版本（这称为麻烦最小化开发应用程序）。</p>
<p>让我们来看看我们的Web应用程序的一个示例pom.xml，以了解Spring Boot例子程序的配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javadevjournal.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sample web application<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>rWeb Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hateoas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>请看&lt;packaging&gt;标签，Spring Boot可以灵活地将我们的应用程序作为jar包来运行，而不是强迫我们将war作为所需的打包类型。</p>
<h2 id="2-更好的依赖管理"><a href="#2-更好的依赖管理" class="headerlink" title="2. 更好的依赖管理"></a>2. 更好的依赖管理</h2><p>只要仔细检查配置，你不会找到所有这些Spring依赖项的条目（如web MVC，核心，AOP，ORM，验证API等等），你可能已经注意到类似的条目spring-boot-starter- *，这是Spring Boot依赖管理过程。 我们在我们的pom.xml中添加了spring-boot-starter-web，Spring Boot将拉取所有为Spring MVC应用程序必需的依赖（不再需要手动配置）。</p>
<h2 id="3-自动配置"><a href="#3-自动配置" class="headerlink" title="3.自动配置"></a>3.自动配置</h2><p>自动配置是Spring Boot的另一个有趣功能，这就是为什么Spring Boot团队认为它有意思的地方。以下是Spring Boot为你做的一些工作：</p>
<ol>
<li>它将添加所有依赖，如第2点中所述。</li>
<li>自动配置表明Spring Boot具有一些合理的默认设置，即基于配置的Spring Boot将猜测应用程序的类型，并提供运行应用程序所需的默认实现，以防我们未在应用程序中定义这些应用程序。 如果你定义了这些，Spring Boot将确保这些默认值将被取消，并让你的自定义配置将负责应用程序。</li>
<li>为了更清晰的理解，假设你已经为JPA定义了依赖，并且没有定义任何数据库配置，Spring Boot会自动为我们创建所需的配置。</li>
</ol>
<p>请阅读这篇<a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">文章</a>以更加深入地理解<strong>Spring boot的自动配置</strong></p>
<h2 id="3-Servlet容器"><a href="#3-Servlet容器" class="headerlink" title="3. Servlet容器"></a>3. Servlet容器</h2><p>每当我们做出那些小的改变，并且需要将你的应用程序部署到应用服务器来测试我们的改变时，你是否记得在Servlet容器（Tomcat等）上部署它们的过程？Spring Boot提供对嵌入式Servlet容器的支持，我们不再需要在应用服务器上部署我们的应用程序（这可以使用标准main方法轻松运行），同时我们可以使用http://\<host>:\<port>在浏览器上访问我们的应用程序。</port></host></p>
<p>我们的pom.xml中的Spring-boot-starter-web配置条目将为我们的Web应用程序提供嵌入式servlet容器，Apache Tomcat是Spring Boot提供的默认servlet容器，然而，Spring boot也提供了使用其他servlet容器的方法（我们所要做的就是将相应的 starter 添加到pom.xml中）。</p>
<p>请阅读我们的文章<a href="https://www.javadevjournal.com/spring/introduction-to-spring-boot/" target="_blank" rel="external">使用Spring Boot构建应用程序</a>来开始使用Spring Boot构建你的应用程序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们了解了Spring Boot，我们介绍了什么是Spring Boot？ Spring Boot有什么好处？ 我们讨论了Spring Boot的不同特性。 Spring Boot内部为我们做了很多事情，这对我们来说似乎很神奇。 在本系列文章中，我们将揭开Spring Boot的所有内部细节。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/what-is-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/what-is-spring-boot/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将是更侧重于介绍Spring Boot的短文，我们将讨论“什么是Spring Boot”？ 以及Spring Boot如何帮助构建基于Java的企业应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Rust的内存安全革命</title>
    <link href="http://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/"/>
    <id>http://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/</id>
    <published>2018-04-28T08:31:55.000Z</published>
    <updated>2018-04-28T09:09:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的核心特性：内存管理。 该核心特性是Rust的主要创新之一，它的许多独特的特点是基于这种核心特性的。</p>
<p>本文是写给不知道Rust或刚刚开始学习它的程序员的。对于熟悉C、C++或其他使用手动管理内存以及使用垃圾回收器语言的读者来说会更容易理解Rust的特点。 本文是一个旨在介绍Rust核心概念并鼓励进一步学习的高层次介绍。本文不是教程，最后也没有Hello Wrold的Rust例子。</p>
<a id="more"></a>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>现代应用程序使用计算机的内存主要有两种方式：栈和堆。这可能不适用于使用汇编或编写嵌入式系统软件的情况，但让我们还是关注一般的应用程序的场景。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>随着程序进入和退出某些区域（通常是函数），以及循环和分支代码块，栈会自动扩展和缩小。所有现代的、高于汇编语言的语言都会自动执行此操作。它们的行为都是相似的，程序员声明变量，使用它，然后丢弃它。 编译器基于代码区域边界知道何时必须保留内存以及何时清除内存。 这是一个严格的流程，但它快速、安全且易于使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = 1       // 创建 A</div><div class="line">    loop &#123;</div><div class="line">        B = 2   // 创建 B</div><div class="line">                // 删除 B</div><div class="line">    &#125;</div><div class="line">                // 删除 A</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>对堆的处理更自由。 程序员可以从代码中的任何一点来请求它的一部分，然后在任何其他点释放它。 它并不明显与程序流程结合，编译器无法确定何时以及如何处理它。程序员有责任对其进行正确处理。</p>
<p>内存<strong>首先</strong>必须被获取到，<strong>然后</strong>被使用，<strong>最后</strong>被仅释放<strong>一次</strong>。这三个步骤似乎很简单，但将其与其他应用程序的流程混合会变得棘手，并且违反其中一个步骤都是灾难性的。 有时候一个错误可能没有任何后果，但是在其他时候，应用程序可能会被终止，甚至更糟糕的是，它的内存可能会悄无声息地被破坏。 这种行为不是确定性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">    release(A)      // 释放</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><p>当内存没有被正确释放当时候，泄露就发生了。内存泄漏成为一个致命的负担，使得应用程序比实际所需使用更多的资源。在极端情况下，如果所有的内存都被占用，并且仍然有更多的需求，它会使程序甚至整个系统崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">                    // &lt;运行时错误&gt; 从未释放</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="释放后使用"><a href="#释放后使用" class="headerlink" title="释放后使用"></a>释放后使用</h3><p>当内存被释放后程序还尝试去使用这块内存，这就是释放后使用。如果内存被还给了操作系统，而我们又尝试去访问它，这会导致致命的段错误，程序会立即被结束。另一个有趣的部分是当被释放的内存被分配器缓存并在下次获取时被重用，这使两个随机部分的代码使用相同位置的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    release(A)      // 释放</div><div class="line">    do_stuff(A)     // &lt;运行时错误&gt; 使用无效指针</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重复释放"><a href="#重复释放" class="headerlink" title="重复释放"></a>重复释放</h3><p>内存被释放两次就是重复释放。如果内存被还回操作系统，它就终止程序对它对访问。重复释放的后果很大程度上取决于分配器，释放内存在其他地方使用或只是崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">    release(A)      // 释放</div><div class="line">    release(A)      // &lt;运行时错误&gt; 释放无效指针</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="传统解决方法"><a href="#传统解决方法" class="headerlink" title="传统解决方法"></a>传统解决方法</h1><p>堆管理是个非常古老的问题，程序员发明了许多工具来减轻它。有两种主要的方法，都被证明是有用的，但每一种都有严重缺陷。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>这是一个简单的方法。程序获得特殊的机制检测到从某时刻开始给定的内存块将永远不会被使用，因此它可以安全释放。该方法防止了内存泄露、释放后使用、重复释放。证明内存永远不会被再次使用的最简单的方法是证明它是不可访问的。当程序将内存的地址存储在栈上、静态变量或堆上时，该内存是可到访问的，堆本身是可到达的，因此可以在不猜测的情况下获得。而内存本身是可访问的，因此可以毫无疑问地获得它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">   ...</div><div class="line">   A = &lt;pointer to&gt;──────┐</div><div class="line">   ...                   |</div><div class="line">&#125;                        │</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ AA = &quot;reachable&quot;         ║</div><div class="line">║ AB = &lt;pointer to&gt;──────┐ ║</div><div class="line">╚════════════════════════│═╝</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ ABA = &quot;also reachable&quot;   ║</div><div class="line">╚══════════════════════════╝</div><div class="line"></div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ BA = &quot;unreachable&quot;       ║</div><div class="line">║ BB = &lt;pointer to&gt;──────┐ ║</div><div class="line">╚════════════════════════│═╝</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ BBA = &quot;also unreachable&quot; ║</div><div class="line">╚══════════════════════════╝</div></pre></td></tr></table></figure>
<p>有许多智能的策略来检查可访问性，但它们都会产生显著的开销。例如，引用计数器会增加内存使用量并为每个堆访问增加开销。另一方面，追踪垃圾回收器允许自由访问，但引入了大量的内存可访问性分析，这些分析可以在后台不断运行，或者为了清理内存可以完全停止程序的执行。 无论如何，垃圾回收器都会为应用程序增加额外的工作量并增加内存使用量。</p>
<h2 id="严格的规则"><a href="#严格的规则" class="headerlink" title="严格的规则"></a>严格的规则</h2><p>因此垃圾回收器是一个很好但消耗大量资源的解决方案。但是，如果成本难以承受或者根本没有可能使用它，我们可以做些什么呢？ 程序员发明了一个特殊的规则，它使内存管理更容易。 它是基于所有权和生命周期的规则。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>所有权是这样的一个想法，可以有很多指向分配内存的指针，但只有其中一个被视为拥有该内存。当拥有所有权的指针被销毁时，应该使用它来释放分配给它的内存。非所有权的指针可以被创建和销毁任意个，但它们永远不应该用于释放内存。这使得内存管理更加清晰，因为只有一个重要指针要跟踪和释放。它还解决了前面提到的三个堆问题中的两个问题：泄漏和重复释放。所有权可能是API和程序流程中的一个软性协议，但某些语言和库提供的工具使得此策略的执行更加明确且不易出错。例如，现代C++提供了内置的智能指针，它明确表示有拥有权的指针并实现像销毁时释放的合适行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()      // 获取</div><div class="line">    do_stuff(A)         // 使用</div><div class="line">    release(A)          // 释放, 指针拥有内存</div><div class="line">                        // 删除指针</div><div class="line">&#125;</div><div class="line"></div><div class="line">do_stuff(B) &#123;</div><div class="line">    do_more_stuff(B)    // 使用</div><div class="line">                        // 不会释放，该指针不是所有权的指针</div><div class="line">                        // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期是程序执行过程中的一段时间，而这段时间内一段特定的数据被有效使用。处理堆分配的内存指针时，这是非常重要的属性，这些指针并不拥有内存。 只要拥有内存的指针不释放内存，它们就可以安全使用。而有所有权的指针释放内存之后，再使用它们就是错误，因为它们的生命周期结束了。值得注意的是，任何包含给定生命期周期的指针的结构都应该被认为具有不超过指针的生命期周期。这不是一个可以执行的简单的规则，但它可以防止前面提到的第三个堆内存问题：释放后使用。 这补充了所有权的保证，使得程序的完全内存安全，而无需垃圾回收器这样的开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // A&apos;s lifetime begins</div><div class="line">    do_stuff(A)     // use A</div><div class="line">    B = A           // B&apos;s lifetime begins</div><div class="line">    do_stuff(B)     // use B</div><div class="line">    release(A)      // release, A&apos;s and B&apos;s lifetimes end</div><div class="line">    do_stuff(A)     // &lt;RUN TIME FAIL&gt; use A after its lifetime ended</div><div class="line">    do_stuff(B)     // &lt;RUN TIME FAIL&gt; use B after its lifetime ended</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><p>有时Rust被描述为混合解决方案。 实际上，它所做的只是强化代码中的所有权和生命周期规则，然而结果是，用Rust写代码非常安全和无忧无虑，它类似于垃圾回收语言。编译器进行静态校验该程序是内存安全的，如果无法校验它是内存安全的，编译器会产生一个指出潜在风险的错误。 当编译通过后，代码保证不会导致内存损坏。 因为这些校验在构建输出二进制文件之前都发生了，所以这个过程对程序的执行没有任何影响，就像它是用纯C或C++编写的一样轻量。</p>
<h2 id="所有权-1"><a href="#所有权-1" class="headerlink" title="所有权"></a>所有权</h2><p>Rust有非常严格的所有权概念。每一块被分配的内存被一些结构的单独实例所拥有。这些结构可以是任何类型，但通常他们最终是某种来自标准库的集合或Box（Rust的智能指针）。这些包装器负责在自己被销毁的时候释放所拥有的内存。没有简单的方法来显式分配内存和获取原始指针，而不需要任何负责任的包装器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_fn</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(<span class="number">1234</span>);    <span class="comment">// 获取</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_box);         <span class="comment">// 使用</span></div><div class="line">                                    <span class="comment">// 删除 my_box,</span></div><div class="line">                                    <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归销毁"><a href="#递归销毁" class="headerlink" title="递归销毁"></a>递归销毁</h3><p>所有权是递归的，所以如果一个结构存储另一个结构的值，它将获得后者及其所有子结构的所有权。这也意味着，当容器被销毁时，它必须递归地销毁其所有内容。Rust处理这样的情况可以说是开箱即用一样轻松。所有结构都定义了析构器，它遍历所有字段并首先销毁它们。结构的作者可以在销毁期间添加自己的步骤，例如在编写客户端时关闭数据库连接，但是在此之后字段仍然会被逐一销毁。默认的处理行为在绝大多数情况下都是足够的，因此结构很少会定义析构函数，但是不管有没有定义析构函数，它们都不会泄漏内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;                       <span class="comment">// 结构定义</span></div><div class="line">    my_box: <span class="built_in">Box</span>&lt;<span class="keyword">u32</span>&gt;,                   <span class="comment">// 它只有一个字段,</span></div><div class="line">                                        <span class="comment">// 在堆上一个持有整数的Box类型数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_fn</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> my_struct = MyStruct &#123;          <span class="comment">// 创建结构实例</span></div><div class="line">        my_box: <span class="built_in">Box</span>::new(<span class="number">1234</span>),         <span class="comment">// 获取内存</span></div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_struct.my_box);   <span class="comment">// 使用</span></div><div class="line">                                        <span class="comment">// 删除 my_struct,</span></div><div class="line">                                        <span class="comment">// 同时删除 my_box,</span></div><div class="line">                                        <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="用栈替代堆"><a href="#用栈替代堆" class="headerlink" title="用栈替代堆"></a>用栈替代堆</h3><p>Rust的所有权模式带来了一个强大的特性：复杂的堆管理简化为简单的栈管理。程序员不需要担心如何分配和释放内存，这些工作都通过使用局部变量来处理。甚至即使结构里嵌套了许多堆内存的引用，在栈上也总是只有一个根结构，当程序不再需要它的时候，它会自动销毁。</p>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><p>不幸的是，编写那些访问数据需要拥有这些数据的程序并不方便。Rust提供普通的、非智能的、没有所有权的引用，这种引用使得没有所有权的访问成为可能。当这样的引用被创建时，它引用的值是借用的。借用会创建一个双向关系：引用必须具有不超过它引用的值的生命周期，但该值在引用的生命周期内不得移动。这两条规则任何一条被破坏的话，引用所指向的就是无效内存。Rust静态地跟踪并强制执行生命周期的正确性并拒绝危险的程序执行流程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">valid_flow</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value);          <span class="comment">// 使用值但是没有移动它</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, borrow);         <span class="comment">// 使用借用</span></div><div class="line">                                    <span class="comment">// 删除借用</span></div><div class="line">                                    <span class="comment">// 安全地删除值，</span></div><div class="line">                                    <span class="comment">// 因为它不再被借用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrow_outlives_value</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="keyword">return</span> borrow                   <span class="comment">// 借用没有被删除</span></div><div class="line">                                    <span class="comment">// &lt;编译时错误&gt; 删除值,</span></div><div class="line">                                    <span class="comment">// 但是它仍然被借用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_moved_during_borrow_lifetime</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(value);   <span class="comment">// &lt;编译时错误&gt; 值被移动了</span></div><div class="line">                                    <span class="comment">// 而它还被借用着</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归借用"><a href="#递归借用" class="headerlink" title="递归借用"></a>递归借用</h3><p>结构的生命周期永远不能超过它们的任何字段的生命周期。如果其中一个字段恰好是引用，则必须证明整个结构实例在引用值之前被销毁。如果存在对具有生命周期限制的结构的引用，则引用本身的生命周期不能超过结构。只要编译器可以证明它是安全的，这种关系就可以嵌套并绑定任意次数。当编译器无法猜测正确的关系时，可以用简单的语法明确定义它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">nested_borrow_outlives_value</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">                                    <span class="comment">// 使用的是值的生命周期</span></div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(borrow);  <span class="comment">// 创建 my_box</span></div><div class="line">                                    <span class="comment">// 用的是借用的生命周期,</span></div><div class="line">                                    <span class="comment">// 这是值的生命周期</span></div><div class="line">    <span class="keyword">return</span> my_box                   <span class="comment">// &lt;编译时错误&gt;</span></div><div class="line">                                    <span class="comment">// my_box 没有被删除,</span></div><div class="line">                                    <span class="comment">// 但是值被删除了,</span></div><div class="line">                                    <span class="comment">// 这造成借用的生命周期</span></div><div class="line">                                    <span class="comment">// 超过了值的生命周期</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="规则的妥协"><a href="#规则的妥协" class="headerlink" title="规则的妥协"></a>规则的妥协</h1><p>认为每一个系统都可以用限制性的、静态证明的安全性代码来表达是天真的想当然。在绝大多数的情况下，规则可以胜任，但有时规则也必须进行妥协，Rust提供工具来做这件事。</p>
<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><p>标准库提供一些包装器将所有权和借用的检查推迟到运行时。这就使有效性检查程序不那么繁忙，并提供了灵活性和很少的运行时开销。例如，Rc是一个没有所有者的Box（带有智能指针的内存）。 它是一个有引用计数器的可被垃圾回收的内存，它的最后一个引用消失的时候，它就被销毁。 Rust提供了更多的包装器，但它们稍微超出了本介绍的范围，它们适用于运行时规则，本文没有涉及。</p>
<h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>当在库和工具中进入足够低的层次时，Rust的安全保证变得无法应用。 例如，box和集合触及内存分配和指针，但没有安全保证，因为它们自己做安全保证。 它们可以写在Rust中，因为它们的代码明确标记为不安全。这使得完全忽略安全检查，但这非常危险。 所有外部C库包装器在某些层次也必须使用不安全的代码。 他们定义安全规则，使其与其余代码无缝集成。 不安全的代码是Rust强大能力的来源，但它带来了巨大的责任。 应尽可能避免使用它。</p>
<h1 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h1><p>Rust看起来不错，它是由聪明的人使用其他聪明人的学术研究设计的，但它真的有用吗？是的，的确有用。大多数情况下，它只会强制元素之间的明确关系，进行合理安全的设计。毕竟，Rust是与Firefox Web浏览器的未来引擎Servo并行设计的。从一开始，它不仅在理论上是好的，而且在实际的、复杂的软件开发中也被证明是可用的。经过一年使用Rust进行商业编程后，我可以确认，Rust的规则不是一种负担，而是在架构和稳定性保证方面提供了很大的帮助。 我真的相信，Rust这种语言是属于未来的，我强烈推荐大家使用它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://anixe.pl/content/news/rust_memory_safety_revolution" target="_blank" rel="external">https://anixe.pl/content/news/rust_memory_safety_revolution</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的核心特性：内存管理。 该核心特性是Rust的主要创新之一，它的许多独特的特点是基于这种核心特性的。&lt;/p&gt;
&lt;p&gt;本文是写给不知道Rust或刚刚开始学习它的程序员的。对于熟悉C、C++或其他使用手动管理内存以及使用垃圾回收器语言的读者来说会更容易理解Rust的特点。 本文是一个旨在介绍Rust核心概念并鼓励进一步学习的高层次介绍。本文不是教程，最后也没有Hello Wrold的Rust例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://szpzs.oschina.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://szpzs.oschina.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="http://szpzs.oschina.io/tags/Ownership/"/>
    
      <category term="Lifetimes" scheme="http://szpzs.oschina.io/tags/Lifetimes/"/>
    
  </entry>
  
  <entry>
    <title>以NIF的方式在Elixir里使用C</title>
    <link href="http://szpzs.oschina.io/2018/04/03/using-c-from-elixir-with-nifs/"/>
    <id>http://szpzs.oschina.io/2018/04/03/using-c-from-elixir-with-nifs/</id>
    <published>2018-04-03T06:54:22.000Z</published>
    <updated>2018-04-03T07:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang支持一种方式，就是用C来实现函数，并在Erlang中透明地使用它们。这些函数被叫做NIFs（原生实现的函数）。在两种场景下，NIF被证明是完美的解决方案：当你需要原始的计算速度时；当你需要从Erlang调用已有的C接口时。在本文中，我们一起来看看这两种场景。</p>
<a id="more"></a>
<p>请注意，如果我们想要使用C程序（也就是我们想要与现有的C程序进行交互），那么NIF并不是我们唯一的选择。Erlang有其他方式处理外部函数接口来与其他语言交互。其中之一就是Port；如果你想深入了解，可以阅读 Sasa Juric 写的非常棒的<a href="http://theerlangelist.com/article/outside_elixir" target="_blank" rel="external">文章</a>。</p>
<p>我们将全面了解NIF。首先，我们将看看如何写简单的NIF来执行算术计算；接着，我们看看如何在Elixir里使用这些NIF。然后，我们了解如何从NIF里访问已有的C程序。最后，我们学习如何将C的编译合并到我们Elixir代码编译中。</p>
<p>我在本文中所讲的绝大部分内容都可以在Erlang官方文档中 <a href="http://www.erlang.org/doc/man/erl_nif.html" target="_blank" rel="external">erl_nif C 库</a> 中阅读到更多细节。</p>
<p>本文中讨论的内容适用于Erlang和Elixir，只需进行最小限度的调整。 我会在Elixir中展示我所有的例子，但我会随时提及Erlang和Elixir两者。</p>
<h1 id="严肃的NIF警告"><a href="#严肃的NIF警告" class="headerlink" title="严肃的NIF警告"></a>严肃的NIF警告</h1><p>NIF是危险的。我猜你肯定听说过Erlang（Elixir）如何可靠、容错，进程是如何隔离的，一个进程内部的崩溃只会影响到它自己，以及其他的很棒的特性。当你开始玩NIF的时候，你可以和所有Erlang好的东西说再见。一个NIF里的崩溃（比如可怕的段错误）将会使得整个Erlang虚拟机崩溃。没有监督者来恢复，没有容错，没有隔离。这意味着当你使用NIF的时候需要极度的小心谨慎，并且你应该总是确信你有一个好的理由来使用它。</p>
<p>另一个值得注意的是NIF不会被Erlang的调度器抢占：一个NIF做为一个单独的计算单元，它不会被中断。这意味着你的NIF应该尽可能地快; 正如Erlang的NIF文档所建议的那样，一个很好的经验法则是将NIF保持在毫秒级的执行时间内。查看Erlang文档，了解当你的NIF需要更多时间完成时应采取的措施。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>NIF的工作方式简单：你写一个C文件，然后在一些Erlang提供的设施下导出一些函数，然后编译这个文件。接着，你定义一个Erlang/Elixir文件，在里面调用 :erlang.load_nif/2 。这个函数将把C文件里的所有NIF定义为调用模块里的函数。</p>
<p>在实践中更容易明白这一点。</p>
<p>让我们从容易的开始：写一个没有副作用的NIF，它有一个入参和一个返回值。为完成这个例子，我们写一个 fast_compare 函数，它有两个整数入参，然后比较它们，如果相等就返回0，如果第一个比第二个小，就返回-1，否则就返回1。</p>
<h2 id="定义一个NIF"><a href="#定义一个NIF" class="headerlink" title="定义一个NIF"></a>定义一个NIF</h2><p>我们开始写 fast_compare.c 文件。首先我们必须包含 erl_nif.h 这个头文件，它包含了使用NIF的时候，我们需要的所有东西（类型、函数、宏）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div></pre></td></tr></table></figure>
<p>C编译器并不知道erl_nif.h在哪里，因此，当稍后我们编译我们的程序的时候，必须指出它的所在。</p>
<p>现在，定义NIF的所有C文件有相似的结构：C函数列表，接着是被导出到Erlang/Elixir的C函数列表（以及它们的名字），最后，调用 ERL_NIF_INIT 宏，它执行把所有这个一切串联起来的神秘的事情。</p>
<p>在我们的例子里，C函数列表就只有 fast_compare 函数。这个函数的签名如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="comment">// cool stuff here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个NIF的特定类型：ERL_NIF_TERM 和 ErlNifEnv。</p>
<p>ERL_NIF_TERM 是一个“包装”类型，它表示在C里所有的Erlang数据类型（像binary，list，tuple，等等）。我们必须使用 erl_nif.h 提供的函数来将一个 ERL_NIF_TERM 转换为一个C的值（或者多个C的值），反之亦然。</p>
<p>ErlNifEnv仅仅是NIF被执行所在的Erlang环境，我们绝大多数只是把它在函数中进行传递而不必实际对它进行操作。</p>
<p>我们来看看 fast_compare 的参数（所有的NIF参数都如此）：</p>
<ul>
<li>env 如上所述，仅是NIF被执行所在的Erlang环境，我们不比太关心它。</li>
<li>argc 当从Erlang调用NIF的时候，传递给它的参数个数。后面我们将详述。</li>
<li>argv 传递给NIF的参数的数组。</li>
</ul>
<h2 id="读取Erlang-Elixir类型的值为C类型的值"><a href="#读取Erlang-Elixir类型的值为C类型的值" class="headerlink" title="读取Erlang/Elixir类型的值为C类型的值"></a>读取Erlang/Elixir类型的值为C类型的值</h2><p>我们从Elixir调用 fast_compare ，如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fast_compare(<span class="number">99</span>, <span class="number">100</span>)</div><div class="line"><span class="comment">#=&gt; -1</span></div></pre></td></tr></table></figure>
<p>当执行 fast_compare ，argc为2，argv 是 99 和 100 组成的数组。然而，这些参数的类型是 ERL_NIF_TERM ，因此我们必须将它们“转换”为C的数据类型才能操作它们。erl_nif.h 提供了函数将Erlang的数据类型转换为C的数据类型。在本例子里，我们需要用enif_get_int这个函数。enif_get_int的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">enif_get_int</span><span class="params">(ErlNifEnv *env, ERL_NIF_TERM term, <span class="keyword">int</span> *ip)</span></span>;</div></pre></td></tr></table></figure>
<p>我们必须传入变量 env，我们需要转换的Erlang数据（从argv中取出的），以及转换得到的值所存储的地址。</p>
<h2 id="将C类型的值转换为Erlang类型的值"><a href="#将C类型的值转换为Erlang类型的值" class="headerlink" title="将C类型的值转换为Erlang类型的值"></a>将C类型的值转换为Erlang类型的值</h2><p>erl_nif.h 提供了几个 enif_make_* 类似的函数来将C类型的值转换为Erlang类型的值。它们都有相似的签名（只是根据被转换的数据类型不同而有差别），并且它们都返回 ERL_NIF_TERM类型的值。在本例子中，我们需要 enif_make_int 函数，它的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">ERL_NIF_TERM <span class="title">enif_make_int</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> i)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="编写NIF"><a href="#编写NIF" class="headerlink" title="编写NIF"></a>编写NIF</h2><p>我们已经知道如何在Erlang类型数据和C类型数据之间进行转换，那么编写NIF就很直观了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  <span class="comment">// Fill a and b with the values of the first two args</span></div><div class="line">  enif_get_int(env, argv[<span class="number">0</span>], &amp;a);</div><div class="line">  enif_get_int(env, argv[<span class="number">1</span>], &amp;b);</div><div class="line"></div><div class="line">  <span class="comment">// Usual C unreadable code because this way is more true</span></div><div class="line">  <span class="keyword">int</span> result = a == b ? <span class="number">0</span> : (a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> enif_make_int(env, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="连接我们的C"><a href="#连接我们的C" class="headerlink" title="连接我们的C"></a>连接我们的C</h2><p>我们现在必须将我们写的函数导出到Erlang。我们必须使用ERL_NIF_INIT这个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERL_NIF_INIT(erl_module, functions, load, upgrade, unload, reload)</div></pre></td></tr></table></figure>
<ul>
<li>erl_module 是Erlang模块，我们导出的函数将被定义在里面。它不需要被双引号括起来，因为它将被ERL_NIF_INIT字符串化（例如，用my_module而不是用”my_module”）；</li>
<li>functions 是ErlNifFunc结构类型数据的数组，它定义哪些NIF被导出，以及对应的Erlang函数和它的参数个数；</li>
<li>load，upgrade，unload，reload是函数指针，它们指向那些NIF被装载卸载等操作的回调函数；我们现在不太关心这些回调函数，把它们全部设置为NULL。</li>
</ul>
<p>我们所需的所有元素都准备好了。完整的C文件如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  enif_get_int(env, argv[<span class="number">0</span>], &amp;a);</div><div class="line">  enif_get_int(env, argv[<span class="number">1</span>], &amp;b);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> result = a == b ? <span class="number">0</span> : (a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> enif_make_int(env, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Let's define the array of ErlNifFunc beforehand:</span></div><div class="line"><span class="keyword">static</span> ErlNifFunc nif_funcs[] = &#123;</div><div class="line">  <span class="comment">// &#123;erl_function_name, erl_function_arity, c_function&#125;</span></div><div class="line">  &#123;<span class="string">"fast_compare"</span>, <span class="number">2</span>, fast_compare&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ERL_NIF_INIT(Elixir.FastCompare, nif_funcs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</div></pre></td></tr></table></figure>
<p>要记得我们必须要在ERL_NIF_INIT宏里使用Elixir模块的全名的原子（是Elixir.FastCompare而不是FastCompare）。</p>
<h2 id="编译我们的C代码"><a href="#编译我们的C代码" class="headerlink" title="编译我们的C代码"></a>编译我们的C代码</h2><p>NIF文件应该编译为 .so 共享库。编译标志在不同的系统和编译器中有所不同，但它们应该看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cc <span class="_">-f</span>PIC -I$(ERL_INCLUDE_PATH) \</div><div class="line">     -dynamiclib -undefined dynamic_lookup \</div><div class="line">     -o fast_compare.so fast_compare.c</div></pre></td></tr></table></figure>
<p>使用这个命令，我们用一些为了生产动态代码的标志把 fast_compare.c 编译为 fast_compare.so （-o fast_compare.so）。注意我们如何把 $(ERL_INCLUDE_PATH) 包含在搜索路径里：这个路径包含了erl_nif.h 头文件。这个路径通常在Erlang的安装目录里，即 lib/erts-VERSION/include。</p>
<h2 id="在Elixir中装载NIF"><a href="#在Elixir中装载NIF" class="headerlink" title="在Elixir中装载NIF"></a>在Elixir中装载NIF</h2><p>剩下的事情是装载在Elixir模块 FastCompare 里定义的NIF。如Erlang中关于NIF的文档所建议，钩子 @on_load 是做这件事的最适合的地方。</p>
<p>请注意，对于我们要定义的每个NIF，我们也需要在加载模块中定义相应的Erlang / Elixir函数。 这可以被利用来在NIF不可用的情况下定义例如回退代码。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># fast_compare.ex</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">FastCompare</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@on_load</span> <span class="symbol">:load_nifs</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load_nifs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:erlang</span>.load_nif(<span class="string">'./fast_compare'</span>, <span class="number">0</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fast_compare</span></span>(_a, _b) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"NIF fast_compare/2 not implemented"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:erlang.load_nif/2 的第二个参数可以是任何东西，它会被传递给我们上面提到的load回调函数。 你可以看看<a href="http://www.erlang.org/doc/man/erlang.html#load_nif-2" target="_blank" rel="external">erlang.load_nif/2</a>的文档以获取更多信息。</p>
<p>搞定！我们可以在IEx里测试一下我们的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; c <span class="string">"fast_compare.ex"</span></div><div class="line">iex&gt; FastCompare.fast_compare(<span class="number">99</span>, <span class="number">100</span>)</div><div class="line">-<span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>写“纯”的NIF（没有副作用，只是转换）非常有用。我非常喜欢的一个例子是 <a href="https://github.com/devinus/markdown" target="_blank" rel="external">devinus/markdown</a> 这个Elixir库：这个库用NIF封装了一个C的markdown解析器。这个用例是完美的，因为将Markdown转换为HTML可能是一项昂贵的任务，而通过将该工作委托给C来做可以获得更好的性能。</p>
<h1 id="有用的东西：资源"><a href="#有用的东西：资源" class="headerlink" title="有用的东西：资源"></a>有用的东西：资源</h1><p>正如我上面提到的，NIF的一个非常有用的地方是包装已有的C库。然而，这些库常常提供它们自己的数据抽象和数据结构。例如，一个C的数据库驱动导出一个 db_conn_t 类型来表示一条数据库链接，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// fields</span></div><div class="line">&#125; <span class="keyword">db_conn_t</span>;</div></pre></td></tr></table></figure>
<p>相应的函数初始化链接、发起查询、释放链接，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">db_conn_t</span> *db_init_conn();</div><div class="line"><span class="function">db_type <span class="title">db_query</span><span class="params">(<span class="keyword">db_conn_t</span> *conn, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_free_conn</span><span class="params">(<span class="keyword">db_conn_t</span> *conn)</span></span>;</div></pre></td></tr></table></figure>
<p>如果我们能够在Erlang/Elixir里处理db_conn_t数据类型并且在NIF调用之间传递它们的话，这将非常有用。NIF的API有一个叫做 <strong>resources</strong> 的概念。没有比用Erlang的官方文档更好的方式来快速解释什么是 <strong>resources</strong> 。</p>
<blockquote>
<p><strong>资源对象的使用是一种从NIF返回指向原生数据结构的指针的安全方法。 资源对象只是一块内存。 […].</strong></p>
</blockquote>
<p>资源是内存块，我们可以构建并返回指向该内存的安全指针作为Erlang的类型数据。</p>
<p>让我们来探讨一下如何在NIF内部包装上面简单的API。 我们将从这个骨架C文件开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// fields here</span></div><div class="line">&#125; <span class="keyword">db_conn_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">db_conn_t</span> *db_init_conn();</div><div class="line"><span class="function">db_type <span class="title">db_query</span><span class="params">(<span class="keyword">db_conn_t</span> *conn, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_free_conn</span><span class="params">(<span class="keyword">db_conn_t</span> *conn)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="资源的创建"><a href="#资源的创建" class="headerlink" title="资源的创建"></a>资源的创建</h2><p>要创建一个资源，我们必须要使用 enif_alloc_resource 函数的帮助来分配一些内存。从这个函数的签名你可以看出它和 malloc 函数相似（原则上）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">enif_alloc_resource</span><span class="params">(ErlNifResourceType *res_type, <span class="keyword">unsigned</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>enif_alloc_resource 的第一个参数是一个资源类型（这只是我们用来区分不同类型资源的东西），第二个参数是需要分配的内存大小，返回值是已分配内存的指针。</p>
<h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>资源类型是用 enif_open_resource_type 函数来创建的。我们可以在我们的C文件里声明资源类型作为全局变量。同时，利用传递给 ERL_NIF_INIT的load回调函数的便利性来创建资源类型并且把它们赋值给全局变量。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ErlNifResourceType *DB_RES_TYPE;</div><div class="line"></div><div class="line"><span class="comment">// 每次当一个资源被释放的时候这个函数被调用</span></div><div class="line"><span class="comment">// 资源被释放在enif_release_resource函数被调用</span></div><div class="line"><span class="comment">// 以及Erlang回收内存的时候发生</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">db_res_destructor</span><span class="params">(ErlNifEnv *env, <span class="keyword">void</span> *res)</span> &#123;</div><div class="line">  db_free_conn((<span class="keyword">db_conn_t</span> *) res);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">load</span><span class="params">(ErlNifEnv *env, <span class="keyword">void</span> **priv_data, ERL_NIF_TERM load_info)</span> &#123;</div><div class="line">  <span class="keyword">int</span> flags = ERL_NIF_RT_CREATE | ERL_NIF_RT_TAKEOVER;</div><div class="line">  DB_RES_TYPE =</div><div class="line">    enif_open_resource_type(env, <span class="literal">NULL</span>, <span class="string">"db"</span>, db_res_destructor, flags, <span class="literal">NULL</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h3><p>我们现在可以包装db_init_conn并且创建我们的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">db_init_conn_nif</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="comment">// 让我们给一个 db_conn_t 指针分配内存</span></div><div class="line">  <span class="keyword">db_conn_t</span> **conn_res = enif_alloc_memory(DB_RES_TYPE, <span class="keyword">sizeof</span>(<span class="keyword">db_conn_t</span> *));</div><div class="line"></div><div class="line">  <span class="comment">// 让我们创建一条链接并且把它拷贝到指针所指的内存</span></div><div class="line">  <span class="keyword">db_conn_t</span> *conn = db_init_conn();</div><div class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *) conn_res, (<span class="keyword">void</span> *) &amp;conn, <span class="keyword">sizeof</span>(<span class="keyword">db_conn_t</span> *));</div><div class="line"></div><div class="line">  <span class="comment">// 我们现在可以让Erlang类型数据持有这个资源...</span></div><div class="line">  ERL_NIF_TERM term = enif_make_resource(env, conn_res);</div><div class="line">  <span class="comment">// ...然后释放这个资源以便在Erlang垃圾回收的时候它将被释放</span></div><div class="line">  enif_release_resource(conn_res);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> term;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><p>为了包装db_query，我们需要获取 db_init_conn_nif 返回的资源。为实现这个功能，我们需要使用 enif_get_resource 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">db_query_nif</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">db_conn_t</span> **conn_res;</div><div class="line">  enif_get_resource(env, argv[<span class="number">0</span>], DB_RES_TYPE, (<span class="keyword">void</span> *) conn_res);</div><div class="line"></div><div class="line">  <span class="keyword">db_conn_t</span> *conn = *conn_res;</div><div class="line"></div><div class="line">  <span class="comment">// 我们现在可以运行我们的查询</span></div><div class="line">  db_query(conn, ...);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> argv[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在Elixir里使用资源"><a href="#在Elixir里使用资源" class="headerlink" title="在Elixir里使用资源"></a>在Elixir里使用资源</h3><p>让我们跳过在DB模块里导出我们创建的NIF，直接跳到IEx shell环节，而且假设C代码已经编译并被DB模块装载进虚拟机了。正如我前面所述，当资源返回给Erlang/Elixir的时候完全是一个不透明的数据。它们表现得就像是空的的二进制数据。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; conn_res = DB.db_conn_init()</div><div class="line"><span class="string">""</span></div><div class="line">iex&gt; DB.db_query(conn_res, ...)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>因为资源是不透明的数据，除了将它们回传给其他NIF，你无法在Erlang/Elixir里对它进行任何有意义的处理。它们的行为和看起来像二进制数据，这甚至可以导致问题，因为他们可以被误认为二进制数据。基于这个缘故，我建议将资源包装到结构当中。这样我们可以限制我们的公共API仅能处理结构并且在内部处理资源。我们也可以通过实现结构的 Inspect 协议来获得好处，这种方式使得我们可以安全地检测资源，而隐藏了它们看起来像是二进制数据的事实。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">DBConn</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:resource</span>]</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">defimpl</span> <span class="title">Inspect</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="用Mix编译"><a href="#用Mix编译" class="headerlink" title="用Mix编译"></a>用Mix编译</h1><p>Mix提供了一个特性，叫做<a href="http://elixir-lang.org/docs/stable/mix/Mix.html#compilers/0" target="_blank" rel="external">Mix 编译器</a>。每一个Mix项目在编译的时候可以指定一个编译器列表来运行。新的Mix编译器是自动编译C源代码的完美场所。对于本节的范围，假设我们正在构建一个叫做 :my_nifs 的Elixir应用程序，该应用程序将使用my_nifs.c C源文件中的NIF。</p>
<p>首先我们创建 Makefile 来编译C源码（反正我们可能会这么做）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ERL_INCLUDE_PATH=$(...)</div><div class="line"></div><div class="line">all: priv/my_nifs.so</div><div class="line"></div><div class="line">priv/my_nifs.so: my_nifs.c</div><div class="line">  cc <span class="_">-f</span>PIC -I$(ERL_INCLUDE_PATH) -dynamiclib -undefined dynamic_lookup -o my_nifs.so my_nifs.c</div></pre></td></tr></table></figure>
<p>这个 Makefile 文件假设 my_nifs.c 存储在我们的Mix项目的根目录。我们将把 .so 共享库存放在我们应用的 priv 目录中，以便在发布的时候它是可用的。现在，无论何时，只要我们修改了 my_nifs.c ，然后运行 make ，priv/my_nifs.so 都会被重新编译。</p>
<p>我们现在可以挂接一个只调用make的新的Mix编译器。在 mix.exs 中，我们来实现之：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Mix</span></span>.Tasks.Compile.MyNifs <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(_args) <span class="keyword">do</span></div><div class="line">    &#123;result, _errcode&#125; = System.cmd(<span class="string">"make"</span>, [], <span class="symbol">stdout_to_stderr:</span> <span class="keyword">true</span>)</div><div class="line">    IO.binwrite(result)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们调用 IO.binwrite/1 来将 make 的运行结果输出到终端。在一个真实的场景里，我们肯定要检查 make 的结果，同时也要确认 cc 和 make 已经安装到系统里，并且其路径可用；不过在这里，我们简单地忽略了这些步骤。</p>
<p>我们现在需要将 :my_nifs 编译器添加到 :my_nifs 应用的编译器列表。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in mix.exs</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyNifs</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:my_nifs</span>,</div><div class="line">     <span class="symbol">compilers:</span> [<span class="symbol">:my_nifs</span>] ++ Mix.compilers,</div><div class="line">     ...]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，任何时候我们运行 $ mix compiler ，我们的C代码就被自动重新编译（如果需要）。当其他库把 :my_nifs 作为依赖的话，这个过程也会一样地执行，因为现在运行 make 是 :my_nifs 项目编译的一个过程。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这是一个很长的帖子，但我希望我覆盖了NIF的大部分内容。如你所见，在Erlang/Elixir里使用NIF是相当方便的。正如本文开头提到的那样，由于NIF的脆弱性（记住NIF可能导致整个Erlang虚拟机崩溃）和速度要求，因此要谨慎使用NIF，而且它并不总是正确的工具。</p>
<p>感谢您的阅读！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/" target="_blank" rel="external">http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang支持一种方式，就是用C来实现函数，并在Erlang中透明地使用它们。这些函数被叫做NIFs（原生实现的函数）。在两种场景下，NIF被证明是完美的解决方案：当你需要原始的计算速度时；当你需要从Erlang调用已有的C接口时。在本文中，我们一起来看看这两种场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/categories/Elixir/NIF/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/tags/NIF/"/>
    
      <category term="C" scheme="http://szpzs.oschina.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用“with”宏更好地控制执行流程</title>
    <link href="http://szpzs.oschina.io/2018/04/02/better-control-flow-using-the-with-macro/"/>
    <id>http://szpzs.oschina.io/2018/04/02/better-control-flow-using-the-with-macro/</id>
    <published>2018-04-02T05:46:11.000Z</published>
    <updated>2018-04-02T05:59:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>从Elixir1.2开始就可以用with宏来写出更有表现力的流程控制语句。与需要深度嵌套的 case 和 if/else 语句不同，你可以只使用一个 with 语句来表达一样的逻辑，而且方式上更加优雅可读性也更好。下面我将探索如何利用它们来改进你的代码。</p>
<h1 id="with-的基础"><a href="#with-的基础" class="headerlink" title="with 的基础"></a>with 的基础</h1><p>with 后跟一个句子列表，这些句子将按顺序执行。如果所有句子的结果都是正常，那么 do 后面的语句将被执行。当其中一个句子的结果有问题，则 do 后面的句子就不执行，而且相关错误值将返回给调用者。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"10"</span>) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">100</span></div><div class="line"></div><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"foo"</span>) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="symbol">:error</span></div><div class="line"></div><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>你也可以在那些句子中使用when子句。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; <span class="keyword">when</span> int != <span class="number">0</span> &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;   <span class="number">99</span> / int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">11.0</span></div></pre></td></tr></table></figure>
<p>另外，你可以使用else来捕获相关可能的异常。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="symbol">:error</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_an_int</span>&#125; <span class="comment"># error for bad parsing</span></div><div class="line">...&gt;   <span class="keyword">false</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_even</span>&#125; <span class="comment"># error for odd number</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:not_even</span>&#125;</div></pre></td></tr></table></figure>
<p>或者，你可以忽略所有错误值，只返回一个统一的错误。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="number">_</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:invalid_value</span>&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:invalid_value</span>&#125;</div></pre></td></tr></table></figure>
<p>你甚至可以在这些句子中赋值。不过要小心，如果你进行了错误的赋值，可能会得到 MatchError 错误。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      squared = int * int,</div><div class="line">...&gt;      <span class="keyword">false</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   squared + <span class="number">1</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">82</span></div><div class="line"></div><div class="line">iex&gt; with <span class="number">1</span> = <span class="string">"1"</span>, <span class="symbol">do:</span> <span class="symbol">:ok</span></div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"1"</span></div></pre></td></tr></table></figure>
<p>with的语法请看官方的<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">详细文档</a>。</p>
<h1 id="一个实际的例子"><a href="#一个实际的例子" class="headerlink" title="一个实际的例子"></a>一个实际的例子</h1><p>让我们来看看一个的例子。你可能遇到这样的情况，你需要在一个控制器里修改一个已经存在的记录并且发送一些通知消息出去。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> Documents.get(params[<span class="string">"id"</span>]) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, document&#125; -&gt;</div><div class="line">      <span class="keyword">case</span> Documents.update(document, params) <span class="keyword">do</span></div><div class="line">        &#123;<span class="symbol">:ok</span>, document&#125; -&gt;</div><div class="line">          Notifications.push_document_updated(document)</div><div class="line">          json(conn, document)</div><div class="line"></div><div class="line">        &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">          render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们很明显地看到我们用嵌套case语句来获得我们需要的执行路径。我们用 with 来重写的话，将会使代码简洁明了得多。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  with &#123;<span class="symbol">:ok</span>, document&#125; &lt;- Documents.get(params[<span class="string">"id"</span>]),</div><div class="line">       &#123;<span class="symbol">:ok</span>, updated_document&#125; &lt;- Documents.update(document, params) <span class="keyword">do</span></div><div class="line">    Notifications.push_document_updated(updated_document)</div><div class="line">    json(conn, document)</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>通过用 with 来重写代码，我们可以很清晰地看到我们期望的执行路径以及捕获的具体错误是什么。</p>
<h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>通常，你会发现自己需要在具有相似错误值的数据中进行匹配，这样会使得处理错误情况更加复杂。我喜欢用的一个小技巧是，使用像 {:my_atom, “expected_value”} 这样的有唯一标识的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  user = conn.assigns.user</div><div class="line">  with &#123;<span class="symbol">:ok</span>, document&#125; &lt;- Document.get(params[<span class="string">"id"</span>]),</div><div class="line">       &#123;<span class="symbol">:can_view?</span>, <span class="keyword">true</span>&#125; &lt;- &#123;<span class="symbol">:can_view?</span>, Authorizer.can_view?(document, user)&#125;,</div><div class="line">       &#123;<span class="symbol">:can_edit?</span>, <span class="keyword">true</span>&#125; &lt;- &#123;<span class="symbol">:can_edit?</span>, Authorizer.can_edit?(document, user)&#125;</div><div class="line">       &#123;<span class="symbol">:ok</span>, updated_document&#125; &lt;- Documents.update(document, params) <span class="keyword">do</span></div><div class="line">    Notifications.push_document_updated(updated_document)</div><div class="line">    json(conn, document)</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:can_view?</span>, <span class="keyword">false</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:can_edit?</span>, <span class="keyword">false</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"403"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>增加一个唯一原子使得更易于标识特定的错误然后返回适当的结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>with 帮助我们在不牺牲错误处理功能和可读性上写出更加整洁，更富表达性的代码。任何时候，当你需要处理复杂的逻辑流程的时候，都记得使用这个宏的优点。最后别忘了仔细阅读<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">官方关于 with 的文档</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://dockyard.com/blog/2018/03/30/better-control-flow-using-the-with-macro" target="_blank" rel="external">https://dockyard.com/blog/2018/03/30/better-control-flow-using-the-with-macro</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从Elixir1.2开始就可以用with宏来写出更有表现力的流程控制语句。与需要深度嵌套的 case 和 if/else 语句不同，你可以只使用一个 with 语句来表达一样的逻辑，而且方式上更加优雅可读性也更好。下面我将探索如何利用它们来改进你的代码。&lt;/p&gt;
&lt;h1 id=&quot;with-的基础&quot;&gt;&lt;a href=&quot;#with-的基础&quot; class=&quot;headerlink&quot; title=&quot;with 的基础&quot;&gt;&lt;/a&gt;with 的基础&lt;/h1&gt;&lt;p&gt;with 后跟一个句子列表，这些句子将按顺序执行。如果所有句子的结果都是正常，那么 do 后面的语句将被执行。当其中一个句子的结果有问题，则 do 后面的句子就不执行，而且相关错误值将返回给调用者。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; with &amp;#123;int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;&amp;#125; &amp;lt;- Integer.parse(&lt;span class=&quot;string&quot;&gt;&quot;10&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; with &amp;#123;int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;&amp;#125; &amp;lt;- Integer.parse(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;:error&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; with &amp;#123;int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;&amp;#125; &amp;lt;- Integer.parse(&lt;span class=&quot;string&quot;&gt;&quot;9&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;      &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; &amp;lt;- Integer.is_even(int) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/categories/Elixir/macro/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="with" scheme="http://szpzs.oschina.io/tags/with/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的宏</title>
    <link href="http://szpzs.oschina.io/2018/03/29/erlang-macro/"/>
    <id>http://szpzs.oschina.io/2018/03/29/erlang-macro/</id>
    <published>2018-03-29T01:57:49.000Z</published>
    <updated>2018-03-29T02:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang的宏的定义语法如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(Const, Replacement)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(Func(Var1,...,VarN)</span>, Replacement).</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>宏定义可以放在模块的属性和函数声明之间的任何地方，但是，宏使用前必须被定义。如果一个宏被几个模块使用，则建议将该宏的定义放置在一个包含文件里。</p>
<p>宏的使用语法如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?Const</div><div class="line">?Func(Arg1,...,ArgN)</div></pre></td></tr></table></figure>
<p>宏在编译期间被展开替换，如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(TIMEOUT, <span class="number">200</span>)</span>.</div><div class="line">...</div><div class="line"><span class="function"><span class="title">call</span><span class="params">(Request)</span> -&gt;</span></div><div class="line">    server:call(refserver, Request, ?TIMEOUT).</div></pre></td></tr></table></figure>
<p>编译期间被替换为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">call</span><span class="params">(Request)</span> -&gt;</span></div><div class="line">    server:call(refserver, Request, <span class="number">200</span>).</div></pre></td></tr></table></figure>
<p>有参数的宏在编译期间，其参数被实参替换，代码如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(MACRO1(X, Y)</span>, &#123;a, X, b, Y&#125;).</div><div class="line">...</div><div class="line"><span class="function"><span class="title">bar</span><span class="params">(X)</span> -&gt;</span></div><div class="line">    ?MACRO1(a, b),</div><div class="line">    ?MACRO1(X, <span class="number">123</span>)</div></pre></td></tr></table></figure>
<p>编译期间被替换为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">bar</span><span class="params">(X)</span> -&gt;</span></div><div class="line">    &#123;a,a,b,b&#125;,</div><div class="line">    &#123;a,X,b,<span class="number">123</span>&#125;.</div></pre></td></tr></table></figure>
<p>如果想看宏展开的效果，可以在编译模块的时候使用 ‘P’ 选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile:file(File, \['P'\]).</div></pre></td></tr></table></figure>
<p>这将产生宏展开后的文件：File.P 。</p>
<p>Erlang预定义了一些宏：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">?MODULE  <span class="comment">%%当前模块的名字</span></div><div class="line"></div><div class="line">?MODULE_STRING  <span class="comment">%%当前模块的名字的字符串</span></div><div class="line"></div><div class="line">?FILE  <span class="comment">%%当前模块的文件名</span></div><div class="line"></div><div class="line">?LINE  <span class="comment">%%当前行号</span></div><div class="line"></div><div class="line">?MACHINE  <span class="comment">%%虚拟机的名字，固定为'BEAM'</span></div></pre></td></tr></table></figure>
<p>除了预定义宏之外，宏是可以重载的。重载宏有多个定义，每个定义具有不同数量的参数。参数化宏在使用的时候，即使没有型参，也要加上括号。如果有型参数，则实参个数必须与型参一致。</p>
<p>宏可以应用于条件编译。如下指令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-undef</span><span class="params">(Macro)</span>. <span class="comment">%%取消宏Macro的定义。</span></div><div class="line"></div><div class="line"><span class="keyword">-ifdef</span><span class="params">(Macro)</span>. <span class="comment">%%如果宏Macro定义了，则编译其下面的语句。</span></div><div class="line"></div><div class="line"><span class="keyword">-ifndef</span><span class="params">(Macro)</span>. <span class="comment">%%如果宏Macro没有定义了，则编译其下面的语句。</span></div><div class="line"></div><div class="line"><span class="keyword">-else</span>. <span class="comment">%%这个指令只允许出现在 ifdef 或 ifndef 的后面。仅当它前面的ifdef 或 ifndef 为false时，它下面的语句才被编译。</span></div><div class="line"></div><div class="line"><span class="keyword">-endif</span>. <span class="comment">%%指示指令 ifdef  或  ifndef  的结束。</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong>上述指令不能出现在函数当中。</p>
<p>例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(m)</span>.</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">-ifdef</span><span class="params">(debug)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(LOG(X)</span>, io:format<span class="params">(<span class="string">"&#123;~p,~p&#125;: ~p~n"</span>, \[?MODULE,?LINE,X\])</span>).</div><div class="line"><span class="keyword">-else</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(LOG(X)</span>, true).</div><div class="line"><span class="keyword">-endif</span>.</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>如果想要LOG(X)宏真正输出内容，则在编译的时候要加上 debug 宏：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% erlc -Ddebug m.erl</span></div></pre></td></tr></table></figure>
<p>或<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(m, &#123;d, debug&#125;).</div><div class="line">&#123;ok,m&#125;</div></pre></td></tr></table></figure></p>
<p>这样?LOG(Arg)就会展开为对 io:format/2 的调用。</p>
<p>如果Arg是宏的参数，那么??Arg将展开为包含这个参数的字符串。这个和C语言中宏参数字符串化类似：#arg</p>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-define</span><span class="params">(TESTCALL(Call)</span>, io:format<span class="params">(<span class="string">"Call ~s: ~w~n"</span>, \[??Call, Call\])</span>).</div><div class="line"></div><div class="line">?TESTCALL(myfunction(<span class="number">1</span>,<span class="number">2</span>)),</div><div class="line">?TESTCALL(you:function(<span class="number">2</span>,<span class="number">1</span>)).</div></pre></td></tr></table></figure>
<p>它的结果是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io:format(<span class="string">"Call ~s: ~w~n"</span>,\[<span class="string">"myfunction ( 1 , 2 )"</span>,myfunction(<span class="number">1</span>,<span class="number">2</span>)\]),</div><div class="line">io:format(<span class="string">"Call ~s: ~w~n"</span>,\[<span class="string">"you : function ( 2 , 1 )"</span>,you:function(<span class="number">2</span>,<span class="number">1</span>)\]).</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang的宏的定义语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;-define&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Const, Replacement)&lt;/span&gt;.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;-define&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Func(Var1,...,VarN)&lt;/span&gt;, Replacement).&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/categories/Erlang/macro/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Erlang里的文件包含</title>
    <link href="http://szpzs.oschina.io/2018/03/26/erlang-file-inclusion/"/>
    <id>http://szpzs.oschina.io/2018/03/26/erlang-file-inclusion/</id>
    <published>2018-03-26T06:19:38.000Z</published>
    <updated>2018-03-26T06:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang中包含文件的语法有两个：</p>
<ul>
<li>-include(File).</li>
<li>-include_lib(File).</li>
</ul>
<p>它们其实是预编译指令。其中File是一个字符串，表示被包含文件的文件名相对路径或绝对路径。</p>
<p>在Erlang中，一般需要被公用的记录和宏定义都放在被包含文件里，文件名后缀名为.hrl。</p>
<p>File可以使用操作系统的环境变量作为路径开头部分。比如：<br>-include(“\$PROJ_ROOT/my_records.hrl”).<br>Erlang将使用os:getenv(PROJ_ROOT)来获得操作系统的环境变量PROJ_ROOT的值，并替换”\$PROJ_ROOT/my_records.hrl”中的\$PROJ_ROOT。</p>
<p>如果File是绝对路径，则Erlang就按绝对路径来查找文件。如果File不是绝对路径，则Erlang按如下顺序来查找文件：</p>
<ul>
<li>当前工作目录</li>
<li>编译后的模块所在目录</li>
<li>通过include选项给出的目录</li>
</ul>
<p>include_lib不指定绝对路径。路径的第一部分被Erlang虚拟机认为是一个应用的名字。例如：</p>
<p>-include_lib(“kernel/include/file.hrl”).</p>
<p>Erlang使用code:lib_dir(kernel)来获得kernel应用的绝对路径，然后替换”kernel/include/file.hrl”里的kernel，最后得到绝对路径。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang中包含文件的语法有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-include(File).&lt;/li&gt;
&lt;li&gt;-include_lib(File).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们其实是预编译指令。其中File是一个字符串，表示被包含文件的文件名相对路径或绝对路径。&lt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Preprocessor" scheme="http://szpzs.oschina.io/categories/Erlang/Preprocessor/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="include" scheme="http://szpzs.oschina.io/tags/include/"/>
    
      <category term="include_lib" scheme="http://szpzs.oschina.io/tags/include-lib/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的调度器如何绑定到CPU</title>
    <link href="http://szpzs.oschina.io/2018/03/23/erlang-scheduler-binding-cpu/"/>
    <id>http://szpzs.oschina.io/2018/03/23/erlang-scheduler-binding-cpu/</id>
    <published>2018-03-23T05:37:31.000Z</published>
    <updated>2018-04-01T10:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调度器绑定CPU"><a href="#调度器绑定CPU" class="headerlink" title="调度器绑定CPU"></a>调度器绑定CPU</h2><p>在启动Erlang虚拟机的时候可以通过参数来设置它的调度器以什么方式绑定CPU。这个参数是 +sbt，也可以用另一个参数 +stbt。它们的使用方法是：</p>
<p>+sbt 绑定类型</p>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl +sbt db</div></pre></td></tr></table></figure>
<p>这两个参数的差异表现在对如下错误的处理方式上：</p>
<ul>
<li>某些不支持绑定CPU功能的平台上尝试绑定调度器到CPU</li>
<li>没有可用的CPU拓扑。运行时系统无法自动侦测到CPU拓扑，并且我们也没有设置自定义的CPU拓扑。</li>
</ul>
<p>当发生上述两种情况的时候，如果使用的是 +sbt 参数，则运行时系统会打印错误消息并拒绝启动；而如果使用的是 +stbt 参数，则运行时系统会忽略错误，并且用调度器不绑定CPU的方式启动。</p>
<a id="more"></a>
<p>当前有效的绑定类型如下：<br>u、ns、ts、ps、s、nnts、nnps、tnnps、db。</p>
<p>下面对上述有效类型进行说明。我的机器CPU信息如下：</p>
<p>有两个NUMA节点，每个节点有一个物理处理器，两个物理处理器为：p1和p2，每个物理处理器有4个核，每个核有两个线程。p1上的线程标识符为：第一个核{0,8}，第二个核{1,9}，第三个核{2,10}，第四个核{3,11}；p2上的线程标识符为：第一个核{4,12}，第二个核{5,13}，第三个核{6,14}，第四个核{7,15}。</p>
<p>u：是 unbound 的首字母。调度器不绑定在某个CPU线程上，而是由操作系统决定调度器在那个CPU线程上执行以及什么时候迁移到别的cpu线程上。这是Erlang虚拟机的默认行为。</p>
<p>ns：代表 no_spread。标识符相近的调度器尽可能地绑定在相近的CPU线程上。调度器绑定到cpu线程的顺序是：{0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15}。</p>
<p>ts：代表 thread_spread。低标识符的调度器先绑定所有CPU核的第一个线程，然后再绑定所有CPU核的第二个线程，以此类推。调度器绑定到cpu线程的顺序是：{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}。</p>
<p>ps：代表 processor_spread。和ts方式一样，只是会跨物理处理器核间隔地绑定。调度器绑定到cpu线程的顺序是：{0,4,1,5,2,6,3,7,8,12,9,13,10,14,11,15}。</p>
<p>s：代表 spread。调度器尽可能地绑定到cpu线程上。与ns方式相似。调度器绑定到cpu线程的顺序是：{0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15}。</p>
<p>nnts：代表 no_node_thread_spread。与thread_spread方式相似。但是，如果有多个NUMA节点存在，则调度器会先把一个NUMA节点内的cpu线程全部绑定完，然后再去绑定下一个NUMA节点内的cpu线程。调度器绑定到cpu线程的顺序是：{0,1,2,3,8,9,10,11,4,5,6,7,12,13,14,15}。</p>
<p>nnps：代表 no_node_processor_spread。与processor_spread方式相似。但是，如果有多个NUMA节点存在，则调度器会先把一个NUMA节点内的cpu线程全部绑定完，然后再去绑定下一个NUMA节点内的cpu线程。调度器绑定到cpu线程的顺序是：{0,1,2,3,8,9,10,11,4,5,6,7,12,13,14,15}。</p>
<p>tnnps：代表 thread_no_node_processor_spread。是thread_spread和no_node_processor_spread方式的组合。调度器将在NUMA节点间顺序绑定cpu线程，但是会先在一个NUMA节点内的cpu核的同类线程都绑定完了再到下一个NUMA节点。调度器绑定到cpu线程的顺序是：{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}。</p>
<p>db：代表 default_bind。是调度器绑定cpu的默认方式。目前就是thread_no_node_processor_spread方式。将来可能会改变为别的方式。调度器绑定到cpu线程的顺序是：{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}。</p>
<h2 id="自定义CPU拓扑"><a href="#自定义CPU拓扑" class="headerlink" title="自定义CPU拓扑"></a>自定义CPU拓扑</h2><p>自定义CPU拓扑会覆盖任何自动监测到的CPU拓扑。将调度器绑定到逻辑处理器时会使用自定义的CPU拓扑。</p>
<p>自定义CPU拓扑的格式定义：</p>
<ul>
<li>&lt;Id&gt; = integer(); when 0 =&lt; &lt;Id&gt; =&lt; 65535</li>
<li>&lt;IdRange&gt; = &lt;Id&gt;-&lt;Id&gt;</li>
<li>&lt;IdOrIdRange&gt; = &lt;Id&gt; | &lt;IdRange&gt;</li>
<li>&lt;IdList&gt; = &lt;IdOrIdRange&gt;,&lt;IdOrIdRange&gt; | &lt;IdOrIdRange&gt;</li>
<li>&lt;LogicalIds&gt; = L&lt;IdList&gt;</li>
<li>&lt;ThreadIds&gt; = T&lt;IdList&gt; | t&lt;IdList&gt;</li>
<li>&lt;CoreIds&gt; = C&lt;IdList&gt; | c&lt;IdList&gt;</li>
<li>&lt;ProcessorIds&gt; = P&lt;IdList&gt; | p&lt;IdList&gt;</li>
<li>&lt;NodeIds&gt; = N&lt;IdList&gt; | n&lt;IdList&gt;</li>
<li>&lt;IdDefs&gt; = &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt; | &lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;<ul>
<li>&lt;LogicalIds&gt;必须是一个标识符列表。</li>
<li>除&lt;LogicalIds&gt;之外至少还有一个其他的标识符类型也必须有一个标识符列表。</li>
<li>所有标识符列表必须产生相同数量的标识符。</li>
</ul>
</li>
<li>CpuTopology = &lt;IdDefs&gt;:&lt;IdDefs&gt; | &lt;IdDefs&gt;</li>
<li>&lt;IdRange&gt;可以递增也可以递减</li>
</ul>
<p>大写字母表示真实标识符，小写字母表示仅用于描述拓扑的伪标识符。作为实际标识符传递的标识符可能被运行时系统用于访问特定硬件，如果它们不正确，行为是未定义的。由于在没有真实的逻辑CPU标识符的情况下定义CPU拓扑没有意义，所以不接受假的逻辑CPU标识符。线程，核心，处理器和节点标识符可以省略。如果省略，线程ID默认为t0，核心ID默认为c0，处理器ID默认为p0，节点ID将为未定义。每个逻辑处理器必须属于一个且只有一个NUMA节点，或者没有逻辑处理器必须属于任何NUMA节点。NUMA节点标识符是系统范围的。 也就是说，系统上的每个NUMA节点都必须具有唯一的标识符。处理器标识符也是系统范围的。 核心标识符是处理器范围的。 线程标识符是核心范围。标识符类型的顺序意味着CPU拓扑的层次结构。</p>
<p>标识符类型的顺序：</p>
<ul>
<li>&lt;LogicalId&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt;</li>
<li>&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</li>
</ul>
<p>只要每个逻辑处理器属于一个且只有一个NUMA节点，则CPU拓扑可由NUMA节点外部处理器和NUMA节点内部处理器一起组成。</p>
<h2 id="linux-的CPU信息查询和NUMA工具"><a href="#linux-的CPU信息查询和NUMA工具" class="headerlink" title="linux 的CPU信息查询和NUMA工具"></a>linux 的CPU信息查询和NUMA工具</h2><ul>
<li>lscpu<ul>
<li>显示CPU架构信息</li>
</ul>
</li>
<li>mpstat -P ALL<ul>
<li>显示各个CPU负载情况</li>
</ul>
</li>
<li>numactl –hardware<ul>
<li>显示各个NUMA节点的内存以及distance情况</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;调度器绑定CPU&quot;&gt;&lt;a href=&quot;#调度器绑定CPU&quot; class=&quot;headerlink&quot; title=&quot;调度器绑定CPU&quot;&gt;&lt;/a&gt;调度器绑定CPU&lt;/h2&gt;&lt;p&gt;在启动Erlang虚拟机的时候可以通过参数来设置它的调度器以什么方式绑定CPU。这个参数是 +sbt，也可以用另一个参数 +stbt。它们的使用方法是：&lt;/p&gt;
&lt;p&gt;+sbt 绑定类型&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;erl +sbt db&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两个参数的差异表现在对如下错误的处理方式上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某些不支持绑定CPU功能的平台上尝试绑定调度器到CPU&lt;/li&gt;
&lt;li&gt;没有可用的CPU拓扑。运行时系统无法自动侦测到CPU拓扑，并且我们也没有设置自定义的CPU拓扑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发生上述两种情况的时候，如果使用的是 +sbt 参数，则运行时系统会打印错误消息并拒绝启动；而如果使用的是 +stbt 参数，则运行时系统会忽略错误，并且用调度器不绑定CPU的方式启动。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="scheduler" scheme="http://szpzs.oschina.io/categories/Erlang/scheduler/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="sbt" scheme="http://szpzs.oschina.io/tags/sbt/"/>
    
      <category term="cpu" scheme="http://szpzs.oschina.io/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>勉励自己</title>
    <link href="http://szpzs.oschina.io/2017/12/31/2018-encourage-myself/"/>
    <id>http://szpzs.oschina.io/2017/12/31/2018-encourage-myself/</id>
    <published>2017-12-31T09:37:52.000Z</published>
    <updated>2017-12-31T09:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/encourage-myself.jpg" style="border:0;"></p>
<h1 align="center">世界上任何书籍都不能带给你好运，</h1><br><h1 align="center">但是它们能让你悄悄成为你自己。</h1><br><h1 align="center">我继续和时间做朋友。</h1>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/encourage-myself.jpg&quot; style=&quot;border:0;&quot;&gt;&lt;/p&gt;
&lt;h1 align=&quot;center&quot;&gt;世界上任何书籍都不能带给你好运，&lt;/h1&gt;&lt;br&gt;&lt;h1 align=&quot;center&quot;&gt;但是它们能让你悄悄成为
    
    </summary>
    
    
      <category term="Time" scheme="http://szpzs.oschina.io/tags/Time/"/>
    
      <category term="时间" scheme="http://szpzs.oschina.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="2018" scheme="http://szpzs.oschina.io/tags/2018/"/>
    
      <category term="勉励" scheme="http://szpzs.oschina.io/tags/%E5%8B%89%E5%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>简说MQTT--第三部分：会话、服务质量和保留消息</title>
    <link href="http://szpzs.oschina.io/2017/12/22/mqtt-in-a-nutshell-3/"/>
    <id>http://szpzs.oschina.io/2017/12/22/mqtt-in-a-nutshell-3/</id>
    <published>2017-12-22T06:28:00.000Z</published>
    <updated>2017-12-22T06:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，我们希望MQTT代理会在客户端断开连接时存储客户端的订阅和队列消息，并在客户端稍后重新联机的时候将这些消息传递给它。在MQTT的世界中，存在保留消息，QoS级别和清除会话等技术，这些都对客户端存储消息有所影响。 我们将在这篇短文中讨论它们。</p>
<a id="more"></a>
<h1 id="清除会话"><a href="#清除会话" class="headerlink" title="清除会话"></a>清除会话</h1><p>您可以选择通过指定CONNECT数据包中的“clean_session”标志来告诉代理是否应该在连接时为您存储会话信息。</p>
<p>如果一条客户端链接仅仅是发布消息，它不会关心代理是否记得它。但是，如果客户端连接到代理是为了订阅消息，则通过将CONNECT数据包中的“clean_session”位设置为0来使连接“持久化”，这样是便利的或必要的。如果这么设置的话，这个客户端的订阅信息和未传送给它的消息将被代理存储下来。</p>
<p>要将clean_session设置为false，必须使用客户端ID。</p>
<p>当处于连接状态的时候，想修改“clean_session”设置是不可能的。要想修改它，你需要用新的设置来重连代理。</p>
<h1 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h1><p>不是所有“持久化”的连接上的消息都将被存储。QoS级别也会对其产生影响。</p>
<p>MQTT协议只保证具有QoS 1或QoS 2级别的消息确实传送给订阅者。对于那些QoS 0级别的消息，MQTT尝试发送它们一次，但是不保证一定送达。遵循这个原则，当用户断开连接时，即使这个连接是“持久化”的，也只有QoS 1和QoS 2级别的消息被存储。</p>
<p>值得注意的是，MQTT并不使用端到端的QoS，这意味着这些消息只有在用QoS != 0 发布并且用QoS != 0 订阅的情况下才被存储。</p>
<h1 id="保留消息"><a href="#保留消息" class="headerlink" title="保留消息"></a>保留消息</h1><p>如果您发布的MQTT消息的’retain’位设置为1，则它可以被保留在代理上，当订阅者连接到代理后，保留的消息会传递给它。</p>
<p>这是一个有用的特性，只有“保留”这个词有时令人困惑。它不保留相同主题的所有消息。 对于每个主题，只保留上次发布的消息，而较早的消息则由其后续消息替换掉。此外，’retain’标志设置为0的消息不会替换相同主题的保留消息，只有保留的消息替换保留的消息。</p>
<p>一个使用保留消息的场景：</p>
<p>一个传感器测量一个房间的温度并且每个小时将数据更新到系统中。如果温度数据用保留消息的方式发布到系统中，则无论什么时候，客户端连接到代理的时候只收到一份有用的数据，它不需要等待它不需要等待一段很长时间来等待新的数据发布，并且它也不会遭受大量无用而且过期数据的冲击。</p>
<blockquote>
<p>注意：保留的消息不属于任何会话。不管“clean_session”标志如何设置，保留消息都被保留。此外，它在会话结束时也被保留。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-2040b244aa4b" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-2040b244aa4b</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，我们希望MQTT代理会在客户端断开连接时存储客户端的订阅和队列消息，并在客户端稍后重新联机的时候将这些消息传递给它。在MQTT的世界中，存在保留消息，QoS级别和清除会话等技术，这些都对客户端存储消息有所影响。 我们将在这篇短文中讨论它们。&lt;/p&gt;
    
    </summary>
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>关于变量绑定的棘手问题</title>
    <link href="http://szpzs.oschina.io/2017/11/22/tricky-question/"/>
    <id>http://szpzs.oschina.io/2017/11/22/tricky-question/</id>
    <published>2017-11-22T08:41:00.000Z</published>
    <updated>2017-11-22T08:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我的工作中，我有个任务是为Erlang程序员应聘者设计一套选择题考卷，我决定包含一个关于变量绑定的棘手问题。在加入这个问题之前，我决定自己先尝试一下（你懂的……我这是为了预防万一）并且我发现了一些可能让你第一眼看到觉得很惊讶的事情，尽管这在事后是很明显的。</p>
<a id="more"></a>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>不用说，这个问题最后没有列入考试，所以不要指望从这篇文章中得到一个简单的答案。这个问题是：</p>
<blockquote>
<p>假设一开始没有任何变量被绑定，那么下面的表达式计算结束后，哪些变量被绑定了？</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A = <span class="number">1</span>,</div><div class="line">B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">      C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">      D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">    <span class="keyword">end</span>,</div><div class="line">A + B.</div></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<ol>
<li>没有</li>
<li>A 和 B</li>
<li>A、B、C 和 D</li>
<li>不可能确切地知道</li>
</ol>
</blockquote>
<p>请不要先往下阅读，而是停在这里！你自己先思考答案是什么？而且不能启动一个Erlang shell来测试这条表达式。切接不要偷看下面的内容！</p>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>让我们先剔除那些显而易见的选项。</p>
<p>答案不可能是选项1，因为我们在表达式里明确地绑定了一个变量。选项1唯一能被选上的条件是表达式发生错误。毫无疑问，这不可能发生。</p>
<p>选项3也不正确，因为代码执行路径有两个分支，其中一个不会绑定C变量，另一个不会绑定D变量。</p>
<p>在我看来，答案是选项2。我认为，C 和 D只是case表达式里的临时变量。</p>
<p>但是，情况并非如此。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; A = <span class="number">1</span>,</div><div class="line"><span class="number">1</span>&gt; B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line"><span class="number">1</span>&gt;       C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line"><span class="number">1</span>&gt;       D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line"><span class="number">1</span>&gt;     <span class="keyword">end</span>,</div><div class="line"><span class="number">1</span>&gt; A + B.</div><div class="line"><span class="number">1.063499807059608</span></div><div class="line"><span class="number">2</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.063499807059608</span></div><div class="line">C = <span class="number">0.063499807059608</span></div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; f().</div><div class="line">ok</div><div class="line"><span class="number">4</span>&gt; e(<span class="number">1</span>).</div><div class="line"><span class="number">1.3765011035828076</span></div><div class="line"><span class="number">5</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.37650110358280764</span></div><div class="line">C = <span class="number">0.37650110358280764</span></div><div class="line">ok</div><div class="line"><span class="number">6</span>&gt; f().</div><div class="line">ok</div><div class="line"><span class="number">7</span>&gt; e(<span class="number">1</span>).</div><div class="line"><span class="number">1.0869922372383418</span></div><div class="line"><span class="number">8</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.08699223723834182</span></div><div class="line">D = <span class="number">0.9130077627616582</span></div><div class="line">ok</div><div class="line"><span class="number">9</span>&gt;</div></pre></td></tr></table></figure>
<p>如你所见，有时候C被绑定，有时候却是D被绑定，这依赖于case语句所执行的分支，即使被执行的case语句分支的表达式不需要这些变量，也会发生这样的情况：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>&gt; <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line"><span class="number">10</span>&gt;   C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; low;</div><div class="line"><span class="number">10</span>&gt;   D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; high</div><div class="line"><span class="number">10</span>&gt; <span class="keyword">end</span>.</div><div class="line">low</div><div class="line"><span class="number">11</span>&gt; b().</div><div class="line">C = <span class="number">0.3006547812129776</span></div><div class="line">ok</div><div class="line"><span class="number">12</span>&gt; f(), e(<span class="number">10</span>), b().</div><div class="line">C = <span class="number">0.12584026085863464</span></div><div class="line">ok</div><div class="line"><span class="number">13</span>&gt; f(), e(<span class="number">10</span>), b().</div><div class="line">D = <span class="number">0.9295007071083405</span></div><div class="line">ok</div><div class="line"><span class="number">14</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="到底是为什么呢？"><a href="#到底是为什么呢？" class="headerlink" title="到底是为什么呢？"></a>到底是为什么呢？</h1><p>正如我之前说过的，这个问题可能令人惊讶，但事实上，它是非常明显的，而且有据可查。case语句分支的头部匹配变量是完全有效的，它可以像下面这样使用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">      C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; low;</div><div class="line">      C <span class="keyword">when</span> C &gt;= <span class="number">0.5</span> -&gt; high</div><div class="line">    <span class="keyword">end</span>,</div><div class="line">&#123;B, C&#125;.</div></pre></td></tr></table></figure>
<p>这是一种非常复杂的编码方式，我根本不推荐这样做，你甚至可以把它弄得更糟糕：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">  C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; B = low;</div><div class="line">  C <span class="keyword">when</span> C &gt;= <span class="number">0.5</span> -&gt; B = high</div><div class="line"><span class="keyword">end</span>,</div><div class="line">&#123;B, C&#125;.</div></pre></td></tr></table></figure>
<p>但是，除了代码的样式和可维护性问题之外，这段代码是完全有效的，这意味着在case表达式的被计算之后，在case子句中（包括在头部和身体中）被绑定的变量都是绑定的。我知道有更学术的方式来表达这个问题，比如用像闭包或作用域等词汇，但是我将把这个解释权留给像iraunkortasuna这样的大牛们，他们比我能干的多。</p>
<p>考虑到这一点，在我们最初的例子中，无论是C还是D（但不是两者）都是在对整个表达式的计算之后绑定的，这是合理的。但是，你想知道，这样的代码是非常不安全的……难道Erlang不应该警告我吗？Erlang不应该阻止我写出这样一个非确定性的东西吗？</p>
<p>当然，Erlang会帮我们的！不过不是Erlang的shell，而是Erlang的编译器，它会对这类代码进行告警，而且它非常聪明。如下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(x)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>])</span>.</div><div class="line"><span class="function"><span class="title">bad</span><span class="params">(A)</span> -&gt;</span></div><div class="line">  B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">        C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">        D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">      <span class="keyword">end</span>,</div><div class="line">  A + B.</div></pre></td></tr></table></figure>
<p>这是我们的原始代码，在这种情况下，即使C或D在case语句之后是未绑定的，因为它们没有被使用，编译器什么也不说。</p>
<p>现在我们看看另一个版本的代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(x)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>])</span>.</div><div class="line"><span class="function"><span class="title">bad</span><span class="params">(A)</span> -&gt;</span></div><div class="line">  B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">        C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">        D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">      <span class="keyword">end</span>,</div><div class="line">  A + B - C.</div></pre></td></tr></table></figure>
<p>在这个例子里，编译器将不会编译这个模块，相反，它会报告如下错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x.erl:<span class="number">8</span>: variable 'C' unsafe in '<span class="keyword">case</span>' (line <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>我们可以对上述错误消息的可用性和可读性进行深入的讨论，但是这个模块不能编译的事实毫无疑问对Erlang开发者是有帮助的。</p>
<p><strong>小贴士：</strong>如果在编译Erlang模块时看到类似这样的错误，请注意警告：8（其中使用了不安全变量）和4（变量可能绑定的地方）中的两个行号。</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/erlang-battleground/tricky-question-25a956298b9d" target="_blank" rel="external">https://medium.com/erlang-battleground/tricky-question-25a956298b9d</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的工作中，我有个任务是为Erlang程序员应聘者设计一套选择题考卷，我决定包含一个关于变量绑定的棘手问题。在加入这个问题之前，我决定自己先尝试一下（你懂的……我这是为了预防万一）并且我发现了一些可能让你第一眼看到觉得很惊讶的事情，尽管这在事后是很明显的。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="variable binding" scheme="http://szpzs.oschina.io/tags/variable-binding/"/>
    
  </entry>
  
  <entry>
    <title>简说MQTT--第二部分：MQTT是如何运作的？</title>
    <link href="http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-2/"/>
    <id>http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-2/</id>
    <published>2017-09-21T05:58:34.000Z</published>
    <updated>2017-09-21T06:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>与传统的客户端/服务器协议不同，MQTT不是端到端的。MQTT是一种发布订阅消息交换协议。另外，与消息队列不同，MQTT不维护任何队列。它使用主题来路由消息。</p>
<p>这次我们将向你展示MQTT是如何运作的。</p>
<a id="more"></a>
<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><p>MQTT是一种发布订阅消息交换协议，它的含义是：</p>
<ol>
<li>通信系统中有发布者和订阅者。发布者发布消息而订阅者接收消息。我们把发布者和订阅者统称为客户端。客户端可以同时是发布者和订阅者。</li>
<li>在系统中有另外一个角色，它接收发布者的消息并且将消息派发给订阅者。我们一般称这个角色为消息Broker。</li>
</ol>
<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>在MQTT中，另一个重要的概念是主题，每一条消息都有一个主题，它决定了消息将被谁接收。主题是MQTT的路由机制。</p>
<p>举个例子，如果一个天气预报服务正在更新各个城市的温度数据。这个服务并不知道谁将接收哪个城市的温度数据，它只是用主题来标识这些数据，比如，“temperature/newyork” 或 “temperature/frankfurt”，并且将它们发送给Broker。那些对城市天气有兴趣的人可以在Broker上订阅一个或多个这样的主题。一旦一条消息到达Broker，它就会检查消息里的主题，并且将消息派发给相应的订阅者。</p>
<p>主题由一个或多个层级组成，层级之间被斜杠（/）分隔。有时主题和分类和目录相似。</p>
<p>主题中的通配符(“#” 和 “+”)使得订阅者更易于一次订阅多个主题。“+”表示一个单独的层级，而“#”表示多个层级。多数情况下，你可以按你的意愿自由地命名主题，但是有一个列外：以“$”开头的主题是保留给系统使用的。</p>
<p>MQTT天然支持一对多（广播）的消息传递：一个发布者用一个主题发布一条消息到Broker，Broker派发这条消息给所有订阅这个主题的客户端。</p>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>一条消息就是我们想要在通信系统中与其他方交换的信息。交换消息是MQTT的目的。MQTT用控制数据包来传输消息和维护链接。</p>
<p>一个MQTT数据包包括一个固定的头部，一个可选的可变头部以及一个可选的有效负载数据部分：</p>
<ul>
<li>固定头部出现在所有MQTT控制包中。它包括包的类型、各种标志以及包的剩余长度。</li>
<li>可变头部出现在一些MQTT控制包中。它的内容根据包的类型不同而不同。</li>
<li>有效负载数据出现在一些MQTT控制包中。它是包的最后一部分。业务相关的数据都在这部分中。</li>
</ul>
<p>如你所猜测的一样，最小的MQTT包只有2字节。</p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>现在我们已经有了通信中的各种角色、路由消息的方式以及约定的消息格式，我们可以用这些基本元素来构建一个通信系统。</p>
<p>如下图所示，想象一下，我们在一所医院里：</p>
<p><img alt="MQTT communication, an example" src="/images/mqtt-communication.png" style="border: 0;"></p>
<p>住院病人的重要统计数据由可穿戴设备收集并发送到中心服务器，然后发送给相关人员（或设备）。</p>
<p>一个传感器，这里我们以温度计为例，测量患者的体温并将这个温度数据设置主题：“传感器/ 1 /温度话题”后发布到MQTT Broker。很明显，这个传感器的角色就是发布者。关心这个病人的任何数据的人（比如他的医生）可以订阅“sensor/1/#”这个主题；任何需要收集所有病人体温数据的人或设备可以订阅主题： “sensor/+/temperature”；只关心这个病人的体温的人可以精确地订阅主题：“sensor/1/temperature”，而不需要任何通配符。</p>
<h1 id="MQTT的特殊特点"><a href="#MQTT的特殊特点" class="headerlink" title="MQTT的特殊特点"></a>MQTT的特殊特点</h1><h2 id="QOS"><a href="#QOS" class="headerlink" title="QOS"></a>QOS</h2><p>MQTT实现了简单但是有效的3级服务质量系统：</p>
<ul>
<li>0：最多一次</li>
<li>1：最少一次</li>
<li>2：仅有一次</li>
</ul>
<h2 id="保留的消息"><a href="#保留的消息" class="headerlink" title="保留的消息"></a>保留的消息</h2><p>如果MQTT消息的保留标志被设置了，则消息可以被Broker保留。当一个客户端链接到Broker并订阅了一个主题，而Broker有这个主题的一条保留的消息，客户端将立刻收到这条消息。每一个主题最多只有一条保留的消息。</p>
<h2 id="遗愿消息"><a href="#遗愿消息" class="headerlink" title="遗愿消息"></a>遗愿消息</h2><p>MQTT经常被用于不可靠的网络环境。客户端可能没有正常关闭链接（DISCONNECT消息没有发送出去）的情况下丢失链接。在这种情况下，遗愿消息可以做客户端应该做的事情。</p>
<p>每个客户端当它链接到Broker的时候可以设置一条遗愿消息。遗愿消息和其他消息一样，它也有服务质量级别、保留属性以及主题。这条消息被存储在Broker上，当Broker检测到客户端丢失了链接，Broker把这条遗愿消息发送给所有订阅了遗愿消息的主题的所有在线客户端。如果客户端发送一个“DISCONNECT”包给Broker后断开链接，那么它的遗愿消息被丢弃。</p>
<h1 id="MQTT数据包"><a href="#MQTT数据包" class="headerlink" title="MQTT数据包"></a>MQTT数据包</h1><p>MQTT定义了14种消息类型。它们被用于创建链接、断开链接、发布消息、订阅主题、维护链接或保证服务质量。</p>
<p>消息类型如下表所示：</p>
<p><img alt="MQTT communication, an example" src="/images/mqtt-packet-type.png" style="border: 0;"></p>
<p>在本系列的下一篇文章中，我们将演示如何创建一个简单的MQTT应用并解释有关协议和数据包格式。</p>
<p>待续……</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-4e8dd6ef57c0" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-4e8dd6ef57c0</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与传统的客户端/服务器协议不同，MQTT不是端到端的。MQTT是一种发布订阅消息交换协议。另外，与消息队列不同，MQTT不维护任何队列。它使用主题来路由消息。&lt;/p&gt;
&lt;p&gt;这次我们将向你展示MQTT是如何运作的。&lt;/p&gt;
    
    </summary>
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>简说MQTT--第一部分：MQTT是啥？</title>
    <link href="http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-1/"/>
    <id>http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-1/</id>
    <published>2017-09-21T05:39:41.000Z</published>
    <updated>2017-09-21T05:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>MQTT是什么？这个问题的最贴切的答案是我在网站mqtt.org看到的：</p>
<blockquote>
<p>“MQTT是机器对机器(M2M)/物联网的链接协议。”</p>
</blockquote>
<p>它解释得十分清楚，MQTT是M2M和物联网（IoT）连接协议。要理解MQTT，我们需要首先去了解M2M或物联网。</p>
<a id="more"></a>
<h1 id="M2M和物联网"><a href="#M2M和物联网" class="headerlink" title="M2M和物联网"></a>M2M和物联网</h1><p>许多人已经在用物联网了，他们中有些人只是没有意识到。最近我去拜访我的一位朋友。他对他的新智能烤箱很兴奋，迫不及待地想告诉我他的烤箱是多么聪明：食谱下载到智能手机，然后通过WiFi发送到烤箱；可以通过智能手机的应用程序远程调控烘烤；当食物烤好了，烤箱就发出通知给智能手机。嗯，他已经进入物联网时代了。</p>
<p>物联网的基本概念并不新，它是设备之间的联网，让设备自己收集和交换数据。有时这种数据交换甚至在没有人工干预（机器对机器的连接）的情况下发生。各种设备通过网络彼此集成。现在，这种集成的规模可以是巨大的，它能够提高效率、精度和经济效益，减少人为干预。</p>
<p>在物联网的世界里，几乎所有的东西（包括人）都可以连接起来。事物互联有可能带来新的好处，我们要做的是利用我们的好奇心和想象力来释放这种潜力。高德纳说，到2020，将有超过260亿个连接设备。计算机，手机，平板电脑，台灯，咖啡机，汽车，光传感器，运动探测器，生物芯片，飞机和任何你能想象的东西。有人建议把“物”当做“硬件、软件、数据和服务不可分割的混合物”。</p>
<h1 id="为什么是MQTT"><a href="#为什么是MQTT" class="headerlink" title="为什么是MQTT"></a>为什么是MQTT</h1><p>物联网的一个关键要素是，“事物”具有连接的能力。他们需要一种大家都能理解的通用语言，一种连接协议。多年来，世界上已经有很多连接协议，像HTTP这样的协议被数以百万计的应用程序所使用。为什么不是只有一个广泛使用的协议？为什么MQTT是物联网的协议？</p>
<p>“什么事物都可以连接，也将被连接”。想想这样的场景：早上5点半，你的智能手机告诉客厅的暖气调节器调节室内温度，以适应日常活动。5点50，你的智能手机告诉咖啡机开始煮咖啡。当你在6点被你的智能手机叫醒，万事都准备妥当，甚至你喜欢的美剧已经被下载到你的平板电脑里了。当你享受宁静的早晨时，你可能会注意到一件事：所有连接的设备都是如此不同，而它们却一起工作得很好。</p>
<p>我们刚刚讨论的这个物联网场景，我们叫它做智能家居。我们来构建一个智慧城市或者甚至构建一个智慧世界如何？在这个世界里，一个超级计算机可以和一个芯片上的系统交换数据。例如，医疗中心监控病人植入的芯片，并向病人的医生发出警报。当任何设备被允许接入并且设备在地理上广泛分布时，应该使用什么样的通信协议呢？</p>
<p>它必须是一个轻量级的协议，占用的代码量很小，对于这个协议来说，非常有限的网络带宽就足够了。MQTT就是这种协议。</p>
<blockquote>
<p>“MQTT是一个客户端服务器的发布/订阅消息传输协议。它轻量、开放、简单，且设计为易于实现。这些特性使得它非常适合在许多情况下使用，包括受限的环境，例如用于机器对机器的通信（M2M）和物联网环境，在其中只需要占用少量的代码和/或网络带宽。”<br> – – 引用自MQTT规范</p>
</blockquote>
<h1 id="关于MQTT的历史"><a href="#关于MQTT的历史" class="headerlink" title="关于MQTT的历史"></a>关于MQTT的历史</h1><p>MQTT是MQ Telemetry Transport的缩写。它首先是Andy Stanford-Clark 和 Arlen Nipper在1999年发明的。他们当时在做一个管道的监控和数据采集系统（Telemetry这个词就来自这里），需要实时在卫星链路和拨号线路上传输数据，以连接远程管道。基于这些有限的资源，他们开始考虑做一个新的<strong>发布和订阅协议</strong>，就是MQTT协议。</p>
<blockquote>
<p>MQTT按下面5个目标来设计的：<br>它必须能简单地被实现；<br>它必须有数据传输的服务质量；<br>它必须轻量和带宽高效；<br>它必须可传输任意数据；<br>以及它必须可保持会话。</p>
</blockquote>
<p>今天，这五个目标依然被支持，它们本质上和物联网的需求是相等的。</p>
<p>IBM在2010年正式免费发布MQTT3.1，OASIS在2014年标准化了这个协议。写本文的时候，MQTT的版本是3.1.1。MQTT下一个版本是5.0，一个MQTT5.0的工作草稿正在被公示。</p>
<h1 id="MQTT-v-s-XMPP"><a href="#MQTT-v-s-XMPP" class="headerlink" title="MQTT v.s. XMPP"></a>MQTT v.s. XMPP</h1><p>将MQTT和其他协议进行比较可以使得我们更易于理解为什么MQTT适合物联网，在此我们将它和XMPP进行比较，XMPP是上世纪90年代后期诞生的消息协议。</p>
<ol>
<li>XMPP发明于1999年。它是eXtensible Messaging and Presence Protocol的缩写。</li>
<li>MQTT使用固定大小，即一个字节的头部，以及两个字节的KeepAlive包。它的包小，而且易于编解码。而XMPP用XML封装，它的包大并且交互复杂。</li>
<li>MQTT使用主题来路由消息，它比基于JID的点对点路由的XMPP更灵活。</li>
<li>MQTT不定义有效载荷数据的格式，因此它很容易携带不同的更高层协议的数据。而XMPP用XML来格式化有效载荷数据，它必须用Base64格式封装二进制数据。</li>
<li>MQTT支持消息确认和QoS机制，这些XMPP都没有，因此MQTT更加可靠。</li>
</ol>
<p>待续……</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-cc24370920c2" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-cc24370920c2</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MQTT是什么？这个问题的最贴切的答案是我在网站mqtt.org看到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“MQTT是机器对机器(M2M)/物联网的链接协议。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它解释得十分清楚，MQTT是M2M和物联网（IoT）连接协议。要理解MQTT，我们需要首先去了解M2M或物联网。&lt;/p&gt;
    
    </summary>
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的乐趣犹如驾驭魅影</title>
    <link href="http://szpzs.oschina.io/2017/08/01/joy-of-erlang/"/>
    <id>http://szpzs.oschina.io/2017/08/01/joy-of-erlang/</id>
    <published>2017-08-01T12:58:22.000Z</published>
    <updated>2017-08-07T07:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在电影&lt;&lt;阿凡达&gt;&gt;里，有一条超级大的翼龙，它叫做魅影，男主角为了赢得蓝色族人的信任必须学会骑魅影。一般来说，魅影不喜欢被骑，但如果你和它打一架，而且把它制服，然后把你的蓝马尾辫连接到魅影的尾巴上，你就能拥有它的生命。这就像拥有一辆你能控制的飞车，在与强敌作战时，你可以很方便地用你的思想控制它，给未来的同事留下深刻印象。但是学会骑魅影是很危险的，很少有人能成功。</p>
<p>我喜欢把Erlang编程语言看作是一条魅影。大多数人都害怕Erlang。关于其能力的传说比比皆是。为了掌握它，你必须与它战斗，征服它，并(最后)把你的思想与它联系起来。但假设你能活下来，你就可以控制世界上最先进的服务器平台，让它做事情的时候通常无需再思考。现在让我来告诉你：驾驭魅影是很有趣的。</p>
<p>本指南旨在教会你Erlang的思想，这样你就不会害怕而离开，而是可以战胜你自己的魅影。我将只介绍一些Erlang语言特性，但是我们将使用它们来解决大量实际问题。它的目的是让你想要并且有信心去学习并掌握Erlang语言其他知识。</p>
<p>欢迎您将这些示例输入到自己的Erlang shell中，并执行它们，不过这些示例的设计是为了便于阅读而设计的。我建议你把这份文件打印出来，在舒适的椅子上仔细地阅读，并且远离电子邮件、编译器、3D电影以及其他干扰。</p>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><a href="#part-one">定义函数： 一个简单布尔逻辑库</a></li>
<li><a href="#part-two">递归地调用函数：一个简单算术运算库</a></li>
<li><a href="#part-three">整数列表：基本字符串处理</a></li>
<li><a href="#part-four">Erlang算法的乐趣</a></li>
<li><a href="#part-five">下一步</a></li>
<li><a href="#part-six">源代码</a></li>
</ol>
<h1 id="定义函数：-一个简单布尔逻辑库"><a href="#定义函数：-一个简单布尔逻辑库" class="headerlink" title="定义函数： 一个简单布尔逻辑库"></a><span id="part-one">定义函数： 一个简单布尔逻辑库</span></h1><p>在Erlang里，函数由一个或多个分支语句组成。最后一个分支语句必须用  .  号结束；而其他分支语句必须用  ;  号结束。当函数被调用的时候，第一个和入参匹配的分支语句被执行。你可能会思考，如果C语言的switch语句暴露在有毒污泥中并成为超级英雄，那么函数将会怎样。</p>
<p>最简单的例子，一个函数只有一个语句。如下所示，函数 noop 简单地返回它的参数，即变量A（变量总是大写开头的）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">noop</span><span class="params">(A)</span> -&gt;</span> A.</div></pre></td></tr></table></figure>
<p>注意，Erlang没有 return 语句。函数总是返回最后一个表达式的结果。因为每一个表达式都有一个结果，而且每一个函数分支语句至少有一个表达式，所以每一个函数总是有一个返回值。</p>
<p>现在假设我们希望实现一个布尔函数 not，它把true或false作为它的参数。not 函数需要两个子句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">not</span><span class="params">(true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">not</span><span class="params">(false)</span> -&gt;</span> <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<p>每次 not 函数被执行，Erlang首先测试入参是否是true（如果是，执行第一个子句），然后再测试入参是否是false（如果是，则执行第二个子句）。用入参和函数定义进行匹配被称为模式匹配。模式匹配使得在不使用内部控制结构的情况下很容易编写复杂的函数。</p>
<p>我们可以使用模式匹配来判断同一变量是否在参数列表中出现不止一次。比如，如下函数实现相等操作符：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, B)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>如果两个入参相同，则函数返回true；否则，函数返回false。</p>
<p>小心！在这个函数里子句的顺序很重要。如果像下面这样写，则是错误的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, B)</span> -&gt;</span> <span class="literal">false</span>; <span class="comment">% 错</span></div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<p>为什么会错呢？Erlang首先尝试匹配第一个子句。但是如果两个入参相同，第一个子句依然匹配，A和B被简单地绑定为相等的值。第二个子句永远不会被执行到。在形参列表里用不同名字到变量并不是说一定要给它们绑定不相等的值。</p>
<p>我们现在已经准备好实现更多的布尔逻辑。如下是 and 的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 与: 如果两个入参是true则是true, 否则是false</span></div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(false, true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, false)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>你可能认为所有这些真值表子句太啰嗦。它们的确是很啰嗦。我们可以用一个特别的匿名变量来将后面三个子句缩减到一个子句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 与: 如果两个入参是true则是true, 否则是false</span></div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>匿名变量(_)总是匹配任何数据。它没有被赋值，所以正如我们在上面的第二个子句中看到的，参数列表中的两个或多个下划线变量不需要匹配相同的项。匿名变量通常用来“丢弃”我们不关心的一部分模式。</p>
<p>现在我们有了常规变量和下划线变量，我们的布尔逻辑库的其余部分就容易写了。花点时间了解一下为什么下面的每一个功能都正好符合要求。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 或: 如果一个或两个参数是true则是true，否则为false。</span></div><div class="line"><span class="function"><span class="title">or</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">or</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 异或: 两个参数不同则是true，否则为false。</span></div><div class="line"><span class="function"><span class="title">xor</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">xor</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 非与: 两个参数是true则为false，否则为true。</span></div><div class="line"><span class="function"><span class="title">nand</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">nand</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 非或: 两个参数是false则为true，否则为false。</span></div><div class="line"><span class="function"><span class="title">nor</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">nor</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>如你所见，模式匹配给予Erlang函数极大的表达能力。在下一节中，我们将把模式匹配与递归相结合，建立一个新的算术运算库。在大多数语言中，递归通常是最后的手段，只用于实现复杂的算法。在Erlang，递归通常是最简单和最有效的方式来做一些平常的事情。</p>
<h1 id="递归地调用函数：一个简单算术运算库"><a href="#递归地调用函数：一个简单算术运算库" class="headerlink" title="递归地调用函数：一个简单算术运算库"></a><span id="part-two">递归地调用函数：一个简单算术运算库</span></h1><p>Erlang有一套丰富的算术运算符。不过在这一节里，我们不会使用它们。相反，我们将只使用我们目前为止学到的函数知识来构建我们自己的完整的算术运算库。</p>
<p>本节中的任务诚然是人为的，并且递归绝对不是在现实世界中解决这个问题的最简单的方法。然而，本节的练习将是好的方式来实践递归思维来为第3节做准备，在那里，递归是解决问题的最好方法。</p>
<p>回想一下递归函数至少有两部分：它们必须首先测试某种基本情况（算法终止），如果基本情况不满足，递归函数必须执行一些逻辑，然后发出对自身的调用。在Erlang，递归函数通常至少有两个子句：一个“基本情况”子句和“所有其他情况”子句。</p>
<p>事情将很快变得清晰。为解决问题，为将提供两个函数，算术运算库剩余的部分将以它们为基础来构建：incr 和 decr。假设incr增加入参，decr减少入参，如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">incr</span><span class="params">(A)</span> -&gt;</span> A + <span class="number">1</span>.</div><div class="line"><span class="function"><span class="title">decr</span><span class="params">(A)</span> -&gt;</span> A - <span class="number">1</span>.</div></pre></td></tr></table></figure>
<p>我们可以用这两个函数将任何两个正整数加到一起吗？</p>
<p>事实上我们可以！</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 两个正整数相加</span></div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A.</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span> add(incr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>有时从底层到顶部阅读递归函数是最容易的。所以先看第二个子句，它说将A和B相加与将(A+1)和(B-1)相加是相等的，这明显是正确的。因此，这个函数一直给A加一，给B减一，直到B为0。当B为0的时候，函数结束（第一个子句）。这时，add函数被递归调用了B次，也就是说A被增加了B次，因此最后的结果就是 A+B。</p>
<p>现在有点有趣，不是吗？让我们来实现减法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 从A减去B（B是正整数）</span></div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A.</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> -&gt;</span> sub(decr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>一样的思想。从第二个子句开始，我们看到(A - B)和((A - 1) - (B - 1))相等。这明显是对的。递归调用一直持续到B为0，这个时候，A被减少了B次，结果就是A - B。</p>
<p>当B是负整数的时候，这些函数都不无效。我们可以非常简单地修改add函数以适应负整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 任意两个整数相加</span></div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> add(decr(A), incr(B));</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span> add(incr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>请注意，在第二个子句中Erlang卫句的使用（when B &lt; 0）。我们可以在参数列表后用关键字 when 再加上表达式来指定条件判断。有许多种卫句，但是现在，我们只做整数的比较。</p>
<p>sub函数的修改也差不多：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 从整数A减去任意整数B。</span></div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> sub(incr(A), incr(B));</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> -&gt;</span> sub(decr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>完成了加、减函数，乘法就很容易实现了。正如我们把加法作为一系列加一一样来实现，我们将把乘法作为一系列的加法来实现，还是使用递归。我们使用这样的等式：A × B = A + A × (B - 1)。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% A乘以B（正整数）</span></div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> -&gt;</span> add(A, multiply(A, decr(B))).</div></pre></td></tr></table></figure>
<p>增加对负整数的支持也很容易，因为：A × (B + 1) - A = A × B：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 整数A乘以任意整数B</span></div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> sub(multiply(A, incr(B)), A);</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> -&gt;</span> add(A, multiply(A, decr(B))).</div></pre></td></tr></table></figure>
<p>除法呢？没问题。整数的除法，我们真正关心的是两个操作：求商和求余。这两个操作，我们都用被除数减去除数，直到我们接近0。求余操作更容易些：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求 A 除以 B 的余数</span></div><div class="line"><span class="function"><span class="title">remainder</span><span class="params">(A, B)</span> <span class="title">when</span> A &lt; B -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">remainder</span><span class="params">(A, B)</span> -&gt;</span> remainder(sub(A, B), B).</div></pre></td></tr></table></figure>
<p>至于求余函数，我们将使用Erlang里的通用模式，内部递归函数，以区别主接口。内部递归函数有一个额外参数，它跟踪我们已经减掉除数的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求A 除以 B 的余</span></div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B)</span> -&gt;</span> quotient(A, B, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="comment">% 包括累加器的内部函数</span></div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B, Answer)</span> <span class="title">when</span> A &lt; B -&gt;</span> Answer;</div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B, Answer)</span> -&gt;</span> quotient(sub(A, B), B, incr(Answer)).</div></pre></td></tr></table></figure>
<p>有了乘法和除法，我们就可以解决现实的一些问题。例如，让我们来实现一个幂函数。我们使用与前面完全相同的想法，认识求一个数的幂实际上只是一系列的乘法调用。也就是说，$$A^B = A × A^{B-1}$$</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求A的B次幂(正整数)</span></div><div class="line"><span class="function"><span class="title">pow</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">pow</span><span class="params">(A, B)</span> -&gt;</span> multiply(A, pow(A, decr(B))).</div></pre></td></tr></table></figure>
<p>在实践中，所有这些功能都是非常低效的，因为他们把所有的一切都转变为一系列递增或递减。但是这种递归的思想框架对于充分利用Erlang是绝对必要的，正如我们将要构建的字符串处理库中所看到的。</p>
<h1 id="整数列表：基本字符串处理"><a href="#整数列表：基本字符串处理" class="headerlink" title="整数列表：基本字符串处理"></a><span id="part-three">整数列表：基本字符串处理</span></h1><p>在Erlang里，字符串用整数列表来表示。这些整数是ASCII字符码或者是Unicode码点。例如，字符串”dog”就是表示为由100 (“d”), 111 (“o”), 103 (“g”)组成的列表。Erlang列表的字面量是由方括号括起来的，所以如果你愿意的话，”dog” 可以写为 [100, 111, 103]。要获得一个字符的编码，只要简单地在其前面加上美元符号\$。所以[\$d, \$o, \$g] 和 [100, 111, 103] 以及”dog”是相等的。</p>
<p>每一个列表都分为两部分：头部和尾部。头部是第一个元素，尾部则是除了头部外剩下的部分。列表是一个递归数据结构。列表的尾部是一个列表，它有自己的头部和尾部。以此类推。</p>
<p>空列表表示为[]，它没有头部，也没有尾部。</p>
<p>在Erlang里，添加一个元素到列表的头部使用 | 操作符（管道符号）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewList = [NewItem | OldList]</div></pre></td></tr></table></figure>
<p>| 也可以用在模式匹配中，从一个列表中抽取头部元素：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">some_function</span><span class="params">([FirstItem | RestOfList])</span> -&gt;</span></div><div class="line">   ... do something with FirstItem ...</div></pre></td></tr></table></figure>
<p>反转一个列表，使用函数lists:reverse()。反转一个列表可能看起来是一个不太常用的操作，但正如我们将看到的，它在Erlang实现列表算法时一直使用。</p>
<p>我们现在对字符串了解得足够多了，可以开始做一个例子。让我们写一个函数，将输入的第一字符转换为大写字符。</p>
<p>这个函数的基本思想是简单的。我们检查输入字符串的第一个字符（头部）是否是小写ASCII字符。如果是，我们把它转换成大写（通过增加大写ASCII字符和小写字母之间的差值），然后把它和尾部重写组合成一个字符串。如果不是，我们就简单地返回输入字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">capfirst</span><span class="params">([Head | Tail])</span> <span class="title">when</span> H<span class="title">ead</span> &gt;= $<span class="title">a</span>, H<span class="title">ead</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    [Head + ($A - $a) | Tail];</div><div class="line"><span class="function"><span class="title">capfirst</span><span class="params">(Other)</span> -&gt;</span></div><div class="line">    Other.</div></pre></td></tr></table></figure>
<p>在这里，我们使用了一些新的数学运算符，它们其中的含义你可能会明白。还要注意，逗号用于分隔同一子句中的多个判断条件。</p>
<p>如果你认为很好玩，那就等到你尝试将整个字符串转换为大写。在一个没有for循环的世界，一个进程如何处理字符串的每个元素？是时候重新审视我们的老朋友：递归。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 公共函数</span></div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">(String)</span> -&gt;</span></div><div class="line">   uppercase(String, []).</div><div class="line"></div><div class="line"><span class="comment">% 内部函数</span></div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>和我们在第二节写的函数 quotient 一样，这个函数有一个公共接口以及一个有额外参数的内部递归函数。额外的参数称为累加器，它的初始值为空列表。一般的策略是从输入的头部弹出一个元素，转换它，并将其加到累加器的头部。当我们处理完输入，我们要的结果将存储在累加器里，只不过它的顺序是反的。因此，我们调用 lists:reverse 并返回结果给公共接口函数。</p>
<p>让我们一句一句地检查一下内部函数子句，看看这个策略是如何实现的。</p>
<p>在基准情况下，没有更多的输入。因此，我们反转累加器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div></pre></td></tr></table></figure>
<p>如果还有输入，并且下一个字符是处于ASCII小写字母 a 和 z 之间的话，我们把它转换为大写字母，并把它加到累加器上，然后在剩下的输入上递归地调用 uppercase 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char + ($A - $a) | Output]);</div></pre></td></tr></table></figure>
<p>当下一个字符不是小写的ASCII字符的时候，最后一个子句匹配。在这种情况下，我们只需将字符从输入毫无更改地直接移动到累加器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>这个算法到此就结束了。写一个将所有字符转为小写的函数 lowercase ，这个作为一个练习由读者自己实现。</p>
<p>我们接着来实现一个有趣的函数。把每个单词的第一个字母转成大写，而不是把单词的里的所有字母转成大写。我们叫这个函数做 titlecase 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">(String)</span> -&gt;</span></div><div class="line">    titlecase(String, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], [] = Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], [$\  |_] = Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>titlecase 和 uppercase 的不同是，我们在决定处理每个字符之前用模式匹配检查一下累加器。如果累加器是空的（第二个子句），说明我们在输入的开始之处，并且要将接下来的字母大写化。如果累加器有一个空的字符在它的头部（第三个子句），说明我们在一个单词的开始之处，并且要将接下来的字母大写化。注意，空格字符的整数表示是用美元符号加上一个空格（”$\ “）。在这里我们也使用了匹配操作符（”=”），这使得在参数列表里可以很好地结合模式匹配和变量赋值。</p>
<p>如你所见，递归、累加器和模式匹配是一个强大的组合。我们可以编写无状态变量或正则表达式的上下文相关算法。更重要的是，我们可以清楚地表达问题的解决方案，并对我们的算法的正确性有信心。Erlang的乐趣在于编写代码而不必担心忘记某些东西。</p>
<h1 id="Erlang算法的乐趣"><a href="#Erlang算法的乐趣" class="headerlink" title="Erlang算法的乐趣"></a><span id="part-four">Erlang算法的乐趣</span></h1><p>现在我们可以开始好好玩耍了。既然你现在知道Erlang的基本知识，我就不会花太多时间来解释下面的算法了。它们对你来说只是让你思考和享受。</p>
<p>面试中一个经典的问题是，如何将一个字符串转换为整数（如：C语言中的atoi函数）。如下是Erlang的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([$- | String])</span> -&gt;</span> <span class="comment">% negative</span></div><div class="line">    -<span class="number">1</span> * atoi(String, <span class="number">0</span>);</div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">(String)</span> -&gt;</span> <span class="comment">% non-negative</span></div><div class="line">    atoi(String, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([], Acc)</span> -&gt;</span></div><div class="line">    Acc;</div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([C | Rest], Acc)</span> <span class="title">when</span> C &gt;= $0, C =&lt; $9 -&gt;</span></div><div class="line">    atoi(Rest, <span class="number">10</span> * Acc + (C - $<span class="number">0</span>)).</div></pre></td></tr></table></figure>
<p>注意，这里的累加器是一个整数，而不是我们前面例子里那样上一个字符串。当然，原则上，累加器可以是任何东西。</p>
<p>现在假设我们要做反向操作：将一个整数转换为字符串。代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    [$<span class="number">0</span>];</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer)</span> <span class="title">when</span> I<span class="title">nteger</span> &lt; 0 -&gt;</span> <span class="comment">% negative</span></div><div class="line">    [$-|to_string(-<span class="number">1</span> * Integer, [])];</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer)</span> -&gt;</span> <span class="comment">% positive</span></div><div class="line">    to_string(Integer, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(<span class="number">0</span>, Acc)</span> -&gt;</span></div><div class="line">    Acc;</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer, Acc)</span> -&gt;</span></div><div class="line">    to_string(Integer div <span class="number">10</span>, [(Integer rem <span class="number">10</span>) + $<span class="number">0</span> | Acc]).</div></pre></td></tr></table></figure>
<p>注意，在这里我用了两个整数操作符：div是整数除，rem是整数取模（在C风格语言里通常用%表示）。</p>
<p>让我们假设用Erlang来写一个工具套件，需要将正整数的列数字转换为大多数电子表格使用的字符串表示形式（“A”到“Z”，然后是“AA”到“ZZ”，以此类推）。代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(Number)</span> -&gt;</span></div><div class="line">    num2excel((Number-<span class="number">1</span>) <span class="keyword">div</span> <span class="number">26</span>, (Number-<span class="number">1</span>) <span class="keyword">rem</span> <span class="number">26</span>, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(<span class="number">0</span>, Remainder, Acc)</span> -&gt;</span></div><div class="line">    [(Remainder + $A)|Acc];</div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(Quotient, Remainder, Acc)</span> -&gt;</span></div><div class="line">    num2excel((Quotient-<span class="number">1</span>) <span class="keyword">div</span> <span class="number">26</span>, (Quotient-<span class="number">1</span>) <span class="keyword">rem</span> <span class="number">26</span>, [(Remainder + $A)|Acc]).</div></pre></td></tr></table></figure>
<p>或者在我们的工具套件里的单词处理器需要单词统计函数。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">% public</div><div class="line">wordcount(Input) -&gt;</div><div class="line">    wordcount(Input, 0).</div><div class="line"></div><div class="line">% internal</div><div class="line">wordcount([], Count) -&gt;</div><div class="line">    Count;</div><div class="line">% End of the input. Count the last word, if we didn't already</div><div class="line">wordcount([C1], Count) when C1 =/= $\  -&gt;</div><div class="line">    Count+1;</div><div class="line">% End of a word. Count it.</div><div class="line">wordcount([C1, C2|Rest], Count) when C1 =/= $\ , C2 =:= $\  -&gt;</div><div class="line">    wordcount([C2|Rest], Count + 1);</div><div class="line">% Not the end of a word. Don't count it.</div><div class="line">wordcount([_|Rest], Count) -&gt;</div><div class="line">    wordcount(Rest, Count).</div></pre></td></tr></table></figure>
<p>在这里我们用了两个新的操作符：=:= 是Erlang的相等操作符，=/=是Erlang的不等操作符。现在你明白了。</p>
<p>当然，如果我们计划构建一个产品来与Microsoft FrontPage竞争，那么我将需要一个方法来转义HTML特殊字符。这个功能实现起来不费吹灰之力，代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">escape</span><span class="params">(String)</span> -&gt;</span></div><div class="line">    escape(String, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([], Acc)</span> -&gt;</span></div><div class="line">    lists:reverse(Acc);</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&lt; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;lt;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&gt; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;gt;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&amp; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;amp;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([C | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, [C | Acc]).</div></pre></td></tr></table></figure>
<p>上述代码有一些新东西：有两个参数的lists:reverse()。它反转第一个参数，然后把第二个参数加在其后。这样的代码很方便，我们反向构建累加器（在字符串处理中经常如此）。</p>
<p>Outlook Express最好要小心了，因为我们现在有了编写杀手级电子邮件客户端的工具。让我们将即将发送出去的邮件用每行80个字符的方式来格式化。当我们扫描输入的时候，我们将有一个单词累加器，并且有一个输出累加器，我们要决定什么时候将累加的单词增加到输出累加器里，以及什么时候增加新行字符。在此你需要一个新的操作符：++ 将两个列表串起来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">% 公共接口</div><div class="line">wordwrap(Input) -&gt;</div><div class="line">    wordwrap(Input, [], [], 0, 80).</div><div class="line"></div><div class="line">% 内部函数</div><div class="line">% 没有输入了，我们结束处理，输出结果</div><div class="line">wordwrap([], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    lists:reverse(WordAcc ++ Acc);</div><div class="line"></div><div class="line">% 遇到输入里的换行符</div><div class="line">wordwrap([$\n | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\n | WordAcc ++ Acc], [], 0, WrapAt);</div><div class="line"></div><div class="line">% 当前行长度达到需要换行的长度，并且输入字符为空字符。新增一行</div><div class="line">wordwrap([$\  | Rest], Acc, WordAcc, WrapAt, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\n | WordAcc ++ Acc], [], 0, WrapAt);</div><div class="line"></div><div class="line">% 当前行长度未达到换行长度，输入字符为空字符。</div><div class="line">wordwrap([$\  | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\  | WordAcc ++ Acc], [], LineLength + 1 + length(WordAcc), WrapAt);</div><div class="line"></div><div class="line">% 在建立单词时其长度大于需要换行长度</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, 0, WrapAt) when erlang:length(WordAcc) &gt; WrapAt -&gt;</div><div class="line">    wordwrap(Rest, Acc, [C | WordAcc], 0, WrapAt);</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, LineLength, WrapAt)</div><div class="line">                        when erlang:length(WordAcc) + LineLength &gt; WrapAt -&gt;</div><div class="line">    wordwrap(Rest, [$\n | Acc], [C | WordAcc], 0, WrapAt);</div><div class="line"></div><div class="line">% 构建一个单词</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, Acc, [C | WordAcc], LineLength, WrapAt).</div></pre></td></tr></table></figure>
<p>上述就是我们实现的代码。</p>
<h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a><span id="part-five">下一步</span></h1><p>Erlang是一种丰富的语言，当你深入了解它时，你会更加欣赏它。为了直接讲解本文中的算法，我刻意避免覆盖Erlang的主要数据结构、库及其内置函数。但是如果你喜欢用Erlang的思维框架思考问题，我鼓励你阅读本文后去学习它其余的知识，并开始把Erlang用在工作中。Erlang拥有一个活跃的、不断增长的、友好的开发人员社区、令人兴奋的有潜力的应用程序以及许多有趣和有用的开源项目。</p>
<p>诚然，学习驾驭魅影是艰难的事情，但一旦你掌握了它，你一定会为你的付出而喜悦。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><span id="part-six">源代码</span></h1><p><a href="http://www.evanmiller.org/joy_of_erlang.erl" target="_blank" rel="external">下载本文中所示的源代码</a></p>
<blockquote>
<p>*原文链接<a href="http://www.evanmiller.org/joy-of-erlang.html" target="_blank" rel="external">http://www.evanmiller.org/joy-of-erlang.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在电影&amp;lt;&amp;lt;阿凡达&amp;gt;&amp;gt;里，有一条超级大的翼龙，它叫做魅影，男主角为了赢得蓝色族人的信任必须学会骑魅影。一般来说，魅影不喜欢被骑，但如果你和它打一架，而且把它制服，然后把你的蓝马尾辫连接到魅影的尾巴上，你就能拥有它的生命。这就像拥有一辆你能控制的飞车，在与强敌作战时，你可以很方便地用你的思想控制它，给未来的同事留下深刻印象。但是学会骑魅影是很危险的，很少有人能成功。&lt;/p&gt;
&lt;p&gt;我喜欢把Erlang编程语言看作是一条魅影。大多数人都害怕Erlang。关于其能力的传说比比皆是。为了掌握它，你必须与它战斗，征服它，并(最后)把你的思想与它联系起来。但假设你能活下来，你就可以控制世界上最先进的服务器平台，让它做事情的时候通常无需再思考。现在让我来告诉你：驾驭魅影是很有趣的。&lt;/p&gt;
&lt;p&gt;本指南旨在教会你Erlang的思想，这样你就不会害怕而离开，而是可以战胜你自己的魅影。我将只介绍一些Erlang语言特性，但是我们将使用它们来解决大量实际问题。它的目的是让你想要并且有信心去学习并掌握Erlang语言其他知识。&lt;/p&gt;
&lt;p&gt;欢迎您将这些示例输入到自己的Erlang shell中，并执行它们，不过这些示例的设计是为了便于阅读而设计的。我建议你把这份文件打印出来，在舒适的椅子上仔细地阅读，并且远离电子邮件、编译器、3D电影以及其他干扰。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="recursion" scheme="http://szpzs.oschina.io/tags/recursion/"/>
    
      <category term="function" scheme="http://szpzs.oschina.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>为什么我经常从头开始实现某些功能</title>
    <link href="http://szpzs.oschina.io/2017/06/14/why-i-often-implement-things-from-scratch/"/>
    <id>http://szpzs.oschina.io/2017/06/14/why-i-often-implement-things-from-scratch/</id>
    <published>2017-06-14T02:28:00.000Z</published>
    <updated>2017-06-14T02:32:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>从前有一个Erlang程序员，他需要一个FTP服务器，运行在一个私有网络上的一个主机上。实际上，他不需要一个FTP服务器，他只需要在中央服务器和他的客户端机器之间传输文件，但是他认为他需要一个FTP服务器来完成这个操作。</p>
<a id="more"></a>
<p>他在网上搜索了FTP服务器，确实找到了几个。他们当然是免费的，因为即使他工作的组织有很多钱，但是购买这样一种产品的行政程序是相当可观的。这个项目还必须有合适的许可证形式，这样法律部门才会高兴。</p>
<p>他下载了几个这样的服务器，其中一些是无法编译的，即使它们确实编译了，它们也必须正确配置才能运行，这并不容易。</p>
<p>突然，我们的程序员有了一种想法：他可能可以自己编写一个FTP服务器，而自己编写FTP服务器可能比查找和安装其他人编写的FTP服务器要快。</p>
<p>他问自己：“我想做什么呢?”。</p>
<p>“将远程目录的文件列出来，在本地和远程机器之间拷贝文件等等。”</p>
<p>然后他想起他正在做的项目使用了分布式Erlang。</p>
<p>他想：“这一定很容易”。他是对的。</p>
<p>然后…在服务器机器上，他输入了如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="variable">$erl</span> -name server -cookie ASDRTFERT</div><div class="line">1&gt; node().</div><div class="line"><span class="string">'server@host1.somenet.com'</span></div></pre></td></tr></table></figure>
<p>然后他在另一台机器上输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="variable">$erl</span> -name client1 -cookie ASDRTFERT</div><div class="line">1&gt; node().</div><div class="line"><span class="string">'client1@host23.somenet.com'</span></div></pre></td></tr></table></figure>
<p>现在他已经启动了两个Erlang节点。分布式Erlang的优点是你可以轻松地在任何节点上运行代码，因此要检查他是否能够从客户机节点访问服务器节点，程序员就会输入如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; rpc:call(server@host1.somenet.com',</div><div class="line">erlang, node, []).</div><div class="line">'server@host1.somenet.com'</div></pre></td></tr></table></figure>
<p>如果命令在第一台机器上发出，那将会发生什么。我们可以自己尝试一下。现在我们的程序员知道他可以就像在本地机器上一样调用远程机器上的任何功能。</p>
<p>例子如下：</p>
<p>如果本地命令是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; file:get_cwd()</div></pre></td></tr></table></figure>
<p>在服务器上执行这个命令时，他只需要调用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; rpc:call(server@host1.somenet.com',file, get_cwd, []).</div></pre></td></tr></table></figure>
<p>那么列出远程机器的文件，他输入如下命令即可：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; rpc:call(server@host1.somenet.com',</div><div class="line">     file, list_dir, [<span class="string">"."</span>]).</div><div class="line">&#123;ok, [<span class="string">"Makefile"</span>,</div><div class="line">  <span class="string">"readme"</span>,</div><div class="line"> ....</div></pre></td></tr></table></figure>
<p>然后他决定把远程机器的Makefile文件拷贝到他本地机器上，因此他写了如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; &#123;ok, Bin&#125; = rpc:call(server@host1.smenet.com',</div><div class="line">                file, read_file, [<span class="string">"Makefile"</span>]).</div><div class="line">&lt;&lt;<span class="string">".SUFFIXES: .erl .beam .yrl"</span> .....&gt;&gt;</div><div class="line"><span class="number">3</span>&gt; file:write_file(<span class="string">"Makefile"</span>, [Bin]).</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>此时，所有在shell中键入的内容变得冗长乏味，因此他启动了emacs并编写了如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(myftp)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([get_file/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">get_file</span><span class="params">(F)</span> -&gt;</span></div><div class="line">&#123;ok, B&#125; = rpc:call(server@host1.smenet.com',</div><div class="line">                  file, read_file, [F]),</div><div class="line">file:write_file(F ++ <span class="string">".copy"</span>, [B]).</div></pre></td></tr></table></figure>
<p>然后他编译并测试他的程序：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; c(myftp).</div><div class="line">&#123;ok,myftp&#125;</div><div class="line"><span class="number">5</span>&gt; myftp:get_file(<span class="string">"Makefile"</span>).</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>就这么简单，他搞定了。</p>
<h2 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h2><p>如果你有合适的工具，那么在从头开始实现一些东西比很麻烦地下载编译和安装别人写的东西更快。</p>
<p>这是一个真实的故事，只不过我刚刚写了这段代码。编写此代码和博客的时间与在我的机器上找到并安装一个FTP服务器差不多。</p>
<blockquote>
<p><em>原文链接：</em>  [<a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-often-implement-things-from.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com/2006/09/why-i-often-implement-things-from.html</a>]</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从前有一个Erlang程序员，他需要一个FTP服务器，运行在一个私有网络上的一个主机上。实际上，他不需要一个FTP服务器，他只需要在中央服务器和他的客户端机器之间传输文件，但是他认为他需要一个FTP服务器来完成这个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="rpc" scheme="http://szpzs.oschina.io/categories/Erlang/rpc/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="rpc" scheme="http://szpzs.oschina.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Mnesia表分片</title>
    <link href="http://szpzs.oschina.io/2017/05/30/Mnesia-Table-Fragmentation-erlangcentral/"/>
    <id>http://szpzs.oschina.io/2017/05/30/Mnesia-Table-Fragmentation-erlangcentral/</id>
    <published>2017-05-30T02:53:27.000Z</published>
    <updated>2017-05-30T03:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">概述</a></li>
<li><a href="#part-two">要求</a></li>
<li><a href="#part-three">分片表的样例</a></li>
<li><a href="#part-four">启动一个Erlang节点</a></li>
<li><a href="#part-five">用20个表创建分片表</a></li>
<li><a href="#part-six">数据操作</a></li>
<li><a href="#part-seven">添加记录</a></li>
<li><a href="#part-eight">选择有限的记录</a></li>
<li><a href="#part-nine">分片表的列表</a></li>
</ol>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><span id="part-one">概述</span></h1><p>本文描述如何创建Mnesia分片表以及如何使用它们。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a><span id="part-two">要求</span></h1><p>假如我必须做一个图书索引应用程序。我有一张表用来记录所有可用的图书馆书籍。表的记录结构如下节所述。因为数据量巨大，所以我想把这个表在一个单独的Erlang节点里分片。如果你想分布式处理这个分片的表，你可以参考<a href="http://erlangcentral.org/wiki/index.php?title=Distributing_a_Mnesia_schema" target="_blank" rel="external">这篇文章</a>来分布式处理Mnesia的表。与表分片的其他相关工作都保持不变。</p>
<h1 id="分片表的样例"><a href="#分片表的样例" class="headerlink" title="分片表的样例"></a><span id="part-three">分片表的样例</span></h1><p>我需要这张表是disk_copies模式。其他模式也以相同的方式操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-record</span><span class="params">(book_info, &#123;isbn, name, author, keywords, category, description&#125;)</span>.</div></pre></td></tr></table></figure>
<h1 id="启动一个Erlang节点"><a href="#启动一个Erlang节点" class="headerlink" title="启动一个Erlang节点"></a><span id="part-four">启动一个Erlang节点</span></h1><p>我们的例子节点foo@example默认的磁盘存储路径被设置为在当前路径下的Mnesia.foo@example目录。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -sname foo</div></pre></td></tr></table></figure>
<p>这个路径可以在启动一个Erlang节点的时候通过用 -mnesia dir ‘“/path/of/your/preference”‘ ‘ 启动参数来改写。</p>
<p>让我们创建一个基于磁盘的schema，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnesia:create_schema([node()]).</div></pre></td></tr></table></figure>
<h1 id="用20个表创建分片表"><a href="#用20个表创建分片表" class="headerlink" title="用20个表创建分片表"></a><span id="part-five">用20个表创建分片表</span></h1><p>在本例中，所有20个分片在相同的Erlang/Mnesia节点里。另外这些分片是disc_copies类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mnesia:create_table(book_info,</div><div class="line">   [&#123;frag_properties, [&#123;node_pool, [node()]&#125;, &#123;n_fragments, <span class="number">20</span>&#125;, &#123;n_disc_copies, <span class="number">1</span>&#125;]&#125;,</div><div class="line">   &#123;index, [name, keywords, category]&#125;,</div><div class="line">   &#123;attributes, record_info(fields, book_info)&#125;]),</div></pre></td></tr></table></figure>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a><span id="part-six">数据操作</span></h1><p>为了能够访问在一个分片表的记录，Mnesia必须确定该真实记录属于那个分片。这通过mnesia_frag模块来做到，这个模块实现了mnesia_access回调行为。mnesia_frag封装标准Mnesia操作函数到其函数里，并将其作为参数传递给mnesia:activity/4。</p>
<h1 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a><span id="part-seven">添加记录</span></h1><p>创建一个调用mnesia:write/3的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AddFun = <span class="keyword">fun</span>() -&gt;</div><div class="line">           mnesia:write(book_info, Record, write)</div><div class="line">          <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在如下所示在mnesia:activity/4里调用这个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = mnesia:activity(transaction, AddFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>注意，我已将活动访问上下文用作“事务”。事务可以确保操作要么全部成功要么全部失败（即保证操作的原子性）。我可以使用如下几个访问上下文：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;transaction, Retries&#125;</div><div class="line">sync_transaction</div><div class="line">&#123;sync_transaction, Retries&#125;</div><div class="line">async_dirty</div><div class="line">sync_dirty</div><div class="line">ets</div></pre></td></tr></table></figure>
<p>例如，你想用脏模式做以上的操作，你可以这么写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = mnesia:activity(async_dirty, AddFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>你可以参考mnesia:activity/4文档来获得更多信息。</p>
<h1 id="选择有限的记录"><a href="#选择有限的记录" class="headerlink" title="选择有限的记录"></a><span id="part-eight">选择有限的记录</span></h1><p>做为一个例子，让我们选择作者是steve的10条记录。记住10不是硬性限制。用mnesia:select/4函数创建一个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MatchHead = #book_info&#123;author = <span class="string">"steve"</span>, _ = '_'&#125;,</div><div class="line">Guard = [],</div><div class="line">Result = ['$_'],</div><div class="line">MatchSpec = [&#123;MatchHead, Guard, Result&#125;],</div><div class="line">SelFun = <span class="keyword">fun</span>() -&gt;</div><div class="line">          mnesia:select(book_info, MatchSpec, <span class="number">10</span>, read)</div><div class="line">         <span class="keyword">end</span>,</div></pre></td></tr></table></figure>
<p>现在如下所示在mnesia:activity/4里调用这个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result = mnesia:activity(transaction, SelFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>Result的结果类型是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result -&gt; '$end_of_table' | &#123;[Objects], Cont&#125; | transaction abort</div></pre></td></tr></table></figure>
<p>在一个分片的表里，如果上述Result结果是{[Objects], Cont}，并且返回的对象数量少于我们期望的（10个），那么你需要递归地用Cont（continuation）来调用mnesia:select/1，直到你得到期望数量的结果或者’$end_of_table’。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SelFun2 = <span class="keyword">fun</span>() -&gt;</div><div class="line">             mnesia:select(Cont)</div><div class="line">           <span class="keyword">end</span>,</div><div class="line">Result2 = mnesia:activity(transaction, SelFun2, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>Result2的结果类型是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result2 -&gt; '$end_of_table' | &#123;[Objects], Cont&#125; | transaction abort</div></pre></td></tr></table></figure>
<h1 id="分片表的列表"><a href="#分片表的列表" class="headerlink" title="分片表的列表"></a><span id="part-nine">分片表的列表</span></h1><p>要获取分片表的列表，调用mnesia:table_info/2，并加上 frag_names 选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnesia:activity(async_dirty, mnesia:table_info/<span class="number">2</span>, [store, frag_names], mnesia_frag).</div></pre></td></tr></table></figure>
<p>本教程到此结束！现在你知道如何写一个基本的Mnesia分片表程序了。</p>
<blockquote>
<p><em>原文链接：</em>  [<a href="http://www2.erlangcentral.org/wiki/?title=Mnesia_Table_Fragmentation" target="_blank" rel="external">http://www2.erlangcentral.org/wiki/?title=Mnesia_Table_Fragmentation</a>]</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;分片表的样例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;启动一个Erlang节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;用20个表创建分片表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;数据操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;添加记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-eight&quot;&gt;选择有限的记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-nine&quot;&gt;分片表的列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Mnesia" scheme="http://szpzs.oschina.io/categories/Mnesia/"/>
    
      <category term="Fragmentation" scheme="http://szpzs.oschina.io/categories/Mnesia/Fragmentation/"/>
    
    
      <category term="Mnesia" scheme="http://szpzs.oschina.io/tags/Mnesia/"/>
    
      <category term="Fragmentation" scheme="http://szpzs.oschina.io/tags/Fragmentation/"/>
    
  </entry>
  
  <entry>
    <title>如何在运行时求值Erlang的代码字符串</title>
    <link href="http://szpzs.oschina.io/2017/03/16/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/"/>
    <id>http://szpzs.oschina.io/2017/03/16/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/</id>
    <published>2017-03-16T14:03:09.000Z</published>
    <updated>2017-03-16T14:13:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang有一种能力，在运行时读取一个代表一行代码的字符然后执行这行代码。</p>
<p>它可以解析这个字符串，执行它，然后返回结果。</p>
<ol>
<li><a href="#part-one">求值简单的表达式</a></li>
<li><a href="#part-two">安全注意事项</a><br> 2.1. <a href="#part-two-one">SQL注入攻击是什么？(请耐心看看)</a><br> 2.2 <a href="#part-two-two">与Erlang有关的安全问题是什么？！</a></li>
<li><a href="#part-three">拦截本地函数调用</a></li>
<li><a href="#part-four">拦截非本地函数调用</a></li>
<li><a href="#part-five">还有什么？</a></li>
</ol>
<a id="more"></a>
<h1 id="求值简单的表达式"><a href="#求值简单的表达式" class="headerlink" title="求值简单的表达式"></a><span id="part-one">求值简单的表达式</span></h1><p>最基本的，我们可以读取任何传入的表达式并执行它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),    <span class="comment">% 扫描代码为一些字符串标记</span></div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),     <span class="comment">% 解析这些字符串标记为一个抽象格式</span></div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, []),  <span class="comment">% 求值表达式，返回结果值</span></div><div class="line">    Result.</div></pre></td></tr></table></figure>
<p>尝试传递一些简单的算术表达式。很简单吧？</p>
<p>记住，语句用逗号结束，而函数用句号结束，所以你需要包括那些标点符号。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &gt; 2."</span>).</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4+2."</span>).</div><div class="line"><span class="number">6</span></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"A=7+2,A-4."</span>).</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>如果这就是你所需要的，真棒。</p>
<p>如果你有时间，你可能想要了解这开辟了潜在安全闸门。</p>
<h1 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a><span id="part-two">安全注意事项</span></h1><p>如果你只允许任何人执行任意一行代码，将会有一些很严重的问题，而且立刻就有更多的漏洞出现。</p>
<p>首先，要做一个比较…</p>
<h2 id="SQL注入攻击是什么？-请耐心看看"><a href="#SQL注入攻击是什么？-请耐心看看" class="headerlink" title="SQL注入攻击是什么？(请耐心看看)"></a><span id="part-two-one">SQL注入攻击是什么？(请耐心看看)</span></h2><p>我要转换一下话题，谈谈SQL注入攻击。</p>
<p>例如，我们已经一个web页面，用户可以在这个页面上只输入他们的用户名来查看关于他们自己的信息。在幕后，我们只是获取用户输入的用户名，然后将其插入一个查询语句中，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name = <span class="string">" + "</span>gwinney<span class="string">"</span></div></pre></td></tr></table></figure>
<p>只要用户规规矩矩地玩，一切都好。但是，如果他们输入的名字是 “gwinney; delete * from user_table” 呢？现在，这个查询语句变成如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name = <span class="string">" + "</span>gwinney; <span class="keyword">delete</span> * <span class="keyword">from</span> user_table<span class="string">"</span></div></pre></td></tr></table></figure>
<p>这个问题的解决方案（如果你把这样的代码提交到StackOverflow，至少一半的人会对你大吼大叫）是净化输入。我们应该检查一下以确保它做的是我们期望的，对于SQL来说，这通常意味着参数化查询。</p>
<p>我不想在此对这个问题进行太多的细述，但如果我们以正确的方式做的话，查询看起来更像下面这样，它这将查询失败，因为疯狂的用户名不存在。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="string">'gwinney; delete * from user_table'</span><span class="string">"</span></div></pre></td></tr></table></figure>
<h2 id="与Erlang有关的安全问题是什么？！"><a href="#与Erlang有关的安全问题是什么？！" class="headerlink" title="与Erlang有关的安全问题是什么？！"></a><span id="part-two-two">与Erlang有关的安全问题是什么？！</span></h2><p>相似地，我们可能会碰到表达式代码的安全问题。</p>
<p>我们被允许包含任何函数 – 本地函数、BIF（Erlang的内建函数）和在你创建的其他模块里暴露出来的函数 – 的调用，并且它将解析它们然后尝试执行它们。</p>
<p>如果我们让上述函数能被外界访问，即使是间接的，而且输入没有经过净化，那么我们就是给别人直接调用各种他们没有业务调用函数的能力。危险啊！</p>
<p>那么我们如何防止这样的危险呢？</p>
<h1 id="拦截本地函数调用"><a href="#拦截本地函数调用" class="headerlink" title="拦截本地函数调用"></a><span id="part-three">拦截本地函数调用</span></h1><p>我们可以给 erl_eval:exprs 提供一个函数，所有本地函数的调用都被传给它，我们就可以在这个函数里做一些额外的动作。</p>
<p>本地函数是那些在相同的模块里，它们可以不需要指定模块名而被调用。（虽然一些BIF，比如list_to_binary，不需要指定模块名，这是因为它们被系统自动导入了 – 它们仍然被认为是非本地的。）</p>
<p>在下面的代码里有一些新元素。一个叫做handle_local_function的函数和一个叫做get_random_number的本地函数（感谢<a href="https://xkcd.com/221/" target="_blank" rel="external">xkcd</a>）。这个处理函数输出一个相关信息然后处理传入给它的函数名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),</div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),</div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, [],</div><div class="line">                                        &#123;value, fun handle_local_function/2&#125;),</div><div class="line">    Result.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_local_function</span><span class="params">(FunctionName, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">        get_random_number -&gt; get_random_number();</div><div class="line">        what_time_is_it -&gt; calendar:universal_time();</div><div class="line">        are_we_there_yet -&gt; <span class="string">"no"</span>;</div><div class="line">        _ -&gt; <span class="string">"uh uh uh. you didn't say the magic word!"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> get_random_number<span class="params">()</span> -&gt; integer<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">get_random_number</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="number">4</span>.  <span class="comment">% 通过公平的骰子选择；保证是随机的</span></div></pre></td></tr></table></figure>
<p>现在再运行这个模块，传入一些新的表达式。</p>
<p>我们可以拦截这些本地函数（可能不是真的存在，但表达式求值器不知道），并且按照我们的要求重定向它们…或者如果用户试图做一些无效的事情，只会吐出一条消息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"get_random_number()."</span>).</div><div class="line">Local call to get_random_number with []</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"what_time_is_it()."</span>).</div><div class="line">Local call to what_time_is_it with []</div><div class="line">&#123;&#123;<span class="number">2017</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">15</span>,<span class="number">21</span>,<span class="number">53</span>&#125;&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"are_we_there_yet()."</span>).</div><div class="line">Local call to are_we_there_yet with []</div><div class="line"><span class="string">"no"</span></div><div class="line"></div><div class="line">parser:evaluate_expression(<span class="string">"break_the_system()."</span>).</div><div class="line">Local call to break_the_system with []</div><div class="line"><span class="string">"uh uh uh. you didn't say the magic word!"</span></div></pre></td></tr></table></figure>
<h1 id="拦截非本地函数调用"><a href="#拦截非本地函数调用" class="headerlink" title="拦截非本地函数调用"></a><span id="part-four">拦截非本地函数调用</span></h1><p>相似地，我们可以给 erl_eval:exprs 提供一个函数，所有非本地函数的调用都被传给它。（当前模块外的任何东西，包括BIF、甚至用于比较的运算符。）</p>
<p>如下代码被扩展来处理非本地函数。注意，我们如何必须显式处理属于Erlang模块的一部分的 &gt; 和 &lt; 比较运算符，我们如何能够把不存在的函数重导向到存在的函数，以及如果一个函数不被支持，我们如何能够输出一条消息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),</div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),</div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, [],</div><div class="line">                                        &#123;value, fun handle_local_function/2&#125;,</div><div class="line">                                        &#123;value, fun handle_non_local_function/2&#125;),</div><div class="line">    Result.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_local_function</span><span class="params">(FunctionName, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">        get_random_number -&gt; get_random_number();</div><div class="line">        what_time_is_it -&gt; calendar:universal_time();</div><div class="line">        are_we_there_yet -&gt; <span class="string">"no"</span>;</div><div class="line">        _ -&gt; <span class="string">"uh uh uh. you didn't say the magic word!"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_non_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_non_local_function</span><span class="params">(&#123;ModuleName,FunctionName&#125;, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Non-local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> ModuleName <span class="keyword">of</span></div><div class="line">        erlang -&gt;</div><div class="line">            <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">                '&gt;' -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                '&lt;' -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                list_to_binary -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                _ -&gt; <span class="string">"nope"</span></div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        calendar -&gt;</div><div class="line">            <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">                universal_time -&gt; calendar:universal_time();</div><div class="line">                lets_pretend_this_returns_four -&gt; <span class="number">4</span>;</div><div class="line">                something_ridiculous -&gt; <span class="string">"what calendar are you using??"</span>;</div><div class="line">                _ -&gt; <span class="string">"notgonnahappen"</span></div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        _ -&gt; <span class="string">"don't think about it"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> get_random_number<span class="params">()</span> -&gt; integer<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">get_random_number</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="number">4</span>.  <span class="comment">% chosen by fair dice roll; guaranteed to be random</span></div></pre></td></tr></table></figure>
<p>大于和小于比较是允许的，但是等于却不允许。一些函数被允许，一些函数不被允许，一些函数被重定向。在上一个例子中，一个邪恶的用户尝试用他们邪恶的计划搞垮系统。但他被挫败了。:p</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &lt; 2."</span>).</div><div class="line">Non-local call to '&lt;' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="literal">false</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &gt; 2."</span>).</div><div class="line">Non-local call to '&gt;' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 == 2."</span>).</div><div class="line">Non-local call to '==' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="string">"nope"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"list_to_binary(\"hi\")."</span>).</div><div class="line">Non-local call to list_to_binary with [<span class="string">"hi"</span>]</div><div class="line">&lt;&lt;<span class="string">"hi"</span>&gt;&gt;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"binary_to_list(&lt;&lt;\"hi\"&gt;&gt;)."</span>).</div><div class="line">Non-local call to binary_to_list with [&lt;&lt;<span class="string">"hi"</span>&gt;&gt;]</div><div class="line"><span class="string">"nope"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:universal_time()."</span>).</div><div class="line">Non-local call to universal_time with []</div><div class="line">&#123;&#123;<span class="number">2017</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">21</span>,<span class="number">4</span>,<span class="number">42</span>&#125;&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:local_time()."</span>).</div><div class="line">Non-local call to local_time with []</div><div class="line"><span class="string">"notgonnahappen"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:lets_pretend_this_returns_four()."</span>).</div><div class="line">Non-local call to lets_pretend_this_returns_four with []</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:something_ridiculous()."</span>).</div><div class="line">Non-local call to something_ridiculous with []</div><div class="line"><span class="string">"what calendar are you using??"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"sys:terminate(some_process, \"buahaha\")."</span>).</div><div class="line">Non-local call to terminate with [some_process,<span class="string">"buahaha"</span>]</div><div class="line"><span class="string">"don't think about it"</span></div></pre></td></tr></table></figure>
<h1 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a><span id="part-five">还有什么？</span></h1><p>Erlang里的好例子很难得到，你在这里看到的是一些试验和错误。如果你发现自己试图解析代码，并在运行时执行它，也许这会让你理解得更深。</p>
<p>其他资源：</p>
<ul>
<li><a href="http://www2.erlangcentral.org/wiki/?title=String_Eval" target="_blank" rel="external">执行存储在字符串里的Erlang代码</a>（涉及到绑定变量，这个我在本文没有介绍）</li>
<li>官方文档：<a href="http://erlang.org/doc/man/erl_scan.html" target="_blank" rel="external">erl_scan</a>、<a href="http://erlang.org/doc/man/erl_parse.html" target="_blank" rel="external">erl_parse</a>、<a href="http://erlang.org/doc/man/erl_eval.html" target="_blank" rel="external">erl_eval</a>（一切都在那里…一壶咖啡准备好了）</li>
<li><a href="http://people.apache.org/~dennisbyrne/infoq/DSLs_in_Erlang.ppt" target="_blank" rel="external">Erlang里的领域特定语言</a>（ppt文档，你可以下载来看）</li>
<li><a href="http://stackoverflow.com/q/6786034/301857" target="_blank" rel="external">参数化语句能阻止所有SQL注入吗？</a>（如果你感兴趣的话，这是一个在Stackoverflow上关于SQL注入更多细节的贴子。）</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://grantwinney.com/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/" target="_blank" rel="external">https://grantwinney.com/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang有一种能力，在运行时读取一个代表一行代码的字符然后执行这行代码。&lt;/p&gt;
&lt;p&gt;它可以解析这个字符串，执行它，然后返回结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;求值简单的表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;安全注意事项&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;SQL注入攻击是什么？(请耐心看看)&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#part-two-two&quot;&gt;与Erlang有关的安全问题是什么？！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;拦截本地函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;拦截非本地函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;还有什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="erl_scan erl_parse erl_eval" scheme="http://szpzs.oschina.io/categories/Erlang/erl-scan-erl-parse-erl-eval/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="erl_scan" scheme="http://szpzs.oschina.io/tags/erl-scan/"/>
    
      <category term="erl_parse" scheme="http://szpzs.oschina.io/tags/erl-parse/"/>
    
      <category term="erl_eval" scheme="http://szpzs.oschina.io/tags/erl-eval/"/>
    
  </entry>
  
  <entry>
    <title>Elixir的多态性</title>
    <link href="http://szpzs.oschina.io/2017/03/13/polymorphism-in-elixir/"/>
    <id>http://szpzs.oschina.io/2017/03/13/polymorphism-in-elixir/</id>
    <published>2017-03-13T06:17:46.000Z</published>
    <updated>2017-03-13T06:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>多态性是向不同类型的实体提供单一接口。本质上，它允许不同的数据类型响应相同的函数。因此，相同的函数为不同的数据类型完成相同的行为。Elixir语言有‘协议’和简洁的方式实现多态性。</p>
<a id="more"></a>
<p>让我们实现一个基本的协议，它将开氏和华氏温度转换为摄氏温度。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Kelvin</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Kelvin"</span>, <span class="symbol">symbol:</span> <span class="string">"K"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Fahrenheit</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Fahrenheit"</span>, <span class="symbol">symbol:</span> <span class="string">"°F"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Celsius</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Temperature</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Convert Kelvin and Fahrenheit to Celsius degree</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(degree)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Temperature</span></span>, <span class="symbol">for:</span> Kelvin <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Deduct 273.15</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(kelvin) <span class="keyword">do</span></div><div class="line">    celsius_degree = kelvin.degree - <span class="number">273.15</span></div><div class="line">    %Celsius&#123;<span class="symbol">degree:</span> celsius_degree&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Temperature</span></span>, <span class="symbol">for:</span> Fahrenheit <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Deduct 32, then multiply by 5, then divide by 9</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(fahrenheit) <span class="keyword">do</span></div><div class="line">    celsius_degree = (fahrenheit.degree - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></div><div class="line">    %Celsius&#123;<span class="symbol">degree:</span> celsius_degree&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，我们实现了开氏和华氏温度的转换。</p>
<p>让我们尝试一些转换：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; fahrenheit = %Fahrenheit&#123;<span class="symbol">degree:</span> <span class="number">45</span>&#125;</div><div class="line">%Fahrenheit&#123;<span class="symbol">degree:</span> <span class="number">45</span>, <span class="symbol">name:</span> <span class="string">"Fahrenheit"</span>, <span class="symbol">symbol:</span> <span class="string">"°F"</span>&#125;</div><div class="line">iex&gt; celsius = Temperature.to_celsius(fahrenheit)</div><div class="line">%Celsius&#123;<span class="symbol">degree:</span> <span class="number">7.22</span>, <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>&#125;</div><div class="line"></div><div class="line">iex&gt; kelvin = %Kelvin&#123;<span class="symbol">degree:</span> <span class="number">300</span>&#125;</div><div class="line">%Kelvin&#123;<span class="symbol">degree:</span> <span class="number">300</span>, <span class="symbol">name:</span> <span class="string">"Kelvin"</span>, <span class="symbol">symbol:</span> <span class="string">"K"</span>&#125;</div><div class="line">iex&gt; celsius = Temperature.to_celsius(kelvin)</div><div class="line">%Celsius&#123;<span class="symbol">degree:</span> <span class="number">26.85</span>, <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>&#125;</div></pre></td></tr></table></figure>
<p>让我们试着转换没有实现to_celsius函数的任何其他数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Temperature.to_celsius(%&#123;degree: 12&#125;)</div><div class="line">** (Protocol.UndefinedError) protocol Temperature not implemented for %&#123;degree: 12&#125;</div><div class="line">    iex:11: Temperature.impl_for!/1</div><div class="line">    iex:15: Temperature.to_celsius/1</div></pre></td></tr></table></figure>
<p>如果你想要转换所有数据类型，你可以为<strong>Any</strong>这个数据类型定义一个实现。最后，如果你有时间，请阅读 <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/enum.ex#L3096" target="_blank" rel="external"><strong>Enum</strong></a> 和 <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/string/chars.ex#L3" target="_blank" rel="external"><strong>String.Char</strong></a> 的源码，它们是Elixir核心代码里多态性的好例子。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929#.d09i4bf56" target="_blank" rel="external">https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929#.d09i4bf56</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态性是向不同类型的实体提供单一接口。本质上，它允许不同的数据类型响应相同的函数。因此，相同的函数为不同的数据类型完成相同的行为。Elixir语言有‘协议’和简洁的方式实现多态性。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="polymorphism" scheme="http://szpzs.oschina.io/categories/Elixir/polymorphism/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/categories/Elixir/polymorphism/protocol/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/tags/protocol/"/>
    
      <category term="polymorphism" scheme="http://szpzs.oschina.io/tags/polymorphism/"/>
    
  </entry>
  
</feed>
