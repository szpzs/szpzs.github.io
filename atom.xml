<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.github.io/"/>
  <updated>2016-09-20T09:02:25.000Z</updated>
  <id>http://szpzs.github.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang Thursday – erl_tar:extract/1</title>
    <link href="http://szpzs.github.io/2016/09/20/erlang-thursday-erl-tar-extract-1/"/>
    <id>http://szpzs.github.io/2016/09/20/erlang-thursday-erl-tar-extract-1/</id>
    <published>2016-09-20T08:45:02.000Z</published>
    <updated>2016-09-20T09:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erl_tar.html#extract-1" target="_blank" rel="external">erl_tar:extract/1</a> 。</p>
<p>erl_tar:extract/1 有一个入参，这个入参可能是一个二进制元组、文件描述符元组或是文件名，函数把tar文件的内容解压到当前目录。</p>
<a id="more"></a>
<p>由于我们需要一个tar文件来演示解压它，那么我们来创建一些文件并将它们加入一个新的tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"woof"</span> &gt; dog.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"meow"</span> &gt; cat.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"sparkle"</span> &gt; pony.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">'Wocka Wocka Wocka!'</span> &gt; bear.txt</div><div class="line">$ tar -cvf animal_sounds.tar dog.txt cat.txt pony.txt bear.txt</div><div class="line">a dog.txt</div><div class="line">a cat.txt</div><div class="line">a pony.txt</div><div class="line">a bear.txt</div></pre></td></tr></table></figure>
<p>接着我们也创建一个压缩版本的tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ tar -cvzf animal_sounds.tar.gz dog.txt cat.txt pony.txt bear.txt</div><div class="line">a dog.txt</div><div class="line">a cat.txt</div><div class="line">a pony.txt</div><div class="line">a bear.txt</div></pre></td></tr></table></figure>
<p>为了测试解压这两个tar文件，我们清空当前目录的已经加入tar文件的相关文件。</p>
<p>`` bash<br>$ rm dog.txt cat.txt pony.txt bear.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">确保我们准备好了用来试验的tar文件后，我们打开Erlang shell，然后调用 erl_tar:extract/1 函数。</div><div class="line"></div><div class="line">``` erlang</div><div class="line">erl_tar:extract(&quot;animal_sounds.tar&quot;).</div><div class="line">% ok</div></pre></td></tr></table></figure></p>
<p>看起来直截了当，我们回到命令行看看我们解压出来的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls dog.txt cat.txt pony.txt bear.txt</div><div class="line">bear.txt cat.txt  dog.txt  pony.txt</div><div class="line">$ rm dog.txt cat.txt pony.txt bear.txt</div></pre></td></tr></table></figure>
<p>确认文件后，为了试验，我们把它们删除继续下面的试验。</p>
<p><strong>erl_tar:extract/2</strong></p>
<p>Erlang还有一个 <a href="http://www.erlang.org/doc/man/erl_tar.html#extract-2" target="_blank" rel="external">erl_tar:extract/2</a> 函数，它允许我们通过提供一个列表做为它第二个入参来做为解压的选项。</p>
<p>我们可以用 erl_tra:extract/2 解压文件并让它在控制台打印相关的信息，并且可以增加指定另外的选项，不仅打印相关信息而且解压动作不重写已经存在的任何对应的文件。</p>
<p>`` erlang<br>erl_tar:extract(“animal_sounds.tar”, [verbose]).<br>% x /Users/proctor/tmp/dog.txt<br>%<br>% x /Users/proctor/tmp/cat.txt<br>%<br>% x /Users/proctor/tmp/pony.txt<br>%<br>% x /Users/proctor/tmp/bear.txt<br>%<br>% ok<br>erl_tar:extract(“animal_sounds.tar”, [verbose, keep_old_files]).<br>% x /Users/proctor/tmp/dog.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/cat.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/pony.txt - exists, not created<br>%<br>% x /Users/proctor/tmp/bear.txt - exists, not created<br>%<br>% ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">接着还是回到命令行把解压出来的文件删除继续试验。</div><div class="line"></div><div class="line">``` bash</div><div class="line">$ rm dog.txt cat.txt pony.txt bear.txt</div></pre></td></tr></table></figure></p>
<p>接下来我们通过传入有原子 compressed 组成的列表做为第二个参数来解压 animal_sounds.tar.gz。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, compressed, keep_old_files]).</div><div class="line"><span class="comment">% x /Users/proctor/tmp/dog.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/cat.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/pony.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% x /Users/proctor/tmp/bear.txt</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>有些时候在你的程序中处理tar文件的时候，你不想必需要在文件系统下操作所有tar里的文件而只是读取tar文件的内容，所以有一个选贤可以让tar文件内容保存在内存中</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, compressed, keep_old_files, memory]).</div><div class="line"><span class="comment">% &#123;ok,[&#123;"dog.txt",&lt;&lt;"woofn"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"cat.txt",&lt;&lt;"meown"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"pony.txt",&lt;&lt;"sparklen"&gt;&gt;&#125;,</span></div><div class="line"><span class="comment">%      &#123;"bear.txt",&lt;&lt;"Wocka Wocka Wocka!n"&gt;&gt;&#125;]&#125;</span></div></pre></td></tr></table></figure>
<p>当传入 memory 这个选项，erl_tar:extract/2 的返回值变为一个状态元组，其中有一个包含了被解压tar文件内每一个文件的文件名和它们的二进制内容组成的元组形成的列表。<br>如果一个错误在解压文件到内存的时候发生，比如我们忘了传入 compressed 选项给一个压缩tar文件，函数将返回一个错误元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:extract(<span class="string">"animal_sounds.tar.gz"</span>, [verbose, memory]).</div><div class="line"><span class="comment">% &#123;error,eof&#125;</span></div></pre></td></tr></table></figure>
<p>erl_tar:extract/2 还可以接收跟多的选项，所以我强烈建议你仔细阅读官方文档获取全部可选项。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-extract-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-extract-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/erl_tar.html#extract-1&quot;&gt;erl_tar:extract/1&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;erl_tar:extract/1 有一个入参，这个入参可能是一个二进制元组、文件描述符元组或是文件名，函数把tar文件的内容解压到当前目录。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erl_tar" scheme="http://szpzs.github.io/categories/Erlang/erl-tar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erl_tar" scheme="http://szpzs.github.io/tags/erl-tar/"/>
    
      <category term="extract" scheme="http://szpzs.github.io/tags/extract/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – erl_tar:create/2</title>
    <link href="http://szpzs.github.io/2016/09/20/erlang-thursday-erl-tar-create-2/"/>
    <id>http://szpzs.github.io/2016/09/20/erlang-thursday-erl-tar-create-2/</id>
    <published>2016-09-20T08:36:09.000Z</published>
    <updated>2016-09-20T08:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/erl_tar.html#create-2" target="_blank" rel="external">erl_tar:create/2</a> 。</p>
<p>erl_tar:create/2 根据传入的文件名来创建一个tar文件并将参提供的文件列表加入到tar文件里。</p>
<a id="more"></a>
<p>erl_tar:create/2 有两个入参，第一个入参是一个要写入内容到文件名，第二个入参是一个将要加入tar文件里的文件列表。</p>
<p>首先我们打开一个新的操作系统shell会话并且创建一些文件，这些文件将加入到一个新tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"foo"</span> &gt; foo.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"bar"</span> &gt; bar.txt</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"baz"</span> &gt; baz.txt</div><div class="line">$ ls</div><div class="line">bar.txt  baz.txt  foo.txt  test.tar</div></pre></td></tr></table></figure>
<p>现在我们有了一些可以归档的文件，我们可以打开一个新的erl shell，并且创建一个新的tar文件，它的名字是test.tar。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"test.tar"</span>, [<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"baz.txt"</span>]).</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>看起来好像是有用的，所以我们回到OS shell，看看刚才我们给 erl_tar:create/2（译者注：作者手误写成了 erl_tar:create/3 ） 函数传的那个tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -tf test.tar</div><div class="line">foo.txt</div><div class="line">bar.txt</div><div class="line">baz.txt</div></pre></td></tr></table></figure>
<p>没错，tar可以读这个文件并且告诉我们，那三个我们传入的文件都真的在tar文件里。</p>
<p>erl_tar:create/3</p>
<p>Erlang也提供了 erl_tar:create/3 它最后一个入参是一个选项列表。</p>
<p>我们将创建一个新的tar文件，它里面的文件和上面的例子是一样的，第三个入参我们表明我们想要这个tar文件被压缩而且执行过程中在控制台输出执行过程的内容。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"options.tar.gz"</span>,</div><div class="line">               [<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"baz.txt"</span>],</div><div class="line">               [compressed, verbose]).</div><div class="line"><span class="comment">% a foo.txt</span></div><div class="line"><span class="comment">% a bar.txt</span></div><div class="line"><span class="comment">% a baz.txt</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>再次回到OS shell，来看看这个tar文件里包含的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -tf options.tar.gz</div><div class="line">foo.txt</div><div class="line">bar.txt</div><div class="line">baz.txt</div></pre></td></tr></table></figure>
<p>然后我们来测试一下，这个文件是否能被gzip解压缩。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gzip --test options.tar.gz</div><div class="line">$</div></pre></td></tr></table></figure>
<p>结果gzip认为这个文件压缩完整性很好。接着我们来看看我们创建的这两个tar文件在大小上的差异。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls <span class="_">-l</span> test.tar options.tar.gz</div><div class="line">-rw-r--r--  1 -------  -----    154 Sep XX HH:MM options.tar.gz</div><div class="line">-rw-r--r--  1 -------  -----  10240 Sep XX HH:MM test.tar</div></pre></td></tr></table></figure>
<p>从文件大小来看，options.tar.gz 的确是被压缩的，因为它比test.tar小了两个数量级。</p>
<p>创建一个已经存在的文件</p>
<p>我们刚刚创建了 test.tar 并且看了它内部的内容。现在我们来看看传入相同的文件名test.tar和一个空的文件列表来创建一个已经存在的文件，这样做会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create(<span class="string">"test.tar"</span>, []).</div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>然后我们看看它的内容，发现它原来的内容被替换了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar -tf test.tar</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这说明，erl_tar:create/2 创建tar文件并且覆盖已经存在的文件，如果文件已经存在它不会输出错误（假设用户的shell有权限写该文件或目录）。</p>
<p>在一个不存在的路径上创建tar文件</p>
<p>如果我们给一个不存在的路径, 我们可以看到 erl_tar:create/2 将返回一个错误元组，包括了文件名以及错误原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl_tar:create('/path/does/<span class="keyword">not</span>/exist.tar', []).</div><div class="line"><span class="comment">% &#123;error,&#123;'/path/does/not/exist.tar',enoent&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>其他潜在的陷阱</p>
<p>首先官方文档说该函数入参是文件名，但是它没有指明erl_tar模块中文件名的数据类型是什么。</p>
<p>如果你用原子来做文件名，你会像我第一次用字符串做文件名前一样得到下面例子的错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">erl_tar:create('test.tar', ['foo.txt', 'bar.txt', 'baz.txt']).</div><div class="line">** exception error: no function clause matching filename:join([]) (filename.erl, line <span class="number">392</span>)</div><div class="line">     in function  erl_tar:split_filename/<span class="number">4</span> (erl_tar.erl, line <span class="number">423</span>)</div><div class="line">     in call from erl_tar:create_header/<span class="number">3</span> (erl_tar.erl, line <span class="number">352</span>)</div><div class="line">     in call from erl_tar:add1/<span class="number">4</span> (erl_tar.erl, line <span class="number">305</span>)</div><div class="line">     in call from erl_tar:foreach_while_ok/<span class="number">2</span> (erl_tar.erl, line <span class="number">940</span>)</div><div class="line">     in call from erl_tar:create/<span class="number">3</span> (erl_tar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<p>其次，根据erl_tar官方文档的 <a href="http://erlang.org/doc/man/erl_tar.html#id180770" target="_blank" rel="external">限制</a> 这一节，为了最大的兼容性，在各种不同操作系统和tar程序版本中，文件名应该少于100个字符。</p>
<p>最后，当我们指定文件名的时候，包不包括扩展名由我们使用者决定，这和 erl_tar:compress/2 函数一样不为我们使用者管理文件扩展名。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tar-create-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tar-create-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/erl_tar.html#create-2&quot;&gt;erl_tar:create/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;erl_tar:create/2 根据传入的文件名来创建一个tar文件并将参提供的文件列表加入到tar文件里。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erl_tar" scheme="http://szpzs.github.io/categories/Erlang/erl-tar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erl_tar" scheme="http://szpzs.github.io/tags/erl-tar/"/>
    
      <category term="create" scheme="http://szpzs.github.io/tags/create/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – erl_tidy:file/1</title>
    <link href="http://szpzs.github.io/2016/09/20/erlang-thursday-erl-tidy-file-1/"/>
    <id>http://szpzs.github.io/2016/09/20/erlang-thursday-erl-tidy-file-1/</id>
    <published>2016-09-20T08:27:50.000Z</published>
    <updated>2016-09-20T08:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们看看Erlang的 erl_tidy 模块，我们从 <a href="http://www.erlang.org/doc/man/erl_tidy.html#file-1" target="_blank" rel="external">erl_tidy:file/1</a> 开始。</p>
<p>erl_tidy:file/1 入参是一个文件名，它整理并简洁美观地输出入参指定的文件的源码。</p>
<a id="more"></a>
<p>在我的tmp目录里有我解决 FizzBuzz 的快速实现模块，我将看看 erl_tidy:file/1 如何处理这个文件，因为我确定它的处理不是那么的漂亮。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>我们打开一个新的Erlang shell，然后用入参 fizzbuzz.erl 来调用 erl_tidy:file/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erl_tidy:file(<span class="string">"fizzbuzz.erl"</span>).</div><div class="line"><span class="comment">% fizzbuzz.erl:6: replacing call to `lists:map/2' with a list comprehension.</span></div><div class="line"><span class="comment">% fizzbuzz.erl:6: changing application of implicit fun to direct local call.</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>看起来它不喜欢我在代码中用map而且它修改了我调用 translate/1 函数的方式。</p>
<p>关掉shell，我们来看看目录下多了什么。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls <span class="_">-l</span></div><div class="line">total 16</div><div class="line">-rw-r--r--  1 proctor  staff  402 Sep  9 22:06 fizzbuzz.erl</div><div class="line">-rw-r--r--  1 proctor  staff  405 Sep  9 22:05 fizzbuzz.erl.bak</div></pre></td></tr></table></figure>
<p>让我们来看看 fizzbuzz.erl.bak ，主要是确认它的内容是 fizzbuzz.erl 的原始内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>它的确是 fizzbuzz.erl 的原始内容。</p>
<p>现在我们来看看被 erl_tidy:file/1 修改后的 fizzbuzz.erl 文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-module(fizzbuzz).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = [translate(V1) || V1 &lt;- lists:seq(1, N)],</div><div class="line">    lists:foreach(fun (Item) -&gt; io:format("~s~n", [Item])</div><div class="line">		  end,</div><div class="line">		  Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">    'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt; 'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt; 'Buzz';</div><div class="line">translate(N) -&gt; integer_to_list(N).</div></pre></td></tr></table></figure>
<p>正如函数输出的两行消息所说的，我们现在用一个列表解析替代map，并且直接调用 translate/1 函数。</p>
<p>它还把传给 lists:foreach/2 的匿名函数的 end 放在新的一行，也把列表 Translations 放在新的一行。</p>
<p>最后，translate/1 三个分支被改成一行，而且文件最后的换行符也被删掉。</p>
<p>据官方文档所讲，如果 fizzbuzz.erl 有任何没使用的函数都会被删除，同时过时的结构和函数也会被修改。</p>
<p>总的来说，这个好用的Erlang应用小工具可以帮助你的代码保持稳定的风格并将代码保持整洁。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erl_tidy-file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erl_tidy-file-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们看看Erlang的 erl_tidy 模块，我们从 &lt;a href=&quot;http://www.erlang.org/doc/man/erl_tidy.html#file-1&quot;&gt;erl_tidy:file/1&lt;/a&gt; 开始。&lt;/p&gt;
&lt;p&gt;erl_tidy:file/1 入参是一个文件名，它整理并简洁美观地输出入参指定的文件的源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erl_tidy" scheme="http://szpzs.github.io/categories/Erlang/erl-tidy/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erl_tidy" scheme="http://szpzs.github.io/tags/erl-tidy/"/>
    
      <category term="file" scheme="http://szpzs.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:pid/3</title>
    <link href="http://szpzs.github.io/2016/09/20/erlang-thursday-c-pid-3/"/>
    <id>http://szpzs.github.io/2016/09/20/erlang-thursday-c-pid-3/</id>
    <published>2016-09-20T08:14:28.000Z</published>
    <updated>2016-09-20T08:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们简单讲讲 <a href="http://erlang.org/doc/man/c.html#pid-3" target="_blank" rel="external">c:pid/3</a>.</p>
<p>c:pid/3 三个入参分别是一个pid的三个部分的整数值，返回值的类型是与入参值对应的Pid类型。</p>
<a id="more"></a>
<p>我们调用 self 函数来得到当前的pid，然后我们可以调用 c:pid/3 和 self 返回的值进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self().</div><div class="line">% &lt;0.42.0&gt;</div><div class="line">c:pid(0, 42, 0).</div><div class="line">% &lt;0.42.0&gt;</div><div class="line">self() =:= c:pid(0, 42, 0).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>这个函数有什么用呢？有时候当我们检测一个在线系统的时候，在Erlang里有些调用是需要Pid类型的入参而不只是pid的三个整数值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  128774    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163760    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                 448    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.27.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                17940    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div><div class="line">erlang:is_process_alive(c:pid(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>)).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>让我们以正常的方式给这个函数传入一些让其异常的值看看它会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">c:pid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% &lt;0.0.0&gt;</span></div><div class="line">c:pid(<span class="number">111110</span>, <span class="number">0</span>, <span class="number">1111110</span>).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  list_to_pid/1</span></div><div class="line"><span class="comment">%         called as list_to_pid("&lt;111110.0.1111110&gt;")</span></div><div class="line"><span class="comment">%      in call from c:pid/3 (c.erl, line 424)</span></div></pre></td></tr></table></figure>
<p>像<0.0.0>这样的pid是有效的pid，但是传入无效的pid，函数抛出异常，从异常信息里我们看到它尝试调用 list_to_pid 。</0.0.0></p>
<p>让我们快速看看 list_to_pid 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erlang:list_to_pid(<span class="string">"&lt;0.42.0&gt;"</span>).</div><div class="line"><span class="comment">% &lt;0.42.0&gt;</span></div><div class="line">c:pid(<span class="number">0</span>, <span class="number">42</span>, <span class="number">0</span>) =:= erlang:list_to_pid(<span class="string">"&lt;0.42.0&gt;"</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>看起来 c:pid/3 是一个 list_to_pid 的封装函数，它把pid的三个部分的整数值构建成一个字符串，然后调用 list_to_pid 来得到一个 Pid 类型的值。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-pid-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-pid-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们简单讲讲 &lt;a href=&quot;http://erlang.org/doc/man/c.html#pid-3&quot;&gt;c:pid/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:pid/3 三个入参分别是一个pid的三个部分的整数值，返回值的类型是与入参值对应的Pid类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="pid" scheme="http://szpzs.github.io/tags/pid/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – user_default</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-user-default/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-user-default/</id>
    <published>2016-09-19T13:30:25.000Z</published>
    <updated>2016-09-19T13:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们来看看user_default模块。</p>
<p>我是在想验证当我在erl shell中调用 c/1 和 l/1 的函数的版本的时候偶然发现这个模块的，然后研究 <a href="http://www.erlang.org/doc/man/shell_default.html" target="_blank" rel="external">shell_default</a> 的文档。</p>
<a id="more"></a>
<p>文档中提到，如果我们想让一些函数在shell里直接可用，我们可以生成一个名字为user_default的模块，然后在自己的 .erlang 文件里指定该模块的路径，这样的话user_default模块里的导出函数就可以直接在shell里可用了。</p>
<p>既然我手上有一个 fizzbuzz 的例子，那么让我们开始按文档的说明生成一个user_default模块证明我们可以让它正常工作。我们将把它放在我们home目录的tmp目录里。</p>
<p>~/tmp/user_default.erl</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-module(user_default).</div><div class="line"></div><div class="line">-export([fizzbuzz/1]).</div><div class="line"></div><div class="line">fizzbuzz(N) -&gt;</div><div class="line">    Translations = lists:map(fun translate/1, lists:seq(1, N)),</div><div class="line">    lists:foreach(fun(Item) -&gt; io:format("~s~n", [Item]) end, Translations).</div><div class="line"></div><div class="line">translate(N) when N rem 3 =:= 0 andalso N rem 5 =:= 0 -&gt;</div><div class="line">   'FizzBuzz';</div><div class="line">translate(N) when N rem 3 =:= 0 -&gt;</div><div class="line">   'Fizz';</div><div class="line">translate(N) when N rem 5 =:= 0 -&gt;</div><div class="line">   'Buzz';</div><div class="line">translate(N) -&gt;</div><div class="line">   integer_to_list(N).</div></pre></td></tr></table></figure>
<p>在我们的home目录下新建一个 .erlang 文件，添加如下内容，指明我们刚刚创建的user_default文件的路径。</p>
<p>～/.erlang<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code:load_abs(<span class="string">"tmp/user_default"</span>).</div></pre></td></tr></table></figure></p>
<p>如果你已经有一个 .erlang 文件，那么在这个文件的第一行必须是 <a href="http://www.erlang.org/doc/man/code.html#load_abs-1" target="_blank" rel="external">code:load_abs/1</a> 函数，其参数为 user_default 模块。</p>
<p>确定上述两个文件都保存好了，然后打开erlang shell来尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line">** exception error: undefined shell command fizzbuzz/<span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>然而并没有像文档里讲的那样起作用。我意识到，我们用的是 load_abs 函数，并且 user_default 是一个新模块，这个错误可能是因为没有文件可装载。让我们用erlc编译这个模块，然后再尝试。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd tmp/</div><div class="line">$ erlc user_default.erl</div><div class="line">$ ls user_default.*</div><div class="line">user_default.beam user_default.erl</div><div class="line">$ cd ..</div></pre></td></tr></table></figure>
<p>我们现在有一个BEAM文件在~/tmp目录里，所以让我们再次启动Erlang shell并尝试调用 fizzbuzz/1 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.2</span>.<span class="number">1</span>]  [<span class="number">64</span>-bit] [smp:<span class="number">8</span>:<span class="number">8</span>] [async-threads:<span class="number">10</span>] [hipe] [kernel-poll:<span class="literal">false</span>] [dtrace]</div><div class="line"></div><div class="line">Eshell V6.<span class="number">2.1</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; fizzbuzz(<span class="number">20</span>).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">Fizz</div><div class="line"><span class="number">4</span></div><div class="line">Buzz</div><div class="line">Fizz</div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Fizz</div><div class="line">Buzz</div><div class="line"><span class="number">11</span></div><div class="line">Fizz</div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">14</span></div><div class="line">FizzBuzz</div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">17</span></div><div class="line">Fizz</div><div class="line"><span class="number">19</span></div><div class="line">Buzz</div><div class="line">ok</div><div class="line"><span class="number">2</span>&gt;</div></pre></td></tr></table></figure>
<p>终于正常工作了！我们现在可以在shell里不需要指定模块名而直接调用 fizzbuzz/1 。</p>
<p>更多的关于 .erlang 文件的信息可以阅读 <a href="http://www.erlang.org/documentation/doc-5.1/doc/getting_started/getting_started.html#1.7" target="_blank" rel="external">Erlang中关于配置部分的文档</a> 。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-user_default/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-user_default/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们来看看user_default模块。&lt;/p&gt;
&lt;p&gt;我是在想验证当我在erl shell中调用 c/1 和 l/1 的函数的版本的时候偶然发现这个模块的，然后研究 &lt;a href=&quot;http://www.erlang.org/doc/man/shell_default.html&quot;&gt;shell_default&lt;/a&gt; 的文档。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="user_default" scheme="http://szpzs.github.io/categories/Erlang/user-default/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="user_default" scheme="http://szpzs.github.io/tags/user-default/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:i/0</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-c-i-0/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-c-i-0/</id>
    <published>2016-09-19T13:24:00.000Z</published>
    <updated>2016-09-19T13:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续讲c模块的另一个函数 <a href="http://erlang.org/doc/man/c.html#i-0" target="_blank" rel="external">c:i/0</a> 。</p>
<p>c:i/0 输出系统的信息，展示本节点的所有进程信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">c:i().</div><div class="line"><span class="comment">% Pid                   Initial Call                          Heap     Reds Msgs</span></div><div class="line"><span class="comment">% Registered            Current Function                     Stack</span></div><div class="line"><span class="comment">% &lt;0.0.0&gt;               otp_ring0:start/2                      987     4987    0</span></div><div class="line"><span class="comment">% init                  init:loop/1                              2</span></div><div class="line"><span class="comment">% &lt;0.3.0&gt;               erlang:apply/2                        6772   823443    0</span></div><div class="line"><span class="comment">% erl_prim_loader       erl_prim_loader:loop/3                   6</span></div><div class="line"><span class="comment">% &lt;0.6.0&gt;               gen_event:init_it/6                    376      220    0</span></div><div class="line"><span class="comment">% error_logger          gen_event:fetch_msg/5                    8</span></div><div class="line"><span class="comment">% &lt;0.7.0&gt;               erlang:apply/2                        1598      463    0</span></div><div class="line"><span class="comment">% application_controlle gen_server:loop/6                        7</span></div><div class="line"><span class="comment">% &lt;0.9.0&gt;               application_master:init/4              376       44    0</span></div><div class="line"><span class="comment">%                       application_master:main_loop/2           6</span></div><div class="line"><span class="comment">% &lt;0.10.0&gt;              application_master:start_it/4          233       69    0</span></div><div class="line"><span class="comment">%                       application_master:loop_it/4             5</span></div><div class="line"><span class="comment">% &lt;0.11.0&gt;              supervisor:kernel/1                   4185    49109    0</span></div><div class="line"><span class="comment">% kernel_sup            gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.12.0&gt;              rpc:init/1                             233       35    0</span></div><div class="line"><span class="comment">% rex                   gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.13.0&gt;              global:init/1                          233       51    0</span></div><div class="line"><span class="comment">% global_name_server    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.14.0&gt;              erlang:apply/2                         233       19    0</span></div><div class="line"><span class="comment">%                       global:loop_the_locker/1                 5</span></div><div class="line"><span class="comment">% &lt;0.15.0&gt;              erlang:apply/2                         233        3    0</span></div><div class="line"><span class="comment">%                       global:loop_the_registrar/0              2</span></div><div class="line"><span class="comment">% &lt;0.16.0&gt;              inet_db:init/1                         233      206    0</span></div><div class="line"><span class="comment">% inet_db               gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.17.0&gt;              global_group:init/1                    233       59    0</span></div><div class="line"><span class="comment">% global_group          gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.18.0&gt;              file_server:init/1                    2586     2562    0</span></div><div class="line"><span class="comment">% file_server_2         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.19.0&gt;              erlang:apply/2                        2586   155919    0</span></div><div class="line"><span class="comment">% code_server           code_server:loop/1                       3</span></div><div class="line"><span class="comment">% &lt;0.20.0&gt;              supervisor_bridge:standard_error/      233       41    0</span></div><div class="line"><span class="comment">% standard_error_sup    gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.21.0&gt;              erlang:apply/2                         233        9    0</span></div><div class="line"><span class="comment">% standard_error        standard_error:server_loop/1             2</span></div><div class="line"><span class="comment">% &lt;0.22.0&gt;              supervisor_bridge:user_sup/1           610       87    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.23.0&gt;              erlang:apply/2                         233       24    0</span></div><div class="line"><span class="comment">% user                  user:server_loop/2                       5</span></div><div class="line"><span class="comment">% &lt;0.24.0&gt;              kernel_config:init/1                   233      286    0</span></div><div class="line"><span class="comment">%                       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.25.0&gt;              supervisor:kernel/1                    233       58    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.29.0&gt;              kjell_profile:init/1                   987    27100    0</span></div><div class="line"><span class="comment">% kjell_profile         gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.30.0&gt;              kjell_extension:init/1                2586     3903    0</span></div><div class="line"><span class="comment">% kjell_extension       gen_server:loop/6                        9</span></div><div class="line"><span class="comment">% &lt;0.45.0&gt;              k_user_drv:server/2                    987     2218    0</span></div><div class="line"><span class="comment">% user_drv              k_user_drv:server_loop/5                 8</span></div><div class="line"><span class="comment">% &lt;0.46.0&gt;              k_group:server/3                       987    14541    0</span></div><div class="line"><span class="comment">%                       k_group:server_loop/3                    4</span></div><div class="line"><span class="comment">% &lt;0.47.0&gt;              erlang:apply/2                       28690     4406    0</span></div><div class="line"><span class="comment">%                       kjell:shell_rep/4                       17</span></div><div class="line"><span class="comment">% &lt;0.48.0&gt;              erlang:apply/2                        1598    20585    0</span></div><div class="line"><span class="comment">%                       c:pinfo/1                               49</span></div><div class="line"><span class="comment">% Total                                                      58707  1110447    0</span></div><div class="line"><span class="comment">%                                                              237</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个函数返回进程的id，进程的初始化函数即启动进程的函数，进程堆的大小，进程的规约数，进程消息队列里的消息数，进程的注册名字，进程当前所处的函数，以及进程的栈大小。</p>
<p>c:i/0 的输出也包括堆大小、规约数，消息队列大小以及栈大小的各项数据的总和。</p>
<p>c模块也提供 c:ni/0 函数，它展示所有联通的节点的系统信息。</p>
<p>从该函数输出的进程信息来看，我们可以找到几个和 <a href="https://karlll.github.io/kjell/" target="_blank" rel="external">kjell</a> 相关的进程，kjell是我用来替换 erl shell的，它易于查找进程的信息。</p>
<p>查看一个kjell相关的进程，我们可以获得其pid，然后通过调用 <a href="http://erlang.org/doc/man/c.html#i-3" target="_blank" rel="external">c:i/3</a> 展示进程的信息来深入观察该进程，我们可以用pid的3个整数做为此函数的入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c:i(<span class="number">0</span>, <span class="number">47</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% [&#123;current_function,&#123;kjell,shell_rep,4&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span></div><div class="line"><span class="comment">%  &#123;status,waiting&#125;,</span></div><div class="line"><span class="comment">%  &#123;message_queue_len,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;messages,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;links,[&lt;0.48.0&gt;,&lt;0.46.0&gt;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;dictionary,[&#123;&#123;result,1&#125;,ok&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;command,1&#125;,[&#123;call,1,&#123;remote,1,&#123;atom,1,c&#125;,&#123;atom,1,i&#125;&#125;,[]&#125;]&#125;,</span></div><div class="line"><span class="comment">%               &#123;evaluator,&lt;0.48.0&gt;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;trap_exit,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;error_handler,error_handler&#125;,</span></div><div class="line"><span class="comment">%  &#123;priority,normal&#125;,</span></div><div class="line"><span class="comment">%  &#123;group_leader,&lt;0.46.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;total_heap_size,46421&#125;,</span></div><div class="line"><span class="comment">%  &#123;heap_size,28690&#125;,</span></div><div class="line"><span class="comment">%  &#123;stack_size,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;reductions,4479&#125;,</span></div><div class="line"><span class="comment">%  &#123;garbage_collection,[&#123;min_bin_vheap_size,46422&#125;,</span></div><div class="line"><span class="comment">%                       &#123;min_heap_size,233&#125;,</span></div><div class="line"><span class="comment">%                       &#123;fullsweep_after,65535&#125;,</span></div><div class="line"><span class="comment">%                       &#123;minor_gcs,2&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;suspending,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们查看指定的进程的信息，我们可以看到它的链接进程，消息和消息队列长度，堆栈的信息，以及其他各种可能有用的相关设置。</p>
<p>同样，这几个函数也没有observer那样有漂亮的界面，不过它们在你无法直接通过一个终端来访问节点的时候可以派上用场，比如在一个跳板机上工作；它们能给你一个好的方式使得你能知道你的erlang节点的运行情况。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-i-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-i-0/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续讲c模块的另一个函数 &lt;a href=&quot;http://erlang.org/doc/man/c.html#i-0&quot;&gt;c:i/0&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;c:i/0 输出系统的信息，展示本节点的所有进程信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="i" scheme="http://szpzs.github.io/tags/i/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:regs/0</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-c-regs-0/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-c-regs-0/</id>
    <published>2016-09-19T12:58:00.000Z</published>
    <updated>2016-09-19T13:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看看c模块并研究 <a href="http://erlang.org/doc/man/c.html#regs-0" target="_blank" rel="external">c:regs/0</a>.</p>
<p>c:regs/0 输出当前节点上注册的进程的信息，比如进程的名字，进程的id，执行规约数，以及其他信息。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">c:regs().</div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered procs on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Pid          Initial Call                      Reds Msgs</span></div><div class="line"><span class="comment">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</span></div><div class="line"><span class="comment">% code_server           &lt;0.19.0&gt;     erlang:apply/2                  121202    0</span></div><div class="line"><span class="comment">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  156994    0</span></div><div class="line"><span class="comment">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                220    0</span></div><div class="line"><span class="comment">% file_server_2         &lt;0.18.0&gt;     file_server:init/1                  92    0</span></div><div class="line"><span class="comment">% global_group          &lt;0.17.0&gt;     global_group:init/1                 59    0</span></div><div class="line"><span class="comment">% global_name_server    &lt;0.13.0&gt;     global:init/1                       51    0</span></div><div class="line"><span class="comment">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     206    0</span></div><div class="line"><span class="comment">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 3398    0</span></div><div class="line"><span class="comment">% kernel_safe_sup       &lt;0.28.0&gt;     supervisor:kernel/1                 58    0</span></div><div class="line"><span class="comment">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              49109    0</span></div><div class="line"><span class="comment">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</span></div><div class="line"><span class="comment">% standard_error        &lt;0.21.0&gt;     erlang:apply/2                       9    0</span></div><div class="line"><span class="comment">% standard_error_sup    &lt;0.20.0&gt;     supervisor_bridge:standar           41    0</span></div><div class="line"><span class="comment">% user                  &lt;0.24.0&gt;     group:server/3                      36    0</span></div><div class="line"><span class="comment">% user_drv              &lt;0.23.0&gt;     user_drv:server/2                 1219    0</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% ** Registered ports on node nonode@nohost **</span></div><div class="line"><span class="comment">% Name                  Id              Command</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>尽管这个函数的输出没有observer函数提供的图形界面漂亮，但是它是一个有用的工具，在你无法运行observer函数来获得图形界面的时候能够帮助你得到这些进程是什么进程以及这些进程在做什么。</p>
<p>c模块还提供了一个 c:nregs/0 函数，它展示本节点以及与本节点联通的所有节点的所有注册进程的信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">node().</div><div class="line">% 'foo@127.0.0.1'</div><div class="line">nodes().</div><div class="line">% ['bar@127.0.0.1']</div><div class="line">c:nregs().</div><div class="line">%</div><div class="line">% ** Registered procs on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;0.7.0&gt;      erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;0.19.0&gt;     auth:init/1                        880    0</div><div class="line">% code_server           &lt;0.25.0&gt;     erlang:apply/2                  122302    0</div><div class="line">% erl_epmd              &lt;0.18.0&gt;     erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;0.3.0&gt;      erlang:apply/2                  163458    0</div><div class="line">% error_logger          &lt;0.6.0&gt;      gen_event:init_it/6                264    0</div><div class="line">% file_server_2         &lt;0.24.0&gt;     file_server:init/1                  92    0</div><div class="line">% global_group          &lt;0.23.0&gt;     global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;0.13.0&gt;     global:init/1                      339    0</div><div class="line">% inet_db               &lt;0.16.0&gt;     inet_db:init/1                     255    0</div><div class="line">% init                  &lt;0.0.0&gt;      otp_ring0:start/2                 5405    0</div><div class="line">% kernel_safe_sup       &lt;0.34.0&gt;     supervisor:kernel/1                 58    0</div><div class="line">% kernel_sup            &lt;0.11.0&gt;     supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;0.20.0&gt;     net_kernel:init/1                  792    0</div><div class="line">% net_sup               &lt;0.17.0&gt;     supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;0.12.0&gt;     rpc:init/1                          35    0</div><div class="line">% standard_error        &lt;0.27.0&gt;     erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;0.26.0&gt;     supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;0.30.0&gt;     group:server/3                      36    0</div><div class="line">% user_drv              &lt;0.29.0&gt;     user_drv:server/2                 1661    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'foo@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">%</div><div class="line">% ** Registered procs on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Pid          Initial Call                      Reds Msgs</div><div class="line">% application_controlle &lt;6108.7.0&gt;   erlang:apply/2                     463    0</div><div class="line">% auth                  &lt;6108.19.0&gt;  auth:init/1                        880    0</div><div class="line">% code_server           &lt;6108.25.0&gt;  erlang:apply/2                  124588    0</div><div class="line">% erl_epmd              &lt;6108.18.0&gt;  erl_epmd:init/1                    268    0</div><div class="line">% erl_prim_loader       &lt;6108.3.0&gt;   erlang:apply/2                  164400    0</div><div class="line">% error_logger          &lt;6108.6.0&gt;   gen_event:init_it/6                301    0</div><div class="line">% file_server_2         &lt;6108.24.0&gt;  file_server:init/1                  92    0</div><div class="line">% global_group          &lt;6108.23.0&gt;  global_group:init/1                 67    0</div><div class="line">% global_name_server    &lt;6108.13.0&gt;  global:init/1                      341    0</div><div class="line">% inet_db               &lt;6108.16.0&gt;  inet_db:init/1                     255    0</div><div class="line">% inet_gethost_native   &lt;6108.42.0&gt;  inet_gethost_native:serve           83    0</div><div class="line">% inet_gethost_native_s &lt;6108.41.0&gt;  supervisor_bridge:inet_ge           41    0</div><div class="line">% init                  &lt;6108.0.0&gt;   otp_ring0:start/2                 5515    0</div><div class="line">% kernel_safe_sup       &lt;6108.34.0&gt;  supervisor:kernel/1                127    0</div><div class="line">% kernel_sup            &lt;6108.11.0&gt;  supervisor:kernel/1              57226    0</div><div class="line">% net_kernel            &lt;6108.20.0&gt;  net_kernel:init/1                  796    0</div><div class="line">% net_sup               &lt;6108.17.0&gt;  supervisor:erl_distributi          285    0</div><div class="line">% rex                   &lt;6108.12.0&gt;  rpc:init/1                        1302    0</div><div class="line">% standard_error        &lt;6108.27.0&gt;  erlang:apply/2                       9    0</div><div class="line">% standard_error_sup    &lt;6108.26.0&gt;  supervisor_bridge:standar           41    0</div><div class="line">% user                  &lt;6108.30.0&gt;  group:server/3                      36    0</div><div class="line">% user_drv              &lt;6108.29.0&gt;  user_drv:server/2                 2801    0</div><div class="line">%</div><div class="line">% ** Registered ports on node 'bar@127.0.0.1' **</div><div class="line">% Name                  Id              Command</div><div class="line">% ok</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-regs-0/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-regs-0/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续看看c模块并研究 &lt;a href=&quot;http://erlang.org/doc/man/c.html#regs-0&quot;&gt;c:regs/0&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:regs/0 输出当前节点上注册的进程的信息，比如进程的名字，进程的id，执行规约数，以及其他信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="regs" scheme="http://szpzs.github.io/tags/regs/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday Bonus – Functional fizzbuzz</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-bonus-functional-fizzbuzz/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-bonus-functional-fizzbuzz/</id>
    <published>2016-09-19T07:50:40.000Z</published>
    <updated>2016-09-19T07:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday红包。</p>
<p>过去的这个周末我读了文章  <a href="http://comp-phil.blogspot.com/2015/08/bro-do-you-even-fizzbuzz.html" target="_blank" rel="external">Bro, Do You Even FizzBuzz?!?</a> ，它阐述如何在Clojure里不用取模运算符来解决 FizzBuzz 问题。</p>
<a id="more"></a>
<p>在以同样的算法用Ruby来解决这个问题并发布<a href="http://www.proctor-it.com/ruby-tuesday-functional-fizzbuzz/" target="_blank" rel="external">博客</a>后，我想我应该将这个问题用Erlang也来解决，同时也看看有何不同。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(fizzbuzz)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([fizzbuzz/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Results = do_fizzbuzz(N),</div><div class="line">    lists:foreach(<span class="keyword">fun</span>(X) -&gt; io:format(<span class="string">"~p~n"</span>, [X]) <span class="keyword">end</span>, Results).</div><div class="line"></div><div class="line"><span class="function"><span class="title">do_fizzbuzz</span><span class="params">(N)</span> -&gt;</span></div><div class="line">    Fizzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">"fizz"</span>], N),</div><div class="line">    Buzzes = cycle([<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"buzz"</span>], N),</div><div class="line">    FizzBuzzes = lists:zipwith(<span class="keyword">fun</span> lists:append/<span class="number">2</span>, Fizzes, Buzzes),</div><div class="line">    Numbers = lists:seq(<span class="number">1</span>, N),</div><div class="line">    lists:zipwith(fun translate/2, Numbers, FizzBuzzes).</div><div class="line"></div><div class="line"><span class="function"><span class="title">cycle</span><span class="params">(List, N)</span> -&gt;</span></div><div class="line">    lists:sublist(lists:append(lists:duplicate(N, List)), N).</div><div class="line"></div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(Number, <span class="string">""</span>)</span> -&gt;</span></div><div class="line">    integer_to_list(Number);</div><div class="line"><span class="function"><span class="title">translate</span><span class="params">(_, Translation)</span> -&gt;</span></div><div class="line">    Translation.</div></pre></td></tr></table></figure>
<p>在Erlang的解决方案里有几个点要注意。</p>
<p>首先，Erlang没有任何懒列表或序列的直接概念，也没有 cycle 函数，所以我只能临时凑合着调用 lists:duplicate, lists:append 和 lists:sublist 来处理一个列表，从而循环处理原列表来生成一个有N个元素的列表。虽然这个做法不是最高效的方式，但是它是可行的。</p>
<p>其次，lists:zipwith 的能力对于一些管道的想法有帮助，因为我们可以处理这些链在一起的元素，而不是必须在不同的步骤中去处理它们。</p>
<p>第三，我们不用case语句，而是用一个有guard分支的函数来决定一个翻译存在与否，如果是是否用这个翻译，如果不是是否用这个数字。</p>
<p>我希望这起到抛砖引玉的作用，也希望听到你怎样更高效的方案，或者除了用一般的有guard分支来检查剩余元素的模式匹配的其他方法来解决FizzBuzz问题。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-functional-fizzbuzz/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家一个Erlang Thursday红包。&lt;/p&gt;
&lt;p&gt;过去的这个周末我读了文章  &lt;a href=&quot;http://comp-phil.blogspot.com/2015/08/bro-do-you-even-fizzbuzz.html&quot;&gt;Bro, Do You Even FizzBuzz?!?&lt;/a&gt; ，它阐述如何在Clojure里不用取模运算符来解决 FizzBuzz 问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="Functional" scheme="http://szpzs.github.io/categories/Erlang/Functional/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="fizzbuzz" scheme="http://szpzs.github.io/tags/fizzbuzz/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:m/1</title>
    <link href="http://szpzs.github.io/2016/09/19/erlang-thursday-c-m-1/"/>
    <id>http://szpzs.github.io/2016/09/19/erlang-thursday-c-m-1/</id>
    <published>2016-09-19T07:47:15.000Z</published>
    <updated>2016-09-19T07:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续研究c模块，讲的函数是 <a href="http://erlang.org/doc/man/c.html#m-1" target="_blank" rel="external">c:m/1</a>.</p>
<p>c:m/1 入参是一个表示模块名字的原子，返回值是这个模块的信息。它打印出来的信息包括编译的日期、时间和编译选项，还有装载的目标（BEAM）文件以及这个模块中导出函数组成的列表。</p>
<a id="more"></a>
<p>我们来看看erlang中的string模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">c:m(string).</div><div class="line"><span class="comment">% Module string compiled: Date: November 28 2014, Time: 06.47</span></div><div class="line"><span class="comment">% Compiler options:  [&#123;outdir,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../ebin"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../include"&#125;,</span></div><div class="line"><span class="comment">%                     &#123;i,"/private/tmp/erlang-pY1Kv2/otp-OTP-17.3.4/lib/stdlib/src/../../kernel/include"&#125;,</span></div><div class="line"><span class="comment">%                     warnings_as_errors,debug_info]</span></div><div class="line"><span class="comment">% Object file: /usr/local/Cellar/erlang/17.3.4/lib/erlang/lib/stdlib-2.2/ebin/string.beam</span></div><div class="line"><span class="comment">% Exports:</span></div><div class="line"><span class="comment">% centre/2                      rstr/2</span></div><div class="line"><span class="comment">% centre/3                      span/2</span></div><div class="line"><span class="comment">% chars/3                       str/2</span></div><div class="line"><span class="comment">% chars/2                       strip/1</span></div><div class="line"><span class="comment">% chr/2                         strip/2</span></div><div class="line"><span class="comment">% concat/2                      strip/3</span></div><div class="line"><span class="comment">% copies/2                      sub_string/2</span></div><div class="line"><span class="comment">% cspan/2                       sub_string/3</span></div><div class="line"><span class="comment">% equal/2                       sub_word/2</span></div><div class="line"><span class="comment">% join/2                        sub_word/3</span></div><div class="line"><span class="comment">% left/2                        substr/2</span></div><div class="line"><span class="comment">% left/3                        substr/3</span></div><div class="line"><span class="comment">% len/1                         to_float/1</span></div><div class="line"><span class="comment">% module_info/0                 to_integer/1</span></div><div class="line"><span class="comment">% module_info/1                 to_lower/1</span></div><div class="line"><span class="comment">% rchr/2                        to_upper/1</span></div><div class="line"><span class="comment">% right/2                       tokens/2</span></div><div class="line"><span class="comment">% right/3                       words/1</span></div><div class="line"><span class="comment">%                               words/2</span></div><div class="line"><span class="comment">% ok</span></div></pre></td></tr></table></figure>
<p>我们可以看到这个模块是2014年11月28日在我的机器上编译的，还看到 warnings_as_errors 和 debug_info 这两个编译选项打开了，还有beam文件的路径以及string模块所有导出的不同函数。</p>
<p>接着我们看看在erlang shell里编译的模块。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">c(fizzbuzz).</div><div class="line">% &#123;ok,fizzbuzz&#125;</div><div class="line">c:m(fizzbuzz).</div><div class="line">% Module fizzbuzz compiled: Date: August 5 2015, Time: 22.14</div><div class="line">% Compiler options:  []</div><div class="line">% Object file: /Users/proctor/tmp/fizzbuzz.beam</div><div class="line">% Exports:</div><div class="line">%          fizzbuzz/1</div><div class="line">%          module_info/0</div><div class="line">%          module_info/1</div><div class="line">% ok</div></pre></td></tr></table></figure>
<p>c:m(fizzubzz)的输出显示fizzbuzz被编译了，并且是从我的用户目录下的tmp目录装载的，同时还有一个导出函数fizzbuzz/1 和在每个模块都有的两个版本导出函数module_info。</p>
<p>今天讲的这个函数不是你每天都可能用的函数，不过了解它对你调试和检查你的erlang应用很有帮助。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-m-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-m-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续研究c模块，讲的函数是 &lt;a href=&quot;http://erlang.org/doc/man/c.html#m-1&quot;&gt;c:m/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:m/1 入参是一个表示模块名字的原子，返回值是这个模块的信息。它打印出来的信息包括编译的日期、时间和编译选项，还有装载的目标（BEAM）文件以及这个模块中导出函数组成的列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="xm" scheme="http://szpzs.github.io/tags/xm/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – c:xm/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-c-xm-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-c-xm-1/</id>
    <published>2016-09-18T12:26:16.000Z</published>
    <updated>2016-09-18T12:29:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 <a href="http://erlang.org/doc/man/c.html#xm-1" target="_blank" rel="external">c:xm/1</a>.</p>
<p>c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。</p>
<a id="more"></a>
<p>首先让我们检查一下erlang模块，看看它是否有废弃的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c:xm(erlang).</div><div class="line"><span class="comment">% [&#123;deprecated,[]&#125;,&#123;undefined,[]&#125;,&#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是没有调用废弃的函数，没有未定义的函数，也没有未被使用的函数在erlang模块里。注：上述结果我是在Erlang 17.3.4 下得到的，根据你使用不同的erlang版本，你可能得到不一样的结果，因为 erlang:now/0 在18.0版本里已经是废弃的函数。（译者注：这句话有点费解，官网对 c:xm/1 对解析是：This function finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1. ）</p>
<p>为了找到符合这样标准的现存模块，我查看 Erlang 17.0 的 <a href="http://erlang.org/download/otp_src_17.0.readme" target="_blank" rel="external">README</a> 来搜索 deprecated 这个词。 找到如下这句：</p>
<p>pg 模块已经废弃，它将在Erlang/OTP 18中被删除。</p>
<p>那么让我们把这个模块名传给 c:xm/1 看看有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c:xm(pg).</div><div class="line"><span class="comment">% [&#123;deprecated,[&#123;&#123;pg,create,1&#125;,&#123;pg,master,1&#125;&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;pg,create,2&#125;,&#123;pg,master,1&#125;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;undefined,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>我们可以看到我们得到了pg模块里有关废弃的函数信息。</p>
<p>虽然你在日常工作中需要使用这个函数的几率很低，因为erlang相关的工具通常都非常注意这些方面，这足够引起人们的好奇，看起来调用这个函数似乎很值得，尤其如果那个时间Erlang代码的编译是Erlang内部完成的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-xm-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-xm-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 &lt;a href=&quot;http://erlang.org/doc/man/c.html#xm-1&quot;&gt;c:xm/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="xm" scheme="http://szpzs.github.io/tags/xm/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:is_subset/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/</id>
    <published>2016-09-18T12:22:01.000Z</published>
    <updated>2016-09-18T12:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#is_subset-2" target="_blank" rel="external">ordsets:is_subset/2</a>.</p>
<p>ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">10</span>)).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">SetB = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)).</div><div class="line"><span class="comment">% [2,4,6,8,10]</span></div><div class="line">SetC = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>)).</div><div class="line"><span class="comment">% [1,4,7,10,13]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:is_subset(SetB, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetB).</div><div class="line"><span class="comment">% false</span></div><div class="line">ordsets:is_subset(SetC, SetA).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>有几个事实要跟不熟悉集合理论的同学讲讲。首先，空集合是所有集合的子集；其次，一个集合是它自己的子集；最后，如果集合B是集合A的超集，则集合A是集合B的子集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ordsets:is_subset(EmptySet, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetB).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetC).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, EmptySet).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetA).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#is_subset-2&quot;&gt;ordsets:is_subset/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="is_subset" scheme="http://szpzs.github.io/tags/is-subset/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:subtract/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-subtract-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-subtract-2/</id>
    <published>2016-09-18T12:18:09.000Z</published>
    <updated>2016-09-18T12:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#subtract-2" target="_blank" rel="external">ordsets:subtract/2</a>.</p>
<p>ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">OrderedSetA = ordsets:from_list([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">OrderedSetB = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">OrderedSetC = ordsets:from_list([<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">16</span>, -<span class="number">16</span>]).</div><div class="line"><span class="comment">% [-16,-4,-2,2,4,16]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetA, OrderedSetB).</div><div class="line"><span class="comment">% [4]</span></div><div class="line">ordsets:subtract(OrderedSetA, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">ordsets:subtract(OrderedSetB, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">ordsets:subtract(EmptySet, OrderedSetA).</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetB, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5,8,13]</span></div></pre></td></tr></table></figure>
<p>请注意，ordsets:subtract/2 的入参顺序是不可换的，这一点和 ordsets:union/2 或者 ordsets:intersection/2 不一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:subtract(OrderedSetA, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">ordsets:subtract(OrderedSetC, OrderedSetA).</div><div class="line"><span class="comment">% [-16,-4,-2,16]</span></div></pre></td></tr></table></figure>
<p>如果你不是一直跟读Erlang Thursday的话，我再次友情提醒你，虽然Erlang用列表来表示有序集合，但是并不意味着列表是有序集合。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="subtract" scheme="http://szpzs.github.io/tags/subtract/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday Bonus! Performace of erlang:length/1 on a list</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</id>
    <published>2016-09-18T12:12:46.000Z</published>
    <updated>2016-09-18T12:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday福利。</p>
<p>上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：</p>
<p>有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？</p>
<a id="more"></a>
<p>我可以百分之九九确定Erlang必须每次都要遍历列表来计算其长度，因为它用链接列表类的数据结构来构造它的列表，但是我不确定是否有一些聪明的实现方法是我没有意识到，这些方法能提高获取列表长度到速度。</p>
<p>在写今天的Erlang Thursday的时候，我意识到，我应该用 timer:tc 函数，通过它来展示需要多长时间来获取不同列表的长度来证明 erlang:length/1 函数的执行情况。</p>
<p>为了纪念这个问题，也为了在下一次会议的时候能回忆其它，我在这里记录相关内容。我们要明白，timer:tc 函数返回的结果里第一个元素是被测量函数执行的微秒时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10</span>)]).</div><div class="line">&#123;<span class="number">2</span>,<span class="number">10</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000</span>)]).</div><div class="line">&#123;<span class="number">5</span>,<span class="number">1000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000</span>)]).</div><div class="line">&#123;<span class="number">41</span>,<span class="number">10000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000</span>)]).</div><div class="line">&#123;<span class="number">134</span>,<span class="number">100000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>)]).</div><div class="line">&#123;<span class="number">1918</span>,<span class="number">1000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000000</span>)]).</div><div class="line">&#123;<span class="number">25139</span>,<span class="number">10000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000000</span>)]).</div><div class="line">&#123;<span class="number">1368691</span>,<span class="number">100000000</span>&#125;</div></pre></td></tr></table></figure>
<p>在链接列表有大概1000元素以后，我们可以看到计算其长度的时间线性增长，尽管不是真正对所有节点做遍历，但是在算法复杂度（大O）上看是相同复杂度级别。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家一个Erlang Thursday福利。&lt;/p&gt;
&lt;p&gt;上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：&lt;/p&gt;
&lt;p&gt;有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/categories/Erlang/erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/tags/erlang/"/>
    
      <category term="length" scheme="http://szpzs.github.io/tags/length/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:intersection/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-intersection-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-intersection-2/</id>
    <published>2016-09-18T12:08:06.000Z</published>
    <updated>2016-09-18T12:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看ordsets模块并且讲讲 <a href="http://erlang.org/doc/man/ordsets.html#intersection-2" target="_blank" rel="external">ordsets:intersection/2</a> 。</p>
<p>ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OrderedSet1 = ordsets:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>]</div><div class="line">OrderedSet2 = ordsets:from_list([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet1, OrderedSet2).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet2, OrderedSet1).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>因为 ordsets:intersection/2 在集合中找共同的元素，就向上面的例子一样，入参的顺序是可以交换的，不管两个入参的有序集合的参数顺序如何，我们得到的结果是一样的。</p>
<p>如果没有共同的元素，则结果是一个空的有序集合（其实就是一个空列表，上周的文章 <a href="http://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">ordsets:union/2</a> 里强调了用一个列表来当做一个有序集合是危险的）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Evens = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</div><div class="line">Odds = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>]</div><div class="line">ordsets:intersection(OrderedSet2, ordsets:new()).</div><div class="line">[]</div><div class="line">ordsets:intersection(Evens, Odds).</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>Erlang也提供了 <a href="http://erlang.org/doc/man/ordsets.html#intersection-1" target="_blank" rel="external">ordsets:intersection/1</a> 函数，它的入参是一个由多个有序集合为元素组成的列表，它返回的结果是列表里所有的有序集合的交集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">OrderedSet3 = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</div><div class="line">ordsets:intersection([Evens, Odds, OrderedSet1]).</div><div class="line">[]</div><div class="line">ordsets:intersection([Odds, OrderedSet2, OrderedSet1]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection([Evens, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">2</span>]</div><div class="line">ordsets:intersection([Odds, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续看ordsets模块并且讲讲 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#intersection-2&quot;&gt;ordsets:intersection/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="intersection" scheme="http://szpzs.github.io/tags/intersection/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:union/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-union-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-union-2/</id>
    <published>2016-09-18T11:55:20.000Z</published>
    <updated>2016-09-18T12:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#union-2" target="_blank" rel="external">ordsets:union/2</a> 。</p>
<p>ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">SetB = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">SetC = ordsets:from_list([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]).</div><div class="line"><span class="comment">% [1,3,4,5,9]</span></div><div class="line">SetD = ordsets:from_list([a, b, c, d, e]).</div><div class="line"><span class="comment">% [a,b,c,d,e]</span></div><div class="line">UnionAB = ordsets:union(SetA, SetB).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">UnionAC = ordsets:union(SetA, SetC).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div></pre></td></tr></table></figure>
<p>因为Erlang里的字符串实际上是字符列表，我们可以从字符串产生有序集合，然后通过这个函数得到两个字符串里不重复的字符并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:from_list(<span class="string">"Kermit"</span>).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list([<span class="number">75</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">116</span>]).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list(<span class="string">"Mississippi"</span>).</div><div class="line"><span class="comment">% "Mips"</span></div><div class="line">ordsets:union(ordsets:from_list(<span class="string">"Kermit"</span>), ordsets:from_list(<span class="string">"Mississippi"</span>)).</div><div class="line"><span class="comment">% "KMeimprst"</span></div></pre></td></tr></table></figure>
<p>ordsets模块也包含 <a href="http://erlang.org/doc/man/ordsets.html#union-1" target="_blank" rel="external">ordsets:union/1</a> ，它的入参是一个由有序集合组成的列表，它返回的是列表里所有有序集合的并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UnionAC = ordsets:union([SetA, SetC]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABC = ordsets:union([SetB, SetC, SetA]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABCD = ordsets:union([SetB, SetC, SetA, SetD]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9,a,b,c,d,e]</span></div><div class="line">UnionCD = ordsets:union([SetC, SetD]).</div><div class="line"><span class="comment">% [1,3,4,5,9,a,b,c,d,e]</span></div></pre></td></tr></table></figure>
<p>警告：有序集合的表现形式虽然只是一个列表，但是如果你传递一个普通列表给 ordsets:union/2 ，你将得不到你预期的结果，因为这个函数要求每个有序集合里的元素是真正的有序并且是一个集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c,1]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-union-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#union-2&quot;&gt;ordsets:union/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="union" scheme="http://szpzs.github.io/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thrusday – queue:out/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thrusday-queue-out-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thrusday-queue-out-1/</id>
    <published>2016-09-18T11:49:21.000Z</published>
    <updated>2016-09-18T11:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的的是queue模块原生API中的  <a href="http://erlang.org/doc/man/queue.html#out-1" target="_blank" rel="external">queue:out/1</a> 函数。</p>
<p>queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。</p>
<a id="more"></a>
<p>“是什么让这个函数这么厉害？”，你可能会这么问我。</p>
<p>这应该是这个函数由元组、标签元组组成，它的不可变性，它的宽容性，以及我们最终看到它返回结果的事实，所有这些使得我希望更多的队列实现都有像这样的一个API。</p>
<p>首先应该由很多次我自己或别人的过往经历中，在尝试弹出队列第一个元素的时候忘了检查这个队列是否是空的，从而造成一个很不友好的运行时错误。</p>
<p>queue:out/1 恰恰相反，当你给它的入参是一个空队列的时候，它并不触发一个错误，而是返回一个标签元组来告诉你，你传入的队列是空的，另外它还返回一个空队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:out(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们的入参是一个非空队列，queue:out/1 返回一个两元素元组。第一个元素是一个标签元组，它告诉我们，我们得到了一个值以及入参队列的头部元素，第二个元素，我们得到了入参队列移除头部元素后剩下的元素组成的队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([a, b, c, d]).</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">&#123;&#123;value, Head&#125;, NewQueue&#125; = queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">Head.</div><div class="line"><span class="comment">% a</span></div><div class="line">NewQueue.</div><div class="line"><span class="comment">% &#123;[d],[b,c]&#125;</span></div><div class="line">queue:head(NewQueue).</div><div class="line"><span class="comment">% b</span></div></pre></td></tr></table></figure>
<p>当我们在跨语言条件下谈论队列的理论上的概念时，“pop”这个概念做了两个事情，返回队列的头部元素，同时修改队列将其头部元素删除。</p>
<p>由于Erlang的队列是不可改变的，那么你仔细想想几分钟，你就会感觉到 queue:out/1 这个函数的妙处了，它也做了“pop”概念中的两件事情，就是返回队列头部，同时返回一个删除了头部元素的新的队列。</p>
<p>Erlang的queue模块也提供了函数 <a href="http://erlang.org/doc/man/queue.html#out_r-1" target="_blank" rel="external">queue:out_r/1</a> ，它的行为和 queue:out/1 基本一样，不一样的是它操作的是队列的尾部元素而不是队列的头部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:out_r(queue:from_list([a, b, c, d])).</div><div class="line"><span class="comment">% &#123;&#123;value,d&#125;,&#123;,[a,b]&#125;&#125;</span></div><div class="line">queue:out_r(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我希望你和我一样发现 queue:out/1 方便好用。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thrusday-queue-out-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thrusday-queue-out-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的的是queue模块原生API中的  &lt;a href=&quot;http://erlang.org/doc/man/queue.html#out-1&quot;&gt;queue:out/1&lt;/a&gt; 函数。&lt;/p&gt;
&lt;p&gt;queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="out" scheme="http://szpzs.github.io/tags/out/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:split/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-split-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-split-2/</id>
    <published>2016-09-18T11:45:36.000Z</published>
    <updated>2016-09-18T12:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲queue模块的原生API：<a href="http://erlang.org/doc/man/queue.html#split-2" target="_blank" rel="external">queue:split/2</a> 。</p>
<p>queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([a, <span class="number">1</span>, b, <span class="number">2</span>, c, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:split(<span class="number">4</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[2],[a,1,b]&#125;,&#123;[4,3],&#125;&#125;</span></div><div class="line">queue:split(<span class="number">0</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[]&#125;,&#123;[4,3,c],[a,1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">1</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[a]&#125;,&#123;[4,3,c],[1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">7</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[4,3,c],[a,1,b,2]&#125;,&#123;[],[]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">15</span>, QueueOne).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:split/2</span></div><div class="line"><span class="comment">%         called as queue:split(15,&#123;[4,3,c],[a,1,b,2]&#125;)</span></div><div class="line">&#123;SplitFirst, SplitSecond&#125; = queue:split(<span class="number">3</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[b,1],[a]&#125;,&#123;[4,3,c],[2]&#125;&#125;</span></div><div class="line">SplitFirst.</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">SplitSecond.</div><div class="line"><span class="comment">% &#123;[4,3,c],[2]&#125;</span></div><div class="line">queue:peek(SplitFirst).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(SplitSecond).</div><div class="line"><span class="comment">% &#123;value,2&#125;</span></div></pre></td></tr></table></figure>
<p>Erlang也提供一个 <a href="http://erlang.org/doc/man/queue.html#join-2" target="_blank" rel="external">queue:join/2</a> 函数，它有两个入参，入参类型都是队列，函数返回值是一个新的队列，新队列是由第二个入参队列添加到第一个入参队列后面形成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:join(SplitFirst, SplitSecond).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:join(SplitSecond, SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[2,c,3,4,a]&#125;</span></div><div class="line">queue:join(queue:new(), SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">queue:join(queue:new(), queue:new()).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-split-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-split-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲queue模块的原生API：&lt;a href=&quot;http://erlang.org/doc/man/queue.html#split-2&quot;&gt;queue:split/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="split" scheme="http://szpzs.github.io/tags/split/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:peek/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-peek-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-peek-1/</id>
    <published>2016-09-18T11:39:35.000Z</published>
    <updated>2016-09-18T11:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 <a href="http://erlang.org/doc/man/queue.html#peek-1" target="_blank" rel="external">queue:peek/1</a> 。</p>
<p>queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:peek(QueueOne).</div><div class="line"><span class="comment">% &#123;value,1&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>queue:peek/1 绝对不会修改入参队列，所以我们可以再一次调用上述例子，或者像下面例子一样多次调用，而我们的入参队列不会被修改。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueTwo = queue:from_list([a, b, c, d, e, f]).</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div></pre></td></tr></table></figure>
<p>不像上一篇文章里我们看到的 <a href="http://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">queue:head/1</a> ，我们可以安全地在入参队列为空的情况下调用 queue:peek/1 函数，而不是获得一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:head/1</span></div><div class="line"><span class="comment">%         called as queue:head(&#123;[],[]&#125;)</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>Erlang的 queue 模块也包含函数 <a href="http://erlang.org/doc/man/queue.html#peek_r-1" target="_blank" rel="external">queue:peek_r/1</a> ，它返回入参队列的尾部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">queue:peek_r(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,f&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue.</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-peek-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-peek-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 &lt;a href=&quot;http://erlang.org/doc/man/queue.html#peek-1&quot;&gt;queue:peek/1&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="peek" scheme="http://szpzs.github.io/tags/peek/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:tail/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-tail-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-tail-1/</id>
    <published>2016-09-18T11:31:31.000Z</published>
    <updated>2016-09-18T11:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 <a href="http://erlang.org/doc/man/queue.html#tail-1" target="_blank" rel="external">queue:tail/1</a>.</p>
<p>queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">Tail = queue:tail(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Tail).</div><div class="line"><span class="comment">% 2</span></div><div class="line">queue:to_list(Tail).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>我们可以看到上述调用 queue:tail/1 的例子不像其它语言一样是一个破坏性操作，它完全保留了原始的入参队列的完整性。</p>
<p>做为将一个队列做为双端来处理的Okasaki API的一部分，queue:tail/1 有一个对应的函数 <a href="http://erlang.org/doc/man/queue.html#liat-1" target="_blank" rel="external">queue:liat/1</a> ，这个函数返回移除入参队列的最后一个元素后形成的新队列。queue:liat/1 也有一个别名函数，就是Okasaki API的 <a href="http://erlang.org/doc/man/queue.html#init-1" target="_blank" rel="external">queue:init/1</a>.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:liat(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">queue:init(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Erlang官方文档也指出有一个别名函数 queue:lait/1 ，大家最好不要用它，因为它的拼写是错误的。</p>
<p>因为我们是要深入细节然后看看我们能学到什么，那么让我们一起来到目前为止我们接触到的不同的tail函数在接收一个空队列为入参会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:tail(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop/1</span></div><div class="line"><span class="comment">%         called as queue:drop(&#123;[],[]&#125;)</span></div><div class="line">queue:liat(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div><div class="line">queue:init(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>当我们分别调用 <a href="http://erlang.org/doc/man/queue.html#drop-1" target="_blank" rel="external">queue:tail/1</a> 和 <a href="http://erlang.org/doc/man/queue.html#drop_r-1" target="_blank" rel="external">queue:liat/1</a> 的时候，看起来像我们在调用 queue:drop/1 和 queue:drop_r/1 得到的异常错误一样。</p>
<p>当我们用一个有若干元素的队列做为入参来调用 queue:drop/1 和 queue:drop_r/1 ，然后看看的执行情况，看起来 queue:tail/1 就是 queue:drop/1 的别名函数，而 queue:list/1 和 queue:init/1 就是 queue:drop_r/1 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:drop(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">queue:drop_r(Queue).</div><div class="line">&#123;[<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-tail-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-tail-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 &lt;a href=&quot;http://erlang.org/doc/man/queue.html#tail-1&quot;&gt;queue:tail/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="tail" scheme="http://szpzs.github.io/tags/tail/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:head/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-queue-head-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-queue-head-1/</id>
    <published>2016-09-17T08:44:16.000Z</published>
    <updated>2016-09-17T08:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看<a href="http://erlang.org/doc/man/queue.html#head-1" target="_blank" rel="external">queue:head/1</a>.</p>
<p>queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Queue).</div><div class="line"><span class="comment">% 1</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>上述例子显示，queue:head/1 函数没有修改原来的队列，而仅是返回它的第一个元素。</p>
<p>因为 queue:head/1 仅仅是返回队列头部能找到的值，而且不是一个标签元组，如果我们尝试从一个空的队列获取它的头部元素则会抛出一个错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">%** exception error: empty</span></div><div class="line"><span class="comment">%     in function  queue:head/1</span></div><div class="line"><span class="comment">%        called as queue:head(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>为了安全起见，让我们不在一个空队列上运行该函数而造成抛出异常，queue模块也定义了一个函数 queue:is_empty/1 ，你可以用它来检查一个队列是否为空。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:is_empty(EmptyQueue).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>像 queue:cons/2 和Okazaki API的其它函数一样，模块里也有一个函数<a href="http://erlang.org/doc/man/queue.html#daeh-1" target="_blank" rel="external">queue:dash</a> （head单词倒过来写），它从队列获取最后一个元素，它也是 <a href="http://erlang.org/doc/man/queue.html#last-1" target="_blank" rel="external">queue:last/1</a> 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:daeh(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:last(Queue).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>如果你调用 queue:dash/1 和 queue:last/1 的时候用空队列做入参也会引起错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:daeh(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:last(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>如果我们仔细看 queue:dash/1 和 queue:last/1 引起的错误，我们看到这个错误来自扩展API的 queue:get_r/1 。如果我们仔细看 queue:get_r/1 的执行情况，他看起来像 queue:tail/1 和 queue:dash/1 ，而这两个函数真的仅是 <a href="http://erlang.org/doc/man/queue.html#get_r-1" target="_blank" rel="external">queue:get_r/1</a> 别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:get_r(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-head-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看&lt;a href=&quot;http://erlang.org/doc/man/queue.html#head-1&quot;&gt;queue:head/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="head" scheme="http://szpzs.github.io/tags/head/"/>
    
  </entry>
  
</feed>
