<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2017-02-20T22:28:47.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mix 和 OTP－依赖和伞型项目</title>
    <link href="http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/"/>
    <id>http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/</id>
    <published>2017-02-20T22:25:27.000Z</published>
    <updated>2017-02-20T22:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">外部依赖</a></li>
<li><a href="#part-two">内部依赖</a></li>
<li><a href="#part-three">伞型项目</a></li>
<li><a href="#part-four">伞型项目里的依赖</a></li>
<li><a href="#part-five">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将讨论用Mix如何管理依赖。</p>
<p>我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。</p>
<p>构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。</p>
<a id="more"></a>
<h1 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a><span id="part-one">外部依赖</span></h1><p>外包依赖是没有绑定到你的业务领域的。例如，如果你需要为你的分布式 kv 应用提供HTTP API，你可以用 <a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a> 项目作为一个外包依赖。</p>
<p>安装外部依赖是简单的。最常见的，我们通过在我们的mix.exs文件里的deps函数内列出依赖来使用 <a href="https://hex.pm/" target="_blank" rel="external">Hex包管理器</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="string">"~&gt; 1.0"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个依赖指向已经发布到Hex的Plug的1.x.x版本系列的最新版本。这由版本号数字前的 ~&gt; 符号表示。有关指定版本要求的更多信息，请参见<a href="https://hexdocs.pm/elixir/Version.html" target="_blank" rel="external">版本模块的文档</a>。</p>
<p>通常，稳定版本被发布到Hex。如果你想依赖一个还处于开发中的外部依赖，Mix也能够管理git依赖：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="symbol">git:</span> <span class="string">"git://github.com/elixir-lang/plug.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你将注意到，当你增加一个依赖到你的项目，Mix生成一个mix.lock文件来保证<em>可重复构建</em>。这个lock文件必需被提交到你的版本控制系统，以便保证所有使用这个项目的人将使用和你一样的依赖版本。</p>
<p>Mix提供很多任务来处理依赖，这些任务可以用 mix help 来列出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">help</span></div><div class="line">mix deps              <span class="comment"># 列出依赖和它们的状态</span></div><div class="line">mix deps.clean        <span class="comment"># 删除给定的依赖文件</span></div><div class="line">mix deps.compile      <span class="comment"># 编译依赖</span></div><div class="line">mix deps.get          <span class="comment"># 获取所有过时的依赖</span></div><div class="line">mix deps.tree         <span class="comment"># 打印依赖树</span></div><div class="line">mix deps.unlock       <span class="comment"># 解锁给定的依赖</span></div><div class="line">mix deps.update       <span class="comment"># 更新给定的依赖</span></div></pre></td></tr></table></figure>
<p>最常用的任务是 mix deps.get 和 mix deps.update 。一旦被获取到，依赖被自动编译。你可以通过输入 mix help deps 和在 <a href="https://hexdocs.pm/mix/Mix.Tasks.Deps.html" target="_blank" rel="external">Mix.Tasks.Deps 模块文档</a>里读到更多关于依赖的内容。</p>
<h1 id="内部依赖"><a href="#内部依赖" class="headerlink" title="内部依赖"></a><span id="part-two">内部依赖</span></h1><p>内部依赖项是特定于你的项目的依赖。它们通常在你的项目/公司/组织范围之外是没有意义的。大多数时候，你想让他们私有化，无论是由于技术，经济或商业原因。</p>
<p>如果你有一个内部依赖，Mix支持两种方法与它一起工作：git仓库和伞型项目。</p>
<p>例如，如果你推送 kv 应用到一个git仓库，你将需要在你的依赖代码里列出它以便使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">git:</span> <span class="string">"https://github.com/YOUR_ACCOUNT/kv.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果仓库是私有的，您可能需要指定私有URL git@github.com:YOUR_ACCOUNT/kv.git 。在任何情况下，Mix将能够把它拿来给你，只要你有适当的凭据。</p>
<p>在Elixir里不鼓励使用git依赖作为内部依赖。记住：运行时和Elixir生态已经提供了应用这个概念。因此，我们希望你经常将你的代码分解成可以被逻辑地组织的应用，即使在单个项目中也是如此。</p>
<p>然而，如果你把每个应用作为一个独立的项目放入一个git仓库，那么你的项目可能非常难以维护，因为你将花费大量时间来管理那些git仓库而不是写你代码。</p>
<p>因为这个原因，Mix支持“伞型项目”。伞型项目允许你创建一个项目，它拥有许多项目，而且保持它们在一个单独源码仓库里。这正是下一节我们将要探索的风格。</p>
<p>让我们创建一个新的Mix项目。我们将创造性地命名它为 kv_umbrella ，这个新项目里面将拥有已经存在的 kv 应用和新的 kv_server 应用。目录结构将如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>关于这个方法令人感兴趣的事情是，Mix有许多遍历措施来处理这样的项目，诸如用一个命令将apps里的所有应用都编译和测试的能力。但是，尽管它们都在apps目录里，它们依然是彼此解耦的，所以，如果你想的话，你就可以独立地构建、测试和部署每一个应用。</p>
<p>所以让我们开始吧！</p>
<h1 id="伞型项目"><a href="#伞型项目" class="headerlink" title="伞型项目"></a><span id="part-three">伞型项目</span></h1><p>让我们用 mix new 开始一个新项目。这个新项目将被命名为 kv_umbrella ，并且在创建它的时候，我们需要传递 --umbrella 参数。不要在已经存在的 kv 项目里创建这个新项目！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix new kv_umbrella --umbrella</div><div class="line">* creating .gitignore</div><div class="line">* creating README.md</div><div class="line">* creating mix.exs</div><div class="line">* creating apps</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div></pre></td></tr></table></figure>
<p>从打印出来的信息我们可以看到生成的文件少了很多。生成的mix.exs文件也不同。让我们看一看这个文件（注释已经被删除）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KvUmbrella</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">apps_path:</span> <span class="string">"apps"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>使得这个项目与前面的项目不同的是在项目定义里有一个 apps_path: “apps” 条目。它的意思是这个项目将表现得像一把伞。这样的项目既没有源码文件也没有测试用例，但是它们可以有它们自己的依赖。每一个子应用必须定义在apps目录里。</p>
<p>让我们进入apps目录里开始构建 kv_server 。这一次，我们将传递 --sup 标志，它将告诉Mix自动为我们生成一颗监督树，替代在前面章节里如我们所做的手工构建监督树：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv_umbrella/apps</div><div class="line">$ mix new kv_server --module KVServer --sup</div></pre></td></tr></table></figure>
<p>生成的文件与我们第一次为 kv 所生成的相似，有一些不同。让我们打开 mix.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv_server</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line">     <span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line">     <span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line">     <span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.4"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">     <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>首先，因为我们在kv_umbrella/apps里创建这个项目，Mix自动监测到伞型结构并且增加四行到项目定义里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>这些选项的意思是，所有选项将被放置到 kv_umbrella/deps ，并且它们将共享同样的构建、配置和锁文件。这确保为整个伞型结构，依赖将被获取并被编译一次，而不是每一个伞型应用一次。</p>
<p>第二个改变是在 mix.exs 里的 application 函数中：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们传递了 --sup 标志，Mix自动增加了 mod: {KVServer.Application, []} ，指明 KVServer.Application 是我们的应用回调模块。KVServer.Application 将启动我们的应用监督树。</p>
<p>事实上，让我们打开 lib/kv_server/application.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Application <span class="keyword">do</span></div><div class="line">  <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Application.html</span></div><div class="line">  <span class="comment"># for more information on OTP Applications</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    import Supervisor.Spec, <span class="symbol">warn:</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">    <span class="comment"># Define workers and child supervisors to be supervised</span></div><div class="line">    children = [</div><div class="line">      <span class="comment"># Starts a worker by calling: KVServer.Worker.start_link(arg1, arg2, arg3)</span></div><div class="line">      <span class="comment"># worker(KVServer.Worker, [arg1, arg2, arg3]),</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Supervisor.html</span></div><div class="line">    <span class="comment"># for other strategies and supported options</span></div><div class="line">    opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">    Supervisor.start_link(children, opts)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：它定义了应用回调函数，start/2，而不是使用 Supervisor 模块定义一个名为 KVServer.Supervisor 的监督者，它便捷地在行内定义了监督者！你可以通过阅读<a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor模块文档</a>获得更多这样的监督者的内容。</p>
<p>我们已经可以试试我们第一个伞型子应用。我们可以在 apps/kv_server 里运行测试，但是那样不好玩。相反，到伞型项目的根目录，运行 mix test ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>它正常运行！</p>
<p>因为我们想让 kv_server 最终使用我们在 kv 里定义的功能，因此我们需要将 kv 作为一个依赖加入我们的应用。</p>
<h1 id="伞型项目里的依赖"><a href="#伞型项目里的依赖" class="headerlink" title="伞型项目里的依赖"></a><span id="part-four">伞型项目里的依赖</span></h1><p>Mix支持一种简单的机制使得一个伞型子应用依赖于另一个伞型子应用。打开 apps/kv_server/mix.exs 并且按如下所示修改 deps/0 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">in_umbrella:</span> <span class="keyword">true</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述代码使得 :kv作为 :kv_server 里的一个可用依赖并且在启动 :kv_server 前自动启动 :kv 应用。</p>
<p>最后，拷贝我们已经构建好的 kv 应用到我们新的伞型项目的 apps 目录里。最终的目录结构和我们前面提到的结构匹配上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>我们现在需要修改 apps/kv/mix.exs 让其包含我们已经在 apps/kv_server/mix.exs 所见到的伞型相关条目。打开 apps/kv/mix.exs 并将如下内容加入 project 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>现在你可以从伞型项目根目录用 mix test 运行两个应用的测试。太棒了！</p>
<p>请记住，伞型项目是一个方便工具用来帮助你组织和管理你的应用。apps 目录里的应用仍然是彼此解耦的。它们之间的依赖必须明确地列出来。这允许它们被一起开发，但是如果需要的话，独立地编译、测试和部署。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-five">总结</span></h1><p>在这一章，我们学到了更多关于Mix依赖和伞型项目的内容。我们决定构建一个伞型项目，因为我们认为 kv 和 kv_server 是内部依赖的，其重要性只存在于这个项目的上下文里。</p>
<p>在将来，你将写应用并且你将注意到它们可以被提取到一个简洁的单元，这个单元能被不同的项目使用。在这种情况下，使用Git或Hex依赖是要走的路。</p>
<p>这里有几个问题，当你使用依赖的时候你可以问自己。问题是：这个应用在这个项目之外有意义吗？</p>
<ul>
<li>如果没有，则使用一个有伞型子应用的伞型项目。</li>
<li>如果有，则这个项目在你的公司或组织外部可以被共享吗？<ul>
<li>不可以， 则使用一个私有git仓库。</li>
<li>如果可以，则推送你的代码到一个git仓库并且用Hex做频繁的发布。</li>
</ul>
</li>
</ul>
<p>我们的伞型项目构建好并运行了，是时候开始写我们的服务器了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;外部依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;内部依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;伞型项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;伞型项目里的依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将讨论用Mix如何管理依赖。&lt;/p&gt;
&lt;p&gt;我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs 3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。&lt;/p&gt;
&lt;p&gt;构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Dependency Umbrella-Apps" scheme="http://szpzs.oschina.io/categories/Elixir/Dependency-Umbrella-Apps/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Dependency" scheme="http://szpzs.oschina.io/tags/Dependency/"/>
    
      <category term="Umbrella-Apps" scheme="http://szpzs.oschina.io/tags/Umbrella-Apps/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－ETS</title>
    <link href="http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/"/>
    <id>http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/</id>
    <published>2017-02-20T05:41:49.000Z</published>
    <updated>2017-02-20T06:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">ETS作为缓存</a></li>
<li><a href="#part-two">竞争条件</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！</p>
<p>在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。</p>
<blockquote>
<p>警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。</p>
</blockquote>
<a id="more"></a>
<h1 id="ETS作为缓存"><a href="#ETS作为缓存" class="headerlink" title="ETS作为缓存"></a><span id="part-one">ETS作为缓存</span></h1><p>ETS允许我们存储任何Elixir数据到一个内存表里。与ETS表交互是通过Erlang :ets 模块做到的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:set</span>, <span class="symbol">:protected</span>])</div><div class="line"><span class="number">8207</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(table, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>当创建一个ETS表的时候，需要两个入参：一个表名字和一个选项集合。从可用选项中，我们选择传递表类型和它的访问规则。我们选择了 :set 类型，这意味着键不能是重复的。我们也设置表的访问规则为 :protected ，这意味着只有创建表的进程能写这个表，不过其他进程可以从表里读取数据。这两个选项实际上是默认值，所以从现在开始我们将忽略它们。</p>
<p>ETS表可以被命名，允许我们通过给定的名字访问它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:named_table</span>])</div><div class="line"><span class="symbol">:buckets_registry</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(<span class="symbol">:buckets_registry</span>, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(<span class="symbol">:buckets_registry</span>, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>让我们修改 KV.Registry 来使用ETS表。因为我们的registry需要一个名字作为入参，我们计划用与registry相同的名字来命名ETS表。ETS的名字和进程的名字存储在不同的地方，因此没有冲突的可能。</p>
<p>打开 lib/kv/registry.ex ，让我们修改它的实现。我们增加注释到源码中来强调我们所做的修改：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry with the given `name`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 1. 传递名字给GenServer的init回调函数</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, name, <span class="symbol">name:</span> name)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">when</span> is_atom(server) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 2. 查询现在直接在ETS里做，没有访问服务器</span></div><div class="line">    <span class="keyword">case</span> <span class="symbol">:ets</span>.lookup(server, name) <span class="keyword">do</span></div><div class="line">      [&#123;^name, pid&#125;] -&gt; &#123;<span class="symbol">:ok</span>, pid&#125;</div><div class="line">      [] -&gt; <span class="symbol">:error</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Stops the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">    GenServer.stop(server)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(table) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 3. 我们已经用ETS表替换名字映射</span></div><div class="line">    names = <span class="symbol">:ets</span>.new(table, [<span class="symbol">:named_table</span>, <span class="symbol">read_concurrency:</span> <span class="keyword">true</span>])</div><div class="line">    refs  = %&#123;&#125;</div><div class="line">    &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 4. 原来为查询服务的handle_call回调函数被删除</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 5. 读写ETS表而不是映射</span></div><div class="line">    <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, _pid&#125; -&gt;</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">      <span class="symbol">:error</span> -&gt;</div><div class="line">        &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">        ref = Process.monitor(pid)</div><div class="line">        refs = Map.put(refs, ref, name)</div><div class="line">        <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 6. 从ETS表而不是从映射删除</span></div><div class="line">    &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">    <span class="symbol">:ets</span>.delete(names, name)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：在我们修改前， KV.Registry.lookup/2 发送请求给服务器，但是现在它直接从ETS表里读取，ETS表被所有进程共享。这是我们实现的缓存机制背后的主要思想。</p>
<p>为了让缓存机制工作，被创建的ETS表需要有 :protected 访问规则（访问规则的默认值），因此所有客户端可以从它读取数据，而只有 KV.Registry 进程可以写数据到这个表里。当表启动的时候，我们已经设置 read_concurrency: true ，这样就优化了表的并发读取操作的通用场景。</p>
<p>我们上面的修改已经使得我们的测试失败，因为我们原来是用registry进程的pid来做所有操作，而现在registry查询需要ETS表的名字。但是，ETS表的名字和registry进程的名字相同，这个问题就很容易修复。如下所示修改 test/kv/registry_test.exs 的setup函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> context.test&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们修改 setup ，一些测试用例将继续失败。你可能甚至注意到，在不同的运行之间，测试的通过和失败也不是一致的。例如：“spawns buckets”测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">  assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>可能在这一行失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div></pre></td></tr></table></figure>
<p>如果我们刚刚在上一行创建了bucket，这一行为何会失败？</p>
<p>那些发生的失败的原因是因为为了教学目的，我们已经犯两个错误：</p>
<ol>
<li>我们过早地优化（通过增加这个缓存层）</li>
<li>我们使用 cast/2 （但是我们应该使用 call/2 ）</li>
</ol>
<h1 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a><span id="part-two">竞争条件</span></h1><p>在Elixir里做开发不会使得你的代码免于竞争条件。然而，Elixir的简单抽象，默认情况下不共享数据，更容易发现竞争条件的根本原因。</p>
<p>在我们测试里所发生的是，在一个操作和我们可以观察到在ETS表里这个改变的时间之间有一个延迟。下面是我们所期望的事件发生步骤：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>registry创建bucket并修改缓存表</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 {:ok, bucket}</li>
</ol>
<p>但是，因为 KV.Registry.create/2 是一个 cast 操作，这个命令在我们实际写表前返回。换句话说，实际发生的步骤如下：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 :error</li>
<li>registry创建bucket并修改缓存表</li>
</ol>
<p>要修复这个错误，我们需要通过用 call/2 替代 cast/2 来使得 KV.Registry.create/2 成为同步操作。这将保证在修改被写入表后客户端才继续执行。让我们如下所示修改这个函数和它的回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">  GenServer.call(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, _from, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt;</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="symbol">:error</span> -&gt;</div><div class="line">      &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">      ref = Process.monitor(pid)</div><div class="line">      refs = Map.put(refs, ref, name)</div><div class="line">      <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将回调函数从 handle_cast/2 改为 handle_call/3，并且修改它用被创建的bucket的pid作为返回结果。总的来说，Elixir开发者喜欢用 call/2 而不是 cast/2 ，因为 call/2 也提供反压（你被阻塞一直到你获得响应）。在不必要的时候使用 cast/2 也可以被认为是一种过早优化。</p>
<p>让我们再次运行测试，这次，我们将传递 --trace 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> --trace</div></pre></td></tr></table></figure>
<p>当你的测试有死锁或有竞争条件的时候 --trace 选项有用，因为它同步地运行所有测试（async: true 无效了）并且显示每一个测试详细信息。这次我们将减少到一到两个不连续的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes buckets on <span class="built_in">exit</span> (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:19</div><div class="line">   Assertion with == failed</div><div class="line">   code: KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == :error</div><div class="line">   lhs:  &#123;:ok, <span class="comment">#PID&lt;0.109.0&gt;&#125;</span></div><div class="line">   rhs:  :error</div><div class="line">   stacktrace:</div><div class="line">     <span class="built_in">test</span>/kv/registry_test.exs:23</div></pre></td></tr></table></figure>
<p>根据失败消息，我们期望bucket不再存在表里，但是它依然还在！这个问题和我们刚才解决的问题相反：已经解决的问题是在创建bucket的命令和修改表之间有延迟，现在的这个问题是bucket进程死亡和它的信息从表里删除之间存在延迟。</p>
<p>不幸的是，这次我们不能简单地修改负责清理ETS表的 handle_info/2 函数 为同步操作。相反，我们要找到一个方法保证registry已经处理了当bucket崩溃的时候发送给它的 :DOWN 通知。</p>
<p>一个简单的方法来做到这点，就是通过发送一个同步请求给registry：因为消息按顺序被处理，如果registry响应了一个在Agent.stop调用后发送的请求，这就说明 :DOWN 消息已经被处理了。让我们通过创建一个“假的”bucket来做到这点，它是一个在Agent.stop后的同步请求，在两个测试用例里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Kill the bucket and wait for the notification</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Wait until the bucket is dead</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试用例现在应该（一直）通过！</p>
<p>到此我们的优化章节结束。我们用ETS作为一个缓存机制，读取可以从任何进程发起，但是写入依然只能通过一个单独的进程顺序执行。更重要的是，我们也学到，一旦数据可以被异步读取，我们需要明白它可能引入竞争条件。</p>
<p>下一章我们将讨论外部和内部的依赖以及Mix如何帮助我们管理大型代码库。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/ets.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/ets.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;ETS作为缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;竞争条件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！&lt;/p&gt;
&lt;p&gt;在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Elixir/ETS/"/>
    
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－监督者和应用</title>
    <link href="http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/"/>
    <id>http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/</id>
    <published>2017-02-19T11:02:53.000Z</published>
    <updated>2017-02-20T05:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个监督者</a></li>
<li><a href="#part-two">理解应用</a><br> 2.1. <a href="#part-two-one">启动应用</a><br> 2.2. <a href="#part-two-two">应用的回调函数</a><br> 2.3. <a href="#part-two-three">项目或者应用？</a></li>
<li><a href="#part-three">简单的一对一监督者</a></li>
<li><a href="#part-four">监督树</a></li>
<li><a href="#part-five">Observer</a></li>
<li><a href="#part-six">测试里的共享状态</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。</p>
<p>当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。</p>
<p>在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。</p>
<a id="more"></a>
<h1 id="我们第一个监督者"><a href="#我们第一个监督者" class="headerlink" title="我们第一个监督者"></a><span id="part-one">我们第一个监督者</span></h1><p>创建一个监督者和创建一个GenServer没有太大的不同。我们将在文件 lib/kv/supervisor.ex 里定义一个名为 KV.Supervisor 的模块，它将使用 Supervisor 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Registry, [KV.Registry])</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的监督者目前只有一个孩子：registry。如下格式的一个工作者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker(KV.Registry, [KV.Registry])</div></pre></td></tr></table></figure>
<p>将用下面的调用启动一个进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KV.Registry.start_link(KV.Registry)</div></pre></td></tr></table></figure>
<p>我们传递给start_link的入参是这个进程的名字。给在监督树下的进程命名是通用的做法，这样使得其他进程不需要知道它们的pid就可以通过名字来访问它们。这是有用的，因为一个被监督的进程可能崩溃，这样的话，当监督者重启它时，它的pid将改变。通过使用一个名字，我们可以保证新的被重启的进程将注册到同样的名字下，而不用一定获取最新的pid。注意，用定义它的相同的模块的名字来注册进程也是通用的做法，这使得在调试或监测一个运行的系统时更方便直接。</p>
<p>最后，我们用孩子列表和策略 :one_for_one 作为入参调用 supervise/2 。</p>
<p>监督策略规定，当一个孩子进程发生崩溃的时候会发生什么。:one_for_one 的意思是，如果一个孩子进程死了，只有它一个将被重启。因为我们只有一个孩子进程，所有这些就是我们所需的。Supervisor行为支持许多不同的策略，我们将在本章中讨论它们。</p>
<p>因为现在KV.Registry.start_link/1期望有一个入参，我们需要改变我们的实现来接收这样的入参。打开 lib/kv/registry.ex 并替换 start_link/0 的实现如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Starts the registry with the given `name`.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">  GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> name)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们也需要修改我们的测试用例，当启动一个registry的时候给它一个名字。用下面的内容替换 test/kv/registry_test.exs 里的setup回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>setup/2也可以接收测试上下文，和test/3相似。除了我们在设置块中添加的任何值外，上下文还包含一些默认键，例如：:case， :test，:file 和 :line。我们用当前运行的测试的相同名字作为快捷方式来启动一个registry。</p>
<p>现在我们的测试通过，我们可以带我们的监督者兜兜风。如果我们在我们的项目目录里用 iex -S mix 启动一个控制台，我们可以手工启动一个监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Registry.create(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>当我们启动监督者，registry工作者自动被启动，允许我们创建bucket而不需要手工去启动它。</p>
<p>在实践中，我们很少手动启动应用的监督者。相反，它被作为应用的回调的一部分启动。</p>
<h1 id="理解应用"><a href="#理解应用" class="headerlink" title="理解应用"></a><span id="part-two">理解应用</span></h1><p>在这整个时间里我们一直在一个应用里工作。每次我们修改完一个文件并运行 mix compile ，我们会看到在编译输出里有一个 Generated kv app 的消息。</p>
<p>我们可以找到这个被创建的 .app 文件，它在 _build/dev/lib/kv/ebin/kv.app 。让我们看看它的内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;application,kv,</div><div class="line">             [&#123;registered,[]&#125;,</div><div class="line">              &#123;description,<span class="string">"kv"</span>&#125;,</div><div class="line">              &#123;applications,[kernel,stdlib,elixir,logger]&#125;,</div><div class="line">              &#123;vsn,<span class="string">"0.0.1"</span>&#125;,</div><div class="line">              &#123;modules,[<span class="string">'Elixir.KV'</span>,<span class="string">'Elixir.KV.Bucket'</span>,</div><div class="line">                        <span class="string">'Elixir.KV.Registry'</span>,<span class="string">'Elixir.KV.Supervisor'</span>]&#125;]&#125;.</div></pre></td></tr></table></figure>
<p>这个文件包含Erlang数据（用Erlang语法写的）。即使我们不熟悉Erlang，也很容易猜出这个文件有我们应用的定义。它包含我们应用的版本，由它定义的所有模块，以及我们依赖的应用的列表，比如：Erlang的kernel、elixir它自己和在mix.exs文件里的应用列表里指定的logger。</p>
<p>每次我们增加一个新的模块到我们的应用都要手工修改这个文件将会是非常麻烦的。这就是为什么Mix帮我们生成并维护它的原因。</p>
<p>我们也可以通过在我们mix.exs项目文件里自定义 application/0 的返回值来配置被创建的 .app 文件。我们马上将做我们第一个自定义的应用。</p>
<h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a><span id="part-two-one">启动应用</span></h2><p>当我们定义了一个应用规格说明文件：.app 文件，我们就能把应用当做一个整体来启动和停止。目前我们不需要关注这个文件是因为有两个原因：</p>
<ol>
<li>Mix自动为我们启动我们当前的应用。</li>
<li>即使Mix没有启动我们的应用程序，我们的应用程序还没有做任何事情当它启动的时候。</li>
</ol>
<p>不管怎样，让我们看看Mix如何为我们启动应用。让我们用 iex -S mix 启动一个项目的控制台并且进行如下操作：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:already_started</span>, <span class="symbol">:kv</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>哇！它已经启动了。Mix通常启动在我们项目的 mix.exs 文件所定义的整个应用层级的应用；如果这些应用依赖其他应用，它也会同样地为这些所依赖的应用做相同的事情。</p>
<p>我们可以传递一个选项给Mix要求它不要启动我们的应用。让我们运行 iex -S mix run --no-start 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们可以停止我们的 :kv 应用和 :logger应用，:logger应用是由Elixir默认启动的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.stop(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Application.stop(<span class="symbol">:logger</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然后让我们再次启动我们的应用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:not_started</span>, <span class="symbol">:logger</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们得到了一个错误因为 :kv 应用依赖的 :logger 应用没有启动。我们需要按正确顺序手工启动每一个应用或如下所示调用 Application.ensure_all_started ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.ensure_all_started(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, [<span class="symbol">:logger</span>, <span class="symbol">:kv</span>]&#125;</div></pre></td></tr></table></figure>
<p>没有什么真正值得兴奋的，不过它展现了我们如何能控制我们的应用。</p>
<blockquote>
<p>当你运行 iex -S mix 的时候，它相当于运行 iex -S mix run 。所以当你启动IEx无论何时你需要传递更多选项给Mix，一定运行 iex -S mix run ，然后传递任何选项给run命令接收。你可以在你的shell里运行mix help run找到更多关于run的信息。</p>
</blockquote>
<h2 id="应用的回调函数"><a href="#应用的回调函数" class="headerlink" title="应用的回调函数"></a><span id="part-two-two">应用的回调函数</span></h2><p>既然我们花了所有时间来谈论应用如何启动和停止，则必定有方法在应用启动的时候做一些有用的事情。而事实上，有！</p>
<p>我们可以指定一个应用的回调函数。这个函数将在应用启动的时候被调用。这个函数必须返回格式为 {:ok, pid} 的结果，pid是监督者进程的进程标识符。</p>
<p>我们可以用两个步骤来设置应用的回调函数。首先，打开 mix.exs 文件，然后，按如下所示改变 def application ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:mod 选项指定了“应用回调模块”，它后面的参数将在应用启动的时候被传递。应用回调模块可以是任何实现了 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application</a> 行为的模块。</p>
<p>现在我们已经指定了 KV 作为模块回调，我们需要修改定义在 lib/kv.ex 的 KV 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    KV.Supervisor.start_link</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们 use Application 时，我们需要定义一些函数，和当我们使用 Supervisor 或 GenServer 时相似。这次我们只是需要定义一个 start/2 函数。如果我们想在应用结束时指定自定义的行为，我们可以定义一个 stop/1 函数。</p>
<p>让我们再次用 iex -S mix 来启动我们项目的控制台。我们将看到一个名为 KV.Registry 的进程已经在运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create(KV.Registry, &quot;shopping&quot;)</div><div class="line">:ok</div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, &quot;shopping&quot;)</div><div class="line">&#123;:ok, #PID&lt;0.88.0&gt;&#125;</div></pre></td></tr></table></figure>
<p>我们如何知道它是正常运行的？毕竟，我们创建了一个bucket然后查询它；当然，它应该正常运行，对吗？好的，记得 KV.Registry.create/2 使用 GenServer.cast/2 ，因此将返回 :ok ，而不管消息是否找到它的目标。在这个时候，我们不知道监督者和服务器是否起来了，以及bucket是否被创建了。但是， KV.Registry.lookup/2 使用 GenServer.call/3 ，而且将阻塞并等待从服务器返回的结果。我的确得到了正确的响应，所以我们知道所有事情都起来并运行着。</p>
<p>做一个实验，尝试用 GenServer.call/3 替代来重新实现 KV.Registry.create/2 ，并且短暂地使得应用回调不可用。在控制台再次运行上面的代码，你会立即看到创建步骤失败。</p>
<p>记得在继续教程前恢复代码。</p>
<h2 id="项目或者应用？"><a href="#项目或者应用？" class="headerlink" title="项目或者应用？"></a><span id="part-two-three">项目或者应用？</span></h2><p>Mix区分项目和应用。基于我们的mix.exs文件内容，我们可以说我们有一个Mix项目，它定义了一个 :kv 应用。正如我们将在后面章节所看到的，有的项目没有定义任何应用。</p>
<p>当我们说“项目”的时候，你应该考虑Mix。Mix是一种工具，它管理你的项目。它知道如何编译你的项目，测试你的项目等等。它也知道如何编译和启动与你的项目相关的应用程序。</p>
<p>当我们谈论应用的时候，我们谈论的是OTP。应用程序是由运行时作为一个整体来启动和停止的实体。你可以从<a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application的官方文档</a>里学到更多关于应用的内容，也可以通过运行 mix help compile.app 来学到更多在 def application 里被支持的选项。</p>
<h1 id="简单的一对一监督者"><a href="#简单的一对一监督者" class="headerlink" title="简单的一对一监督者"></a><span id="part-three">简单的一对一监督者</span></h1><p>我们现在已经成功地定义了我们的监督者，它作为我们应用生命周期的一部分被自动地启动（和结束）。</p>
<p>然而我们记得在 handle_cast/2 回调函数里，我们的 KV.Registry 同时链接和监测着bucket进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>链接是双向的，这暗示着bucket的崩溃会导致registry的崩溃。虽然我们现在有监督者，它保证registry将被恢复并运行，但是崩溃registry意味着我们丢失所有bucket名字与它们相应进程的关联数据。</p>
<p>换句话说，我们希望registy继续运行，即使一个bucket溃。让我们写一个新的registry测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 用非正常原因停止bucket</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 等待一直到bucket死亡</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个测试用例和“removes bucket on exit”测试用例相似，不同点是我们有点苛刻地发送 :shutdown 作为退出原因替代 :normal 。和 Agent.stop/1 相反，Process.exit/2 是一个异步操作，因此我们不能简单地在发送退出信号后立即调用 KV.Registry.lookup/2 来查询，因为那时还无法保证bucket已死。为解决这个问题，我们在测试期间也监测bucket，一旦我们确认它死掉了，我们才查询registry，这样就避免了条件竞争。</p>
<p>因为bucket被链接到registry，而registry被链接到测试进程，那么杀掉bucket导致registry崩溃，从而导致测试进程也崩溃：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes bucket on crash (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:52</div><div class="line">   ** (EXIT from <span class="comment">#PID&lt;0.94.0&gt;) shutdown</span></div></pre></td></tr></table></figure>
<p>这个问题有一个解决办法，提供一个调用 Agent.start/1 的 KV.Bucket.start/0  ，然后在registry里使用它，删除bucket和registry之间的链接。但是，这是一个坏主意，因为这么修改了后，bucket将不会和任何一个进程链接。这就意味着，如果有人停止 :kv 应用，所有的bucket因为无法被访问而继续存活。不仅如此，如果一个进程是不可被访问的，它们就更难被监测。</p>
<p>我们将通过定义一个新的创建和监督所有bucket的监督者来解决这个问题。有一个监督者策略，叫做 :simple_one_for_one ，它特别适合这样的场景：它允许我们指定一个工作者模板并监督许多基于这个模板的子进程。使用这个策略，没有一个工作者在监督者初始化的时候被启动，而每次通过调用 start_child/2 启动一个新的工作者。</p>
<p>让我们在 lib/kv/bucket/supervisor.ex 文件里定义我们的 KV.Bucket.Supervisor ，内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="comment"># 一个存储监督者名字的简单模块属性</span></div><div class="line">  <span class="variable">@name</span> KV.Bucket.Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> <span class="variable">@name</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_bucket</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_child(<span class="variable">@name</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Bucket, [], <span class="symbol">restart:</span> <span class="symbol">:temporary</span>)</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:simple_one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>和第一个监督者相比这个监督者有三处改变。</p>
<p>首先，我们决定给这个监督者一个本地名字 KV.Bucket.Supervisor 。我们也定义了一个 start_bucket/0 函数，它将启动一个bucket作为叫做 KV.Bucket.Supervisor 监督者的子进程。我们将在registry里直接调用 start_bucket/0 来替换对 KV.Bucket.start_link 的调用。</p>
<p>最后，在 init/1 回调函数里，我们标注工作者是 :temporary 。这意味着，如果一个bucket死了，它不会被重启。这是因为我们只是想用监督者作为一种聚集bucket的机制。</p>
<p>运行 iex -S mix  ，我们来试试我们新的监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Bucket.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(bucket, <span class="string">"eggs"</span>, <span class="number">3</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(bucket, <span class="string">"eggs"</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>让我们修改registry，用KV.Bucket.Supervisor 来重写bucket如何被重启：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们按上述所示进行了修改，我们的测试用例将失败，因为没有bucket监督者。让我们来自动启动bucket监督者作为我们主监督树的一部分来替代每次测试都直接地启动bucket监督者。</p>
<h1 id="监督树"><a href="#监督树" class="headerlink" title="监督树"></a><span id="part-four">监督树</span></h1><p>为了在我们的应用里使用bucket监督者，我们需要把它加进 KV.Supervisor 的子进程了。注意：我们开始有监督其他监督者的监督者，形成所谓的“监督树”。</p>
<p>打开 lib/kv/supervisor.ex ，按如下所示修改 init/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这次我们增加一个监督者作为一个子进程，没有用参数来启动它。重新运行测试套件，现在所有测试用例都将通过。</p>
<p>因为我们增加了更多的子进程给监督者，所以评估 :one_for_one 监督策略是否依然正确也很重要。有一个瑕疵马上显现出来，就是 KV.Registry 工作者进程和 KV.Bucket.Supervisor 监督者进程之间的关系。如果 KV.Registry 死了，所有链接 KV.Bucket 名字到 KV.Bucket 进程的信息丢失，而且因此 KV.Bucket.Supervisor 也必须死，否则，它管理的 KV.Bucket 进程将成为孤儿。</p>
<p>根据这一观察，我们应该考虑转移到另一个监督策略。另外两个候选者是：:one_for_all 和 :rest_for_one 。一个监督者使用 :one_for_all 策略，则无论何时它任何一个子进程死亡，它将杀掉和重启它所有的子进程。乍一看，这似乎适合我们的使用情况，但它似乎也有点霸道，因为如果 KV.Bucket.Supervisor 死了，KV.Registry 是完全能够清理它自己的。在这种情况下，:rest_for_one 策略就派上用场了：当一个进程崩溃了，监督者将只是杀掉和重启在崩溃子进程后启动的子进程。让我们重写我们的监督树，用这个策略来替代原来的策略：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:rest_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，如果 KV.Registry 工作者崩溃，则 KV.Registry 和 KV.Supervisor 的“剩余”子进程（即 KV.Bucket.Supervisor ）将被重启。但是，如果 KV.Bucket.Supervisor 崩溃了，KV.Registry 将不会被重启，因为它先于 KV.Bucket.Supervisor 启动。</p>
<p>还有其他的策略和其他的选项可以给 worker/2，supervisor/2 和 supervise/2 函数，所以不要忘了仔细阅读 <a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor</a> 和 <a href="https://hexdocs.pm/elixir/Supervisor.Spec.html" target="_blank" rel="external">Supervisor.Spec</a> 模块的文档。</p>
<p>为了帮助开发者记住如何使用 Supervisor 和它方便的函数，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a> 已经创建了 <a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/Supervisor_CheatSheet.pdf" target="_blank" rel="external">Supervisor备忘录</a> 。</p>
<p>在我们转到下一章前还剩下两个话题。</p>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><span id="part-five">Observer</span></h1><p>现在我们已经定义了我们的监督树，这是一个很好的机会介绍Erlang自带的Observer工具。用 iex -S mix 启动你的应用，然后在里面输入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:observer</span>.start</div></pre></td></tr></table></figure>
<p>一个包含我们系统的所有各类信息的图形界面弹出来，信息包括从总的统计到负载图，也有所有运行的进程和应用的列表。</p>
<p>在应用标签卡里，你将看到你的系统里的所有当前运行的应用以及它们的监督树。你可以选择 kv 应用来进一步浏览它：</p>
<p><img src="/images/getting-started-mix-otp-supervisor-and-application-kv-observer.png" style="border:0;"></p>
<p>不仅如此，当你在终端创建一个新的bucket的时候，你将在Observer里看到被新创建的进程在监督树里展示出来。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create KV.Registry, <span class="string">"shopping"</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们将留给你进一步探索Observer提供了什么。记住，你可以双击监督树里的任何进程来获取这个进程的更多信息，也可以右击一个进程来发送“一个杀死信号”，这是一个完美的方式来模拟失败并看看你的监督者是否如预期地响应。</p>
<p>在一天结束之际，像Observer这样的工具是你想要总是在监督树内启动进程，即使他们是暂时的，以确保它们总是可以到达和监测的主要原因之一。</p>
<h1 id="测试里的共享状态"><a href="#测试里的共享状态" class="headerlink" title="测试里的共享状态"></a><span id="part-six">测试里的共享状态</span></h1><p>到目前为止，我们已经为每一个测试用例启动一个registry来确保它们是被隔离的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>既然我们现在已经改变了我们的registry来使用 KV.Bucket.Supervisor ，它被全局注册，我们的测试现在依靠这个共享、全局的监督者，尽管每个测试用例都有自己的registry。问题是：我们应该这样做吗？</p>
<p>这取决于只要我们只依赖于这个状态的非共享部分，就可以依赖共享的全局状态。例如，每次我们用给定的名字注册一个进程，我们就是正在对应于一个共享了名字的registry来注册一个进程。然而，只要我们通过使用像 context.test 这样的结构来保证这个名字对于每一个测试用例都是特定的，我们就不会在测试用例之间有并发或者数据依赖的问题。</p>
<p>类似的推理应适用于我们的bucket监督者。虽然在共享的bucket监督者上多个registry可能启动bucket，但是那些bucket和registry是彼此隔离的。如果我们使用像 Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数，我们只会遇到并发问题；Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数从所有registry统计所有的bucket数量，当测试用例并发地运行的时候，潜在获得不同结果的问题。</p>
<p>因为我们目前只依赖bucket监督者的非共享部分，因此在我们的测试套件里我们不需要担心并发问题。万一它成为一个问题，我们可以每一个测试用例启动一个监督者并且把它作为入参传递给registry的start_link函数。</p>
<p>现在，我们的应用得到适当的监督和测试，让我们看看如何可以加快速度。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个监督者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;理解应用&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;启动应用&lt;/a&gt;&lt;br&gt; 2.2. &lt;a href=&quot;#part-two-two&quot;&gt;应用的回调函数&lt;/a&gt;&lt;br&gt; 2.3. &lt;a href=&quot;#part-two-three&quot;&gt;项目或者应用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;简单的一对一监督者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;监督树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Observer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;测试里的共享状态&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。&lt;/p&gt;
&lt;p&gt;当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。&lt;/p&gt;
&lt;p&gt;在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Supervisor Application" scheme="http://szpzs.oschina.io/categories/Elixir/Supervisor-Application/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Supervisor" scheme="http://szpzs.oschina.io/tags/Supervisor/"/>
    
      <category term="Application" scheme="http://szpzs.oschina.io/tags/Application/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－GenServer</title>
    <link href="http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/"/>
    <id>http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/</id>
    <published>2017-02-18T04:05:34.000Z</published>
    <updated>2017-02-20T05:50:29.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个GenServer</a></li>
<li><a href="#part-two">测试一个GenServer</a></li>
<li><a href="#part-three">监测的必要性</a></li>
<li><a href="#part-four">call、cast还是info？</a></li>
<li><a href="#part-five">监测还是链接？</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在<a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">上一章</a>我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>, <span class="symbol">name:</span> <span class="symbol">:shopping</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而<strong>我们不应该将用户输入转换为原子</strong>。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！</p>
<p>在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。</p>
<p>我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。</p>
<p>注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。</p>
<p>我们将使用一个 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。</p>
<a id="more"></a>
<h1 id="我们第一个GenServer"><a href="#我们第一个GenServer" class="headerlink" title="我们第一个GenServer"></a><span id="part-one">我们第一个GenServer</span></h1><p>一个GenServer被实现为两部分：客户端API和服务端回调函数。你既可以把这两部分合并到一个单独的模块里，也可以把它们分拆到一个客户端模块和一个服务端模块。客户端和服务端分别运行在隔离的进程里，客户端和服务端来回传递消息，而服务器在内部基于收到的消息而调用相关的函数。本文我们将用一个单独的模块来容纳客户端API和服务端回调函数。</p>
<p>创建一个文件 lib/kv/registry.ex ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## Client API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.call(server, &#123;<span class="symbol">:lookup</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server Callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, %&#123;&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, names) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), names&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, names) <span class="keyword">do</span></div><div class="line">    if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:noreply</span>, names&#125;</div><div class="line">    else</div><div class="line">      &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">      &#123;<span class="symbol">:noreply</span>, Map.put(names, name, bucket)&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个函数是 start_link/3 ，它接收三个入参来启动一个新的GenServer：</p>
<ol>
<li>服务端回调函数被实现所在模块，本例子里是 __MODULE__ ，意思就是当前模块。</li>
<li>初始化参数，本例子里是原子 :ok 。</li>
<li>一个选项列表，它可以被用来指定一些事项，比如服务器名字。本例子里我们传递了一个空列表。</li>
</ol>
<p>有两种类型请求你可以发送给一个GenServer：call 和 cast。call是同步的，服务端<strong>必须</strong>发送一个响应给这一个的请求。cast是异步的，服务端不需要返回响应。</p>
<p>接下来的两个函数，lookup/2 和 create/2 负责发送这些请求给服务端。在本例子中，我们分别用 {:lookup, name} 和 {:create, name} 作为请求消息。请求消息常常被指定为元组，就像本例一样，是为了在第一个参数位置提供多于一个“参数”。通常指定请求的动作作为元组的第一个元素，而剩下的元素作为该动作的参数。注意：请求必需匹配 handle_call/3 或 handle_cast/2 的第一个入参。</p>
<p>上面讲的就是客户端API。在服务器这边，我们可以实现各种各样的回调函数来保证服务器的初始化、终止和处理请求。那些回调函数是可选的，目前我们只实现我们所关心的。</p>
<p>第一个是 init/1 回调函数，它接收传给 GenServer.start_link/3 的参数并且返回 {:ok, state} ，此处的状态是一个新的映射。我们可能已经注意到GenServer的API是如何使得客户端和服务端隔离的更明显的。start_link/3 在客户端，而它所对应的回调函数 init/1 运行在服务端。</p>
<p>对应于 call/2 的请求，我们实现一个 handle_call/3 回调函数来接收它的请求、请求的来源进程（_from），以及当前服务器状态（state）。handle_call/3 回调函数返回一个格式为 {:reply, reply, new_state} 的元组。这个元组的第一个元素，:reply ，表明服务器将发送一个应答给客户端。第二个元素，reply，就是发送给客户端的应答。而第三个元素，new_state，是一个新的服务器状态。</p>
<p>对应于 cast/2 的请求，我们实现了一个 handle_cast/2 回调函数来接收它的请求和当前服务器状态（state）。handle_cast/2  回调函数返回一个格式为 {:noreply, new_state} 的元组。注意：在一个真实的应用里，可能应该用同步调用的方式为 :create 实现回调函数来替换异步的cast函数。我们在本例里这么做是为了说明如何实现一个cast函数的回调。</p>
<p>handle_call/3 和 handle_cast/2 函数还有其他格式的返回元组。也有其他的回调函数我们可以实现，比如：terminate/2 和 code_change/3 。欢迎你探索<a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">整个GenServer文档</a>以了解关于这方面的更多内容。</p>
<p>现在，让我们写一些测试来保证我们的GenServer如我们所期望地工作。</p>
<h1 id="测试一个GenServer"><a href="#测试一个GenServer" class="headerlink" title="测试一个GenServer"></a><span id="part-two">测试一个GenServer</span></h1><p>测试一个GenServer和测试一个Agent没有太大的不同。我们将在测试的setup回调函数里创建一个服务器，并在我们整个测试中使用它。创建一个文件：test/kv/registry_test.exs ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RegistryTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">    KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">    assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试应该毫无阻碍地通过！</p>
<p>你不需要明确地停掉registry，因为当我们的测试结束的时候，它将收到一个 :shutdown 信号。虽然这么处理相应的测试来说没问题。但是如果需要将停止一个GenServer作为一个应用里逻辑的一部分，那么你可以使用 GenServer.stop/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Stops the registry.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">  GenServer.stop(server)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="监测的必要性"><a href="#监测的必要性" class="headerlink" title="监测的必要性"></a><span id="part-three">监测的必要性</span></h1><p>我们的registry几乎完成了。仅剩的问题是，如果一个bucket停止或崩溃了，registry的数据可能会变得过时。让我们增加一个测试用例到 KV.RegistryTest 来揭示这个bug：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的测试用例将在最后的断言处失败，因为bucket的名字还保留在registry里，即使在我们停止了bucket进程后。</p>
<p>为了修复这个bug，我们需要registry监测每一个由它创建的bucket。一旦我们设置了监测，每次bucket退出的时候，registry将收到一个通知，允许我们来清理字典。</p>
<p>让我们用 iex -S mix 启动一个新的控制台，先来玩一下监测：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; Process.monitor(pid)</div><div class="line"><span class="comment">#Reference&lt;0.0.0.551&gt;</span></div><div class="line">iex&gt; Agent.stop(pid)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; flush()</div><div class="line">&#123;<span class="symbol">:DOWN</span>, <span class="comment">#Reference&lt;0.0.0.551&gt;, :process, #PID&lt;0.66.0&gt;, :normal&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Process.monitor(pid) 返回一个唯一的引用，这允许我们匹配将要到来的消息，从而监测引用。我们停止Agent后，我们可以 flush/0 所有消息，注意到：一个 :DOWN 消息到达，带着与monitor返回的一样的引用，告诉我们，bucket进程因为 :normal 原因退出。</p>
<p>让我们重新实现服务端回调函数来修复这个bug并使得测试通过。首先，我们将修改GenServer的状态为两个字典：一个包含 name -&gt; pid ，另一个包含 ref -&gt; name。然后我们需要在 handle_cast/2 里监测bucket，也实现一个 handle_info/2 回调函数来处理监测消息。所有服务端回调函数的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 服务端回调函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  names = %&#123;&#125;</div><div class="line">  refs  = %&#123;&#125;</div><div class="line">  &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, &#123;names, <span class="number">_</span>&#125; = state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), state&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">  names = Map.delete(names, name)</div><div class="line">  &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意，我们能够在不改变任何客户端API的情况下，大幅度地改变服务器实现。这就是明确地隔离服务器和客户端的好处之一。</p>
<p>最后，不同于其他回调函数，我们为 handle_info/2 回调函数定义了一个“catch-all”分支，它丢弃任何未知的消息。想知道为什么，请移步下一节。</p>
<h1 id="call、cast还是info？"><a href="#call、cast还是info？" class="headerlink" title="call、cast还是info？"></a><span id="part-four">call、cast还是info？</span></h1><p>我们已经用了三个回调函数：handle_call/3，handle_cast/2 和 handle_info/2。现在我们要考虑什么时候决定和什么时候使用它们：</p>
<ol>
<li>handle_call/3 必须用于同步请求。这应该是等待服务器的回复是一个有用的反压机制的默认选择。</li>
<li>handle_cast/2 必须用于异步请求，而且当你不关心响应的时候。cast甚至不保证服务端收到了消息，因此，它应该尽量少用。例如，本章我们已经定义的 create/2 函数应该使用 call/2 。我们使用 cast/2 是为了教学目的。</li>
<li>handle_info/2 必须用于服务端接收到的不是GenServer.call/2 或 GenServer.cast/2发送的其他所有消息，包括了用send/2发送的普通消息。监测消息 :DOWN 就是其中的例子。</li>
</ol>
<p>因为任何消息，包括send/2方式的消息都由handle_info/2处理，则有机会不期望的消息到达服务器。因此，如果我们没有定义catch-all分支，那些消息将导致我们的registry崩溃，因为没有分支可以匹配它们。但是我们却不用担心这样的情况发生在handle_call/3 和 handle_cast/2。call和cast只能通过GenServer的API来做，所以一个未知消息就十分可能是由开发者的错误造成。</p>
<p>为了帮助开发者记住call，cast 和 info之间的区别，它们支持的返回值以及其他知识，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a>已经创建了非常棒的<a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf" target="_blank" rel="external">GenServer备忘录</a>.</p>
<h1 id="监测还是链接？"><a href="#监测还是链接？" class="headerlink" title="监测还是链接？"></a><span id="part-five">监测还是链接？</span></h1><p>我们已经在Process这章学习了链接。现在，我们完成了registry模块，我们可能想知道：什么时候我们应该用监测而什么时候我们应该用链接？</p>
<p>链接是双向的。如果你链接了两个进程，其中一个进程崩溃，则另一个进程也将崩溃（除非它捕获了退出信号）。监测是单向的：只有监测的进程才收到关于被监测进程的通知。也就是说：当你想链接崩溃的时候使用链接，而当你只是想获得崩溃、退出等的信息的时候就使用检测。</p>
<p>回到我们的 handle_cast/2 实现，你可以看到registry既链接也监测bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>这是一个坏注意，因为我们不想我们的registry在bucket崩溃的时候也崩溃！我们通常避免直接创建进程，而是把这个责任委托给监督者。正如我们将在下一章所见，监督者依赖于链接，这就解释了为什么基于链接的API（spawn_link，start_link，等）在Elixir和OTP里很普遍。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/genserver.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个GenServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;测试一个GenServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;监测的必要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;call、cast还是info？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;监测还是链接？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/agent.html&quot;&gt;上一章&lt;/a&gt;我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; Agent.start_link(&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; -&amp;gt; %&amp;#123;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;:ok&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;#PID&amp;lt;0.43.0&amp;gt;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; KV.Bucket.put(&lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;milk&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;:ok&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; KV.Bucket.get(&lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;milk&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而&lt;strong&gt;我们不应该将用户输入转换为原子&lt;/strong&gt;。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！&lt;/p&gt;
&lt;p&gt;在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。&lt;/p&gt;
&lt;p&gt;我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。&lt;/p&gt;
&lt;p&gt;注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。&lt;/p&gt;
&lt;p&gt;我们将使用一个 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="GenServer" scheme="http://szpzs.oschina.io/categories/Elixir/GenServer/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="GenServer" scheme="http://szpzs.oschina.io/tags/GenServer/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Agent</title>
    <link href="http://szpzs.oschina.io/2017/02/17/elixir-getting-started-mix-otp-agent/"/>
    <id>http://szpzs.oschina.io/2017/02/17/elixir-getting-started-mix-otp-agent/</id>
    <published>2017-02-17T12:54:47.000Z</published>
    <updated>2017-02-20T05:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">状态的麻烦</a></li>
<li><a href="#part-two">Agents</a></li>
<li><a href="#part-three">用ExUnit回调函数设置测试</a></li>
<li><a href="#part-four">其他Agent动作</a></li>
<li><a href="#part-five">Agent的Client/Server</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将创建一个名为 KV.Bucket 的模块。这个模块将以某种方式存储我们的键值对实体，并允许其他进程读取和修改它们。</p>
<p>如果你跳过了入门教程或已经读过了很长时间，你应该重新读一下<a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">进程</a>这一章。我们将用它作为起始点。</p>
<a id="more"></a>
<h1 id="状态的麻烦"><a href="#状态的麻烦" class="headerlink" title="状态的麻烦"></a><span id="part-one">状态的麻烦</span></h1><p>Elixir是一门不可修改的语言，也就是说默认情况下是没有任何东西是共享的。如果我们想要提供状态，在状态里我们创建“桶”，从其他地方可以放置和读取“桶”里的数据，我们在Elixir有两种主要的选择：</p>
<ul>
<li>进程</li>
<li><a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ETS（Erlang Term Storage）</a></li>
</ul>
<p>我们已经谈论过进程，而ETS是个新事物，我们将在本教程的后面讨论它。当需要使用进程的时候，我们几乎没有自己亲自处理它的，反而是使用Elixir和OTP里可用的进程抽象：</p>
<ul>
<li><a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent</a> - 对状态的简单封装</li>
<li><a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> - “通用服务器”（进程），它封装状态，提供同步和异步调用，支持代码重载等等。</li>
<li><a href="https://hexdocs.pm/elixir/GenEvent.html" target="_blank" rel="external">GenEvent</a> - “通用事件”管理器，它允许发布事件给多个处理者。</li>
<li><a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a> - 计算的异步单元，它允许创建一个进程并且在稍后获取它的结果。</li>
</ul>
<p>我们将在本教程里探讨这些抽象中的大多数。我们要记住：它们都是基于进程之上的实现，使用了Erlang虚拟机提供的基本特性，比如：send、receive、spawn和link。</p>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a><span id="part-two">Agents</span></h1><p><a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent</a>是状态的简单封装。如果你想要从一个进程的所有所得是保持状态，那么agent非常合适。让我们在项目里启动一个iex会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex -S mix</div></pre></td></tr></table></figure>
<p>并且玩一下agent：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, agent&#125; = Agent.start_link <span class="keyword">fn</span> -&gt; [] <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.57.0&gt;&#125;</span></div><div class="line">iex&gt; Agent.update(agent, <span class="keyword">fn</span> list -&gt; [<span class="string">"eggs"</span> | list] <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Agent.get(agent, <span class="keyword">fn</span> list -&gt; list <span class="keyword">end</span>)</div><div class="line">[<span class="string">"eggs"</span>]</div><div class="line">iex&gt; Agent.stop(agent)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们用一个空列表作为初识状态来启动一个agent。我们修改agent的状态，增加我们新的元素到列表头部。<a href="https://hexdocs.pm/elixir/Agent.html#update/3" target="_blank" rel="external">Agent.update/3</a> 的第二个入参是一个函数，这个函数将agent的当前状态作为输入并返回它期望的新状态。最后，我们获取整个列表。<a href="https://hexdocs.pm/elixir/Agent.html#get/3" target="_blank" rel="external">Agent.get/3</a> 的第二个入参是一个函数，这个函数把状态当做输入，然后返回 <a href="https://hexdocs.pm/elixir/Agent.html#get/3" target="_blank" rel="external">Agent.get/3</a> 将返回的值。一旦我们用完agent，我们可以调用 <a href="Agent.stop/3">Agent.stop/3</a> 来终止agent进程。</p>
<p>让我们用agent来实现我们的 KV.Bucket 。不过在开始实现之前，让我们首先写一些测试用例。创建一个文件 test/kv/bucket_test.exs （记住后缀是 .exs），内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.BucketTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"stores values by key"</span> <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="keyword">nil</span></div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">3</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们第一个测试用例启动一个新的 KV.Bucket 并且在其上执行一些 get/2 和 put/3 操作，断言结果。我们不需要明确地停止agent因为它被链接到测试进程，一旦测试结束agent自动地结束。这将一直有效除非这个进程被命名。</p>
<p>也请注意：async: true 选项被传给 ExUnit.Case 。这个选项通过使用我们机器的多核使得这个测试用例和其他 :async 测试用例平行地运行。这对加速我们的测试套件非常有用。但是， :async 必需在不依赖或修改任何全局值的情况下才能被设置。例如，如果测试需要写文件系统、注册进程或访问数据库，那么就保持它为同步的（删除 :async 选项）以避免测试之间的竞争条件。</p>
<p>不管异步与否，我们新的测试将明显会失败，因为被测试的模块里任何一个功能都没有实现。</p>
<p>为了修复失败的测试，让我们创建一个文件： lib/kv/bucket.ex ，它的内容如下所示。在看下面内容前，你自己尝试一下用agent实现 KV.Bucket 模块。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts a new bucket.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Gets a value from the `bucket` by `key`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">    Agent.get(bucket, &amp;Map.get(&amp;<span class="number">1</span>, key))</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Puts the `value` for the given `key` in the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(bucket, key, value) <span class="keyword">do</span></div><div class="line">    Agent.update(bucket, &amp;Map.put(&amp;<span class="number">1</span>, key, value))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用一个映射来保存我们的键和值。捕获运算符，&amp; ，在<a href="http://elixir-lang.org/getting-started/modules-and-functions.html#function-capturing" target="_blank" rel="external">入门教程</a>里有介绍。</p>
<p>现在 KV.Bucket 模块已经被定义，我们的测试应该pass！你可以运行 mix test 来尝试一下。</p>
<h1 id="用ExUnit回调函数设置测试"><a href="#用ExUnit回调函数设置测试" class="headerlink" title="用ExUnit回调函数设置测试"></a><span id="part-three">用ExUnit回调函数设置测试</span></h1><p>在继续往 KV.Bucket 添加更多功能之前，我们来讨论一下 ExUnit 的回调函数。正如你所期望的，所有KV.Bucket的测试用例在设置和测试后停止期间将需要一个启动的bucket。幸运的是，ExUnit支持回调函数来允许我们来跳过这样的重复任务。</p>
<p>让我们用回调函数来重新写测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.BucketTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">bucket:</span> bucket&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"stores values by key"</span>, %&#123;<span class="symbol">bucket:</span> bucket&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="keyword">nil</span></div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">3</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们首先在 setup/1 宏的帮助下定义了一个设置回调。在每次测试之前，在与测试本身相同的过程中运行setup/1 回调。</p>
<p>注意我们需要一种机制从回调传递 bucket 的pid给测试用例。我们使用测试上下文来做这种机制。当我们从回调返回 {:ok, bucket: bucket} ，ExUnit将元组的第二个元素（一个字典）合并到测试上下文。测试上下文是一个映射，我们可以在测试定义匹配它，在代码块里访问这些值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"stores values by key"</span>, %&#123;<span class="symbol">bucket:</span> bucket&#125; <span class="keyword">do</span></div><div class="line">  <span class="comment"># `bucket` 正是从setup传递过来的bucket</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你可以在<a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case模块文档</a>里读到更多关于ExUnit用例的内容，在<a href="https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html" target="_blank" rel="external">ExUnit.Callbacks文档</a>里读到更多回调的内容。</p>
<h1 id="其他Agent动作"><a href="#其他Agent动作" class="headerlink" title="其他Agent动作"></a><span id="part-four">其他Agent动作</span></h1><p>除了获取一个值和修改agent状态，agent允许我们通过 Agent.get_and_update/2 在一个函数调用里获取一个值并且修改agent状态。让我们实现KV.Bucket.delete/2函数，它从bucket删除一个键并返回它的当前值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Deletes `key` from `bucket`.</div><div class="line"></div><div class="line">Returns the current value of `key`, if `key` exists.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Agent.get_and_update(bucket, &amp;Map.pop(&amp;<span class="number">1</span>, key))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在轮到你写一个上面代码的测试用例！另外，要阅读一下<a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent模块的文档</a>学习更多内容。</p>
<h1 id="Agent的Client-Server"><a href="#Agent的Client-Server" class="headerlink" title="Agent的Client/Server"></a><span id="part-five">Agent的Client/Server</span></h1><p>在我们转到下一章内容前，让我们讨论一下agent里的客户端/服务端的概念。让我们展开我们刚刚实现的delete/2函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Agent.get_and_update(bucket, <span class="keyword">fn</span> dict-&gt;</div><div class="line">    Map.pop(dict, key)</div><div class="line">  <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在函数内我们传递给agent的所有内容都发生在agent进程中。在这个场景里，因为agent进程是接收和相应我们消息的，那么我们说agent进程是服务器。函数外不的所有事情发生在客户端。</p>
<p>这个区分很重要。如果有耗时的动作要做，你必须要考虑是在服务端还是在客户端执行这些操作更好。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Process.sleep(<span class="number">1000</span>) <span class="comment"># puts client to sleep</span></div><div class="line">  Agent.get_and_update(bucket, <span class="keyword">fn</span> dict -&gt;</div><div class="line">    Process.sleep(<span class="number">1000</span>) <span class="comment"># puts server to sleep</span></div><div class="line">    Map.pop(dict, key)</div><div class="line">  <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当一个长时间的动作在服务器上执行，则所有对这个特定服务器的其他请求将一直等待到这个动作完成才能得到处理，这可能导致一些客户端超时。</p>
<p>在下一章，我们将探讨GenServers，它的客户机和服务器之间的隔离变得更加明显。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/agent.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;状态的麻烦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Agents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;用ExUnit回调函数设置测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;其他Agent动作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Agent的Client/Server&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将创建一个名为 KV.Bucket 的模块。这个模块将以某种方式存储我们的键值对实体，并允许其他进程读取和修改它们。&lt;/p&gt;
&lt;p&gt;如果你跳过了入门教程或已经读过了很长时间，你应该重新读一下&lt;a href=&quot;http://elixir-lang.org/getting-started/processes.html&quot;&gt;进程&lt;/a&gt;这一章。我们将用它作为起始点。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Agent" scheme="http://szpzs.oschina.io/categories/Elixir/Agent/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Agent" scheme="http://szpzs.oschina.io/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Mix简介</title>
    <link href="http://szpzs.oschina.io/2017/02/16/elixir-getting-started-mix-otp-introduction-to-mix/"/>
    <id>http://szpzs.oschina.io/2017/02/16/elixir-getting-started-mix-otp-introduction-to-mix/</id>
    <published>2017-02-16T07:54:20.000Z</published>
    <updated>2017-02-16T08:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个项目</a></li>
<li><a href="#part-two">项目编译</a></li>
<li><a href="#part-three">运行测试</a></li>
<li><a href="#part-four">环境</a></li>
<li><a href="#part-five">探索</a></li>
</ol>
<p>在本教程里，我们将学习如何构建一个完整的Elixir应用，该应用有自己的监督树、配置、测试等等。</p>
<p>这个应用是一个分布式键值对存储。我们将组织键值对到容器中，然后跨多节点分布这些容器。我们也将构建一个简单的客户端来让我们连接到那些节点中的任何一个，并且像如下所示发送请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>为了构建我们的键值对应用，我们将使用三个主要工具：</p>
<ul>
<li>OTP（开放电信平台）是一个Erlang自带的库的集合。Erlang开发者用OTP来构建健壮、容错的应用。在本章中我们将探讨OTP和Elixir整合有多少方面，包括监督树、事件管理器等等；</li>
<li>Mix是一个Elixir自带的构建工具，它为创建、编译、测试你的应用、管理应用的依赖等等提供任务；</li>
<li>ExUnit是一个Elixir自带的基于单元测试的框架。</li>
</ul>
<p>在本章里，我们将用Mix创建我们的第一个项目，然后逐步探索OTP、Mix和ExUnit里的不同特性。</p>
<blockquote>
<p>注意：本教程需要Elixir v1.2.0 或者更高版本。你可以用 elixir –version 来检查你的Elixir版本并且如果需要的话，你可以按 <a href="http://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="external">Elixir入门教程第一章里</a> 描述的步骤安装一个最新的版本。</p>
<p>如果你对本教程有任何疑问或改进建议请到诸如 <a href="https://elixirforum.com/" target="_blank" rel="external">Elixir论坛</a> 或 <a href="https://github.com/elixir-lang/elixir-lang.github.com/issues" target="_blank" rel="external">问题跟踪</a> 告诉我们。你的建议对我们的教程真的很重要。</p>
<p>最后，本教程的代码在这个<a href="https://github.com/josevalim/kv_umbrella" target="_blank" rel="external">仓库</a>里，你可以把它当做参考。</p>
</blockquote>
<a id="more"></a>
<h1 id="我们第一个项目"><a href="#我们第一个项目" class="headerlink" title="我们第一个项目"></a><span id="part-one">我们第一个项目</span></h1><p>当你安装Elixir的时候，除了得到 elixir、elixirc 和 iex 这些可执行文件，你也得到一个叫做Mix的可执行Elixir脚本。</p>
<p>让我们从命令行通过调用 mix new 创建我们的第一个项目。我们将传递项目名字作为这个命令的参数（在这个例子里项目名字是kv），并且告诉Mix我们的主模块应该是全部大写的KV，而不是默认的Kv：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix new kv --module KV</div></pre></td></tr></table></figure>
<p>Mix将创建一个名为kv的目录，并在这个目录里创建一些文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* creating README.md</div><div class="line">* creating .gitignore</div><div class="line">* creating mix.exs</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div><div class="line">* creating lib</div><div class="line">* creating lib/kv.ex</div><div class="line">* creating <span class="built_in">test</span></div><div class="line">* creating <span class="built_in">test</span>/test_helper.exs</div><div class="line">* creating <span class="built_in">test</span>/kv_test.exs</div></pre></td></tr></table></figure>
<p>让我们简单地看一下那些被创建的文件：</p>
<blockquote>
<p>注意：Mix是一个Elixir可执行文件。这就是说要运行mix，你需要在你的路径里有Elixir可执行文件。如果没有，你可以通过传递这个脚本作为Elixir的参数来运行它：</p>
<pre><code>$ bin/elixir bin/mix new kv --module KV
</code></pre><p>注意：你也可以通过 -S 选项用Elixir执行你路径里的任何脚本：</p>
<pre><code>$ bin/elixir -S mix new kv --module KV
</code></pre><p>当使用 -S 的时候，Elixir在你的路径里找到脚本并执行它。</p>
</blockquote>
<h1 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a><span id="part-two">项目编译</span></h1><p>在我们新项目的目录（kv）里一个名为mix.exs被创建出来，它的主要职责是配置我们的项目。让我们来看看它（注释被删除）:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.3"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps()]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>]]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的mix.exs定义了两个公共函数：project和application。project返回项目的配置，比如，项目名字和版本；application被用来生成一个应用文件。</p>
<p>还有一个名字为 deps 的私有函数，它被project函数调用，它定义我们项目的依赖。定义 deps 作为一个独立函数不是必需的，但是它有助于我们项目配置的整洁。</p>
<p>Mix也用一个简单模块定义来创建了文件 lib/kv.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样的结构已经足够编译我们的项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv</div><div class="line">$ mix compile</div></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Compiling 1 file (.ex)</div><div class="line">Generated kv app</div></pre></td></tr></table></figure>
<p>lib/kv.ex文件被编译，一个名为 kv.app 的应用清单被创建，并且<a href="http://elixir-lang.org/getting-started/protocols.html#protocol-consolidation" target="_blank" rel="external">如入门教程里所描述的一样，所有协议被整合</a>。所有编译产出物用 mix.exs文件里的选项被置于 _build 目录里，。</p>
<p>一旦项目被编译，你就可以如下所示在项目里启动一个iex会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex -S mix</div></pre></td></tr></table></figure>
<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a><span id="part-three">运行测试</span></h1><p>Mix也创建合适的结构来运行我们的项目测试。Mix项目通常遵循这样的习惯，就是lib目录里的每一个文件，在test目录里都有对应的一个文件，文件名格式为：&lt;filename&gt;_test.exs 。正因为这个缘故，我们已经可以找到一个 test/kv_test.exs 文件对应于我们的 lib/kv.ex 文件。它当前还没有做太多功能：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line">  doctest KV</div><div class="line"></div><div class="line">  test <span class="string">"the truth"</span> <span class="keyword">do</span></div><div class="line">    assert <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>重要的是要注意两点：</p>
<ol>
<li>测试文件是Elixir脚本文件（.exs）。这样很方便，因为我们不需要在运行它们前编译它们。</li>
<li>我们定义一个名为 KVTest 的测试模块，用 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case</a> 来注入测试API，并且用 test/2 宏定义一个简单的测试用例。</li>
</ol>
<p>Mix也创建了一个名为 test/test_helper.exs 的文件，它负责设置测试框架：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExUnit.start()</div></pre></td></tr></table></figure>
<p>每一次我们运行我们的测试前，这个文件将被Mix自动 require 。我们可以用 mix test 来运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Compiled lib/kv.ex</div><div class="line">Generated kv app</div><div class="line">[...]</div><div class="line">.</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.04 seconds (0.04s on load, 0.00s on tests)</div><div class="line">1 <span class="built_in">test</span>, 0 failures</div><div class="line"></div><div class="line">Randomized with seed 540224</div></pre></td></tr></table></figure>
<p>注意：通过运行 mix test ，Mix再一次编译源文件并且创建应用文件。这是因为Mix支持多环境，这个我们将在下一节讨论。</p>
<p>而且，你可以看到ExUnit为一个成功的测试用例打印一个点号，而且也自动地随机化测试。让我们故意让测试失败，看看会发生什么。</p>
<p>如下一样修改 test/kv_test.exs 里的断言：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></div></pre></td></tr></table></figure>
<p>现在我们再次运行 mix test （注意，这次没有编译）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  1) <span class="built_in">test</span> the truth (KVTest)</div><div class="line">     <span class="built_in">test</span>/kv_test.exs:5</div><div class="line">     Assertion with == failed</div><div class="line">     code: 1 + 1 == 3</div><div class="line">     lhs:  2</div><div class="line">     rhs:  3</div><div class="line">     stacktrace:</div><div class="line">       <span class="built_in">test</span>/kv_test.exs:6</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.05 seconds (0.05s on load, 0.00s on tests)</div><div class="line">1 <span class="built_in">test</span>, 1 failure</div></pre></td></tr></table></figure>
<p>对于每个失败，Mix打印详细的报告，包含测试用例的名字，失败的代码，以及 == 运算符左边的值（lhs）和右边的值（rhs）。</p>
<p>失败的第二行，正好在测试用例名字下面，这是测试被定义的位置。如果你拷贝测试位置这行（包括文件和行数）然后加在Mix test 后面，Mix将装载和运行这个指定的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> <span class="built_in">test</span>/kv_test.exs:5</div></pre></td></tr></table></figure>
<p>该快捷方式当我们建立我们的项目时将是非常有用的，让我们仅仅运行一个特定的测试来快速迭代。</p>
<p>最后，堆栈跟踪涉及失败本身，它给出有关测试和失败在源文件生成的位置信息。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><span id="part-four">环境</span></h1><p>Mix支持“环境”这个概念。它们允许开发者为特定的场景定制编译和其他选项。默认情况下，Mix理解三种环境：</p>
<ul>
<li>:dev - 这是Mix任务（像 compile）默认运行的</li>
<li>:test - 被 mix test 使用</li>
<li>:prod - 你将在生成环境运行你的项目时使用它</li>
</ul>
<p>环境仅运用到当前的项目。正如稍后我们将看到的，任何你添加到你的项目的依赖将默认运行在 :prod 环境。</p>
<p>定制化每一个环境可以通过在你的mix.exs文件里访问<a href="https://hexdocs.pm/mix/Mix.html#env/1" target="_blank" rel="external">Mix.env函数</a>来做到，这个函数以一个原子方式返回当前环境。我们已经在 :build_embedded 和 :start_permanent 选项里这么使用了：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">  [...,</div><div class="line">   <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">   <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">   ...]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当你编译你的源码的时候，Elixir把编译的生成物放置到 _build 目录里。然而，在许多场合为了避免不必要的拷贝，Elixir将创建文件系统链接，从 _build 到实际源文件。当 :build_embedded 选项为 true 时，它将禁止这个行为，因为它的目的是在 _build 目录里提供运行你的应用的所需要的一切。</p>
<p>相似地，当 :start_permanent 选项为 true 时，它以 permanent  模式启动你的应用，意思是，当你的应用的监督树结束了，Erlang虚拟机也崩溃。注意：我们不想在开发和测试的时候用这种方式，因为为了解决问题而保持Erlang虚拟机实例运行在那样的环境是有用的。</p>
<p>Mix默认使用 :dev 环境，除了 test 任务默认使用 :test 环境。环境可以通过环境变量 MIX_ENV 修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ MIX_ENV=prod mix compile</div></pre></td></tr></table></figure>
<p>或在Windows下这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> <span class="string">"MIX_ENV=prod"</span> &amp;&amp; mix compile</div></pre></td></tr></table></figure>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a><span id="part-five">探索</span></h1><p>Mix的知识还有很多，我们将在构建我们的项目中继续探索它。<a href="https://hexdocs.pm/mix/" target="_blank" rel="external">Mix官方文档里有它的总览</a>。</p>
<p>记住，你可以一直调用 help 任务列出所有可用的任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mix <span class="built_in">help</span></div></pre></td></tr></table></figure>
<p>调用 mix help TASK 你可以得到指定任务的更多信息。</p>
<p>接下来让我们写一些代码！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;项目编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;运行测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;探索&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本教程里，我们将学习如何构建一个完整的Elixir应用，该应用有自己的监督树、配置、测试等等。&lt;/p&gt;
&lt;p&gt;这个应用是一个分布式键值对存储。我们将组织键值对到容器中，然后跨多节点分布这些容器。我们也将构建一个简单的客户端来让我们连接到那些节点中的任何一个，并且像如下所示发送请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs 3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了构建我们的键值对应用，我们将使用三个主要工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OTP（开放电信平台）是一个Erlang自带的库的集合。Erlang开发者用OTP来构建健壮、容错的应用。在本章中我们将探讨OTP和Elixir整合有多少方面，包括监督树、事件管理器等等；&lt;/li&gt;
&lt;li&gt;Mix是一个Elixir自带的构建工具，它为创建、编译、测试你的应用、管理应用的依赖等等提供任务；&lt;/li&gt;
&lt;li&gt;ExUnit是一个Elixir自带的基于单元测试的框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本章里，我们将用Mix创建我们的第一个项目，然后逐步探索OTP、Mix和ExUnit里的不同特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：本教程需要Elixir v1.2.0 或者更高版本。你可以用 elixir –version 来检查你的Elixir版本并且如果需要的话，你可以按 &lt;a href=&quot;http://elixir-lang.org/getting-started/introduction.html&quot;&gt;Elixir入门教程第一章里&lt;/a&gt; 描述的步骤安装一个最新的版本。&lt;/p&gt;
&lt;p&gt;如果你对本教程有任何疑问或改进建议请到诸如 &lt;a href=&quot;https://elixirforum.com/&quot;&gt;Elixir论坛&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;问题跟踪&lt;/a&gt; 告诉我们。你的建议对我们的教程真的很重要。&lt;/p&gt;
&lt;p&gt;最后，本教程的代码在这个&lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;仓库&lt;/a&gt;里，你可以把它当做参考。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Mix" scheme="http://szpzs.oschina.io/categories/Elixir/Mix/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Mix" scheme="http://szpzs.oschina.io/tags/Mix/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－下一步</title>
    <link href="http://szpzs.oschina.io/2017/02/15/elixir-getting-started-where-to-go-next/"/>
    <id>http://szpzs.oschina.io/2017/02/15/elixir-getting-started-where-to-go-next/</id>
    <published>2017-02-15T06:01:27.000Z</published>
    <updated>2017-02-15T06:13:04.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">构建你的第一个Elixir项目</a></li>
<li><a href="#part-two">元编程</a></li>
<li><a href="#part-three">社区和其他资源</a></li>
<li><a href="#part-four">关于Erlang</a></li>
</ol>
<p>渴望学更多吗？请继续阅读！</p>
<a id="more"></a>
<h1 id="构建你的第一个Elixir项目"><a href="#构建你的第一个Elixir项目" class="headerlink" title="构建你的第一个Elixir项目"></a><span id="part-one">构建你的第一个Elixir项目</span></h1><p>为了开始你的第一个项目，Elixir提供了一个构建工具，叫做Mix。你可以按如下所示开始你的新项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix new path/to/new/project</div></pre></td></tr></table></figure>
<p>我们已经写了一个教程，涵盖了如何构建一个Elixir应用，包括它自己的监督树、配置、测试等等。这个应用是一个分布式键值存储，我们把键值对放入容器中，并且把这些容器跨多节点分布：</p>
<ul>
<li><a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix and OTP</a></li>
</ul>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a><span id="part-two">元编程</span></h1><p>Elixir是一种可扩展和非常定制化的编程语言，这归功于它的元编程支持。Elixir中绝大多数元编程是通过宏来做的，宏在一些场景下非常有用，特别是写领域特定语言。我们已经写了一个简短教程来解释宏背后的基本机制，展示如何写宏，以及如何用宏来创建领域特定语言。</p>
<ul>
<li><a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">Elixir中的元编程</a></li>
</ul>
<h1 id="社区和其他资源"><a href="#社区和其他资源" class="headerlink" title="社区和其他资源"></a><span id="part-three">社区和其他资源</span></h1><p>我们有一个<a href="http://elixir-lang.org/learning.html" target="_blank" rel="external">学习区</a>，在里面我们推荐一些书籍、视频和其他资源，都是关于学习Elixir和浏览它的生态系统的。除此之外，社区也提供了大量Elixir资源，比如，会议的演讲、开源项目以及其他学习Elixir的资源。</p>
<p>别忘了你也可以从Github上获取<a href="https://github.com/elixir-lang/elixir" target="_blank" rel="external">Elixir它自己的源代码</a>，Elixir绝大多数代码是用Elixir写的（主要在lib目录里），或者<a href="http://elixir-lang.org/docs.html" target="_blank" rel="external">浏览Elixir的官方文档</a>。</p>
<h1 id="关于Erlang"><a href="#关于Erlang" class="headerlink" title="关于Erlang"></a><span id="part-four">关于Erlang</span></h1><p>Elixir运行在Erlang虚拟机之上，而作为一个名Elixir开发者，他迟早会想要与已存在的Erlang库进行交互。在线上有大量的资源，包括Erlang的基础知识和Erlang的更高级特性：</p>
<ul>
<li><a href="http://elixir-lang.org/crash-course.html" target="_blank" rel="external">Erlang语法：速成课程</a>提供了一个Erlang语法的简洁介绍。每一段代码都伴随着等效的Elixir代码。这是一个好机会，对于你来说不仅可以熟悉Erlang语法，也可以复习你在本教程学到的一些知识。</li>
<li>Erlang的官方网站有一个简短的<a href="http://www.erlang.org/course/concurrent_programming.html" target="_blank" rel="external">教程</a>，它用图来简单地描述了Erlang并发编程的基础知识。</li>
<li><a href="http://learnyousomeerlang.com/" target="_blank" rel="external">《Learn You Some Erlang for Great Good!》</a>是一本非常棒的介绍Erlang的设计原则、标准库、最佳实践以及其他知识的书籍。一旦你已经阅读了上面提及的速成课程，你就可以安全地略过这本书介绍语法的前面几章。当你读到 <a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency" target="_blank" rel="external">并发指南</a> 这一章的时候，才是真正有趣的开始。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/where-to-go-next.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/where-to-go-next.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;构建你的第一个Elixir项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;元编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;社区和其他资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;关于Erlang&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;渴望学更多吗？请继续阅读！&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－Erlang的库</title>
    <link href="http://szpzs.oschina.io/2017/02/14/elixir-getting-started-erlang-libraries/"/>
    <id>http://szpzs.oschina.io/2017/02/14/elixir-getting-started-erlang-libraries/</id>
    <published>2017-02-13T22:18:33.000Z</published>
    <updated>2017-02-13T22:22:34.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">binary模块</a></li>
<li><a href="#part-two">格式化文本输出</a></li>
<li><a href="#part-three">crypto模块</a></li>
<li><a href="#part-four">digraph模块</a></li>
<li><a href="#part-five">ETS</a></li>
<li><a href="#part-six">math模块</a></li>
<li><a href="#part-seven">queue模块</a></li>
<li><a href="#part-eight">rand模块</a></li>
<li><a href="#part-nine">zip和zlib模块</a></li>
</ol>
<p>Elixir提供了非常棒的与Erlang的库交互的能力。实际上，Elixir不鼓励简单地封装Erlang的库，而是提倡直接与Erlang代码交互。本文我们将介绍一些最常见和有用的而在Elixir里找不到的Erlang功能。</p>
<p>当你逐渐熟悉了Elixir，你可能想要探索Erlang的<a href="http://erlang.org/doc/apps/stdlib/index.html" target="_blank" rel="external">STDLIB指引手册</a>来获得更多细节。</p>
<a id="more"></a>
<h1 id="binary模块"><a href="#binary模块" class="headerlink" title="binary模块"></a><span id="part-one">binary模块</span></h1><p>Elixir内建的String模块处理用UTF-8编码的二进制数据。当你要处理不一定要用UTF-8编码的二进制数据的时候，<a href="http://erlang.org/doc/man/binary.html" target="_blank" rel="external">binary模块</a>就有用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.to_charlist <span class="string">"Ø"</span></div><div class="line">[<span class="number">216</span>]</div><div class="line">iex&gt; <span class="symbol">:binary</span>.bin_to_list <span class="string">"Ø"</span></div><div class="line">[<span class="number">195</span>, <span class="number">152</span>]</div></pre></td></tr></table></figure>
<p>上面的例子展示了区别；String模块返回Unicode代码点，而 :binary 处理原始数据的字节。</p>
<h1 id="格式化文本输出"><a href="#格式化文本输出" class="headerlink" title="格式化文本输出"></a><span id="part-two">格式化文本输出</span></h1><p>Elixir没有包含与C语言和其他语言里的printf函数相似的函数。幸运地是，Erlang标准库函数 :io.format/2 和 :io_lib.format/2 可以被用作这样的功能。第一个函数格式化数据输出到终端，而第二个函数格式化数据为一个iolist。格式化说明符不同于printf，<a href="http://erlang.org/doc/man/io.html#format-1" target="_blank" rel="external">细节请参阅Erlang官方文档</a>。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:io</span>.format(<span class="string">"Pi is approximately given by:~10.3f~n"</span>, [<span class="symbol">:math</span>.pi])</div><div class="line">Pi is approximately given <span class="symbol">by:</span>     <span class="number">3.142</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; to_string <span class="symbol">:io_lib</span>.format(<span class="string">"Pi is approximately given by:~10.3f~n"</span>, [<span class="symbol">:math</span>.pi])</div><div class="line"><span class="string">"Pi is approximately given by:     3.142\n"</span></div></pre></td></tr></table></figure>
<p>另外要注意Erlang的格式化函数需要特别注意Unicode的处理。</p>
<h1 id="crypto模块"><a href="#crypto模块" class="headerlink" title="crypto模块"></a><span id="part-three">crypto模块</span></h1><p>crypto模块包含哈希函数、数字签名、加解密等等函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Base.encode16(<span class="symbol">:crypto</span>.hash(<span class="symbol">:sha256</span>, <span class="string">"Elixir"</span>))</div><div class="line"><span class="string">"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"</span></div></pre></td></tr></table></figure>
<p>:crypto模块不是Erlang标准库的一部分，但是它包含在Erlang发行版里。这意味着，任何时候你要使用 :crypto 的时候，就要把它加入你的项目应用列表里。要这么做的话，编辑你的 mix.exs 文件包含它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:crypto</span>]]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="digraph模块"><a href="#digraph模块" class="headerlink" title="digraph模块"></a><span id="part-four">digraph模块</span></h1><p><a href="http://erlang.org/doc/man/digraph.html" target="_blank" rel="external">digraph模块</a>（还有<a href="http://erlang.org/doc/man/digraph_utils.html" target="_blank" rel="external">digraph工具</a>）包含了处理用点和边构建的有向图的函数。在构建了图后，模块里的算法将帮助找到图里的两个节点间的最短路径或回环路径。</p>
<p>给定三个节点，找到从第一个到最后一个节点的最短路径。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; digraph = <span class="symbol">:digraph</span>.new()</div><div class="line">iex&gt; coords = [&#123;<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;]</div><div class="line">iex&gt; [v<span class="number">0</span>, v1, v2] = (<span class="keyword">for</span> c &lt;- coords, <span class="symbol">do:</span> <span class="symbol">:digraph</span>.add_vertex(digraph, c))</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.add_edge(digraph, v<span class="number">0</span>, v1)</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.add_edge(digraph, v1, v2)</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.get_short_path(digraph, v<span class="number">0</span>, v2)</div><div class="line">[&#123;<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;]</div></pre></td></tr></table></figure>
<p>注意：:digraph里的函数在内部修改了图的结构，这是可能的，因为它们被实现为ETS表。下面我们来看看ETS。</p>
<h1 id="ETS"><a href="#ETS" class="headerlink" title="ETS"></a><span id="part-five">ETS</span></h1><p><a href="http://erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 和 <a href="http://erlang.org/doc/man/dets.html" target="_blank" rel="external">dets</a> 模块分别处理内存或硬盘的大数据结构存储。</p>
<p>ETS让你创建一个包含元组的表。默认情况下，ETS表是被保护的，就是说只有拥有者进程可以写这个表，而其他任何进程可以读这个表。ETS有一些功能被用来当做简单数据库、KV存储或者缓存机制。</p>
<p>ets模块的函数将修改表的状态作为副作用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:ets_test</span>, [])</div><div class="line"><span class="comment"># Store as tuples with &#123;name, population&#125;</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"China"</span>, <span class="number">1_374_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"India"</span>, <span class="number">1_284_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"USA"</span>, <span class="number">322_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.i(table)</div><div class="line">&lt;<span class="number">1</span>   &gt; &#123;&lt;&lt;<span class="string">"India"</span>&gt;&gt;,<span class="number">1284000000</span>&#125;</div><div class="line">&lt;<span class="number">2</span>   &gt; &#123;&lt;&lt;<span class="string">"USA"</span>&gt;&gt;,<span class="number">322000000</span>&#125;</div><div class="line">&lt;<span class="number">3</span>   &gt; &#123;&lt;&lt;<span class="string">"China"</span>&gt;&gt;,<span class="number">1374000000</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="math模块"><a href="#math模块" class="headerlink" title="math模块"></a><span id="part-six">math模块</span></h1><p><a href="http://erlang.org/doc/man/math.html" target="_blank" rel="external">math模块</a>包含常用的数学运算，覆盖三角函数、指数函数、对数函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; angle_45_deg = <span class="symbol">:math</span>.pi() * <span class="number">45.0</span> / <span class="number">180.0</span></div><div class="line">iex&gt; <span class="symbol">:math</span>.sin(angle_45_deg)</div><div class="line"><span class="number">0</span>.<span class="number">7071067811865475</span></div><div class="line">iex&gt; <span class="symbol">:math</span>.exp(<span class="number">55.0</span>)</div><div class="line"><span class="number">7.694785265142018</span>e23</div><div class="line">iex&gt; <span class="symbol">:math</span>.log(<span class="number">7.694785265142018</span>e23)</div><div class="line"><span class="number">55.0</span></div></pre></td></tr></table></figure>
<h1 id="queue模块"><a href="#queue模块" class="headerlink" title="queue模块"></a><span id="part-seven">queue模块</span></h1><p><a href="http://erlang.org/doc/man/queue.html" target="_blank" rel="external">queue是一个数据结构</a>，它高效地实现了（双端）FIFO（先进先出）队列。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; q = <span class="symbol">:queue</span>.new</div><div class="line">iex&gt; q = <span class="symbol">:queue</span>.<span class="keyword">in</span>(<span class="string">"A"</span>, q)</div><div class="line">iex&gt; q = <span class="symbol">:queue</span>.<span class="keyword">in</span>(<span class="string">"B"</span>, q)</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line">&#123;<span class="symbol">:value</span>, <span class="string">"A"</span>&#125;</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line">&#123;<span class="symbol">:value</span>, <span class="string">"B"</span>&#125;</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line"><span class="symbol">:empty</span></div></pre></td></tr></table></figure>
<h1 id="rand模块"><a href="#rand模块" class="headerlink" title="rand模块"></a><span id="part-eight">rand模块</span></h1><p><a href="http://erlang.org/doc/man/rand.html" target="_blank" rel="external">rand</a>有返回随机数和设置随机种子的函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform()</div><div class="line"><span class="number">0</span>.<span class="number">8175669086010815</span></div><div class="line">iex&gt; <span class="number">_</span> = <span class="symbol">:rand</span>.seed(<span class="symbol">:exs1024</span>, &#123;<span class="number">123</span>, <span class="number">123534</span>, <span class="number">345345</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform()</div><div class="line"><span class="number">0</span>.<span class="number">5820506340260994</span></div><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform(<span class="number">6</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<h1 id="zip和zlib模块"><a href="#zip和zlib模块" class="headerlink" title="zip和zlib模块"></a><span id="part-nine">zip和zlib模块</span></h1><p>zip模块让你从硬盘或内存读写ZIP文件，也提取文件的信息。</p>
<p>下面的代码统计ZIP文件里的文件个数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:zip</span>.foldl(<span class="keyword">fn</span> <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>, acc -&gt; acc + <span class="number">1</span> <span class="keyword">end</span>, <span class="number">0</span>, <span class="symbol">:binary</span>.bin_to_list(<span class="string">"file.zip"</span>))</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="number">633</span>&#125;</div></pre></td></tr></table></figure>
<p>zlib模块用zlib格式，就如gzip命令里找到的格式，来处理压缩数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; song = <span class="string">"</span></div><div class="line">...&gt; Mary had a little lamb,</div><div class="line">...&gt; His fleece was white as snow,</div><div class="line">...&gt; And everywhere that Mary went,</div><div class="line">...&gt; The lamb was sure to go."</div><div class="line">iex&gt; compressed = <span class="symbol">:zlib</span>.compress(song)</div><div class="line">iex&gt; byte_size song</div><div class="line"><span class="number">110</span></div><div class="line">iex&gt; byte_size compressed</div><div class="line"><span class="number">99</span></div><div class="line">iex&gt; <span class="symbol">:zlib</span>.uncompress(compressed)</div><div class="line"><span class="string">"\nMary had a little lamb,\nHis fleece was white as snow,\nAnd everywhere that Mary went,\nThe lamb was sure to go."</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/erlang-libraries.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/erlang-libraries.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;binary模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;格式化文本输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;crypto模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;digraph模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;ETS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;math模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;queue模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-eight&quot;&gt;rand模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-nine&quot;&gt;zip和zlib模块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Elixir提供了非常棒的与Erlang的库交互的能力。实际上，Elixir不鼓励简单地封装Erlang的库，而是提倡直接与Erlang代码交互。本文我们将介绍一些最常见和有用的而在Elixir里找不到的Erlang功能。&lt;/p&gt;
&lt;p&gt;当你逐渐熟悉了Elixir，你可能想要探索Erlang的&lt;a href=&quot;http://erlang.org/doc/apps/stdlib/index.html&quot;&gt;STDLIB指引手册&lt;/a&gt;来获得更多细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Erlang&#39;s libraries" scheme="http://szpzs.oschina.io/categories/Elixir/Erlang-s-libraries/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Erlang&#39;s libraries" scheme="http://szpzs.oschina.io/tags/Erlang-s-libraries/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－Typespecs 和 behaviours</title>
    <link href="http://szpzs.oschina.io/2017/02/13/elixir-getting-started-typespecs-and-behaviours/"/>
    <id>http://szpzs.oschina.io/2017/02/13/elixir-getting-started-typespecs-and-behaviours/</id>
    <published>2017-02-13T03:13:48.000Z</published>
    <updated>2017-02-13T03:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">类型和规格说明</a><br> 1.1 <a href="#part-one-one">函数规格说明</a><br> 1.2 <a href="#part-one-two">定义自定义类型</a><br> 1.3 <a href="#part-one-three">静态代码分析</a></li>
<li><a href="#part-two">行为</a><br> 2.1 <a href="#part-two-one">定义行为</a><br> 2.2 <a href="#part-two-two">采用行为</a></li>
</ol>
<a id="more"></a>
<h1 id="类型和规格说明"><a href="#类型和规格说明" class="headerlink" title="类型和规格说明"></a><span id="part-one">类型和规格说明</span></h1><p>Elixir是一门动态类型语言，所以Elixir里的所有类型是由运行时推断出来的。尽管如此，Elixir还是有一个标记叫做 <strong>typespecs</strong> ，它被用来：</p>
<ol>
<li>声明类型函数签名（规格说明）</li>
<li>声明自定义数据类型</li>
</ol>
<h2 id="函数规格说明"><a href="#函数规格说明" class="headerlink" title="函数规格说明"></a><span id="part-one-one">函数规格说明</span></h2><p>Elixir默认提供一些基本类型，比如：整形 或 pid，以及更复杂的类型：例如，round/1 函数，它返回一个浮点数最接近的整数，它的入参是一个数字（整数或浮点数）而返回的是一个整数。在<a href="https://hexdocs.pm/elixir/Kernel.html#round/1" target="_blank" rel="external">它的文档里</a>你可以看到，round/1 的类型签名写为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(number) <span class="symbol">:</span>: integer</div></pre></td></tr></table></figure>
<p>:: 的意思是，其左边的函数返回一个值，它的类型就是其左边的类型。</p>
<p>函数规格说明用指令 @spec 来写，刚好置于函数定义的前面。round/1 函数如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@spec</span> round(number) <span class="symbol">:</span>: integer</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span></span>(number), <span class="symbol">do:</span> <span class="comment"># implementation...</span></div></pre></td></tr></table></figure>
<p>Elixir也支持组合类型。例如，整数列表的类型为：[integer] 。<a href="https://hexdocs.pm/elixir/typespecs.html" target="_blank" rel="external">在 typespec 的文档里</a>，你可以看到Elixir提供的所有内建类型。</p>
<h2 id="定义自定义类型"><a href="#定义自定义类型" class="headerlink" title="定义自定义类型"></a><span id="part-one-two">定义自定义类型</span></h2><p>Elixir提供了很多有用的内建类型，这便于在适当的时候定义自定义类型。这可以在定义模块的时候通过 @type 指令来做到。</p>
<p>假设我们有一个 LousyCalculator 模块，它执行一些通常的算术运算（和、乘积，等等），但是，它不返回计算结果，而是返回一个元组，这个元组用运算结果作为第一个元素，用一个随机的评论作为第二个元素。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">LousyCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> &#123;x + y, <span class="string">"You need a calculator to do that?!"</span>&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> multiply(number, number) <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x, y), <span class="symbol">do:</span> &#123;x * y, <span class="string">"Jeez, come on!"</span>&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如你在例子看到的，元组是一个组合类型，并且每一个元组在其内部通过类型来定义。要理解为什么String.t不写作String，请看<a href="https://hexdocs.pm/elixir/typespecs.html#notes" target="_blank" rel="external">在typespec文档里的说明</a>。</p>
<p>定义函数规格说明以上述例子的方式是可行的，不过很快就变得令人烦恼了，因为我们正一遍又一遍地重复输入 {number, String.t} 。我们可以用 @type 指令来声明我们自己的自定义类型。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">LousyCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@typedoc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Just a number followed by a string.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="variable">@type</span> number_with_remark <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: number_with_remark</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> &#123;x + y, <span class="string">"You need a calculator to do that?"</span>&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> multiply(number, number) <span class="symbol">:</span>: number_with_remark</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x, y), <span class="symbol">do:</span> &#123;x * y, <span class="string">"It is like addition on steroids."</span>&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>@typedoc 指令相似于 @doc 和 @moduledoc 指令，它被用来注释自定义类型。</p>
<p>通过 @type 定义的自定义类型被导出而且在它们被定义的模块外部也可用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">QuietCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: number</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> make_quiet(LousyCalculator.add(x, y))</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> make_quiet(LousyCalculator.number_with_remark) <span class="symbol">:</span>: number</div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">make_quiet</span></span>(&#123;num, _remark&#125;), <span class="symbol">do:</span> num</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你想保留自定义类型为私有的，你可以用 @typep 指令替代 @type 指令。</p>
<h2 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a><span id="part-one-three">静态代码分析</span></h2><p>类型规格说明不仅是对开发人员有用的附加文档。例如，Erlang工具 <a href="http://www.erlang.org/doc/man/dialyzer.html" target="_blank" rel="external">Dialyzer</a> 使用类型规格说明来进行代码的静态分析。这就是为什么在 QuietCalculator  例子里，我们为 make_quiet/1 函数写规格说明，即使它被定义为私有函数。</p>
<h1 id="行为"><a href="#行为" class="headerlink" title="行为"></a><span id="part-two">行为</span></h1><p>许多模块共享相同的公共API。我们看看<a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a>，正如它自己的描述所声明，它是web应用里可组合的模块的<strong>规格说明</strong>。每一个plug是一个模块，它必须实现最少两个公共函数：init/1 和 call/2 。</p>
<p>行为提供一种方式：</p>
<ul>
<li>定义必须被一个模块实现的一个函数集合；</li>
<li>确定一个模块实现这个集合里的所有函数。</li>
</ul>
<p>如果你愿意，你可以认为行为就像Java这种面向对象语言里的接口：一个模块必须实现的函数签名的集合。</p>
<h2 id="定义行为"><a href="#定义行为" class="headerlink" title="定义行为"></a><span id="part-two-one">定义行为</span></h2><p>假如我们想实现一些分析器，它们每一个都分析结构化的数据：例如，一个JSON分析器和一个YAML分析器。这两个解析器将有相同的行为方式：两者都提供一个parse/1 函数和一个 extensions/0 函数。parse/1 函数将返回一个Elixir的结构化数据描述，而 extensions/0 函数将返回可被用于每种数据类型（例如，.json对应于JSON文件）的文件扩展名的列表。</p>
<p>我们可以创建一个 Parser 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Parser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@callback</span> parse(String.t) <span class="symbol">:</span>: any</div><div class="line">  <span class="variable">@callback</span> extensions() <span class="symbol">:</span>: [String.t]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>采用 Parser 行为的模块将必须实现所有用 @callback 指令定义的函数。如你所见，@callback 指令期望有一个函数名以及如我们前面所看到的 @spec 指令用到的函数规格说明。</p>
<h2 id="采用行为"><a href="#采用行为" class="headerlink" title="采用行为"></a><span id="part-two-two">采用行为</span></h2><p>采用一个行为很简单：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">JSONParser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> Parser</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str), <span class="symbol">do:</span> <span class="comment"># ... parse JSON</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extensions</span></span>, <span class="symbol">do:</span> [<span class="string">"json"</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">YAMLParser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> Parser</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str), <span class="symbol">do:</span> <span class="comment"># ... parse YAML</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extensions</span></span>, <span class="symbol">do:</span> [<span class="string">"yml"</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果一个模块采用一个给定的行为却没有实现行为需要的所有回调函数中的一个，则一个编译期警告将被生成。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/typespecs-and-behaviours.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;类型和规格说明&lt;/a&gt;&lt;br&gt; 1.1 &lt;a href=&quot;#part-one-one&quot;&gt;函数规格说明&lt;/a&gt;&lt;br&gt; 1.2 &lt;a href=&quot;#part-one-two&quot;&gt;定义自定义类型&lt;/a&gt;&lt;br&gt; 1.3 &lt;a href=&quot;#part-one-three&quot;&gt;静态代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;行为&lt;/a&gt;&lt;br&gt; 2.1 &lt;a href=&quot;#part-two-one&quot;&gt;定义行为&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#part-two-two&quot;&gt;采用行为&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="typespec behaviour" scheme="http://szpzs.oschina.io/categories/Elixir/typespec-behaviour/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="typespec" scheme="http://szpzs.oschina.io/tags/typespec/"/>
    
      <category term="behaviour" scheme="http://szpzs.oschina.io/tags/behaviour/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－尝试、捕获和挽救</title>
    <link href="http://szpzs.oschina.io/2017/02/12/elixir-getting-started-try-catch-and-rescue/"/>
    <id>http://szpzs.oschina.io/2017/02/12/elixir-getting-started-try-catch-and-rescue/</id>
    <published>2017-02-12T11:41:15.000Z</published>
    <updated>2017-02-12T11:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Errors</a></li>
<li><a href="#part-two">Throws</a></li>
<li><a href="#part-three">Exits</a></li>
<li><a href="#part-four">After</a></li>
<li><a href="#part-five">Else</a></li>
<li><a href="#part-six">变量作用域</a></li>
</ol>
<p>Elixir有三种错误机制：errors，throws，和 exits 。本章我们将探索它们每一个，并且包括应该何时使用哪一个的评论。</p>
<a id="more"></a>
<h1 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a><span id="part-one">Errors</span></h1><p>错误（或者叫异常）是在代码里有异常的事情发生的时候被使用的。例如，通过尝试将一个数字和原子相加就可以获得一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:foo</span> + <span class="number">1</span></div><div class="line">** (ArithmeticError) bad argument <span class="keyword">in</span> arithmetic expression</div><div class="line">     <span class="symbol">:erlang</span>.+(<span class="symbol">:foo</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>任何时候用 raise/1 一个运行时错误可以被抛出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; raise <span class="string">"oops"</span></div><div class="line">** (RuntimeError) oops</div></pre></td></tr></table></figure>
<p>其他种类的错误可以通过传入错误名字和一个关键字列表作为入参给函数 raise/2 来抛出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; raise ArgumentError, <span class="symbol">message:</span> <span class="string">"invalid argument foo"</span></div><div class="line">** (ArgumentError) invalid argument foo</div></pre></td></tr></table></figure>
<p>通过创建一个模块并在它里面使用 defexception 结构，你也可以定义自己的错误；用这种方式，你将创建一个和这个错误定义所在的模块的名字相同的错误。最常见的场景是定义一个自定义的异常，并且有一个消息字段：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyError</span></span> <span class="keyword">do</span></div><div class="line">iex&gt;   defexception <span class="symbol">message:</span> <span class="string">"default message"</span></div><div class="line">iex&gt; <span class="keyword">end</span></div><div class="line">iex&gt; raise MyError</div><div class="line">** (MyError) default message</div><div class="line">iex&gt; raise MyError, <span class="symbol">message:</span> <span class="string">"custom message"</span></div><div class="line">** (MyError) custom message</div></pre></td></tr></table></figure>
<p>错误可以用 try/rescue  结构来<strong>挽救</strong>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"oops"</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   e <span class="keyword">in</span> RuntimeError -&gt; e</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%RuntimeError&#123;<span class="symbol">message:</span> <span class="string">"oops"</span>&#125;</div></pre></td></tr></table></figure>
<p>上面的例子挽救了运行时错误并且返回这个错误，然后这个错误被打印在iex会话里。</p>
<p>如果错误对你无用，你就不需要返回它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"oops"</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   RuntimeError -&gt; <span class="string">"Error!"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Error!"</span></div></pre></td></tr></table></figure>
<p>但是在实践中，Elixir开发者很少使用 try/rescue 结构。例如，当一个文件不能被成功打开的时候，许多语言会强制要求你去挽救这个错误。Elixir反而是提供了一个函数 File.read/1 ，它返回一个元组，包含了关于这个文件是否被成功打开的相关消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:enoent</span>&#125;</div><div class="line">iex&gt; File.write <span class="string">"hello"</span>, <span class="string">"world"</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>这里就没有 try/rescue 。如果你想要处理打开一个文件的不同输出，你可以在case语句里使用模式匹配：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> File.read <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, body&#125;      -&gt; IO.puts <span class="string">"Success: <span class="subst">#&#123;body&#125;</span>"</span></div><div class="line">...&gt;   &#123;<span class="symbol">:error</span>, reason&#125; -&gt; IO.puts <span class="string">"Error: <span class="subst">#&#123;reason&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最终由你的程序来决定打开一个文件出现的出错是否是一个异常。这就是为什么Elixir在File.read/1和许多函数上没有强制输出异常。相反，它留给开发者选择最好的方法进行处理。</p>
<p>对于你确实期望一个文件存在（而这个文件不存在就一定是一个错误）的场景，你可以使用 File.read!/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read! <span class="string">"unknown"</span></div><div class="line">** (File.Error) could <span class="keyword">not</span> read file <span class="symbol">unknown:</span> no such file <span class="keyword">or</span> directory</div><div class="line">    (elixir) lib/file.<span class="symbol">ex:</span><span class="number">305</span>: File.read!<span class="regexp">/1</span></div></pre></td></tr></table></figure>
<p>标准库里的许多函数遵循这样的模式：它有一个副本函数，它抛出异常而不是返回用来匹配的元组。这个约定习惯是，创建一个返回 {:ok, result} 或 {:error, reason} 元组的函数（foo）而另一个函数（foo!，相同的名字不过尾部有一个！字符）接收和foo函数一样的入参，但是如果有错误的时候，它抛出一个异常。如果一切正常，foo!将返回结果（而不是用元组包裹起来）。<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File模块</a>是这个约定习惯的很好的例子。</p>
<p>在Elixir里，我们避免使用 try/rescue ，因为我们不使用错误来进行流程控制。我们真正对待错误的看法是：他们是为意外和/或例外情况预留的。如果你确实需要流程控制结构，可以使用 throws 。它就是我们接下来看到的。</p>
<h1 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a><span id="part-two">Throws</span></h1><p>在Elixir里，一个值可以被抛出然后被捕获。throw 和 catch 是为这样的情况保留的，就是：除了用throw 和 catch，不可能来获取到一个值。</p>
<p>实际上这些场景是非常罕见的，除非当你和没有提供合适API的库交互的时候。例如，让我们假设Enum模块没有提供任何API来找到一个值，而这个值就是我们需要在一个数字列表里找到第一个13的倍数的数字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   Enum.each -<span class="number">50</span>..<span class="number">50</span>, <span class="keyword">fn</span>(x) -&gt;</div><div class="line">...&gt;     if rem(x, <span class="number">13</span>) == <span class="number">0</span>, <span class="symbol">do:</span> throw(x)</div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt;   <span class="string">"Got nothing"</span></div><div class="line">...&gt; catch</div><div class="line">...&gt;   x -&gt; <span class="string">"Got <span class="subst">#&#123;x&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got -39"</span></div></pre></td></tr></table></figure>
<p>因为Enum的确是提供了合适的API，所以实际上Enum.find/2是最好的人选：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.find -<span class="number">50</span>..<span class="number">50</span>, &amp;(rem(&amp;<span class="number">1</span>, <span class="number">13</span>) == <span class="number">0</span>)</div><div class="line">-<span class="number">39</span></div></pre></td></tr></table></figure>
<h1 id="Exits"><a href="#Exits" class="headerlink" title="Exits"></a><span id="part-three">Exits</span></h1><p>所有Elixir代码运行在彼此交互的进程里。当一个进程死于“自然原因”（比如，没有处理异常），它会发送一个退出信号。一个进程也可以通过明确地发送一个退出信号而死亡：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn_link <span class="keyword">fn</span> -&gt; exit(<span class="number">1</span>) <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.56.0&gt;</span></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.56.0&gt;) 1</span></div></pre></td></tr></table></figure>
<p>上面的例子，通过发送值为1的退出信号，被链接的进程死亡。Elixir shell自动处理那些消息并打印在终端上。</p>
<p>退出可以用try/catch来“捕获”：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   exit <span class="string">"I am exiting"</span></div><div class="line">...&gt; catch</div><div class="line">...&gt;   <span class="symbol">:exit</span>, <span class="number">_</span> -&gt; <span class="string">"not really"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"not really"</span></div></pre></td></tr></table></figure>
<p>使用 try/catch 已经很少见了，用它来捕获退出更加罕见。</p>
<p>退出信号是由Erlang虚拟机提供的容错系统的一个重要部分。进程常常运行在监督树下，监督树也是进程；这些进程监听从被监督进程来的退出信号。一旦接收到一个退出信号，监督策略被触发，被监督进程被重启。</p>
<p>正是这种监督体系，使得像 try/catch 和 try/rescue 这样的结构在Elixir里那么罕见。我们宁愿“速错”而不是挽救一个错误，因为我们的监督树将保证我们的应用在错误后将回到一个可知的初始状态。</p>
<h1 id="After"><a href="#After" class="headerlink" title="After"></a><span id="part-four">After</span></h1><p>有时候，在一些可能潜在地引起错误的动作后确保资源被清理干净是必须的。try/after 结构允许你这么做。例如，我们可以打开一个文件并使用after分支关闭它，即使有一些事情出错：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"sample"</span>, [<span class="symbol">:utf8</span>, <span class="symbol">:write</span>]</div><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   IO.write file, <span class="string">"olá"</span></div><div class="line">...&gt;   raise <span class="string">"oops, something went wrong"</span></div><div class="line">...&gt; after</div><div class="line">...&gt;   File.close(file)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (RuntimeError) oops, something went wrong</div></pre></td></tr></table></figure>
<p>after分支将被执行而不管try语句块时候成功。然而需要注意，如果一个被链接的进程退出，这个进程将退出并且after分支将不会被执行。因此，after仅提供一个软保证。幸运地是，Elixir里的文件也被链接到当前进程，因此如果当前进程崩溃了，它们将总是被关闭，而与after分支无关。你将发现其他资源比如ETS表、socket、port等等也是这样。</p>
<p>有时你可能想在一个try结构中封装一个函数的整个身体部分，这样通常是为了保证一些代码在后面被执行。这样的场景，Elixir允许你省略 try 这一行：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">RunAfter</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">without_even_trying</span></span> <span class="keyword">do</span></div><div class="line">...&gt;     raise <span class="string">"oops"</span></div><div class="line">...&gt;   after</div><div class="line">...&gt;     IO.puts <span class="string">"cleaning up!"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; RunAfter.without_even_trying</div><div class="line">cleaning up!</div><div class="line">** (RuntimeError) oops</div></pre></td></tr></table></figure>
<p>任何时候，after、rescue 或 catch 其中任何一个被用到了，Elixir将自动地封装函数的身体部分到try结构里。</p>
<h1 id="Else"><a href="#Else" class="headerlink" title="Else"></a><span id="part-five">Else</span></h1><p>提供一个 else 块来允许在表达式执行结果上进行模式匹配。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">2</span></div><div class="line">try <span class="keyword">do</span></div><div class="line">  <span class="number">1</span> / x</div><div class="line">rescue</div><div class="line">  ArithmeticError -&gt;</div><div class="line">    <span class="symbol">:infinity</span></div><div class="line">else</div><div class="line">  y <span class="keyword">when</span> y &lt; <span class="number">1</span> <span class="keyword">and</span> y &gt; -<span class="number">1</span> -&gt;</div><div class="line">    <span class="symbol">:small</span></div><div class="line">  <span class="number">_</span> -&gt;</div><div class="line">    <span class="symbol">:large</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>结果被传递给else，并且在那里陪匹配。请注意，如果一个异常被捕获，else也被执行，catch/rescue 块的结果将传递给else。</p>
<p>else块的异常不被捕获。如果else块里的模式没有被匹配上，一个异常将被抛出，这个异常不被当前的 try/catch/rescue/after 块捕获。</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><span id="part-six">变量作用域</span></h1><p>重要的是要记住，定义在try/catch/rescue/after块内的变量不泄漏到外部环境。这是因为try块可能失败，并且变量可能在第一个地方没有被绑定。换句话说，下面的代码是无效的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"fail"</span></div><div class="line">...&gt;   what_happened = <span class="symbol">:did_not_raise</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   <span class="number">_</span> -&gt; what_happened = <span class="symbol">:rescued</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; what_happened</div><div class="line">** (RuntimeError) undefined <span class="symbol">function:</span> what_happened/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>相反，你可以存储try表达式的值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; what_happened =</div><div class="line">...&gt;   try <span class="keyword">do</span></div><div class="line">...&gt;     raise <span class="string">"fail"</span></div><div class="line">...&gt;     <span class="symbol">:did_not_raise</span></div><div class="line">...&gt;   rescue</div><div class="line">...&gt;     <span class="number">_</span> -&gt; <span class="symbol">:rescued</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">iex&gt; what_happened</div><div class="line"><span class="symbol">:rescued</span></div></pre></td></tr></table></figure>
<p>到此我们结束了try、catch 和 rescue的介绍。你将发现它们在Elixir里用得频率比在其他语言里少很多，虽然在一些库或某些特定的代码不“按规则”玩的情况下，它们用起来可能很方便。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/try-catch-and-rescue.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/try-catch-and-rescue.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Throws&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Exits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;After&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Else&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;变量作用域&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Elixir有三种错误机制：errors，throws，和 exits 。本章我们将探索它们每一个，并且包括应该何时使用哪一个的评论。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="try catch rescue" scheme="http://szpzs.oschina.io/categories/Elixir/try-catch-rescue/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="try" scheme="http://szpzs.oschina.io/tags/try/"/>
    
      <category term="catch" scheme="http://szpzs.oschina.io/tags/catch/"/>
    
      <category term="rescue" scheme="http://szpzs.oschina.io/tags/rescue/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－印记</title>
    <link href="http://szpzs.oschina.io/2017/02/12/elixir-getting-started-sigils/"/>
    <id>http://szpzs.oschina.io/2017/02/12/elixir-getting-started-sigils/</id>
    <published>2017-02-12T01:44:02.000Z</published>
    <updated>2017-02-12T02:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">正则表达式</a></li>
<li><a href="#part-two">字符串、字符列表和词列表印记</a><br> 2.1 <a href="#part-two-one">字符串</a><br> 2.2 <a href="#part-two-two">字符列表</a><br> 2.3 <a href="#part-two-three">词列表</a></li>
<li><a href="#part-three">在印记中插入文本和转义字符</a></li>
<li><a href="#part-four">自定义印记</a></li>
</ol>
<p>我们已经学了Elixir提供双引号字符串和单引号字符列表。然而，这只是涵盖了该语言有文本表示的数据类型结构的表面。例如，原子主要就是通过 :atom 表示来创建的。</p>
<p>Elixir其中一个目标是可扩展性：开发者可以扩展该语言来解决任何特定的领域问题。计算机科学已经成为如此广阔的领域，一门语言解决许多领域的问题来作为它的核心部分是不太可能的。相反，我们最好的方法是使语言具有可扩展性，因此开发人员、公司和社区可以将语言扩展到相关领域。</p>
<p>本章，我们将探索印记，它是由Elixir这门语言提供的处理文本描述数据类型的其中一种机制。印记由波浪字符（~）开始，紧接着是一个字符（这个字符定义本印记），然后是一个分隔符，可选性的修饰符可以增加在最后的分隔符后。</p>
<a id="more"></a>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><span id="part-one">正则表达式</span></h1><p>Elixir里最常用的印记是~r，它被用来创建<a href="https://en.wikipedia.org/wiki/Regular_Expressions" target="_blank" rel="external">正则表达式</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A regular expression that matches strings which contain "foo" or "bar":</span></div><div class="line">iex&gt; regex = ~r/foo|bar/</div><div class="line">~r/foo|bar/</div><div class="line">iex&gt; <span class="string">"foo"</span> =~ regex</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="string">"bat"</span> =~ regex</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<p>Elixir提供Perl兼容正则表达式（regexes），它由<a href="http://www.pcre.org/" target="_blank" rel="external">PCRE</a>库实现。regexes也支持修饰符。例如，i修饰符使得正则表达式不大小写敏感：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"HELLO"</span> =~ ~r/hello/</div><div class="line"><span class="keyword">false</span></div><div class="line">iex&gt; <span class="string">"HELLO"</span> =~ ~r/hello/i</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>请查阅<a href="https://hexdocs.pm/elixir/Regex.html" target="_blank" rel="external">Regex模块</a>获取正则表达式的其他修饰符和被支持的操作的信息。</p>
<p>到目前为止，所有例子都是用 / 来界定一个正则表达式。然后印记支持8种不同的分隔符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">~r/hello/</div><div class="line">~r|hello|</div><div class="line">~r<span class="string">"hello"</span></div><div class="line">~r<span class="string">'hello'</span></div><div class="line">~r(hello)</div><div class="line">~r[hello]</div><div class="line">~r&#123;hello&#125;</div><div class="line">~r&lt;hello&gt;</div></pre></td></tr></table></figure>
<p>支持不同分隔符背后的原因是提供一种不需要转义分隔符来写字面量。例如，一个有斜杠的正则表达式，这样写：~r(^https?://) 肯定比这么写 ~r/^https?:\/\/ 更容易读。相似地，如果正则表达式含有斜杠和捕获组（即使用()），那么你可以使用双引号来替代圆括号。</p>
<h1 id="字符串、字符列表和词列表印记"><a href="#字符串、字符列表和词列表印记" class="headerlink" title="字符串、字符列表和词列表印记"></a><span id="part-two">字符串、字符列表和词列表印记</span></h1><p>除了正则表达式，Elixir还有三种其他印记。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span id="part-two-one">字符串</span></h2><p>~s印记被用来创建字符串，像双引号一样。当一个字符串包含有双引号的时候，~s印记很有用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s(this is a string with <span class="string">"double"</span> quotes, <span class="keyword">not</span> <span class="string">'single'</span> ones)</div><div class="line"><span class="string">"this is a string with \"double\" quotes, not 'single' ones"</span></div></pre></td></tr></table></figure>
<h2 id="字符列表"><a href="#字符列表" class="headerlink" title="字符列表"></a><span id="part-two-two">字符列表</span></h2><p>~c印记被用来创建含有单引号的字符列表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~c(this is a char list containing <span class="string">'single quotes'</span>)</div><div class="line"><span class="string">'this is a char list containing \'single quotes\''</span></div></pre></td></tr></table></figure>
<h2 id="词列表"><a href="#词列表" class="headerlink" title="词列表"></a><span id="part-two-three">词列表</span></h2><p>~w印记被用来创建词列表（词就是普通字符串）。在~w印记里，词被空白分隔。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~w(foo bar bat)</div><div class="line">[<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"bat"</span>]</div></pre></td></tr></table></figure>
<p>~w印记也接收c， s 和 a 修饰符（分别对应，字符列表、字符串和原子），它们指定结果列表的元素的数据类型：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~w(foo bar bat)a</div><div class="line">[<span class="symbol">:foo</span>, <span class="symbol">:bar</span>, <span class="symbol">:bat</span>]</div></pre></td></tr></table></figure>
<h1 id="在印记中插入文本和转义字符"><a href="#在印记中插入文本和转义字符" class="headerlink" title="在印记中插入文本和转义字符"></a><span id="part-three">在印记中插入文本和转义字符</span></h1><p>除了小写印记，Elixir也支持大写印记来处理转义字符和插入文本。虽然 ~s 和 ~S 都返回字符串，但是前者允许转义码和插入文本，而后者则不允许：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s(String with escape codes \x26 <span class="comment">#&#123;"inter" &lt;&gt; "polation"&#125;)</span></div><div class="line"><span class="string">"String with escape codes &amp; interpolation"</span></div><div class="line">iex&gt; ~S(String without escape codes \x26 without <span class="comment">#&#123;interpolation&#125;)</span></div><div class="line"><span class="string">"String without escape codes \\x26 without \#&#123;interpolation&#125;"</span></div></pre></td></tr></table></figure>
<p>下面的转义码可以被用在字符串和字符列表里：</p>
<ul>
<li>\ - 单个反斜杠</li>
<li>\a - 铃声/警报</li>
<li>\b - 退格键</li>
<li>\d - 删除键</li>
<li>\e - 退出键</li>
<li>\f - 换页符</li>
<li>\n - 新行符</li>
<li>\r - 回车符</li>
<li>\s - 空格付</li>
<li>\t - Tab键</li>
<li>\v - 垂直Tab键</li>
<li>\0 - 空字节</li>
<li>\xDD - 用十六进制表示的单字节（比如：\x13）</li>
<li>\uDDDD 和 \u{D…} - 用十六进制表示的Unicode代码点（比如：\u{1F600}）</li>
</ul>
<p>另外，在双引号字符串里的双引号需要用\”来转义，类似的，单引号字符列表里的单引号需要用\’来转义。然而，向上述的例子那样改变分隔符而不是转义它们是一种更好的方式。</p>
<p>印记也支持 heredocs ，即 三个双或单引号作为分隔符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s<span class="string">""</span><span class="string">"</span></div><div class="line">...&gt; this is</div><div class="line">...&gt; a heredoc string</div><div class="line">...&gt; "<span class="string">""</span></div></pre></td></tr></table></figure>
<p>heredocs印记最常用的地方是在写文档的时候。例如，在文档里写转义字符很容易出错，因为需要两次转义一些字符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Converts double-quotes to single-quotes.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; convert("\\\<span class="string">"foo\\\""</span>)</div><div class="line">    <span class="string">"'foo'"</span></div><div class="line"></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line">def convert(...)</div></pre></td></tr></table></figure>
<p>但是用~S，这个问题可以完全避免：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">Converts double-quotes to single-quotes.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; convert("\<span class="string">"foo\""</span>)</div><div class="line">    <span class="string">"'foo'"</span></div><div class="line"></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line">def convert(...)</div></pre></td></tr></table></figure>
<h1 id="自定义印记"><a href="#自定义印记" class="headerlink" title="自定义印记"></a><span id="part-four">自定义印记</span></h1><p>如本文开始的时候所提示，Elixir中的印记是一种扩展。实际上，用印记 ~r/foo/i 和以一个二进制数据和一个字符列表作为入参调用 sigil_r 是等效的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; sigil_r(&lt;&lt;<span class="string">"foo"</span>&gt;&gt;, <span class="string">'i'</span>)</div><div class="line">~r<span class="string">"foo"</span>i</div></pre></td></tr></table></figure>
<p>我们可以通过访问sigil_r文档来看看~r：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; h sigil_r</div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们也可以通过遵循 sigil_{identifier} 模式来实现函数以提供我们自己的印记。例如，让我们来实现 ~i 印记，它返回一个整数（使用可选择的 n 修饰符来返回它的负数）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MySigils</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sigil_i</span></span>(string, []), <span class="symbol">do:</span> String.to_integer(string)</div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sigil_i</span></span>(string, [?n]), <span class="symbol">do:</span> -String.to_integer(string)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; import MySigils</div><div class="line">iex&gt; ~i(<span class="number">13</span>)</div><div class="line"><span class="number">13</span></div><div class="line">iex&gt; ~i(<span class="number">42</span>)n</div><div class="line">-<span class="number">42</span></div></pre></td></tr></table></figure>
<p>印记也可以在宏的帮助下被用来做编译期工作。例如，Elixir里的正则表达式可以在源代码编译期间被编译为一个高效的描述，因此在运行期跳过这一步。如果你对这个主题有兴趣，我们建议你学习更多关于宏的知识，并查阅印记在Kernel模块（即形如sigil_*相关被定义的函数）里是如何实现的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/sigils.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/sigils.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;字符串、字符列表和词列表印记&lt;/a&gt;&lt;br&gt; 2.1 &lt;a href=&quot;#part-two-one&quot;&gt;字符串&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#part-two-two&quot;&gt;字符列表&lt;/a&gt;&lt;br&gt; 2.3 &lt;a href=&quot;#part-two-three&quot;&gt;词列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;在印记中插入文本和转义字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;自定义印记&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们已经学了Elixir提供双引号字符串和单引号字符列表。然而，这只是涵盖了该语言有文本表示的数据类型结构的表面。例如，原子主要就是通过 :atom 表示来创建的。&lt;/p&gt;
&lt;p&gt;Elixir其中一个目标是可扩展性：开发者可以扩展该语言来解决任何特定的领域问题。计算机科学已经成为如此广阔的领域，一门语言解决许多领域的问题来作为它的核心部分是不太可能的。相反，我们最好的方法是使语言具有可扩展性，因此开发人员、公司和社区可以将语言扩展到相关领域。&lt;/p&gt;
&lt;p&gt;本章，我们将探索印记，它是由Elixir这门语言提供的处理文本描述数据类型的其中一种机制。印记由波浪字符（~）开始，紧接着是一个字符（这个字符定义本印记），然后是一个分隔符，可选性的修饰符可以增加在最后的分隔符后。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="sigil" scheme="http://szpzs.oschina.io/categories/Elixir/sigil/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="sigil" scheme="http://szpzs.oschina.io/tags/sigil/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－速构</title>
    <link href="http://szpzs.oschina.io/2017/02/11/elixir-getting-started-comprehensions/"/>
    <id>http://szpzs.oschina.io/2017/02/11/elixir-getting-started-comprehensions/</id>
    <published>2017-02-11T12:59:06.000Z</published>
    <updated>2017-02-11T13:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">生成器和过滤器</a></li>
<li><a href="#part-two">位串生成器</a></li>
<li><a href="#part-three">:into选项</a></li>
</ol>
<p>在Elixir中，遍历一个枚举类型数据，过滤其中一些值并且将值映射到另一个列表里这种做法是很平常的。速构是对于这种数据结构的语法糖：Elixir里将这种语法组织成 for 的格式。</p>
<p>例如，我们可以将一个整数列表的每个值都求平方：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>一个速构有三部分组成：生成器、过滤器和收集动作。</p>
<a id="more"></a>
<h1 id="生成器和过滤器"><a href="#生成器和过滤器" class="headerlink" title="生成器和过滤器"></a><span id="part-one">生成器和过滤器</span></h1><p>上面的表达式中，n &lt;- [1, 2, 3, 4] 是<strong>生成器</strong>。它逐个生成在速构中被使用的值。任何枚举类型数据都可以置于生成器表达式的右边：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- <span class="number">1</span>..<span class="number">4</span>, <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>生成器表达式的左边也支持模式匹配；所有没有匹配到的数据被忽略。想象一下，我们用一个关键字列表而不是一个范围类型数据，键有 :good 和 :bad ，而我们只是想计算 :good 的值的平方：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; values = [<span class="symbol">good:</span> <span class="number">1</span>, <span class="symbol">good:</span> <span class="number">2</span>, <span class="symbol">bad:</span> <span class="number">3</span>, <span class="symbol">good:</span> <span class="number">4</span>]</div><div class="line">iex&gt; <span class="keyword">for</span> &#123;<span class="symbol">:good</span>, n&#125; &lt;- values, <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>除了生成器使用模式匹配，过滤器可以被用来选择一些特定的元素。例如，我们可以选择是3的倍数的值而丢弃其他的值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; multiple_of_3? = <span class="keyword">fn</span>(n) -&gt; rem(n, <span class="number">3</span>) == <span class="number">0</span> <span class="keyword">end</span></div><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- <span class="number">0</span>..<span class="number">5</span>, multiple_of_3?.(n), <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">0</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>速构丢弃所有过滤器返回false或者nil的元素，而选择其他元素。</p>
<p>速构通常提供比使用Enum 和 Stream模块里的函数更加简洁的描述。而且，速构也运行有多个生成器和过滤器。这里有一个例子，接收一个目录组成的列表，然后获得这些目录里每一个文件的大小：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dirs = [<span class="string">'/home/mikey'</span>, <span class="string">'/home/james'</span>]</div><div class="line"><span class="keyword">for</span> dir  &lt;- dirs,</div><div class="line">    file &lt;- File.ls!(dir),</div><div class="line">    path = Path.join(dir, file),</div><div class="line">    File.regular?(path) <span class="keyword">do</span></div><div class="line">  File.stat!(path).size</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>多生成器也可以被用来计算两个列表的笛卡儿积：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> i &lt;- [<span class="symbol">:a</span>, <span class="symbol">:b</span>, <span class="symbol">:c</span>], j &lt;- [<span class="number">1</span>, <span class="number">2</span>], <span class="symbol">do:</span>  &#123;i, j&#125;</div><div class="line">[<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">a:</span> <span class="number">2</span>, <span class="symbol">b:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>, <span class="symbol">c:</span> <span class="number">1</span>, <span class="symbol">c:</span> <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>一个更高级的多生成器和多过滤器的例子是毕达哥拉斯三元数组。一个毕达哥拉斯三元数组是满足形如 a<em>a + b</em>b = c*c 这样等式的一个正整数集合，让我们来写一个速构到名为triple.exs的文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Triple</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pythagorean</span></span>(n) <span class="keyword">when</span> n &gt; <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> a &lt;- <span class="number">1</span>..n,</div><div class="line">        b &lt;- <span class="number">1</span>..n,</div><div class="line">        c &lt;- <span class="number">1</span>..n,</div><div class="line">        a + b + c &lt;= n,</div><div class="line">        a*a + b*b == c*c,</div><div class="line">        <span class="symbol">do:</span> &#123;a, b, c&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>接着在终端里运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex triple.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; Triple.pythagorean(<span class="number">5</span>)</div><div class="line">[]</div><div class="line">iex&gt; Triple.pythagorean(<span class="number">12</span>)</div><div class="line">[&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;]</div><div class="line">iex&gt; Triple.pythagorean(<span class="number">48</span>)</div><div class="line">[&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">8</span>, <span class="number">6</span>, <span class="number">10</span>&#125;, &#123;<span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span>&#125;,</div><div class="line"> &#123;<span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>&#125;, &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">13</span>&#125;, &#123;<span class="number">12</span>, <span class="number">9</span>, <span class="number">15</span>&#125;, &#123;<span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>&#125;, &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">17</span>&#125;, &#123;<span class="number">16</span>, <span class="number">12</span>, <span class="number">20</span>&#125;]</div></pre></td></tr></table></figure>
<p>当输入值很大的时候，上面例子的代码是非常耗时的。另外，因为元组 {b, a, c} 和元组{a, b, c}表示的是相同的毕达哥拉斯三元数组，我们的函数产生了重复的结果。我们可以通过在后续的生成器里从前面的生成器引用变量来优化速构并排除重复的结果，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Triple</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pythagorean</span></span>(n) <span class="keyword">when</span> n &gt; <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> a &lt;- <span class="number">1</span>..n-<span class="number">2</span>,</div><div class="line">        b &lt;- a+<span class="number">1</span>..n-<span class="number">1</span>,</div><div class="line">        c &lt;- b+<span class="number">1</span>..n,</div><div class="line">        a + b + c &lt;= n,</div><div class="line">        a*a + b*b == c*c,</div><div class="line">        <span class="symbol">do:</span> &#123;a, b, c&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最后，要记住，速构里的，在生成器、过滤器或者内部代码块里赋值的变量，不会反映到速构外面去。</p>
<h1 id="位串生成器"><a href="#位串生成器" class="headerlink" title="位串生成器"></a><span id="part-two">位串生成器</span></h1><p>位串生成器也是被支持的，并且当你需要解析位串流的时候是非常有用的。下面的例子里，从一个二进制数据里接收一个由像素组成的列表，数据分别代表红、绿和蓝的值，然后将每个像素转换为三个元素的元组：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; pixels = &lt;&lt;<span class="number">213</span>, <span class="number">45</span>, <span class="number">132</span>, <span class="number">64</span>, <span class="number">76</span>, <span class="number">32</span>, <span class="number">76</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">234</span>, <span class="number">32</span>, <span class="number">15</span>&gt;&gt;</div><div class="line">iex&gt; <span class="keyword">for</span> &lt;&lt;<span class="symbol">r:</span><span class="symbol">:</span><span class="number">8</span>, <span class="symbol">g:</span><span class="symbol">:</span><span class="number">8</span>, <span class="symbol">b:</span><span class="symbol">:</span><span class="number">8</span> &lt;- pixels&gt;&gt;, <span class="symbol">do:</span> &#123;r, g, b&#125;</div><div class="line">[&#123;<span class="number">213</span>, <span class="number">45</span>, <span class="number">132</span>&#125;, &#123;<span class="number">64</span>, <span class="number">76</span>, <span class="number">32</span>&#125;, &#123;<span class="number">76</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">234</span>, <span class="number">32</span>, <span class="number">15</span>&#125;]</div></pre></td></tr></table></figure>
<p>位串生成器也可以和“常规的”枚举类型数据生成器混合使用，同时也支持过滤器。</p>
<h1 id="into选项"><a href="#into选项" class="headerlink" title=":into选项"></a><span id="part-three">:into选项</span></h1><p>上面所有的例子，所有的速构都是返回列表作为它们的结果。但是，通过传递 :into 选项给速构，则速构的结果可以被插入到不同的数据结构里。</p>
<p>例如，一个位串生成器可以使用 :into 选项来很容易地删除一个字符串里的所有空格：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> &lt;&lt;c &lt;- <span class="string">" hello world "</span>&gt;&gt;, c != ?\s, <span class="symbol">into:</span> <span class="string">""</span>, <span class="symbol">do:</span> &lt;&lt;c&gt;&gt;</div><div class="line"><span class="string">"helloworld"</span></div></pre></td></tr></table></figure>
<p>集合、映射和其他字典类型数据也可以赋给 :into 选项。总而言之，:into 接收任何实现了 Collectable 协议的数据结构。</p>
<p>:into常见用例是转换映射里的值，而不需要理会它的键：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> &#123;key, val&#125; &lt;- %&#123;<span class="string">"a"</span> =&gt; <span class="number">1</span>, <span class="string">"b"</span> =&gt; <span class="number">2</span>&#125;, <span class="symbol">into:</span> %&#123;&#125;, <span class="symbol">do:</span> &#123;key, val * val&#125;</div><div class="line">%&#123;<span class="string">"a"</span> =&gt; <span class="number">1</span>, <span class="string">"b"</span> =&gt; <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<p>让我们用流来做另一个例子。因为IO模块提供流（就是实现了Enumerable 和 Collectable 协议），那么一个回响终端，即无论输入的是什么都将其大写后返回的终端，可以使用速构来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = IO.stream(<span class="symbol">:stdio</span>, <span class="symbol">:line</span>)</div><div class="line">iex&gt; <span class="keyword">for</span> line &lt;- stream, <span class="symbol">into:</span> stream <span class="keyword">do</span></div><div class="line">...&gt;   String.upcase(line) &lt;&gt; <span class="string">"\n"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，输入任何字符串到终端里，你将看到大写化后的相同字符串打印在终端里。不幸的是，这个例子也使得你的IEx停在速构里，所以你要按两次 Ctl+C来退出。：）</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/comprehensions.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/comprehensions.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;生成器和过滤器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;位串生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;:into选项&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir中，遍历一个枚举类型数据，过滤其中一些值并且将值映射到另一个列表里这种做法是很平常的。速构是对于这种数据结构的语法糖：Elixir里将这种语法组织成 for 的格式。&lt;/p&gt;
&lt;p&gt;例如，我们可以将一个整数列表的每个值都求平方：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; n &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], &lt;span class=&quot;symbol&quot;&gt;do:&lt;/span&gt; n * n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个速构有三部分组成：生成器、过滤器和收集动作。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="comprehension" scheme="http://szpzs.oschina.io/categories/Elixir/comprehension/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="comprehension" scheme="http://szpzs.oschina.io/tags/comprehension/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－协议</title>
    <link href="http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/"/>
    <id>http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/</id>
    <published>2017-02-10T13:36:51.000Z</published>
    <updated>2017-02-10T13:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">协议和结构体</a></li>
<li><a href="#part-two">实现Any</a><br> 2.1. <a href="#part-two-one">派生</a><br> 2.3. <a href="#part-two-two">回退到Any</a></li>
<li><a href="#part-three">内建协议</a></li>
<li><a href="#part-four">协议整合</a></li>
</ol>
<p>协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。</p>
<p>在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。</p>
<p>虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。</p>
<a id="more"></a>
<p>协议的定义看起来像下面这样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">"Calculates the size (and not the length!) of a data structure"</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Size协议期望有一个接受一个入参（我们想要知道大小的数据结构）叫做size的函数被实现。我们现在可以为一些数据结构实现这个协议，这些数据结构应该有一个合适的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> BitString <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(string), <span class="symbol">do:</span> byte_size(string)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Map <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(map), <span class="symbol">do:</span> map_size(map)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Tuple <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(tuple), <span class="symbol">do:</span> tuple_size(tuple)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们没有为列表实现Size协议，因为列表没有预先计算好的“大小”信息，并且列表的长度必须要被计算出来（用 length/1）。</p>
<p>现在我们有了协议定义和实现，我们可以开始使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(<span class="string">"foo"</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; Size.size(&#123;<span class="symbol">:ok</span>, <span class="string">"hello"</span>&#125;)</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; Size.size(%&#123;<span class="symbol">label:</span> <span class="string">"some label"</span>&#125;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>传入一个没有实现协议的数据类型将会引起一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>为所有Elixir数据类型实现协议是可能的：</p>
<ul>
<li>Atom</li>
<li>BitString</li>
<li>Float</li>
<li>Function</li>
<li>Integer</li>
<li>List</li>
<li>Map</li>
<li>PID</li>
<li>Port</li>
<li>Reference</li>
<li>Tuple</li>
</ul>
<h1 id="协议和结构体"><a href="#协议和结构体" class="headerlink" title="协议和结构体"></a><span id="part-one">协议和结构体</span></h1><p>Elixir的可扩展性的能力来自当协议和结构一起使用时。</p>
<p>在上一章，我们已经学到，虽然结构体底层是映射，但是它没有和映射共享协议实现。例如，<a href="https://hexdocs.pm/elixir/MapSet.html" target="_blank" rel="external">MapSet</a> （基于映射的集合）被实现为结构体。让我们尝试应用Size协议于MapSet上：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(%&#123;&#125;)</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; set = %MapSet&#123;&#125; = MapSet.new</div><div class="line"><span class="comment">#MapSet&lt;[]&gt;</span></div><div class="line">iex&gt; Size.size(set)</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> <span class="comment">#MapSet&lt;[]&gt;</span></div></pre></td></tr></table></figure>
<p>结构体没有和映射共享协议实现，而是需要它自己的协议实现。因为MapSet有它自己的预先计算大小并且可以通过MapSet.size/1访问，我们可以为它定义一个Size协议的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> MapSet <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(set), <span class="symbol">do:</span> MapSet.size(set)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果需要，你可以拿出你自己结构大小的语义。你不仅可以用结构体来构建更健壮的数据类型，比如像队列，而且可以为这个数据类型实现所有相关的协议，比如 Enumerable 和 可能的 Size。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> User <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(_user), <span class="symbol">do:</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="实现Any"><a href="#实现Any" class="headerlink" title="实现Any"></a><span id="part-two">实现Any</span></h1><p>手工为所有类型实现协议可能很快就变得重复和单调乏味。在这种情况下，Elixir提供了两种选择：我们可以明确地为我们的类型派生协议的实现或自动为所有类型实现协议。在这两种情况下，我们需要为Any实现协议。</p>
<h2 id="派生"><a href="#派生" class="headerlink" title="派生"></a><span id="part-two-one">派生</span></h2><p>Elixir允许我们基于Any的实现派生一个协议实现。让我们先实现Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述的实现可以说是不合理的。例如，说一个PID或一个整数的大小为零。</p>
<p>然而，我们应该很好地处理这个Any的实现。为了使用这个实现，我们应该需要告诉我们的结构体明确地派生于这个Size协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">OtherUser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@derive</span> [Size]</div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当派生的时候，Elixir将基于为Any提供的实现为OtherUser实现Size协议。</p>
<h2 id="回退到Any"><a href="#回退到Any" class="headerlink" title="回退到Any"></a><span id="part-two-two">回退到Any</span></h2><p>当找不到实现的时候，对于 @derive 的另外一个选择就是明确地告诉协议退回到Any。这可以在协议定义里通过设置@fallback_to_any为true来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@fallback_to_any</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>正如我们在前一节所说，为Any所做的Size实现不能应用到所有数据类型。这就是为什么@fallback_to_any是一个可选项的原因之一。对于大多数协议来说，当没有实现的时候抛出一个错误是正确的行为。也就是说，假设像上一节一样我们已经实现了Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>那么现在所有数据类型（包括结构体），如果它没有实现Size协议，则被认为大小为0。</p>
<p>派生和回退到Any哪一个技术最好，这要依赖于使用场景。但是，Elixir开发者喜欢明确的而不是推断的。你可以看到许多库倾向于 @derive 方法。</p>
<h1 id="内建协议"><a href="#内建协议" class="headerlink" title="内建协议"></a><span id="part-three">内建协议</span></h1><p>Elixir内建了一些协议。前面的章节里，我们讨论过的Enum模块，它提供了许多函数处理任意数据结构，这个模块就实现了 Enumerable 协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span></div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.reduce <span class="number">1</span>..<span class="number">3</span>, <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span></div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>另一个有用的例子是String.Chars协议，它指明如何用字符转换一个数据结构为一个字符串。它通过to_string函数暴露出来：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_string <span class="symbol">:hello</span></div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>注意到Elixir字符串插入是调用to_string函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"age: <span class="subst">#&#123;<span class="number">25</span>&#125;</span>"</span></div><div class="line"><span class="string">"age: 25"</span></div></pre></td></tr></table></figure>
<p>上面的例子可以正常运行是因为数字数据类型实现了String.Chars协议。如果传递一个元组，则会导致一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;tuple&#125;</span>"</span></div><div class="line">** (Protocol.UndefinedError) protocol String.Chars <span class="keyword">not</span> implemented <span class="keyword">for</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p>当需要“打印”一个更复杂的数据结构的时候，我们可以用基于Inspect协议的inspect函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;inspect tuple&#125;</span>"</span></div><div class="line"><span class="string">"tuple: &#123;1, 2, 3&#125;"</span></div></pre></td></tr></table></figure>
<p>Inspect协议被用来转换任何数据结构为一个易于阅读的文本。像IEx这样的工具就是用它来打印的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">name:</span> <span class="string">"john"</span>, <span class="symbol">age:</span> <span class="number">27</span>&#125;</div></pre></td></tr></table></figure>
<p>记住，按照惯例，每当被检查的价值以#开头，它是代表这是非有Elixir的语法的数据结构。这意味着inspect协议是不可逆的，因为以这种方式信息可能会丢失：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; inspect &amp;(&amp;<span class="number">1</span>+<span class="number">2</span>)</div><div class="line"><span class="string">"#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;"</span></div></pre></td></tr></table></figure>
<p>Elixir还有其他协议，不过本文讲最常用的这几个。</p>
<h1 id="协议整合"><a href="#协议整合" class="headerlink" title="协议整合"></a><span id="part-four">协议整合</span></h1><p>当处理Elixir项目的时候，使用Mix构建工具，你可以看到如下的输出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Consolidated String.Chars</div><div class="line">Consolidated Collectable</div><div class="line">Consolidated List.Chars</div><div class="line">Consolidated IEx.Info</div><div class="line">Consolidated Enumerable</div><div class="line">Consolidated Inspect</div></pre></td></tr></table></figure>
<p>这些是Elixir自带的所有协议并且它们被整合。因为一个协议可以派发消息到任何数据类型，如果对于给定的类型的实现存在，则协议一定检查每一个调用。这可能非常消耗资源。</p>
<p>但是，在我们的项目使用像Mix这样的工具被编译后，我们知道所有被定义的模块，包括协议和他们的实现。用这个方法，协议可以被合并到一个非常简单快速的派发模块。</p>
<p>从Elixir v1.2开始，对于所有项目，协议合并都自动发生。我们将在<strong>Mix和OTP指引</strong>里构建我们的项目。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/protocols.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/protocols.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;协议和结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;实现Any&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;派生&lt;/a&gt;&lt;br&gt; 2.3. &lt;a href=&quot;#part-two-two&quot;&gt;回退到Any&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;内建协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;协议整合&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。&lt;/p&gt;
&lt;p&gt;在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。&lt;/p&gt;
&lt;p&gt;虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/categories/Elixir/protocol/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－结构体</title>
    <link href="http://szpzs.oschina.io/2017/02/09/elixir-getting-started-structs/"/>
    <id>http://szpzs.oschina.io/2017/02/09/elixir-getting-started-structs/</id>
    <published>2017-02-09T14:13:18.000Z</published>
    <updated>2017-02-09T14:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">定义结构体</a></li>
<li><a href="#part-two">访问和修改结构体</a></li>
<li><a href="#part-three">结构体的底层是裸映射</a></li>
<li><a href="#part-four">默认值和所需的键</a></li>
</ol>
<p>在第七章我们学了映射：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div><div class="line">iex&gt; map[<span class="symbol">:a</span>]</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; %&#123;map | <span class="symbol">a:</span> <span class="number">3</span>&#125;</div><div class="line">%&#123;<span class="symbol">a:</span> <span class="number">3</span>, <span class="symbol">b:</span> <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>结构体是构建于映射之上的扩展，它提供了编译时检查和默认值。</p>
<a id="more"></a>
<h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a><span id="part-one">定义结构体</span></h1><p>要定义结构体，就要使用 defstruct 结构</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   defstruct <span class="symbol">name:</span> <span class="string">"John"</span>, <span class="symbol">age:</span> <span class="number">27</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>defstruct 用关键字列表定义结构体有什么字段以及它们的默认值。</p>
<p>结构体的名字就是它们被定义所在的模块的名字。上面例子中，我们定义了一个名字为User的结构体。</p>
<p>我们现在可以用与创建映射相似的语法来创建 User 结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; %User&#123;<span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div></pre></td></tr></table></figure>
<p>结构体提供编译时检查来保证只有通过 defstruct 定义的字段（包括所有被定义的字段）才被允许存在它里面：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;<span class="symbol">oops:</span> <span class="symbol">:field</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:oops</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="访问和修改结构体"><a href="#访问和修改结构体" class="headerlink" title="访问和修改结构体"></a><span id="part-two">访问和修改结构体</span></h1><p>当我们讨论映射的时候，我们展示了我们如何访问和修改映射的字段。同样的技术（和同样的语法）也应用在结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; john = %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; john.name</div><div class="line"><span class="string">"John"</span></div><div class="line">iex&gt; meg = %&#123;john | <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div><div class="line">iex&gt; %&#123;meg | <span class="symbol">oops:</span> <span class="symbol">:field</span>&#125;</div><div class="line">** (KeyError) key <span class="symbol">:oops</span> <span class="keyword">not</span> found <span class="symbol">in:</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Meg"</span>&#125;</div></pre></td></tr></table></figure>
<p>当使用修改语法（|）的时候，Erlang虚拟机意识到没有新的键将加入结构体，准许底层的映射在内存里共享它们的结构。上述例子里，john 和 meg 共享内存里相同的键结构。</p>
<p>结构也可以用于模式匹配，既为匹配上的特定键的值以及确保匹配的值是一个同一类型的结构的匹配值。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; %User&#123;<span class="symbol">name:</span> name&#125; = john</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; name</div><div class="line"><span class="string">"John"</span></div><div class="line">iex&gt; %User&#123;&#125; = %&#123;&#125;</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> %&#123;&#125;</div></pre></td></tr></table></figure>
<h1 id="结构体的底层是裸映射"><a href="#结构体的底层是裸映射" class="headerlink" title="结构体的底层是裸映射"></a><span id="part-three">结构体的底层是裸映射</span></h1><p>上面的例子里，模式匹配可以运作是因为结构体的底层是有固定字段集合的裸映射。作为映射，结构体存储了一个名字为 __struct__ 的“特别的”字段，它持有结构体的名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_map(john)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; john.__struct_<span class="number">_</span></div><div class="line">User</div></pre></td></tr></table></figure>
<p>注意：我们称结构体为裸映射是因为为映射实现的协议没有任何一个可用于结构体。例如，你既不能枚举也不能访问一个结构体：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; john = %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div><div class="line">iex&gt; john[<span class="symbol">:name</span>]</div><div class="line">** (UndefinedFunctionError) function User.fetch/<span class="number">2</span> is undefined (User does <span class="keyword">not</span> implement the Access behaviour)</div><div class="line">             User.fetch(%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;, <span class="symbol">:name</span>)</div><div class="line">iex&gt; Enum.each john, <span class="keyword">fn</span>(&#123;field, value&#125;) -&gt; IO.puts(value) <span class="keyword">end</span></div><div class="line">** (Protocol.UndefinedError) protocol Enumerable <span class="keyword">not</span> implemented <span class="keyword">for</span> %User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"John"</span>&#125;</div></pre></td></tr></table></figure>
<p>然后，因为结构体就是映射，它们可以应用于Map模块的函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; kurt = Map.put(%User&#123;&#125;, <span class="symbol">:name</span>, <span class="string">"Kurt"</span>)</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Kurt"</span>&#125;</div><div class="line">iex&gt; Map.merge(kurt, %User&#123;<span class="symbol">name:</span> <span class="string">"Takashi"</span>&#125;)</div><div class="line">%User&#123;<span class="symbol">age:</span> <span class="number">27</span>, <span class="symbol">name:</span> <span class="string">"Takashi"</span>&#125;</div><div class="line">iex&gt; Map.keys(john)</div><div class="line">[<span class="symbol">:__struct__</span>, <span class="symbol">:age</span>, <span class="symbol">:name</span>]</div></pre></td></tr></table></figure>
<p>结构和协议为Elixir开发者提供了最重要的特征之一：数据多态性。这是我们下一章将要探索的。</p>
<h1 id="默认值和所需的键"><a href="#默认值和所需的键" class="headerlink" title="默认值和所需的键"></a><span id="part-four">默认值和所需的键</span></h1><p>如果在定义结构体的时候你没有指定一个键的默认值，则nil将被当做它的默认值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Product</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   defstruct [<span class="symbol">:name</span>]</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; %Product&#123;&#125;</div><div class="line">%Product&#123;<span class="symbol">name:</span> <span class="keyword">nil</span>&#125;</div></pre></td></tr></table></figure>
<p>你也可以强制在创建结构体的时候某些键必需被指定：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Car</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="variable">@enforce_keys</span> [<span class="symbol">:make</span>]</div><div class="line">...&gt;   defstruct [<span class="symbol">:model</span>, <span class="symbol">:make</span>]</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; %Car&#123;&#125;</div><div class="line">** (ArgumentError) the following keys must also be given <span class="keyword">when</span> building struct <span class="symbol">Car:</span> [<span class="symbol">:make</span>]</div><div class="line">    expanding <span class="symbol">struct:</span> Car.__struct_<span class="number">_</span>/<span class="number">1</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/structs.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/structs.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;定义结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;访问和修改结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;结构体的底层是裸映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;默认值和所需的键&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在第七章我们学了映射：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; map = %&amp;#123;&lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;b:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;b:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; map[&lt;span class=&quot;symbol&quot;&gt;:a&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; %&amp;#123;map | &lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;b:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结构体是构建于映射之上的扩展，它提供了编译时检查和默认值。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="struct" scheme="http://szpzs.oschina.io/categories/Elixir/struct/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="struct" scheme="http://szpzs.oschina.io/tags/struct/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－模块属性</title>
    <link href="http://szpzs.oschina.io/2017/02/09/elixir-getting-started-module-attributes/"/>
    <id>http://szpzs.oschina.io/2017/02/09/elixir-getting-started-module-attributes/</id>
    <published>2017-02-09T12:45:15.000Z</published>
    <updated>2017-02-09T12:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">作为注释</a></li>
<li><a href="#part-two">作为常量</a></li>
<li><a href="#part-three">作为临时存储</a></li>
</ol>
<p>在Elixir里，模块属性服务于三个目标：</p>
<ul>
<li>它们常常用一些信息来注释模块被用户或Erlang虚拟机使用。</li>
<li>它们用作常量。</li>
<li>它们被用于编译期间临时模块存储。</li>
</ul>
<p>让我们一个一个地来仔细看看这三个方面。</p>
<a id="more"></a>
<h1 id="作为注释"><a href="#作为注释" class="headerlink" title="作为注释"></a><span id="part-one">作为注释</span></h1><p>Elixr从Erlang那里带来了模块属性这个概念。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@vsn</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在上面的例子里，我们显式地设置模块的版本属性。@vsn 被Erlang虚拟机的代码重装载机制用来检查模块是否已经更新。如果没有指定版本，版本被设置为模块函数的MD5码校验和。</p>
<p>Elixir有一些保留的属性。下面介绍几个最常用的：</p>
<ul>
<li>@moduledoc - 为当前模块提供文档。</li>
<li>@doc - 为紧跟该属性的函数或宏提供文档。</li>
<li>@behaviour - （注意英式拼写）用于指定一个OTP或用户自定义的行为。</li>
<li>@before_compile - 提供一个模块被编译前将被调用的钩子。这使得在编译前确切地注入函数到模块里成为可能。</li>
</ul>
<p>@moduledoc 和 @doc 是到目前为止用得最多的属性，我们希望你大量使用它们。Elixir把文档当做一等公民并且提供许多函数访问文档。你可以参阅<a href="https://hexdocs.pm/elixir/writing-documentation.html" target="_blank" rel="external">我们官方文档里的关于在Elixir里写文档</a>这篇文章来获得更多信息。</p>
<p>我们回到前面章节里定义的Math模块，增加一些文档然后保存到math.ex文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Provides math-related functions.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      iex&gt; Math.sum(1, 2)</div><div class="line">      3</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Calculates the sum of two numbers.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a, b), <span class="symbol">do:</span> a + b</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Elixir推荐用Markdown加上heredoc来写易于阅读的文档。Heredocs是多行字符串，它们起始都是三个双引号，并且保持内部文本的格式。我们可以从IEx里直接访问任何已经编译的文档：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ elixirc math.ex</div><div class="line">$ iex</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; h Math <span class="comment"># Access the docs for the module Math</span></div><div class="line">...</div><div class="line">iex&gt; h Math.sum <span class="comment"># Access the docs for the sum function</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们也提供了一个叫<a href="https://github.com/elixir-lang/ex_doc" target="_blank" rel="external">ExDoc</a>的工具来将文档生成HTML页面。</p>
<p>你可以查阅Module模块的文档来得到一个所支持属性的完整列表。Elixir也用属性来定义 <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html" target="_blank" rel="external">typespec</a> 。</p>
<p>本部分覆盖了内置的属性。但是，属性也能被开发者使用或者被库扩展来支持自定义行为。</p>
<h1 id="作为常量"><a href="#作为常量" class="headerlink" title="作为常量"></a><span id="part-two">作为常量</span></h1><p>Elixir开发者将经常使用模块属性作为常量。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@initial_state</span> %&#123;<span class="symbol">host:</span> <span class="string">"147.0.0.1"</span>, <span class="symbol">port:</span> <span class="number">3456</span>&#125;</div><div class="line">  IO.inspect <span class="variable">@initial_state</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：和Erlang不同，用户定义的属性默认不存储在模块里。属性的值只是在编译的时候存在。开发者可以通过调用 Module.register_attribute/3 设置一个属性来使得行为更接近Erlang。</p>
</blockquote>
<p>试图访问没有定义的属性将打印一个警告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@unknown</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="symbol">warning:</span> undefined <span class="keyword">module</span> attribute <span class="variable">@unknown</span>, please remove access to <span class="variable">@unknown</span> <span class="keyword">or</span> explicitly set it before access</div></pre></td></tr></table></figure>
<p>最后，属性也可以在函数里被读取：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyServer</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@my_data</span> <span class="number">14</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">first_data</span></span>, <span class="symbol">do:</span> <span class="variable">@my_data</span></div><div class="line">  <span class="variable">@my_data</span> <span class="number">13</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">second_data</span></span>, <span class="symbol">do:</span> <span class="variable">@my_data</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyServer.first_data <span class="comment">#=&gt; 14</span></div><div class="line">MyServer.second_data <span class="comment">#=&gt; 13</span></div></pre></td></tr></table></figure>
<p>每次在函数里读取一个属性，获取到的是这个属性值的当前快照。换句话说，该值在编译时读取，而不是在运行时读取。正如我们将要看到的，这也使得在模块编译时用作存储的属性非常有用。</p>
<h1 id="作为临时存储"><a href="#作为临时存储" class="headerlink" title="作为临时存储"></a><span id="part-three">作为临时存储</span></h1><p>Elixir组织里有一个项目：<a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a>，它就是要建立Elixir中web库和框架的共同基础。</p>
<p>Plug库也允许开发者定义他们自己的能在web服务器里运行的插件：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyPlug</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Plug.Builder</div><div class="line"></div><div class="line">  plug <span class="symbol">:set_header</span></div><div class="line">  plug <span class="symbol">:send_ok</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_header</span></span>(conn, _opts) <span class="keyword">do</span></div><div class="line">    put_resp_header(conn, <span class="string">"x-header"</span>, <span class="string">"set"</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">send_ok</span></span>(conn, _opts) <span class="keyword">do</span></div><div class="line">    send(conn, <span class="number">200</span>, <span class="string">"ok"</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts <span class="string">"Running MyPlug with Cowboy on http://localhost:4000"</span></div><div class="line">Plug.Adapters.Cowboy.http MyPlug, []</div></pre></td></tr></table></figure>
<p>在上面的例子里，我们已经用 plug/1 宏来链接当有web请求的时候将被调用的那些函数。在内部，每次你调用 plug/1，Plug库存储给定的参数到一个 @plugs 属性里。仅在模块被编译前，Plug运行一个回调来定义一个函数（call/2）处理HTTP请求。这个函数将按顺序运行@plugs属性里的所有插件。</p>
<p>为了理解底层的代码，我们需要宏，所以我们将在元编程指导里对这个模式进行回顾。但是此刻我们关注的是如何用模块属性作为存储来允许开发者创建DLS（领域特定语言）。</p>
<p>另一个例子来自<a href="https://hexdocs.pm/ex_unit/" target="_blank" rel="external">ExUnit框架</a>，它用模块属性来作为注释和存储：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line"></div><div class="line">  <span class="variable">@tag</span> <span class="symbol">:external</span></div><div class="line">  test <span class="string">"contacts external service"</span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在ExUnit里标签被用来注释测试用例。标签后续可以用来过滤测试用例。例如，你可以避免在你的本机上运行外部测试用例，因为它们缓慢并且依赖其他服务，尽管在你的构建系统里它们仍然是可用的。</p>
<p>我希望这部分内容让你大概了解Elixir如何支持元编程，以及当进行元编程的时候模块属性如何扮演一个重要角色。</p>
<p>在后面的章节，我们将探索结构和协议，然后再探索异常处理和其他结构，比如印记和列表解析。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/module-attributes.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/module-attributes.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;作为注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;作为常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;作为临时存储&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir里，模块属性服务于三个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们常常用一些信息来注释模块被用户或Erlang虚拟机使用。&lt;/li&gt;
&lt;li&gt;它们用作常量。&lt;/li&gt;
&lt;li&gt;它们被用于编译期间临时模块存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们一个一个地来仔细看看这三个方面。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="module-attribute" scheme="http://szpzs.oschina.io/categories/Elixir/module-attribute/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="module-attribute" scheme="http://szpzs.oschina.io/tags/module-attribute/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－alias、require、和import</title>
    <link href="http://szpzs.oschina.io/2017/02/08/elixir-getting-started-alias-require-and-import/"/>
    <id>http://szpzs.oschina.io/2017/02/08/elixir-getting-started-alias-require-and-import/</id>
    <published>2017-02-08T07:33:12.000Z</published>
    <updated>2017-02-08T07:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">alias</a></li>
<li><a href="#part-two">require</a></li>
<li><a href="#part-three">import</a></li>
<li><a href="#part-four">use</a></li>
<li><a href="#part-five">理解alias</a></li>
<li><a href="#part-six">模块嵌套</a></li>
<li><a href="#part-seven">多重 alias/import/require/use</a></li>
</ol>
<p>为了便于软件重用，Elixir提供了三个指令（alias、require和import）外加一个叫做use的宏。如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 别名一个模块则它可以被叫做Bar而不是Foo.Bar</span></div><div class="line"><span class="keyword">alias</span> Foo.Bar, <span class="symbol">as:</span> Bar</div><div class="line"></div><div class="line"><span class="comment"># 确认这个模块是编译好的并且可用的（常常使用于宏）</span></div><div class="line">require Foo</div><div class="line"></div><div class="line"><span class="comment"># 从Foo导入函数，所以它们被调用可以不需要 Foo. 这个前缀</span></div><div class="line">import Foo</div><div class="line"></div><div class="line"><span class="comment"># 调用Foo里作为一个扩展点定义的代码。</span></div><div class="line"><span class="keyword">use</span> Foo</div></pre></td></tr></table></figure>
<p>我们现在将详细地探讨它们。记住前三个被叫做指令因为它们有作用范围，而use是一个常见的扩展点。</p>
<a id="more"></a>
<h1 id="alias"><a href="#alias" class="headerlink" title="alias"></a><span id="part-one">alias</span></h1><p>alias允许你给任何给定的模块设置别名。</p>
<p>假设一个模块使用 Math.List 里实现的一个特殊列表。alias 指令允许在模块定义里只使用List来指代Math.List：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Stats</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">alias</span> Math.List, <span class="symbol">as:</span> List</div><div class="line">  <span class="comment"># 在模块的后续的定义里，List将展开为Math.List。</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>原来的List依然可以通过完全限定名Elixir.List在模块Stats里访问。</p>
<blockquote>
<p>注意：定义在Elixir里所有的模块定义在Elixir命名空间里。但是，为了方便，当引用它们的时候你可以省略“Elixir.”。</p>
</blockquote>
<p>别名常被用来定义快捷方式。实际上，调用 alias 而不用 :as 选项，则自动将别名设置为模块名的最后一部分，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> Math.List</div></pre></td></tr></table></figure>
<p>和如下的代码是一样的效果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> Math.List, <span class="symbol">as:</span> List</div></pre></td></tr></table></figure>
<p>注意：alias 是有作用范围的，它允许你在特定的函数里设置别名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    <span class="keyword">alias</span> Math.List</div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minus</span></span>(a, b) <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的例子里，因为我们在 plus/2 里调用 alias ，别名将只在 plus/2 里有效，minus/2 将一点也不受影响。</p>
<h1 id="require"><a href="#require" class="headerlink" title="require"></a><span id="part-two">require</span></h1><p>Elixir提供宏作为元编程（写代码来生成代码）的一种机制。</p>
<p>宏是一段代码，它在代码编译的时候被执行和展开。这意味着，为了使用宏，我们需要保证在编译期间它的模块和实现是可用的。这可以用 require 指令来完成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Integer.is_odd(<span class="number">3</span>)</div><div class="line">** (UndefinedFunctionError) function Integer.is_odd/<span class="number">1</span> is undefined <span class="keyword">or</span> private. However there is a macro with the same name <span class="keyword">and</span> arity. Be sure to require Integer if you intend to invoke this macro</div><div class="line">iex&gt; require Integer</div><div class="line">Integer</div><div class="line">iex&gt; Integer.is_odd(<span class="number">3</span>)</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>在Elixir里，Integer.is_odd/1 被定义成为一个宏，所以它可以被用来作为一个卫语句。也就是说，为了调用 Integer.is_odd/1 ，我们首先需要 require Integer模块。</p>
<p>总而言之，一个模块在使用前是不需要被 require 的，除非是我们想要使得模块里的宏可用。尝试调用一个没有被装载的宏将引起一个错误。注意，像 alias 指令，require 也是有作用范围的。我们将在后面的章节更深入地讨论宏。</p>
<h1 id="import"><a href="#import" class="headerlink" title="import"></a><span id="part-three">import</span></h1><p>在任何时候我们想不用完全限定名称而方便地访问其他模块的函数或宏，我们就用 import 。例如，如果我们想用 List 里的 duplicate/2 几次，我们可以 import 它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; import List, <span class="symbol">only:</span> [<span class="symbol">duplicate:</span> <span class="number">2</span>]</div><div class="line">List</div><div class="line">iex&gt; duplicate <span class="symbol">:ok</span>, <span class="number">3</span></div><div class="line">[<span class="symbol">:ok</span>, <span class="symbol">:ok</span>, <span class="symbol">:ok</span>]</div></pre></td></tr></table></figure>
<p>在这个例子里，我们仅从List里导入函数duplicate（只有两个入参）。虽然 :only 是可选的，但是为了避免将给定模块的所有函数都导入到命名空间里，这个用法是被推荐使用的。:except 也可以作为选项被设置，它的作用是为了导入一个模块里 <em>除了</em> 一些函数外其他所有函数。</p>
<p>import 也支持把 :macros 和 :functions 给 :only 选项。例如，导入模块的所有宏，可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Integer, <span class="symbol">only:</span> <span class="symbol">:macros</span></div></pre></td></tr></table></figure>
<p>或者导入模块的所有函数，你可以这么写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Integer, <span class="symbol">only:</span> <span class="symbol">:functions</span></div></pre></td></tr></table></figure>
<p>注意：import也是有作用范围的。这意味着我们可以在函数定义里导入特定的宏和函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">some_function</span></span> <span class="keyword">do</span></div><div class="line">    import List, <span class="symbol">only:</span> [<span class="symbol">duplicate:</span> <span class="number">2</span>]</div><div class="line">    duplicate(<span class="symbol">:ok</span>, <span class="number">10</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述例子，被导入的 List.duplicate/2 只在特定的函数里才可见。duplicate/2 在这个模块（就这个问题而言，在任何其他模块）里的任何其他函数都不可用。</p>
<p>注意：<em>import</em> 一个模块自动就 <em>require</em> 它了</p>
<h1 id="use"><a href="#use" class="headerlink" title="use"></a><span id="part-four">use</span></h1><p>虽然不是指令，use却是与require紧密相关的一个宏，它允许你在当前上下文里使用一个模块。这个 use 宏常常被开发者用来把外部功能带入当前作用范围，经常是模块。</p>
<p>例如，为了用 ExUnit 框架写测试，开发者应该使用 ExUnit.Case 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">AssertionTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"always pass"</span> <span class="keyword">do</span></div><div class="line">    assert <span class="keyword">true</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>背后的原理是，use require 给定的模块然后在它上面调用 __using/1__ 回调函数来允许这个模块注入一些代码到当前上下文。通常来说，如下的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Feature, <span class="symbol">option:</span> <span class="symbol">:value</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>被编译成如下样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  require Feature</div><div class="line">  Feature.__using_<span class="number">_</span>(<span class="symbol">option:</span> <span class="symbol">:value</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="理解alias"><a href="#理解alias" class="headerlink" title="理解alias"></a><span id="part-five">理解alias</span></h1><p>到此，你可能想知道：Elixir的别名到底是什么？它是如何表示的？</p>
<p>Elixir里的一个别名是一个大写开头的标识符（像String，Keyword，等等），在编译的时候它被转换成一个原子。例如，String 这个别名默认情况下被转换为 :”Elixir.String” ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_atom(String)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; to_string(String)</div><div class="line"><span class="string">"Elixir.String"</span></div><div class="line">iex&gt; <span class="symbol">:<span class="string">"Elixir.String"</span></span> == String</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>通过用 alias/2 指令，我们改变了别名所要转换成的原子。</p>
<p>别名转换为原子是因为在Erlang虚拟机里（也是Elixir里）模块总是用原子来表示。例如，如下就是我们用来调用Erlang模块的机制：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:lists</span>.flatten([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<h1 id="模块嵌套"><a href="#模块嵌套" class="headerlink" title="模块嵌套"></a><span id="part-six">模块嵌套</span></h1><p>现在我们已经讨论了别名，我们可以讨论嵌套和它在Elixir里是如何运作的。考虑一下如下例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Foo</span></span> <span class="keyword">do</span></div><div class="line">  <span class="class"><span class="keyword">defmodule</span> <span class="title">Bar</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的例子将定义两个模块：Foo 和 Foo.Bar 。第二个模块可以在Foo里以Bar来访问只要它们在相同的作用范围里。上面的代码和下面的代码完全一样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Elixir</span></span>.Foo <span class="keyword">do</span></div><div class="line">  <span class="class"><span class="keyword">defmodule</span> <span class="title">Elixir</span></span>.Foo.Bar <span class="keyword">do</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="keyword">alias</span> Elixir.Foo.Bar, <span class="symbol">as:</span> Bar</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果，以后，Bar 模块被移到Foo模块定义的外面，它必须用完全限定名称（Foo.Bar）引用或者一个别名必须用前面讨论过的alias指令来设置。</p>
<p>注意：在Elixir里，你不必在定义Foo.Bar模块前必须要定义Foo模块，因为Elixir转换所有模块名字为原子。你可以定义任意嵌套的模块而不需要定义链上的任何模块（比如，定义Foo.Bar.Baz而没有先定义Foo或Foo.Bar）。</p>
<p>正如我们将在后面章节看到的，别名在宏里也扮演了一个至关重要的角色，来保证宏的整洁。</p>
<h1 id="多重-alias-import-require-use"><a href="#多重-alias-import-require-use" class="headerlink" title="多重 alias/import/require/use"></a><span id="part-seven">多重 alias/import/require/use</span></h1><p>从Elixir v1.2开始，一次 alias、 import 或 require 多个模块是可能的。当我们开始嵌套模块这是特别有用的，当构建Elixir的应用程序时这是很常见的。例如，假设你有一个应用，所有模块都嵌套在MyApp下，你可以如下面例子一样一次性为MyApp.Foo，MyApp.Bar 和 MyApp.Baz指定别名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> MyApp.&#123;Foo, Bar, Baz&#125;</div></pre></td></tr></table></figure>
<p>我们已经完成了我们的Elixir模块之旅。最后一个主题是模块属性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/alias-require-and-import.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/alias-require-and-import.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;alias&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;require&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;import&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;use&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;理解alias&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;模块嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;多重 alias/import/require/use&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了便于软件重用，Elixir提供了三个指令（alias、require和import）外加一个叫做use的宏。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 别名一个模块则它可以被叫做Bar而不是Foo.Bar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;alias&lt;/span&gt; Foo.Bar, &lt;span class=&quot;symbol&quot;&gt;as:&lt;/span&gt; Bar&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 确认这个模块是编译好的并且可用的（常常使用于宏）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;require Foo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 从Foo导入函数，所以它们被调用可以不需要 Foo. 这个前缀&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import Foo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 调用Foo里作为一个扩展点定义的代码。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; Foo&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们现在将详细地探讨它们。记住前三个被叫做指令因为它们有作用范围，而use是一个常见的扩展点。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="alias require import" scheme="http://szpzs.oschina.io/categories/Elixir/alias-require-import/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="alias" scheme="http://szpzs.oschina.io/tags/alias/"/>
    
      <category term="require" scheme="http://szpzs.oschina.io/tags/require/"/>
    
      <category term="import" scheme="http://szpzs.oschina.io/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－IO和文件系统</title>
    <link href="http://szpzs.oschina.io/2017/02/07/elixir-getting-started-io-and-the-file-system/"/>
    <id>http://szpzs.oschina.io/2017/02/07/elixir-getting-started-io-and-the-file-system/</id>
    <published>2017-02-07T13:24:28.000Z</published>
    <updated>2017-02-07T13:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">IO模块</a></li>
<li><a href="#part-two">File模块</a></li>
<li><a href="#part-three">Path模块</a></li>
<li><a href="#part-four">进程和组领导</a></li>
<li><a href="#part-five">iodata和chardata</a></li>
</ol>
<p>本章是对输入/输出机制和文件系统相关的任务以及相关模块，比如：<a href="https://hexdocs.pm/elixir/IO.html" target="_blank" rel="external">IO</a>、<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File</a>和<a href="https://hexdocs.pm/elixir/Path.html" target="_blank" rel="external">Path</a>的快速介绍。</p>
<p>我们原本计划这章在本系列教程中更早地出现。然而，我们注意到 IO 系统提供一个非常好的机会来阐明Elixir和VM的一些哲学和奇特之处。</p>
<a id="more"></a>
<h1 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a><span id="part-one">IO模块</span></h1><p>IO模块是Elixir里读写标准输入输出（:stdio）、标准错误（:stderr）、文件和其他IO设备的主要机制。这个模块的使用方式非常简单：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">"hello world"</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.gets <span class="string">"yes or no? "</span></div><div class="line">yes <span class="keyword">or</span> no? yes</div><div class="line"><span class="string">"yes\n"</span></div></pre></td></tr></table></figure>
<p>默认情况下，IO模块的函数从标准输入读数据并往标准输出写数据。我们可以改变这个默认方式，例如，通过传递 :stderr 作为一个入参（来写数据到标准错误）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="symbol">:stderr</span>, <span class="string">"hello world"</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<h1 id="File模块"><a href="#File模块" class="headerlink" title="File模块"></a><span id="part-two">File模块</span></h1><p>File模块包含函数允许我们打开文件当做IO文件。默认地，文件以二进制模式打开，这些文件就需要开发者使用IO模式的特定函数 IO.binread/2 和 IO.binwrite/2 来读写。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"hello"</span>, [<span class="symbol">:write</span>]</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.47.0&gt;&#125;</span></div><div class="line">iex&gt; IO.binwrite file, <span class="string">"world"</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.close file</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>文件也可以用 :utf8 编码方式打开，这就告诉File模块解析从文件读取的字节为UTF-8编码的字节。</p>
<p>除了打开、读写文件的函数，File模块还有许多处理文件系统的函数。那些函数命名方式和Unix的函数相对应。例如，File.rm/1 可以用来删除文件，File.mkdir/1 用来创建目录，File.mkdir_p/1 用来创建目录和它所有的父目录。甚至还有 File.cp_r/2 和 File.rm_rf/1 ，分别递归地拷贝和删除文件和目录（即也复制和删除目录的内容）。</p>
<p>你可能也注意到了File模块里的函数有两种类型：一种是“正常”的，另一种是尾部有一个!号的。例如，上面例子里当我们读”hello”文件的时候，我们使用 File.read/1 。相应地，我们可以用File.read!/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; File.read! <span class="string">"hello"</span></div><div class="line"><span class="string">"world"</span></div><div class="line">iex&gt; File.read <span class="string">"unknown"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:enoent</span>&#125;</div><div class="line">iex&gt; File.read! <span class="string">"unknown"</span></div><div class="line">** (File.Error) could <span class="keyword">not</span> read file <span class="string">"unknown"</span>: no such file <span class="keyword">or</span> directory</div></pre></td></tr></table></figure>
<p>注意：带叹号的版本返回文件的内容而不是元组，而如果有任何错误，这个函数就抛出一个错误。</p>
<p>当你想要用模式匹配处理不同的输出的时候，不带叹号的版本是首选：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> File.read(file) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, body&#125;      -&gt; <span class="comment"># do something with the `body`</span></div><div class="line">  &#123;<span class="symbol">:error</span>, reason&#125; -&gt; <span class="comment"># handle the error caused by `reason`</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>但是，如果你期望文件就在那里，带叹号版本更加有用，因为它抛出有意义的错误。避免这样写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, body&#125; = File.read(file)</div></pre></td></tr></table></figure>
<p>因为，一旦有错误，File.read/1 将返回 {:error, reason} 而且模式匹配将失败。你将仍然得到你想要的结果（一个抛出的错误），但是消息却是关于没有匹配上的模式（因此，错误实际上是什么就显得很神秘）。</p>
<p>因此，如果你不想处理错误结果，就优先使用 File.read!/1 。</p>
<h1 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a><span id="part-three">Path模块</span></h1><p>File模块里的绝大多数函数都期望用路径做入参。最常见的是，这些路径将是普通二进制数据。Path模块提供处理这样路径的工具：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Path.join(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</div><div class="line"><span class="string">"foo/bar"</span></div><div class="line">iex&gt; Path.expand(<span class="string">"~/hello"</span>)</div><div class="line"><span class="string">"/Users/jose/hello"</span></div></pre></td></tr></table></figure>
<p>使用Path模块的函数，而不是直接操纵字符串是首选，因为Path模块透明地处理不同的操作系统之间的差异。最后，记住当在Windows执行文件操作的时候，Elixir将自动将斜线（/）转成反斜线（\）。</p>
<p>到此，我们已经讲完了Elixir提供的处理IO和与文件系统交互的主要模块。下面的部分，我们将讨论关于IO的一些高级话题。这些部分不是写Elixir代码所必需的，因此可以略过它们，不过它们对VM里IO系统是如何实现的以及其他特性提供了一个好的概貌。</p>
<h1 id="进程和组领导"><a href="#进程和组领导" class="headerlink" title="进程和组领导"></a><span id="part-four">进程和组领导</span></h1><p>你可能已经注意到 File.open/2 返回一个元组 {:ok, pid} ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"hello"</span>, [<span class="symbol">:write</span>]</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.47.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>之所以是如此，是因为IO模块实际上是和进程打交道（参见<a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">11章</a>）。当你写 IO.write(pid, binary) 的时候，IO模块将发送一个消息给被pid标识的进程，消息里同时带着期望的操作。让我们看看如果我们用我们自己的进程会发生什么：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = spawn <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;  receive <span class="symbol">do:</span> (msg -&gt; IO.inspect msg)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.57.0&gt;</span></div><div class="line">iex&gt; IO.write(pid, <span class="string">"hello"</span>)</div><div class="line">&#123;<span class="symbol">:io_request</span>, <span class="comment">#PID&lt;0.41.0&gt;, #Reference&lt;0.0.8.91&gt;,</span></div><div class="line"> &#123;<span class="symbol">:put_chars</span>, <span class="symbol">:unicode</span>, <span class="string">"hello"</span>&#125;&#125;</div><div class="line">** (ErlangError) erlang <span class="symbol">error:</span> <span class="symbol">:terminated</span></div></pre></td></tr></table></figure>
<p>上述例子中，在 IO.write/2 后，我们可以看到IO模块发送的请求（四元素元组）被打印出来。紧跟其后，我们看到了失败，因为IO模块所期望的结果我们没有支持。</p>
<p><a href="https://hexdocs.pm/elixir/StringIO.html" target="_blank" rel="external">StringIO</a>模块提供了基于字符串之上的IO设备消息的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = StringIO.open(<span class="string">"hello"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; IO.read(pid, <span class="number">2</span>)</div><div class="line"><span class="string">"he"</span></div></pre></td></tr></table></figure>
<p>通过用进程模型化IO设备，Erlang虚拟机允许同一个网络里的不同节点互访文件进程来在不同节点间读写文件。在所有IO设备中，有一个对所有进程都很特别，就是：<strong>组领导</strong>。</p>
<p>当你写数据给 :stdio 的时候，你实际上是发消息给组领导，由它写数据给标注输出文件描述符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="symbol">:stdio</span>, <span class="string">"hello"</span></div><div class="line">hello</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.puts Process.group_leader, <span class="string">"hello"</span></div><div class="line">hello</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>每个进程都可以配置组领导，组领导在不同的情况下使用。例如，当在一个远程终端上执行代码，它保证远程节点上的消息被重定向并打印在触发请求的终端上。</p>
<h1 id="iodata和chardata"><a href="#iodata和chardata" class="headerlink" title="iodata和chardata"></a><span id="part-five">iodata和chardata</span></h1><p>在上面所有的例子里，当写数据到文件的时候，我们使用二进制数据。在“二进制数据、字符串和字符列表”那一章，我们提到字符串是怎样由二进制数据构成而字符列表unicode代码点的列表。</p>
<p>IO模块和File模块里的函数也允许列表作为入参。不仅如此，它们也运行混合列表，列表里包含整数和二进制数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">'hello world'</span></div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; IO.puts [<span class="string">'hello'</span>, ?\s, <span class="string">"world"</span>]</div><div class="line">hello world</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然而，在IO操作中使用列表需要一些注意。一个列表可能表示一串二进制数据或者一串字符，而到底使用哪一个依赖于IO设备的编码。如果一个文件没有指定编码方式打开，它被期望是原始模式，则IO模块里以 bin* 开头的函数就必须被使用。这些函数期望一个 iodata 作为入参，也就是，它们期望一个表示字节和二进制数据的整数列表被传入。</p>
<p>另一方面，:stdio 和以 :utf8 编码打开的文件将用其余的IO模块中的函数处理。这些函数期望一个 char_data 作为入参，也就是，一个字符或者字符串列表。</p>
<p>虽然这是一个微妙的区别，你只需要担心这些细节，如果你打算传递列表给这些函数。二进制数据已经由底层字节表示，因此它们的表示总是“原始”的。</p>
<p>到此我们结束了IO设备和IO相关功能之旅。我们已经学了四个Elixir模块：<a href="https://hexdocs.pm/elixir/IO.html" target="_blank" rel="external">IO</a>、<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File</a>、<a href="https://hexdocs.pm/elixir/Path.html" target="_blank" rel="external">Path</a>和<a href="https://hexdocs.pm/elixir/StringIO.html" target="_blank" rel="external">StringIO</a>，也学了Erlang虚拟机如何用进程来处理底层IO机制以及如何使用 chardata  和 iodata 来进行IO操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/io-and-the-file-system.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;IO模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;File模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Path模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;进程和组领导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;iodata和chardata&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是对输入/输出机制和文件系统相关的任务以及相关模块，比如：&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;IO&lt;/a&gt;、&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;File&lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;Path&lt;/a&gt;的快速介绍。&lt;/p&gt;
&lt;p&gt;我们原本计划这章在本系列教程中更早地出现。然而，我们注意到 IO 系统提供一个非常好的机会来阐明Elixir和VM的一些哲学和奇特之处。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="io" scheme="http://szpzs.oschina.io/categories/Elixir/io/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="io" scheme="http://szpzs.oschina.io/tags/io/"/>
    
      <category term="file system" scheme="http://szpzs.oschina.io/tags/file-system/"/>
    
      <category term="Path" scheme="http://szpzs.oschina.io/tags/Path/"/>
    
      <category term="StringIO" scheme="http://szpzs.oschina.io/tags/StringIO/"/>
    
      <category term="group leader" scheme="http://szpzs.oschina.io/tags/group-leader/"/>
    
      <category term="iodata" scheme="http://szpzs.oschina.io/tags/iodata/"/>
    
      <category term="chardata" scheme="http://szpzs.oschina.io/tags/chardata/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－进程</title>
    <link href="http://szpzs.oschina.io/2017/02/06/elixir-getting-started-processes/"/>
    <id>http://szpzs.oschina.io/2017/02/06/elixir-getting-started-processes/</id>
    <published>2017-02-06T14:46:57.000Z</published>
    <updated>2017-02-06T14:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">创建进程</a></li>
<li><a href="#part-two">发送和接收消息</a></li>
<li><a href="#part-three">链接</a></li>
<li><a href="#part-four">任务</a></li>
<li><a href="#part-five">状态</a></li>
</ol>
<p>在Elixir，所有代码运行在进程里。进程彼此间隔离，彼此间并发运行，并且通过消息传递来交流。进程不仅是Elixir的并发基础，它也为构建分布式和容错程序提供手段。</p>
<p>Elixir的进程不应该和操作系统的进程混淆。Elixir的进程就内存和CPU的消耗来说是极其轻量的（不同于许多其他编程语言中的线程）。正因如此，成千上万的进程同时运行是很平常的。</p>
<p>在本章里，我们将学习关于创建新进程的基本结构以及进程间收发消息。</p>
<a id="more"></a>
<h1 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a><span id="part-one">创建进程</span></h1><p>创建新进程的基本机制是自动导入的 spawn/1  函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; <span class="number">1</span> + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.43.0&gt;</span></div></pre></td></tr></table></figure>
<p>spawn/1 的入参是一个函数，这个函数将在另一个进程里执行。</p>
<p>注意 spawn/1 返回一个PID（进程标识符）。像如上的例子，你产生的过程很可能是死的。被创建的进程将执行给定的函数，并且在函数结束后退出。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = spawn <span class="keyword">fn</span> -&gt; <span class="number">1</span> + <span class="number">2</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.44.0&gt;</span></div><div class="line">iex&gt; Process.alive?(pid)</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：你将很可能获得一个不同于我们这个例子里获得的进程标识符。</p>
</blockquote>
<p>我们可以调用 self/0 来获取当前进程的PID：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">self</span>()</div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line">iex&gt; Process.alive?(<span class="keyword">self</span>())</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>当我们能够发送和接收消息时，进程变得更加有趣。</p>
<h1 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a><span id="part-two">发送和接收消息</span></h1><p>我们可以用 send/2 发送消息给一个进程并且可以用 receive/1 接收消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; send <span class="keyword">self</span>(), &#123;<span class="symbol">:hello</span>, <span class="string">"world"</span>&#125;</div><div class="line">&#123;<span class="symbol">:hello</span>, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, msg&#125; -&gt; msg</div><div class="line">...&gt;   &#123;<span class="symbol">:world</span>, msg&#125; -&gt; <span class="string">"won't match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>当一条消息发送给一个进程，这个消息存储在进程的邮箱里。receive/1 语句块遍历当前邮箱来查找任何匹配给定模式的消息。receive/1 支持卫语句和许多分支，就如 case/2 一样。</p>
<p>发送消息的进程不会阻塞在 send/2 上，它只是将消息放入接收者的邮箱然后继续执行后面的语句。特别是，进程可以给自己发送消息。在上面的例子里，当 receive 语句块获得执行的时候，发送者进程可能已经死掉了。</p>
<p>如果没有邮箱里的消息匹配任何模式，则当前进程将等待一直到一个匹配的消息到来。超时也可以被指定：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, msg&#125;  -&gt; msg</div><div class="line">...&gt; after</div><div class="line">...&gt;   <span class="number">1_000</span> -&gt; <span class="string">"nothing after 1s"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"nothing after 1s"</span></div></pre></td></tr></table></figure>
<p>当你已经期待的消息已经在邮箱里的时候，可以将超时设置为0。</p>
<p>让我们把这些放在一起并在进程间发送消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; parent = <span class="keyword">self</span>()</div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; send(parent, &#123;<span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;) <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.48.0&gt;</span></div><div class="line">iex&gt; receive <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:hello</span>, pid&#125; -&gt; <span class="string">"Got hello from <span class="subst">#&#123;inspect pid&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got hello from #PID&lt;0.48.0&gt;"</span></div></pre></td></tr></table></figure>
<p>当在使用shell的时候，你可能发现帮助函数 flush/0 非常有用。它刷新并打印邮箱里的所有消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; send <span class="keyword">self</span>(), <span class="symbol">:hello</span></div><div class="line"><span class="symbol">:hello</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:hello</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><span id="part-three">链接</span></h1><p>在Elixir里最通用的创建进程的方式实际上是用 spawn_link/1 函数。在我们展示 spawn_link/1 的例子之前，让我们尝试看看当一个进程失败的时候会发生什么：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.58.0&gt;</span></div><div class="line"></div><div class="line">[error] Process <span class="comment">#PID&lt;0.58.00&gt; raised an exception</span></div><div class="line">** (RuntimeError) oops</div><div class="line">    <span class="symbol">:erlang</span>.apply/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>它只是记录一个错误，而创建者依然运行。这是因为进程间是隔离的。如果我们想一个进程的失败会传递给另一个进程，我们应该将它们链接在一起。这可以用 spawn_link/1 来做到：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn_link <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.41.0&gt;</span></div><div class="line"></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.41.0&gt;) an exception was raised:</span></div><div class="line">    ** (RuntimeError) oops</div><div class="line">        <span class="symbol">:erlang</span>.apply/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>当在shell里发生一个失败，shell自动地捕获这个失败并以合适的格式展现出来。为了理解在我们的代码里到底将发生什么，让我们在一个文件里使用 spawn_link/1 ，并运行它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># spawn.exs</span></div><div class="line">spawn_link <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">receive <span class="keyword">do</span></div><div class="line">  <span class="symbol">:hello</span> -&gt; <span class="string">"let's wait until the process fails"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ elixir spawn.exs</div><div class="line"></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.47.0&gt;) an exception was raised:</span></div><div class="line">    ** (RuntimeError) oops</div><div class="line">        spawn.exs:1: anonymous fn/0 <span class="keyword">in</span> :elixir_compiler_0.__FILE__/1</div></pre></td></tr></table></figure>
<p>这一次，进程失败并且把它的父进程也搞垮了，因为它们是链接的。链接也可以通过调用 Process.link/1 来手工做到。我们建议你看一下 Process 模块来研究进程提供的其他功能。</p>
<p>当构建容错系统的时候，进程和链接扮演重要角色。在Elixir的应用里，我们经常链接我们的进程到一个监督者，当一个进程死掉的时候，这个监督者可以检测到，并且在那个地方启动一个新进程。这是唯一可能的，因为进程是隔离的，默认情况下不共享任何东西。并且因为进程是隔离的，因此没有方法在一个进程失败的时候崩溃或破坏另一个进程的状态。</p>
<p>其他语言需要我们捕获和处理异常，而在Elixir里，我们实际上是乐于让进程失败，因为我们期望监督者正确地重新启动我们的系统。当我们写Elixir程序的时候，“快速失败”是一种常见的哲学！</p>
<p>在Elixir里，spawn/1 和 spawn_link/1 是创建进程的基本命令。虽然目前为止我们只使用了它们两个，但是绝大多数时候我们将使用构建于它们之上的抽象。让我们看看这些抽象中最常用的一个，它叫做任务。</p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a><span id="part-four">任务</span></h1><p>任务构建在创建进程函数之上，以提供更好的错误报告和内省：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex(<span class="number">1</span>)&gt; Task.start <span class="keyword">fn</span> -&gt; raise <span class="string">"oops"</span> <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.55.0&gt;&#125;</span></div><div class="line"></div><div class="line"><span class="number">15</span><span class="symbol">:</span><span class="number">22</span><span class="symbol">:</span><span class="number">33.046</span> [error] Task <span class="comment">#PID&lt;0.55.0&gt; started from #PID&lt;0.53.0&gt; terminating</span></div><div class="line">** (RuntimeError) oops</div><div class="line">    (elixir) lib/task/supervised.<span class="symbol">ex:</span><span class="number">74</span>: Task.Supervised.do_apply/<span class="number">2</span></div><div class="line">    (stdlib) proc_lib.<span class="symbol">erl:</span><span class="number">239</span>: <span class="symbol">:proc_lib</span>.init_p_do_apply/<span class="number">3</span></div><div class="line"><span class="symbol">Function:</span> <span class="comment">#Function&lt;20.90072148/0 in :erl_eval.expr/5&gt;</span></div><div class="line">    <span class="symbol">Args:</span> []</div></pre></td></tr></table></figure>
<p>我们用 Task.start/1 和 Task.start_link/1 替代 spawn/1 和 spawn_link/1 ，它们返回 {:ok, pid} ，而不只是PID。这就是为什么使得任务被用在监督树里。而且Task提供像 Task.async/1 和 Task.await/1 这样的便捷的函数以及易于分布式的功能。</p>
<p>我们将在 <strong>Mix 和 OTP 指导</strong> 里探索这些功能，现在记住使用 Task 来获得更好的错误报告就足够了。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a><span id="part-five">状态</span></h1><p>到目前为止，我们的教程还没有讨论过状态。如果你正在构建一个需要状态的应用，例如，保存你的应用配置，或者你需要分析一个文件并且保存在内存里，那么你需要保存它在哪里？</p>
<p>对于这个问题，进程是最通用的回答。我们可以写无限循环的，维护状态的，并且收发消息的进程。作为一个例子，让我们写一个模块，它开始一个新进程，这个进程像一个键值对存储一样工作，这个模块在名字为kv.exs的文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Task.start_link(<span class="keyword">fn</span> -&gt; loop(%&#123;&#125;) <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">loop</span></span>(map) <span class="keyword">do</span></div><div class="line">    receive <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:get</span>, key, caller&#125; -&gt;</div><div class="line">        send caller, Map.get(map, key)</div><div class="line">        loop(map)</div><div class="line">      &#123;<span class="symbol">:put</span>, key, value&#125; -&gt;</div><div class="line">        loop(Map.put(map, key, value))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：start_link 函数启动一个新进程来运行 loop/1 函数，这个函数以一个空的映射为入参。loop/1 函数然后等待消息，并且为每个消息执行适当的操作。如果是一个 :get 消息，它发送一个消息回去给调用者并再次调用 loop/1 ，接着等待新的消息。而 :put 消息的话，实际上用一个新版本的映射作为入参调用 loop/1 ，这个新版本的映射存储了给定的键和值。</p>
<p>让我们通过运行 iex kv.exs 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.62.0&gt;&#125;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="keyword">nil</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>首先，进程的映射没有键，那么发送一个 :get 消息给它然后刷新当前进程的邮箱将返回 nil ，让我发送一个 :put 消息来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; send pid, &#123;<span class="symbol">:put</span>, <span class="symbol">:hello</span>, <span class="symbol">:world</span>&#125;</div><div class="line">&#123;<span class="symbol">:put</span>, <span class="symbol">:hello</span>, <span class="symbol">:world</span>&#125;</div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:world</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>注意进程如何保持状态，并且我们通过给进程发送消息来获取和修改这个状态。实际上，任何进程只要知道上面例子的pid都能够给这个pid发送消息并且操作它的进程。</p>
<p>注册这个pid并给它一个名字也是可以的，并且允许所有知道它名字的进程都可以给它发送消息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; Process.register(pid, <span class="symbol">:kv</span>)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; send <span class="symbol">:kv</span>, &#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:get</span>, <span class="symbol">:hello</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:world</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>在Elixir应用里用进程来维护状态和名字注册是非常通用的模式。但是，绝大多数时候，我们不需要像上面例子一样来手工实现那些模式，而是使用Elixir自带的许多抽象之一就可以。例如，Elixir提供了 <a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">代理者</a> ，它是以状态为基础的简单抽象：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; Agent.update(pid, <span class="keyword">fn</span> map -&gt; Map.put(map, <span class="symbol">:hello</span>, <span class="symbol">:world</span>) <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Agent.get(pid, <span class="keyword">fn</span> map -&gt; Map.get(map, <span class="symbol">:hello</span>) <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:world</span></div></pre></td></tr></table></figure>
<p>一个 :name 选项一个可以传给 Agent.start_link/2 ，这样它将被自动注册。除了代理者，Elixir提供了一个API来构建通用服务（叫做 GenServer），任务，以及其他更多事务，这些全部由下面的进程驱动。这些，连同监督树，将在 <strong>Mix 和 OTP 指导</strong>（这个指导将从开始到结束构建一个完整的Elixir应用） 里更详细地探讨。</p>
<p>接下来，让我们探索Elixir的I/O世界。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/processes.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;创建进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;发送和接收消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;状态&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir，所有代码运行在进程里。进程彼此间隔离，彼此间并发运行，并且通过消息传递来交流。进程不仅是Elixir的并发基础，它也为构建分布式和容错程序提供手段。&lt;/p&gt;
&lt;p&gt;Elixir的进程不应该和操作系统的进程混淆。Elixir的进程就内存和CPU的消耗来说是极其轻量的（不同于许多其他编程语言中的线程）。正因如此，成千上万的进程同时运行是很平常的。&lt;/p&gt;
&lt;p&gt;在本章里，我们将学习关于创建新进程的基本结构以及进程间收发消息。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Elixir/process/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－枚举类型和流</title>
    <link href="http://szpzs.oschina.io/2017/02/05/elixir-getting-started-enumerables-and-streams/"/>
    <id>http://szpzs.oschina.io/2017/02/05/elixir-getting-started-enumerables-and-streams/</id>
    <published>2017-02-05T02:50:23.000Z</published>
    <updated>2017-02-05T02:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">枚举类型</a></li>
<li><a href="#part-two">积极 vs 懒惰</a></li>
<li><a href="#part-three">管道运算符</a></li>
<li><a href="#part-four">流</a></li>
</ol>
<a id="more"></a>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><span id="part-one">枚举类型</span></h1><p>Elixir提供了枚举类型的概念以及<a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="external">Enum模块</a>来处理它们。我们已经学了两个枚举类型：list 和 map 。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span> x -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.map(%&#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>&#125;, <span class="keyword">fn</span> &#123;k, v&#125; -&gt; k * v <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">12</span>]</div></pre></td></tr></table></figure>
<p>Enum模块提供了大量的函数来转换、排序、分组、过滤枚举数据以及从枚举数据里获取元素。它是程序员在他们的Elixir代码里经常使用的模块之一。</p>
<p>Elixir也提供了范围这种数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)</div><div class="line">[2, 4, 6]</div><div class="line">iex&gt; Enum.reduce(1..3, 0, &amp;+/2)</div><div class="line">6</div></pre></td></tr></table></figure>
<p>Enum模块里的函数正如它的名字所示，它们被限制只能枚举数据结构的值。对于特殊的操作，比如插入和修改特定的元素，你可能需要根据特定的数据类型使用相应的模块。例如，如果你要在列表的给定位置插入一个元素，你应该使用List模块里的List.insert_at/3函数，因为它插入一个值到一个范围数据里是没意义的。</p>
<p>我们说Enum模块里的函数是多态的，是因为它们可以处理多种数据类型。尤其是，Enum模块里的函数可以处理任何实现了<a href="https://hexdocs.pm/elixir/Enumerable.html" target="_blank" rel="external">Enumerable协议</a>的数据。我们将在后续的章节讨论协议；现在我们将学习叫做流的特殊枚举类型。</p>
<h1 id="积极-VS-懒惰"><a href="#积极-VS-懒惰" class="headerlink" title="积极 VS 懒惰"></a><span id="part-two">积极 VS 懒惰</span></h1><p>Enum模块里的所有函数都是积极的。许多函数都期盼一个枚举类型数据然后返回一个列表。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; odd? = &amp;(rem(&amp;<span class="number">1</span>, <span class="number">2</span>) != <span class="number">0</span>)</div><div class="line"><span class="comment">#Function&lt;6.80484245/1 in :erl_eval.expr/5&gt;</span></div><div class="line">iex&gt; Enum.filter(<span class="number">1</span>..<span class="number">3</span>, odd?)</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>这意味着，当用Enum进行多个操作的时候，每个操作都将生成一个中间列表一直到我们最后得到结果。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Enum.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Enum.filter(odd?) |&gt; Enum.sum</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>上面的例子是一个管道操作。我们从一个范围数据开始，然后将它的每个元素乘于3。第一个操作将创建和返回一个有10万元素的列表。接着我们保留这个列表里的所有奇数元素并生成一个新的有5万元素的列表，最后我们统计这些元素的和。</p>
<h1 id="管道运算符"><a href="#管道运算符" class="headerlink" title="管道运算符"></a><span id="part-three">管道运算符</span></h1><p>上面例子使用的 |&gt; 符号是管道运算符：它获取它左边表达式的输出然后将这个输出作为第一个参数传给它右边的函数。它和Unix的 | 管道操作符相似。其目的是突出数据被一系列函数变换。为了看清楚它是如何使得代码更简洁的，我们来看看上述例子不用 |&gt; 运算符来写的样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.sum(Enum.filter(Enum.map(<span class="number">1</span>..<span class="number">100_000</span>, &amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)), odd?))</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>请阅读相关<a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" target="_blank" rel="external">文档</a>来深入理解管道运算符。</p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a><span id="part-four">流</span></h1><p>作为Enum的替代物，Elixir提供了支持懒操作的<a href="https://hexdocs.pm/elixir/Stream.html" target="_blank" rel="external">Stream模块</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Stream.filter(odd?) |&gt; Enum.sum</div><div class="line"><span class="number">7500000000</span></div></pre></td></tr></table></figure>
<p>流是懒惰的，可组合的枚举数据类型。</p>
<p>在上述例子里，1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) 返回一个数据类型，实际上就是一个流，它表示在范围数据 1..100_000上的映射计算：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>))</div><div class="line"><span class="comment">#Stream&lt;[enum: 1..100000, funs: [#Function&lt;34.16982430/1 in Stream.map/2&gt;]]&gt;</span></div></pre></td></tr></table></figure>
<p>而且，它们是可组合的，因为我们可以用管道操作来组合多个流：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>..<span class="number">100_000</span> |&gt; Stream.map(&amp;(&amp;<span class="number">1</span> * <span class="number">3</span>)) |&gt; Stream.filter(odd?)</div><div class="line"><span class="comment">#Stream&lt;[enum: 1..100000, funs: [...]]&gt;</span></div></pre></td></tr></table></figure>
<p>流不是生成中间表，而是建立一系列计算，只有当我们传递底层的流给Enum模块，这些计算才被执行。当处理大的、可能是无限的集合数据时，流非常有用。</p>
<p>Stream模块里的许多函数接收任何枚举数据作为入参，并且返回一个流作为结果。它也提供函数来创建流。例如，Stream.cycle/1 可以通过无限循环给定的枚举数据来创建一个流。小心：不要在这样的流上调用像 Enum.map/2 这样的函数，因为它们会无限循环下去：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = Stream.cycle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">#Function&lt;15.16982430/2 in Stream.cycle/1&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">10</span>)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>另一方面，Stream.unfold/2 可以被用来从一个给定的初始值来创建流：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = Stream.unfold(<span class="string">"hełło"</span>, &amp;String.next_codepoint/<span class="number">1</span>)</div><div class="line"><span class="comment">#Function&lt;39.75994740/2 in Stream.unfold/2&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">3</span>)</div><div class="line">[<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"ł"</span>]</div></pre></td></tr></table></figure>
<p>另一个有趣的函数是 stream.resource/3，它可被用来包裹资源，从而保证资源即使在失败的情况下也可以在枚举之前被正确地打开和在后续被关闭。例如，我们可以用它来流式一个文件：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = File.stream!(<span class="string">"path/to/file"</span>)</div><div class="line"><span class="comment">#Function&lt;18.16982430/2 in Stream.resource/3&gt;</span></div><div class="line">iex&gt; Enum.take(stream, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>上面的例子将获取你选在的文件的前10行。这意味着，流在处理大文件或者像网络资源这样的慢资源上非常有用。</p>
<p>Enum和Stream模块里的函数数量可能让你一开始觉得很难，不过通过各种案例，你将会熟悉它们。尤其是，首先要专注在Enum模块，只在需要懒操作的特别场景，例如处理慢资源或者大的、可能无限的集合数据的时候才转向Stream模块。</p>
<p>下一章，我们将看看Elixir的一个核心特性：进程，它将允许我们以简单和可理解的方式来写并发、并行和分布式程序。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/enumerables-and-streams.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/enumerables-and-streams.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;枚举类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;积极 vs 懒惰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;管道运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;流&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="enumerable stream" scheme="http://szpzs.oschina.io/categories/Elixir/enumerable-stream/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="enumerable" scheme="http://szpzs.oschina.io/tags/enumerable/"/>
    
      <category term="stream" scheme="http://szpzs.oschina.io/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－递归</title>
    <link href="http://szpzs.oschina.io/2017/02/04/elixir-getting-started-recursion/"/>
    <id>http://szpzs.oschina.io/2017/02/04/elixir-getting-started-recursion/</id>
    <published>2017-02-04T10:15:23.000Z</published>
    <updated>2017-02-05T02:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">用递归实现循环</a></li>
<li><a href="#part-two">reduce 和 map 算法</a></li>
</ol>
<a id="more"></a>
<h1 id="用递归实现循环"><a href="#用递归实现循环" class="headerlink" title="用递归实现循环"></a><span id="part-one">用递归实现循环</span></h1><p>由于不可修改的特性，Elixir里的循环（如任何其他函数式语言原因）和命令式语言的写法不同。例如，在命令式语言，如C里，循环的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>); i++) &#123;</div><div class="line">  <span class="built_in">array</span>[i] = <span class="built_in">array</span>[i] * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述例子里，我们修改数组和变量i。在Elixir里修改变量值是不可能的。相反，函数式语言依赖于递归：一个函数被递归地调用，直到一个条件符合了才停止递归动作继续进行。在这个过程里面，没有数据被修改。思考一下下面的例子，打印一个字符串任意次数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Recursion</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_multiple_times</span></span>(msg, n) <span class="keyword">when</span> n &lt;= <span class="number">1</span> <span class="keyword">do</span></div><div class="line">    IO.puts msg</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_multiple_times</span></span>(msg, n) <span class="keyword">do</span></div><div class="line">    IO.puts msg</div><div class="line">    print_multiple_times(msg, n - <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Recursion.print_multiple_times(<span class="string">"Hello!"</span>, <span class="number">3</span>)</div><div class="line"><span class="comment"># Hello!</span></div><div class="line"><span class="comment"># Hello!</span></div><div class="line"><span class="comment"># Hello!</span></div></pre></td></tr></table></figure>
<p>和case语句相似，一个函数可能有多个分支。当传递给函数的参数匹配某个分支的参数模式，并且这个分支的卫语句结果为true，那么这个特定的分支将被执行。</p>
<p>当上述例子里的 print_multiple_times/2 函数刚开始被调用的时候，参数 n 等于3。</p>
<p>第一个分支有一个卫语句，它说，“当且仅当n小于等于1的时候使用这个分支”。因为一开始的时候n等于3，这个条件不成立，则Elixir处理下一个分支定义。</p>
<p>第二个分支定义匹配这个模式并且没有卫语句，因此它将被执行。它首先打印我们的 msg 变量，然后传递 n - 1 （2）作为第二个入参并调用自己。</p>
<p>我们的 msg 变量被打印并且 print_multiple_times/2 被再次调用，这次第二个入参为1。因为n现在为1，print_multiple_times/2 的第一个分支定义的卫语句结果为true，那么我们执行这个特定的分支定义。msg被打印，并且没有其他需要执行的。</p>
<p>我们这样定义 print_multiple_times/2 ，不管传递的第二个参数是什么数值，它可能触发我们第一个分支（也就是基准条件），或者它出发我们第二个分支，它将确保我们离我们的基准条件更近一步。</p>
<h1 id="reduce-和-map-算法"><a href="#reduce-和-map-算法" class="headerlink" title="reduce 和 map 算法"></a><span id="part-two">reduce 和 map 算法</span></h1><p>现在让我们看看我们如何利用递归的能力来对数字列表进行求和：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum_list</span></span>([head | tail], accumulator) <span class="keyword">do</span></div><div class="line">    sum_list(tail, head + accumulator)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum_list</span></span>([], accumulator) <span class="keyword">do</span></div><div class="line">    accumulator</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">IO.puts Math.sum_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>) <span class="comment">#=&gt; 6</span></div></pre></td></tr></table></figure>
<p>我们用列表[1, 2, 3]和初始值0作为入参来调用 sum_list 。我们将尝试每一个分支直到我们找到一个分支，根据模式匹配规则它匹配了。在这个场景下，列表[1, 2, 3]匹配了[head | tail]，它绑定了head为1，tail为[2, 3]，accumulator为0。</p>
<p>然后，我们将列表的头元素加到累加器里：head + accumulator，并且传递列表尾部作为第一个参数，再次递归地调用 sum_list 。这个列表尾部再一次匹配 [head | tail]，这个情况一直到列表为空为止。参见如下演示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum_list [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span></div><div class="line">sum_list [<span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span></div><div class="line">sum_list [<span class="number">3</span>], <span class="number">3</span></div><div class="line">sum_list [], <span class="number">6</span></div></pre></td></tr></table></figure>
<p>当列表为空，它将匹配最后一个分支，然后返回最后结果为6。</p>
<p>将列表分解为一个值的过程称为归约算法，是函数编程的核心。</p>
<p>如果我们想将我们列表的所有元素值都翻倍，我们该如何做呢？</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Math</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double_each</span></span>([head | tail]) <span class="keyword">do</span></div><div class="line">    [head * <span class="number">2</span> | double_each(tail)]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double_each</span></span>([]) <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex math.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; Math.double_each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#=&gt; [2, 4, 6]</span></div></pre></td></tr></table></figure>
<p>在这里我们用递归遍历列表，将其每个元素值翻倍，并且返回一个新的列表。获取列表并在其上映射的过程称为映射算法。</p>
<p>递归和尾调用是Elixir里重要的部分并且也是通常用来创建循环的方法。然后，当你在Elixir里编程，你将几乎很少像上面例子那样使用递归来操作列表。</p>
<p>我们将在下一章看到的 <a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="external">Enum模块</a> 已经提供了许多操作列表的便捷方式。例如，上述例子可以按如下方式来写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span>)</div><div class="line"><span class="number">6</span></div><div class="line">iex&gt; Enum.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>或者使用捕获语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.reduce([1, 2, 3], 0, &amp;+/2)</div><div class="line">6</div><div class="line">iex&gt; Enum.map([1, 2, 3], &amp;(&amp;1 * 2))</div><div class="line">[2, 4, 6]</div></pre></td></tr></table></figure>
<p>让我们更深入地了解可枚举的数据类型：Enumerable，以及它的懒惰对应数据类型：Steam。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/recursion.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/recursion.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;用递归实现循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;reduce 和 map 算法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="recursion" scheme="http://szpzs.oschina.io/categories/Elixir/recursion/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="recursion" scheme="http://szpzs.oschina.io/tags/recursion/"/>
    
  </entry>
  
</feed>
