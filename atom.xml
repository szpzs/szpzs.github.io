<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2017-12-22T06:33:20.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简说MQTT--第三部分：会话、服务质量和保留消息</title>
    <link href="http://szpzs.oschina.io/2017/12/22/mqtt-in-a-nutshell-3/"/>
    <id>http://szpzs.oschina.io/2017/12/22/mqtt-in-a-nutshell-3/</id>
    <published>2017-12-22T06:28:00.000Z</published>
    <updated>2017-12-22T06:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，我们希望MQTT代理会在客户端断开连接时存储客户端的订阅和队列消息，并在客户端稍后重新联机的时候将这些消息传递给它。在MQTT的世界中，存在保留消息，QoS级别和清除会话等技术，这些都对客户端存储消息有所影响。 我们将在这篇短文中讨论它们。</p>
<a id="more"></a>
<h1 id="清除会话"><a href="#清除会话" class="headerlink" title="清除会话"></a>清除会话</h1><p>您可以选择通过指定CONNECT数据包中的“clean_session”标志来告诉代理是否应该在连接时为您存储会话信息。</p>
<p>如果一条客户端链接仅仅是发布消息，它不会关心代理是否记得它。但是，如果客户端连接到代理是为了订阅消息，则通过将CONNECT数据包中的“clean_session”位设置为0来使连接“持久化”，这样是便利的或必要的。如果这么设置的话，这个客户端的订阅信息和未传送给它的消息将被代理存储下来。</p>
<p>要将clean_session设置为false，必须使用客户端ID。</p>
<p>当处于连接状态的时候，想修改“clean_session”设置是不可能的。要想修改它，你需要用新的设置来重连代理。</p>
<h1 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h1><p>不是所有“持久化”的连接上的消息都将被存储。QoS级别也会对其产生影响。</p>
<p>MQTT协议只保证具有QoS 1或QoS 2级别的消息确实传送给订阅者。对于那些QoS 0级别的消息，MQTT尝试发送它们一次，但是不保证一定送达。遵循这个原则，当用户断开连接时，即使这个连接是“持久化”的，也只有QoS 1和QoS 2级别的消息被存储。</p>
<p>值得注意的是，MQTT并不使用端到端的QoS，这意味着这些消息只有在用QoS != 0 发布并且用QoS != 0 订阅的情况下才被存储。</p>
<h1 id="保留消息"><a href="#保留消息" class="headerlink" title="保留消息"></a>保留消息</h1><p>如果您发布的MQTT消息的’retain’位设置为1，则它可以被保留在代理上，当订阅者连接到代理后，保留的消息会传递给它。</p>
<p>这是一个有用的特性，只有“保留”这个词有时令人困惑。它不保留相同主题的所有消息。 对于每个主题，只保留上次发布的消息，而较早的消息则由其后续消息替换掉。此外，’retain’标志设置为0的消息不会替换相同主题的保留消息，只有保留的消息替换保留的消息。</p>
<p>一个使用保留消息的场景：</p>
<p>一个传感器测量一个房间的温度并且每个小时将数据更新到系统中。如果温度数据用保留消息的方式发布到系统中，则无论什么时候，客户端连接到代理的时候只收到一份有用的数据，它不需要等待它不需要等待一段很长时间来等待新的数据发布，并且它也不会遭受大量无用而且过期数据的冲击。</p>
<blockquote>
<p>注意：保留的消息不属于任何会话。不管“clean_session”标志如何设置，保留消息都被保留。此外，它在会话结束时也被保留。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-2040b244aa4b" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-2040b244aa4b</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，我们希望MQTT代理会在客户端断开连接时存储客户端的订阅和队列消息，并在客户端稍后重新联机的时候将这些消息传递给它。在MQTT的世界中，存在保留消息，QoS级别和清除会话等技术，这些都对客户端存储消息有所影响。 我们将在这篇短文中讨论它们。&lt;/p&gt;
    
    </summary>
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>关于变量绑定的棘手问题</title>
    <link href="http://szpzs.oschina.io/2017/11/22/tricky-question/"/>
    <id>http://szpzs.oschina.io/2017/11/22/tricky-question/</id>
    <published>2017-11-22T08:41:00.000Z</published>
    <updated>2017-11-22T08:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我的工作中，我有个任务是为Erlang程序员应聘者设计一套选择题考卷，我决定包含一个关于变量绑定的棘手问题。在加入这个问题之前，我决定自己先尝试一下（你懂的……我这是为了预防万一）并且我发现了一些可能让你第一眼看到觉得很惊讶的事情，尽管这在事后是很明显的。</p>
<a id="more"></a>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>不用说，这个问题最后没有列入考试，所以不要指望从这篇文章中得到一个简单的答案。这个问题是：</p>
<blockquote>
<p>假设一开始没有任何变量被绑定，那么下面的表达式计算结束后，哪些变量被绑定了？</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A = <span class="number">1</span>,</div><div class="line">B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">      C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">      D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">    <span class="keyword">end</span>,</div><div class="line">A + B.</div></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<ol>
<li>没有</li>
<li>A 和 B</li>
<li>A、B、C 和 D</li>
<li>不可能确切地知道</li>
</ol>
</blockquote>
<p>请不要先往下阅读，而是停在这里！你自己先思考答案是什么？而且不能启动一个Erlang shell来测试这条表达式。切接不要偷看下面的内容！</p>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>让我们先剔除那些显而易见的选项。</p>
<p>答案不可能是选项1，因为我们在表达式里明确地绑定了一个变量。选项1唯一能被选上的条件是表达式发生错误。毫无疑问，这不可能发生。</p>
<p>选项3也不正确，因为代码执行路径有两个分支，其中一个不会绑定C变量，另一个不会绑定D变量。</p>
<p>在我看来，答案是选项2。我认为，C 和 D只是case表达式里的临时变量。</p>
<p>但是，情况并非如此。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; A = <span class="number">1</span>,</div><div class="line"><span class="number">1</span>&gt; B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line"><span class="number">1</span>&gt;       C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line"><span class="number">1</span>&gt;       D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line"><span class="number">1</span>&gt;     <span class="keyword">end</span>,</div><div class="line"><span class="number">1</span>&gt; A + B.</div><div class="line"><span class="number">1.063499807059608</span></div><div class="line"><span class="number">2</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.063499807059608</span></div><div class="line">C = <span class="number">0.063499807059608</span></div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; f().</div><div class="line">ok</div><div class="line"><span class="number">4</span>&gt; e(<span class="number">1</span>).</div><div class="line"><span class="number">1.3765011035828076</span></div><div class="line"><span class="number">5</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.37650110358280764</span></div><div class="line">C = <span class="number">0.37650110358280764</span></div><div class="line">ok</div><div class="line"><span class="number">6</span>&gt; f().</div><div class="line">ok</div><div class="line"><span class="number">7</span>&gt; e(<span class="number">1</span>).</div><div class="line"><span class="number">1.0869922372383418</span></div><div class="line"><span class="number">8</span>&gt; b().</div><div class="line">A = <span class="number">1</span></div><div class="line">B = <span class="number">0.08699223723834182</span></div><div class="line">D = <span class="number">0.9130077627616582</span></div><div class="line">ok</div><div class="line"><span class="number">9</span>&gt;</div></pre></td></tr></table></figure>
<p>如你所见，有时候C被绑定，有时候却是D被绑定，这依赖于case语句所执行的分支，即使被执行的case语句分支的表达式不需要这些变量，也会发生这样的情况：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>&gt; <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line"><span class="number">10</span>&gt;   C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; low;</div><div class="line"><span class="number">10</span>&gt;   D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; high</div><div class="line"><span class="number">10</span>&gt; <span class="keyword">end</span>.</div><div class="line">low</div><div class="line"><span class="number">11</span>&gt; b().</div><div class="line">C = <span class="number">0.3006547812129776</span></div><div class="line">ok</div><div class="line"><span class="number">12</span>&gt; f(), e(<span class="number">10</span>), b().</div><div class="line">C = <span class="number">0.12584026085863464</span></div><div class="line">ok</div><div class="line"><span class="number">13</span>&gt; f(), e(<span class="number">10</span>), b().</div><div class="line">D = <span class="number">0.9295007071083405</span></div><div class="line">ok</div><div class="line"><span class="number">14</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="到底是为什么呢？"><a href="#到底是为什么呢？" class="headerlink" title="到底是为什么呢？"></a>到底是为什么呢？</h1><p>正如我之前说过的，这个问题可能令人惊讶，但事实上，它是非常明显的，而且有据可查。case语句分支的头部匹配变量是完全有效的，它可以像下面这样使用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">      C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; low;</div><div class="line">      C <span class="keyword">when</span> C &gt;= <span class="number">0.5</span> -&gt; high</div><div class="line">    <span class="keyword">end</span>,</div><div class="line">&#123;B, C&#125;.</div></pre></td></tr></table></figure>
<p>这是一种非常复杂的编码方式，我根本不推荐这样做，你甚至可以把它弄得更糟糕：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">  C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; B = low;</div><div class="line">  C <span class="keyword">when</span> C &gt;= <span class="number">0.5</span> -&gt; B = high</div><div class="line"><span class="keyword">end</span>,</div><div class="line">&#123;B, C&#125;.</div></pre></td></tr></table></figure>
<p>但是，除了代码的样式和可维护性问题之外，这段代码是完全有效的，这意味着在case表达式的被计算之后，在case子句中（包括在头部和身体中）被绑定的变量都是绑定的。我知道有更学术的方式来表达这个问题，比如用像闭包或作用域等词汇，但是我将把这个解释权留给像iraunkortasuna这样的大牛们，他们比我能干的多。</p>
<p>考虑到这一点，在我们最初的例子中，无论是C还是D（但不是两者）都是在对整个表达式的计算之后绑定的，这是合理的。但是，你想知道，这样的代码是非常不安全的……难道Erlang不应该警告我吗？Erlang不应该阻止我写出这样一个非确定性的东西吗？</p>
<p>当然，Erlang会帮我们的！不过不是Erlang的shell，而是Erlang的编译器，它会对这类代码进行告警，而且它非常聪明。如下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(x)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>])</span>.</div><div class="line"><span class="function"><span class="title">bad</span><span class="params">(A)</span> -&gt;</span></div><div class="line">  B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">        C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">        D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">      <span class="keyword">end</span>,</div><div class="line">  A + B.</div></pre></td></tr></table></figure>
<p>这是我们的原始代码，在这种情况下，即使C或D在case语句之后是未绑定的，因为它们没有被使用，编译器什么也不说。</p>
<p>现在我们看看另一个版本的代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(x)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>])</span>.</div><div class="line"><span class="function"><span class="title">bad</span><span class="params">(A)</span> -&gt;</span></div><div class="line">  B = <span class="keyword">case</span> rand:uniform() <span class="keyword">of</span></div><div class="line">        C <span class="keyword">when</span> C &lt; <span class="number">0.5</span> -&gt; C;</div><div class="line">        D <span class="keyword">when</span> D &gt;= <span class="number">0.5</span> -&gt; <span class="number">1</span> - D</div><div class="line">      <span class="keyword">end</span>,</div><div class="line">  A + B - C.</div></pre></td></tr></table></figure>
<p>在这个例子里，编译器将不会编译这个模块，相反，它会报告如下错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x.erl:<span class="number">8</span>: variable 'C' unsafe in '<span class="keyword">case</span>' (line <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>我们可以对上述错误消息的可用性和可读性进行深入的讨论，但是这个模块不能编译的事实毫无疑问对Erlang开发者是有帮助的。</p>
<p><strong>小贴士：</strong>如果在编译Erlang模块时看到类似这样的错误，请注意警告：8（其中使用了不安全变量）和4（变量可能绑定的地方）中的两个行号。</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/erlang-battleground/tricky-question-25a956298b9d" target="_blank" rel="external">https://medium.com/erlang-battleground/tricky-question-25a956298b9d</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的工作中，我有个任务是为Erlang程序员应聘者设计一套选择题考卷，我决定包含一个关于变量绑定的棘手问题。在加入这个问题之前，我决定自己先尝试一下（你懂的……我这是为了预防万一）并且我发现了一些可能让你第一眼看到觉得很惊讶的事情，尽管这在事后是很明显的。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="variable binding" scheme="http://szpzs.oschina.io/tags/variable-binding/"/>
    
  </entry>
  
  <entry>
    <title>简说MQTT--第二部分：MQTT是如何运作的？</title>
    <link href="http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-2/"/>
    <id>http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-2/</id>
    <published>2017-09-21T05:58:34.000Z</published>
    <updated>2017-09-21T06:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>与传统的客户端/服务器协议不同，MQTT不是端到端的。MQTT是一种发布订阅消息交换协议。另外，与消息队列不同，MQTT不维护任何队列。它使用主题来路由消息。</p>
<p>这次我们将向你展示MQTT是如何运作的。</p>
<a id="more"></a>
<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><p>MQTT是一种发布订阅消息交换协议，它的含义是：</p>
<ol>
<li>通信系统中有发布者和订阅者。发布者发布消息而订阅者接收消息。我们把发布者和订阅者统称为客户端。客户端可以同时是发布者和订阅者。</li>
<li>在系统中有另外一个角色，它接收发布者的消息并且将消息派发给订阅者。我们一般称这个角色为消息Broker。</li>
</ol>
<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>在MQTT中，另一个重要的概念是主题，每一条消息都有一个主题，它决定了消息将被谁接收。主题是MQTT的路由机制。</p>
<p>举个例子，如果一个天气预报服务正在更新各个城市的温度数据。这个服务并不知道谁将接收哪个城市的温度数据，它只是用主题来标识这些数据，比如，“temperature/newyork” 或 “temperature/frankfurt”，并且将它们发送给Broker。那些对城市天气有兴趣的人可以在Broker上订阅一个或多个这样的主题。一旦一条消息到达Broker，它就会检查消息里的主题，并且将消息派发给相应的订阅者。</p>
<p>主题由一个或多个层级组成，层级之间被斜杠（/）分隔。有时主题和分类和目录相似。</p>
<p>主题中的通配符(“#” 和 “+”)使得订阅者更易于一次订阅多个主题。“+”表示一个单独的层级，而“#”表示多个层级。多数情况下，你可以按你的意愿自由地命名主题，但是有一个列外：以“$”开头的主题是保留给系统使用的。</p>
<p>MQTT天然支持一对多（广播）的消息传递：一个发布者用一个主题发布一条消息到Broker，Broker派发这条消息给所有订阅这个主题的客户端。</p>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>一条消息就是我们想要在通信系统中与其他方交换的信息。交换消息是MQTT的目的。MQTT用控制数据包来传输消息和维护链接。</p>
<p>一个MQTT数据包包括一个固定的头部，一个可选的可变头部以及一个可选的有效负载数据部分：</p>
<ul>
<li>固定头部出现在所有MQTT控制包中。它包括包的类型、各种标志以及包的剩余长度。</li>
<li>可变头部出现在一些MQTT控制包中。它的内容根据包的类型不同而不同。</li>
<li>有效负载数据出现在一些MQTT控制包中。它是包的最后一部分。业务相关的数据都在这部分中。</li>
</ul>
<p>如你所猜测的一样，最小的MQTT包只有2字节。</p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>现在我们已经有了通信中的各种角色、路由消息的方式以及约定的消息格式，我们可以用这些基本元素来构建一个通信系统。</p>
<p>如下图所示，想象一下，我们在一所医院里：</p>
<p><img alt="MQTT communication, an example" src="/images/mqtt-communication.png" style="border: 0;"></p>
<p>住院病人的重要统计数据由可穿戴设备收集并发送到中心服务器，然后发送给相关人员（或设备）。</p>
<p>一个传感器，这里我们以温度计为例，测量患者的体温并将这个温度数据设置主题：“传感器/ 1 /温度话题”后发布到MQTT Broker。很明显，这个传感器的角色就是发布者。关心这个病人的任何数据的人（比如他的医生）可以订阅“sensor/1/#”这个主题；任何需要收集所有病人体温数据的人或设备可以订阅主题： “sensor/+/temperature”；只关心这个病人的体温的人可以精确地订阅主题：“sensor/1/temperature”，而不需要任何通配符。</p>
<h1 id="MQTT的特殊特点"><a href="#MQTT的特殊特点" class="headerlink" title="MQTT的特殊特点"></a>MQTT的特殊特点</h1><h2 id="QOS"><a href="#QOS" class="headerlink" title="QOS"></a>QOS</h2><p>MQTT实现了简单但是有效的3级服务质量系统：</p>
<ul>
<li>0：最多一次</li>
<li>1：最少一次</li>
<li>2：仅有一次</li>
</ul>
<h2 id="保留的消息"><a href="#保留的消息" class="headerlink" title="保留的消息"></a>保留的消息</h2><p>如果MQTT消息的保留标志被设置了，则消息可以被Broker保留。当一个客户端链接到Broker并订阅了一个主题，而Broker有这个主题的一条保留的消息，客户端将立刻收到这条消息。每一个主题最多只有一条保留的消息。</p>
<h2 id="遗愿消息"><a href="#遗愿消息" class="headerlink" title="遗愿消息"></a>遗愿消息</h2><p>MQTT经常被用于不可靠的网络环境。客户端可能没有正常关闭链接（DISCONNECT消息没有发送出去）的情况下丢失链接。在这种情况下，遗愿消息可以做客户端应该做的事情。</p>
<p>每个客户端当它链接到Broker的时候可以设置一条遗愿消息。遗愿消息和其他消息一样，它也有服务质量级别、保留属性以及主题。这条消息被存储在Broker上，当Broker检测到客户端丢失了链接，Broker把这条遗愿消息发送给所有订阅了遗愿消息的主题的所有在线客户端。如果客户端发送一个“DISCONNECT”包给Broker后断开链接，那么它的遗愿消息被丢弃。</p>
<h1 id="MQTT数据包"><a href="#MQTT数据包" class="headerlink" title="MQTT数据包"></a>MQTT数据包</h1><p>MQTT定义了14种消息类型。它们被用于创建链接、断开链接、发布消息、订阅主题、维护链接或保证服务质量。</p>
<p>消息类型如下表所示：</p>
<p><img alt="MQTT communication, an example" src="/images/mqtt-packet-type.png" style="border: 0;"></p>
<p>在本系列的下一篇文章中，我们将演示如何创建一个简单的MQTT应用并解释有关协议和数据包格式。</p>
<p>待续……</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-4e8dd6ef57c0" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-4e8dd6ef57c0</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与传统的客户端/服务器协议不同，MQTT不是端到端的。MQTT是一种发布订阅消息交换协议。另外，与消息队列不同，MQTT不维护任何队列。它使用主题来路由消息。&lt;/p&gt;
&lt;p&gt;这次我们将向你展示MQTT是如何运作的。&lt;/p&gt;
    
    </summary>
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>简说MQTT--第一部分：MQTT是啥？</title>
    <link href="http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-1/"/>
    <id>http://szpzs.oschina.io/2017/09/21/mqtt-in-a-nutshell-1/</id>
    <published>2017-09-21T05:39:41.000Z</published>
    <updated>2017-09-21T05:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>MQTT是什么？这个问题的最贴切的答案是我在网站mqtt.org看到的：</p>
<blockquote>
<p>“MQTT是机器对机器(M2M)/物联网的链接协议。”</p>
</blockquote>
<p>它解释得十分清楚，MQTT是M2M和物联网（IoT）连接协议。要理解MQTT，我们需要首先去了解M2M或物联网。</p>
<a id="more"></a>
<h1 id="M2M和物联网"><a href="#M2M和物联网" class="headerlink" title="M2M和物联网"></a>M2M和物联网</h1><p>许多人已经在用物联网了，他们中有些人只是没有意识到。最近我去拜访我的一位朋友。他对他的新智能烤箱很兴奋，迫不及待地想告诉我他的烤箱是多么聪明：食谱下载到智能手机，然后通过WiFi发送到烤箱；可以通过智能手机的应用程序远程调控烘烤；当食物烤好了，烤箱就发出通知给智能手机。嗯，他已经进入物联网时代了。</p>
<p>物联网的基本概念并不新，它是设备之间的联网，让设备自己收集和交换数据。有时这种数据交换甚至在没有人工干预（机器对机器的连接）的情况下发生。各种设备通过网络彼此集成。现在，这种集成的规模可以是巨大的，它能够提高效率、精度和经济效益，减少人为干预。</p>
<p>在物联网的世界里，几乎所有的东西（包括人）都可以连接起来。事物互联有可能带来新的好处，我们要做的是利用我们的好奇心和想象力来释放这种潜力。高德纳说，到2020，将有超过260亿个连接设备。计算机，手机，平板电脑，台灯，咖啡机，汽车，光传感器，运动探测器，生物芯片，飞机和任何你能想象的东西。有人建议把“物”当做“硬件、软件、数据和服务不可分割的混合物”。</p>
<h1 id="为什么是MQTT"><a href="#为什么是MQTT" class="headerlink" title="为什么是MQTT"></a>为什么是MQTT</h1><p>物联网的一个关键要素是，“事物”具有连接的能力。他们需要一种大家都能理解的通用语言，一种连接协议。多年来，世界上已经有很多连接协议，像HTTP这样的协议被数以百万计的应用程序所使用。为什么不是只有一个广泛使用的协议？为什么MQTT是物联网的协议？</p>
<p>“什么事物都可以连接，也将被连接”。想想这样的场景：早上5点半，你的智能手机告诉客厅的暖气调节器调节室内温度，以适应日常活动。5点50，你的智能手机告诉咖啡机开始煮咖啡。当你在6点被你的智能手机叫醒，万事都准备妥当，甚至你喜欢的美剧已经被下载到你的平板电脑里了。当你享受宁静的早晨时，你可能会注意到一件事：所有连接的设备都是如此不同，而它们却一起工作得很好。</p>
<p>我们刚刚讨论的这个物联网场景，我们叫它做智能家居。我们来构建一个智慧城市或者甚至构建一个智慧世界如何？在这个世界里，一个超级计算机可以和一个芯片上的系统交换数据。例如，医疗中心监控病人植入的芯片，并向病人的医生发出警报。当任何设备被允许接入并且设备在地理上广泛分布时，应该使用什么样的通信协议呢？</p>
<p>它必须是一个轻量级的协议，占用的代码量很小，对于这个协议来说，非常有限的网络带宽就足够了。MQTT就是这种协议。</p>
<blockquote>
<p>“MQTT是一个客户端服务器的发布/订阅消息传输协议。它轻量、开放、简单，且设计为易于实现。这些特性使得它非常适合在许多情况下使用，包括受限的环境，例如用于机器对机器的通信（M2M）和物联网环境，在其中只需要占用少量的代码和/或网络带宽。”<br> – – 引用自MQTT规范</p>
</blockquote>
<h1 id="关于MQTT的历史"><a href="#关于MQTT的历史" class="headerlink" title="关于MQTT的历史"></a>关于MQTT的历史</h1><p>MQTT是MQ Telemetry Transport的缩写。它首先是Andy Stanford-Clark 和 Arlen Nipper在1999年发明的。他们当时在做一个管道的监控和数据采集系统（Telemetry这个词就来自这里），需要实时在卫星链路和拨号线路上传输数据，以连接远程管道。基于这些有限的资源，他们开始考虑做一个新的<strong>发布和订阅协议</strong>，就是MQTT协议。</p>
<blockquote>
<p>MQTT按下面5个目标来设计的：<br>它必须能简单地被实现；<br>它必须有数据传输的服务质量；<br>它必须轻量和带宽高效；<br>它必须可传输任意数据；<br>以及它必须可保持会话。</p>
</blockquote>
<p>今天，这五个目标依然被支持，它们本质上和物联网的需求是相等的。</p>
<p>IBM在2010年正式免费发布MQTT3.1，OASIS在2014年标准化了这个协议。写本文的时候，MQTT的版本是3.1.1。MQTT下一个版本是5.0，一个MQTT5.0的工作草稿正在被公示。</p>
<h1 id="MQTT-v-s-XMPP"><a href="#MQTT-v-s-XMPP" class="headerlink" title="MQTT v.s. XMPP"></a>MQTT v.s. XMPP</h1><p>将MQTT和其他协议进行比较可以使得我们更易于理解为什么MQTT适合物联网，在此我们将它和XMPP进行比较，XMPP是上世纪90年代后期诞生的消息协议。</p>
<ol>
<li>XMPP发明于1999年。它是eXtensible Messaging and Presence Protocol的缩写。</li>
<li>MQTT使用固定大小，即一个字节的头部，以及两个字节的KeepAlive包。它的包小，而且易于编解码。而XMPP用XML封装，它的包大并且交互复杂。</li>
<li>MQTT使用主题来路由消息，它比基于JID的点对点路由的XMPP更灵活。</li>
<li>MQTT不定义有效载荷数据的格式，因此它很容易携带不同的更高层协议的数据。而XMPP用XML来格式化有效载荷数据，它必须用Base64格式封装二进制数据。</li>
<li>MQTT支持消息确认和QoS机制，这些XMPP都没有，因此MQTT更加可靠。</li>
</ol>
<p>待续……</p>
<blockquote>
<p>*原文链接<a href="https://medium.com/@emqtt/mqtt-in-a-nutshell-cc24370920c2" target="_blank" rel="external">https://medium.com/@emqtt/mqtt-in-a-nutshell-cc24370920c2</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MQTT是什么？这个问题的最贴切的答案是我在网站mqtt.org看到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“MQTT是机器对机器(M2M)/物联网的链接协议。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它解释得十分清楚，MQTT是M2M和物联网（IoT）连接协议。要理解MQTT，我们需要首先去了解M2M或物联网。&lt;/p&gt;
    
    </summary>
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/categories/MQTT/"/>
    
    
      <category term="MQTT" scheme="http://szpzs.oschina.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的乐趣犹如驾驭魅影</title>
    <link href="http://szpzs.oschina.io/2017/08/01/joy-of-erlang/"/>
    <id>http://szpzs.oschina.io/2017/08/01/joy-of-erlang/</id>
    <published>2017-08-01T12:58:22.000Z</published>
    <updated>2017-08-07T07:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在电影&lt;&lt;阿凡达&gt;&gt;里，有一条超级大的翼龙，它叫做魅影，男主角为了赢得蓝色族人的信任必须学会骑魅影。一般来说，魅影不喜欢被骑，但如果你和它打一架，而且把它制服，然后把你的蓝马尾辫连接到魅影的尾巴上，你就能拥有它的生命。这就像拥有一辆你能控制的飞车，在与强敌作战时，你可以很方便地用你的思想控制它，给未来的同事留下深刻印象。但是学会骑魅影是很危险的，很少有人能成功。</p>
<p>我喜欢把Erlang编程语言看作是一条魅影。大多数人都害怕Erlang。关于其能力的传说比比皆是。为了掌握它，你必须与它战斗，征服它，并(最后)把你的思想与它联系起来。但假设你能活下来，你就可以控制世界上最先进的服务器平台，让它做事情的时候通常无需再思考。现在让我来告诉你：驾驭魅影是很有趣的。</p>
<p>本指南旨在教会你Erlang的思想，这样你就不会害怕而离开，而是可以战胜你自己的魅影。我将只介绍一些Erlang语言特性，但是我们将使用它们来解决大量实际问题。它的目的是让你想要并且有信心去学习并掌握Erlang语言其他知识。</p>
<p>欢迎您将这些示例输入到自己的Erlang shell中，并执行它们，不过这些示例的设计是为了便于阅读而设计的。我建议你把这份文件打印出来，在舒适的椅子上仔细地阅读，并且远离电子邮件、编译器、3D电影以及其他干扰。</p>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><a href="#part-one">定义函数： 一个简单布尔逻辑库</a></li>
<li><a href="#part-two">递归地调用函数：一个简单算术运算库</a></li>
<li><a href="#part-three">整数列表：基本字符串处理</a></li>
<li><a href="#part-four">Erlang算法的乐趣</a></li>
<li><a href="#part-five">下一步</a></li>
<li><a href="#part-six">源代码</a></li>
</ol>
<h1 id="定义函数：-一个简单布尔逻辑库"><a href="#定义函数：-一个简单布尔逻辑库" class="headerlink" title="定义函数： 一个简单布尔逻辑库"></a><span id="part-one">定义函数： 一个简单布尔逻辑库</span></h1><p>在Erlang里，函数由一个或多个分支语句组成。最后一个分支语句必须用  .  号结束；而其他分支语句必须用  ;  号结束。当函数被调用的时候，第一个和入参匹配的分支语句被执行。你可能会思考，如果C语言的switch语句暴露在有毒污泥中并成为超级英雄，那么函数将会怎样。</p>
<p>最简单的例子，一个函数只有一个语句。如下所示，函数 noop 简单地返回它的参数，即变量A（变量总是大写开头的）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">noop</span><span class="params">(A)</span> -&gt;</span> A.</div></pre></td></tr></table></figure>
<p>注意，Erlang没有 return 语句。函数总是返回最后一个表达式的结果。因为每一个表达式都有一个结果，而且每一个函数分支语句至少有一个表达式，所以每一个函数总是有一个返回值。</p>
<p>现在假设我们希望实现一个布尔函数 not，它把true或false作为它的参数。not 函数需要两个子句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">not</span><span class="params">(true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">not</span><span class="params">(false)</span> -&gt;</span> <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<p>每次 not 函数被执行，Erlang首先测试入参是否是true（如果是，执行第一个子句），然后再测试入参是否是false（如果是，则执行第二个子句）。用入参和函数定义进行匹配被称为模式匹配。模式匹配使得在不使用内部控制结构的情况下很容易编写复杂的函数。</p>
<p>我们可以使用模式匹配来判断同一变量是否在参数列表中出现不止一次。比如，如下函数实现相等操作符：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, B)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>如果两个入参相同，则函数返回true；否则，函数返回false。</p>
<p>小心！在这个函数里子句的顺序很重要。如果像下面这样写，则是错误的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, B)</span> -&gt;</span> <span class="literal">false</span>; <span class="comment">% 错</span></div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<p>为什么会错呢？Erlang首先尝试匹配第一个子句。但是如果两个入参相同，第一个子句依然匹配，A和B被简单地绑定为相等的值。第二个子句永远不会被执行到。在形参列表里用不同名字到变量并不是说一定要给它们绑定不相等的值。</p>
<p>我们现在已经准备好实现更多的布尔逻辑。如下是 and 的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 与: 如果两个入参是true则是true, 否则是false</span></div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(false, true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, false)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>你可能认为所有这些真值表子句太啰嗦。它们的确是很啰嗦。我们可以用一个特别的匿名变量来将后面三个子句缩减到一个子句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 与: 如果两个入参是true则是true, 否则是false</span></div><div class="line"><span class="function"><span class="title">and</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">and</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>匿名变量(_)总是匹配任何数据。它没有被赋值，所以正如我们在上面的第二个子句中看到的，参数列表中的两个或多个下划线变量不需要匹配相同的项。匿名变量通常用来“丢弃”我们不关心的一部分模式。</p>
<p>现在我们有了常规变量和下划线变量，我们的布尔逻辑库的其余部分就容易写了。花点时间了解一下为什么下面的每一个功能都正好符合要求。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 或: 如果一个或两个参数是true则是true，否则为false。</span></div><div class="line"><span class="function"><span class="title">or</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">or</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 异或: 两个参数不同则是true，否则为false。</span></div><div class="line"><span class="function"><span class="title">xor</span><span class="params">(A, A)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">xor</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 非与: 两个参数是true则为false，否则为true。</span></div><div class="line"><span class="function"><span class="title">nand</span><span class="params">(true, true)</span> -&gt;</span> <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="title">nand</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">true</span>.</div><div class="line"></div><div class="line"><span class="comment">% 非或: 两个参数是false则为true，否则为false。</span></div><div class="line"><span class="function"><span class="title">nor</span><span class="params">(false, false)</span> -&gt;</span> <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="title">nor</span><span class="params">(_, _)</span> -&gt;</span> <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<p>如你所见，模式匹配给予Erlang函数极大的表达能力。在下一节中，我们将把模式匹配与递归相结合，建立一个新的算术运算库。在大多数语言中，递归通常是最后的手段，只用于实现复杂的算法。在Erlang，递归通常是最简单和最有效的方式来做一些平常的事情。</p>
<h1 id="递归地调用函数：一个简单算术运算库"><a href="#递归地调用函数：一个简单算术运算库" class="headerlink" title="递归地调用函数：一个简单算术运算库"></a><span id="part-two">递归地调用函数：一个简单算术运算库</span></h1><p>Erlang有一套丰富的算术运算符。不过在这一节里，我们不会使用它们。相反，我们将只使用我们目前为止学到的函数知识来构建我们自己的完整的算术运算库。</p>
<p>本节中的任务诚然是人为的，并且递归绝对不是在现实世界中解决这个问题的最简单的方法。然而，本节的练习将是好的方式来实践递归思维来为第3节做准备，在那里，递归是解决问题的最好方法。</p>
<p>回想一下递归函数至少有两部分：它们必须首先测试某种基本情况（算法终止），如果基本情况不满足，递归函数必须执行一些逻辑，然后发出对自身的调用。在Erlang，递归函数通常至少有两个子句：一个“基本情况”子句和“所有其他情况”子句。</p>
<p>事情将很快变得清晰。为解决问题，为将提供两个函数，算术运算库剩余的部分将以它们为基础来构建：incr 和 decr。假设incr增加入参，decr减少入参，如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">incr</span><span class="params">(A)</span> -&gt;</span> A + <span class="number">1</span>.</div><div class="line"><span class="function"><span class="title">decr</span><span class="params">(A)</span> -&gt;</span> A - <span class="number">1</span>.</div></pre></td></tr></table></figure>
<p>我们可以用这两个函数将任何两个正整数加到一起吗？</p>
<p>事实上我们可以！</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 两个正整数相加</span></div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A.</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span> add(incr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>有时从底层到顶部阅读递归函数是最容易的。所以先看第二个子句，它说将A和B相加与将(A+1)和(B-1)相加是相等的，这明显是正确的。因此，这个函数一直给A加一，给B减一，直到B为0。当B为0的时候，函数结束（第一个子句）。这时，add函数被递归调用了B次，也就是说A被增加了B次，因此最后的结果就是 A+B。</p>
<p>现在有点有趣，不是吗？让我们来实现减法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 从A减去B（B是正整数）</span></div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A.</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> -&gt;</span> sub(decr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>一样的思想。从第二个子句开始，我们看到(A - B)和((A - 1) - (B - 1))相等。这明显是对的。递归调用一直持续到B为0，这个时候，A被减少了B次，结果就是A - B。</p>
<p>当B是负整数的时候，这些函数都不无效。我们可以非常简单地修改add函数以适应负整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 任意两个整数相加</span></div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> add(decr(A), incr(B));</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span> add(incr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>请注意，在第二个子句中Erlang卫句的使用（when B &lt; 0）。我们可以在参数列表后用关键字 when 再加上表达式来指定条件判断。有许多种卫句，但是现在，我们只做整数的比较。</p>
<p>sub函数的修改也差不多：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 从整数A减去任意整数B。</span></div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> sub(incr(A), incr(B));</div><div class="line"><span class="function"><span class="title">sub</span><span class="params">(A, B)</span> -&gt;</span> sub(decr(A), decr(B)).</div></pre></td></tr></table></figure>
<p>完成了加、减函数，乘法就很容易实现了。正如我们把加法作为一系列加一一样来实现，我们将把乘法作为一系列的加法来实现，还是使用递归。我们使用这样的等式：A × B = A + A × (B - 1)。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% A乘以B（正整数）</span></div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> -&gt;</span> add(A, multiply(A, decr(B))).</div></pre></td></tr></table></figure>
<p>增加对负整数的支持也很容易，因为：A × (B + 1) - A = A × B：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 整数A乘以任意整数B</span></div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> <span class="title">when</span> B &lt; 0 -&gt;</span> sub(multiply(A, incr(B)), A);</div><div class="line"><span class="function"><span class="title">multiply</span><span class="params">(A, B)</span> -&gt;</span> add(A, multiply(A, decr(B))).</div></pre></td></tr></table></figure>
<p>除法呢？没问题。整数的除法，我们真正关心的是两个操作：求商和求余。这两个操作，我们都用被除数减去除数，直到我们接近0。求余操作更容易些：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求 A 除以 B 的余数</span></div><div class="line"><span class="function"><span class="title">remainder</span><span class="params">(A, B)</span> <span class="title">when</span> A &lt; B -&gt;</span> A;</div><div class="line"><span class="function"><span class="title">remainder</span><span class="params">(A, B)</span> -&gt;</span> remainder(sub(A, B), B).</div></pre></td></tr></table></figure>
<p>至于求余函数，我们将使用Erlang里的通用模式，内部递归函数，以区别主接口。内部递归函数有一个额外参数，它跟踪我们已经减掉除数的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求A 除以 B 的余</span></div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B)</span> -&gt;</span> quotient(A, B, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="comment">% 包括累加器的内部函数</span></div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B, Answer)</span> <span class="title">when</span> A &lt; B -&gt;</span> Answer;</div><div class="line"><span class="function"><span class="title">quotient</span><span class="params">(A, B, Answer)</span> -&gt;</span> quotient(sub(A, B), B, incr(Answer)).</div></pre></td></tr></table></figure>
<p>有了乘法和除法，我们就可以解决现实的一些问题。例如，让我们来实现一个幂函数。我们使用与前面完全相同的想法，认识求一个数的幂实际上只是一系列的乘法调用。也就是说，$$A^B = A × A^{B-1}$$</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 求A的B次幂(正整数)</span></div><div class="line"><span class="function"><span class="title">pow</span><span class="params">(A, <span class="number">0</span>)</span> -&gt;</span> <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">pow</span><span class="params">(A, B)</span> -&gt;</span> multiply(A, pow(A, decr(B))).</div></pre></td></tr></table></figure>
<p>在实践中，所有这些功能都是非常低效的，因为他们把所有的一切都转变为一系列递增或递减。但是这种递归的思想框架对于充分利用Erlang是绝对必要的，正如我们将要构建的字符串处理库中所看到的。</p>
<h1 id="整数列表：基本字符串处理"><a href="#整数列表：基本字符串处理" class="headerlink" title="整数列表：基本字符串处理"></a><span id="part-three">整数列表：基本字符串处理</span></h1><p>在Erlang里，字符串用整数列表来表示。这些整数是ASCII字符码或者是Unicode码点。例如，字符串”dog”就是表示为由100 (“d”), 111 (“o”), 103 (“g”)组成的列表。Erlang列表的字面量是由方括号括起来的，所以如果你愿意的话，”dog” 可以写为 [100, 111, 103]。要获得一个字符的编码，只要简单地在其前面加上美元符号\$。所以[\$d, \$o, \$g] 和 [100, 111, 103] 以及”dog”是相等的。</p>
<p>每一个列表都分为两部分：头部和尾部。头部是第一个元素，尾部则是除了头部外剩下的部分。列表是一个递归数据结构。列表的尾部是一个列表，它有自己的头部和尾部。以此类推。</p>
<p>空列表表示为[]，它没有头部，也没有尾部。</p>
<p>在Erlang里，添加一个元素到列表的头部使用 | 操作符（管道符号）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewList = [NewItem | OldList]</div></pre></td></tr></table></figure>
<p>| 也可以用在模式匹配中，从一个列表中抽取头部元素：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">some_function</span><span class="params">([FirstItem | RestOfList])</span> -&gt;</span></div><div class="line">   ... do something with FirstItem ...</div></pre></td></tr></table></figure>
<p>反转一个列表，使用函数lists:reverse()。反转一个列表可能看起来是一个不太常用的操作，但正如我们将看到的，它在Erlang实现列表算法时一直使用。</p>
<p>我们现在对字符串了解得足够多了，可以开始做一个例子。让我们写一个函数，将输入的第一字符转换为大写字符。</p>
<p>这个函数的基本思想是简单的。我们检查输入字符串的第一个字符（头部）是否是小写ASCII字符。如果是，我们把它转换成大写（通过增加大写ASCII字符和小写字母之间的差值），然后把它和尾部重写组合成一个字符串。如果不是，我们就简单地返回输入字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">capfirst</span><span class="params">([Head | Tail])</span> <span class="title">when</span> H<span class="title">ead</span> &gt;= $<span class="title">a</span>, H<span class="title">ead</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    [Head + ($A - $a) | Tail];</div><div class="line"><span class="function"><span class="title">capfirst</span><span class="params">(Other)</span> -&gt;</span></div><div class="line">    Other.</div></pre></td></tr></table></figure>
<p>在这里，我们使用了一些新的数学运算符，它们其中的含义你可能会明白。还要注意，逗号用于分隔同一子句中的多个判断条件。</p>
<p>如果你认为很好玩，那就等到你尝试将整个字符串转换为大写。在一个没有for循环的世界，一个进程如何处理字符串的每个元素？是时候重新审视我们的老朋友：递归。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 公共函数</span></div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">(String)</span> -&gt;</span></div><div class="line">   uppercase(String, []).</div><div class="line"></div><div class="line"><span class="comment">% 内部函数</span></div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>和我们在第二节写的函数 quotient 一样，这个函数有一个公共接口以及一个有额外参数的内部递归函数。额外的参数称为累加器，它的初始值为空列表。一般的策略是从输入的头部弹出一个元素，转换它，并将其加到累加器的头部。当我们处理完输入，我们要的结果将存储在累加器里，只不过它的顺序是反的。因此，我们调用 lists:reverse 并返回结果给公共接口函数。</p>
<p>让我们一句一句地检查一下内部函数子句，看看这个策略是如何实现的。</p>
<p>在基准情况下，没有更多的输入。因此，我们反转累加器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div></pre></td></tr></table></figure>
<p>如果还有输入，并且下一个字符是处于ASCII小写字母 a 和 z 之间的话，我们把它转换为大写字母，并把它加到累加器上，然后在剩下的输入上递归地调用 uppercase 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char + ($A - $a) | Output]);</div></pre></td></tr></table></figure>
<p>当下一个字符不是小写的ASCII字符的时候，最后一个子句匹配。在这种情况下，我们只需将字符从输入毫无更改地直接移动到累加器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">uppercase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    uppercase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>这个算法到此就结束了。写一个将所有字符转为小写的函数 lowercase ，这个作为一个练习由读者自己实现。</p>
<p>我们接着来实现一个有趣的函数。把每个单词的第一个字母转成大写，而不是把单词的里的所有字母转成大写。我们叫这个函数做 titlecase 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">(String)</span> -&gt;</span></div><div class="line">    titlecase(String, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([], Output)</span> -&gt;</span></div><div class="line">    lists:reverse(Output);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], [] = Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], [$\  |_] = Output)</span> <span class="title">when</span> C<span class="title">har</span> &gt;= $<span class="title">a</span>, C<span class="title">har</span> =&lt; $<span class="title">z</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char + ($A - $a) | Output]);</div><div class="line"><span class="function"><span class="title">titlecase</span><span class="params">([Char | Rest], Output)</span> -&gt;</span></div><div class="line">    titlecase(Rest, [Char | Output]).</div></pre></td></tr></table></figure>
<p>titlecase 和 uppercase 的不同是，我们在决定处理每个字符之前用模式匹配检查一下累加器。如果累加器是空的（第二个子句），说明我们在输入的开始之处，并且要将接下来的字母大写化。如果累加器有一个空的字符在它的头部（第三个子句），说明我们在一个单词的开始之处，并且要将接下来的字母大写化。注意，空格字符的整数表示是用美元符号加上一个空格（”$\ “）。在这里我们也使用了匹配操作符（”=”），这使得在参数列表里可以很好地结合模式匹配和变量赋值。</p>
<p>如你所见，递归、累加器和模式匹配是一个强大的组合。我们可以编写无状态变量或正则表达式的上下文相关算法。更重要的是，我们可以清楚地表达问题的解决方案，并对我们的算法的正确性有信心。Erlang的乐趣在于编写代码而不必担心忘记某些东西。</p>
<h1 id="Erlang算法的乐趣"><a href="#Erlang算法的乐趣" class="headerlink" title="Erlang算法的乐趣"></a><span id="part-four">Erlang算法的乐趣</span></h1><p>现在我们可以开始好好玩耍了。既然你现在知道Erlang的基本知识，我就不会花太多时间来解释下面的算法了。它们对你来说只是让你思考和享受。</p>
<p>面试中一个经典的问题是，如何将一个字符串转换为整数（如：C语言中的atoi函数）。如下是Erlang的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([$- | String])</span> -&gt;</span> <span class="comment">% negative</span></div><div class="line">    -<span class="number">1</span> * atoi(String, <span class="number">0</span>);</div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">(String)</span> -&gt;</span> <span class="comment">% non-negative</span></div><div class="line">    atoi(String, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([], Acc)</span> -&gt;</span></div><div class="line">    Acc;</div><div class="line"><span class="function"><span class="title">atoi</span><span class="params">([C | Rest], Acc)</span> <span class="title">when</span> C &gt;= $0, C =&lt; $9 -&gt;</span></div><div class="line">    atoi(Rest, <span class="number">10</span> * Acc + (C - $<span class="number">0</span>)).</div></pre></td></tr></table></figure>
<p>注意，这里的累加器是一个整数，而不是我们前面例子里那样上一个字符串。当然，原则上，累加器可以是任何东西。</p>
<p>现在假设我们要做反向操作：将一个整数转换为字符串。代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    [$<span class="number">0</span>];</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer)</span> <span class="title">when</span> I<span class="title">nteger</span> &lt; 0 -&gt;</span> <span class="comment">% negative</span></div><div class="line">    [$-|to_string(-<span class="number">1</span> * Integer, [])];</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer)</span> -&gt;</span> <span class="comment">% positive</span></div><div class="line">    to_string(Integer, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(<span class="number">0</span>, Acc)</span> -&gt;</span></div><div class="line">    Acc;</div><div class="line"><span class="function"><span class="title">to_string</span><span class="params">(Integer, Acc)</span> -&gt;</span></div><div class="line">    to_string(Integer div <span class="number">10</span>, [(Integer rem <span class="number">10</span>) + $<span class="number">0</span> | Acc]).</div></pre></td></tr></table></figure>
<p>注意，在这里我用了两个整数操作符：div是整数除，rem是整数取模（在C风格语言里通常用%表示）。</p>
<p>让我们假设用Erlang来写一个工具套件，需要将正整数的列数字转换为大多数电子表格使用的字符串表示形式（“A”到“Z”，然后是“AA”到“ZZ”，以此类推）。代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(Number)</span> -&gt;</span></div><div class="line">    num2excel((Number-<span class="number">1</span>) <span class="keyword">div</span> <span class="number">26</span>, (Number-<span class="number">1</span>) <span class="keyword">rem</span> <span class="number">26</span>, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(<span class="number">0</span>, Remainder, Acc)</span> -&gt;</span></div><div class="line">    [(Remainder + $A)|Acc];</div><div class="line"><span class="function"><span class="title">num2excel</span><span class="params">(Quotient, Remainder, Acc)</span> -&gt;</span></div><div class="line">    num2excel((Quotient-<span class="number">1</span>) <span class="keyword">div</span> <span class="number">26</span>, (Quotient-<span class="number">1</span>) <span class="keyword">rem</span> <span class="number">26</span>, [(Remainder + $A)|Acc]).</div></pre></td></tr></table></figure>
<p>或者在我们的工具套件里的单词处理器需要单词统计函数。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">% public</div><div class="line">wordcount(Input) -&gt;</div><div class="line">    wordcount(Input, 0).</div><div class="line"></div><div class="line">% internal</div><div class="line">wordcount([], Count) -&gt;</div><div class="line">    Count;</div><div class="line">% End of the input. Count the last word, if we didn't already</div><div class="line">wordcount([C1], Count) when C1 =/= $\  -&gt;</div><div class="line">    Count+1;</div><div class="line">% End of a word. Count it.</div><div class="line">wordcount([C1, C2|Rest], Count) when C1 =/= $\ , C2 =:= $\  -&gt;</div><div class="line">    wordcount([C2|Rest], Count + 1);</div><div class="line">% Not the end of a word. Don't count it.</div><div class="line">wordcount([_|Rest], Count) -&gt;</div><div class="line">    wordcount(Rest, Count).</div></pre></td></tr></table></figure>
<p>在这里我们用了两个新的操作符：=:= 是Erlang的相等操作符，=/=是Erlang的不等操作符。现在你明白了。</p>
<p>当然，如果我们计划构建一个产品来与Microsoft FrontPage竞争，那么我将需要一个方法来转义HTML特殊字符。这个功能实现起来不费吹灰之力，代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% public</span></div><div class="line"><span class="function"><span class="title">escape</span><span class="params">(String)</span> -&gt;</span></div><div class="line">    escape(String, []).</div><div class="line"></div><div class="line"><span class="comment">% internal</span></div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([], Acc)</span> -&gt;</span></div><div class="line">    lists:reverse(Acc);</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&lt; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;lt;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&gt; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;gt;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([$&amp; | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, lists:reverse(<span class="string">"&amp;amp;"</span>, Acc));</div><div class="line"><span class="function"><span class="title">escape</span><span class="params">([C | Rest], Acc)</span> -&gt;</span></div><div class="line">    escape(Rest, [C | Acc]).</div></pre></td></tr></table></figure>
<p>上述代码有一些新东西：有两个参数的lists:reverse()。它反转第一个参数，然后把第二个参数加在其后。这样的代码很方便，我们反向构建累加器（在字符串处理中经常如此）。</p>
<p>Outlook Express最好要小心了，因为我们现在有了编写杀手级电子邮件客户端的工具。让我们将即将发送出去的邮件用每行80个字符的方式来格式化。当我们扫描输入的时候，我们将有一个单词累加器，并且有一个输出累加器，我们要决定什么时候将累加的单词增加到输出累加器里，以及什么时候增加新行字符。在此你需要一个新的操作符：++ 将两个列表串起来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">% 公共接口</div><div class="line">wordwrap(Input) -&gt;</div><div class="line">    wordwrap(Input, [], [], 0, 80).</div><div class="line"></div><div class="line">% 内部函数</div><div class="line">% 没有输入了，我们结束处理，输出结果</div><div class="line">wordwrap([], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    lists:reverse(WordAcc ++ Acc);</div><div class="line"></div><div class="line">% 遇到输入里的换行符</div><div class="line">wordwrap([$\n | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\n | WordAcc ++ Acc], [], 0, WrapAt);</div><div class="line"></div><div class="line">% 当前行长度达到需要换行的长度，并且输入字符为空字符。新增一行</div><div class="line">wordwrap([$\  | Rest], Acc, WordAcc, WrapAt, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\n | WordAcc ++ Acc], [], 0, WrapAt);</div><div class="line"></div><div class="line">% 当前行长度未达到换行长度，输入字符为空字符。</div><div class="line">wordwrap([$\  | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, [$\  | WordAcc ++ Acc], [], LineLength + 1 + length(WordAcc), WrapAt);</div><div class="line"></div><div class="line">% 在建立单词时其长度大于需要换行长度</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, 0, WrapAt) when erlang:length(WordAcc) &gt; WrapAt -&gt;</div><div class="line">    wordwrap(Rest, Acc, [C | WordAcc], 0, WrapAt);</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, LineLength, WrapAt)</div><div class="line">                        when erlang:length(WordAcc) + LineLength &gt; WrapAt -&gt;</div><div class="line">    wordwrap(Rest, [$\n | Acc], [C | WordAcc], 0, WrapAt);</div><div class="line"></div><div class="line">% 构建一个单词</div><div class="line">wordwrap([C | Rest], Acc, WordAcc, LineLength, WrapAt) -&gt;</div><div class="line">    wordwrap(Rest, Acc, [C | WordAcc], LineLength, WrapAt).</div></pre></td></tr></table></figure>
<p>上述就是我们实现的代码。</p>
<h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a><span id="part-five">下一步</span></h1><p>Erlang是一种丰富的语言，当你深入了解它时，你会更加欣赏它。为了直接讲解本文中的算法，我刻意避免覆盖Erlang的主要数据结构、库及其内置函数。但是如果你喜欢用Erlang的思维框架思考问题，我鼓励你阅读本文后去学习它其余的知识，并开始把Erlang用在工作中。Erlang拥有一个活跃的、不断增长的、友好的开发人员社区、令人兴奋的有潜力的应用程序以及许多有趣和有用的开源项目。</p>
<p>诚然，学习驾驭魅影是艰难的事情，但一旦你掌握了它，你一定会为你的付出而喜悦。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><span id="part-six">源代码</span></h1><p><a href="http://www.evanmiller.org/joy_of_erlang.erl" target="_blank" rel="external">下载本文中所示的源代码</a></p>
<blockquote>
<p>*原文链接<a href="http://www.evanmiller.org/joy-of-erlang.html" target="_blank" rel="external">http://www.evanmiller.org/joy-of-erlang.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在电影&amp;lt;&amp;lt;阿凡达&amp;gt;&amp;gt;里，有一条超级大的翼龙，它叫做魅影，男主角为了赢得蓝色族人的信任必须学会骑魅影。一般来说，魅影不喜欢被骑，但如果你和它打一架，而且把它制服，然后把你的蓝马尾辫连接到魅影的尾巴上，你就能拥有它的生命。这就像拥有一辆你能控制的飞车，在与强敌作战时，你可以很方便地用你的思想控制它，给未来的同事留下深刻印象。但是学会骑魅影是很危险的，很少有人能成功。&lt;/p&gt;
&lt;p&gt;我喜欢把Erlang编程语言看作是一条魅影。大多数人都害怕Erlang。关于其能力的传说比比皆是。为了掌握它，你必须与它战斗，征服它，并(最后)把你的思想与它联系起来。但假设你能活下来，你就可以控制世界上最先进的服务器平台，让它做事情的时候通常无需再思考。现在让我来告诉你：驾驭魅影是很有趣的。&lt;/p&gt;
&lt;p&gt;本指南旨在教会你Erlang的思想，这样你就不会害怕而离开，而是可以战胜你自己的魅影。我将只介绍一些Erlang语言特性，但是我们将使用它们来解决大量实际问题。它的目的是让你想要并且有信心去学习并掌握Erlang语言其他知识。&lt;/p&gt;
&lt;p&gt;欢迎您将这些示例输入到自己的Erlang shell中，并执行它们，不过这些示例的设计是为了便于阅读而设计的。我建议你把这份文件打印出来，在舒适的椅子上仔细地阅读，并且远离电子邮件、编译器、3D电影以及其他干扰。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="recursion" scheme="http://szpzs.oschina.io/tags/recursion/"/>
    
      <category term="function" scheme="http://szpzs.oschina.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>为什么我经常从头开始实现某些功能</title>
    <link href="http://szpzs.oschina.io/2017/06/14/why-i-often-implement-things-from-scratch/"/>
    <id>http://szpzs.oschina.io/2017/06/14/why-i-often-implement-things-from-scratch/</id>
    <published>2017-06-14T02:28:00.000Z</published>
    <updated>2017-06-14T02:32:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>从前有一个Erlang程序员，他需要一个FTP服务器，运行在一个私有网络上的一个主机上。实际上，他不需要一个FTP服务器，他只需要在中央服务器和他的客户端机器之间传输文件，但是他认为他需要一个FTP服务器来完成这个操作。</p>
<a id="more"></a>
<p>他在网上搜索了FTP服务器，确实找到了几个。他们当然是免费的，因为即使他工作的组织有很多钱，但是购买这样一种产品的行政程序是相当可观的。这个项目还必须有合适的许可证形式，这样法律部门才会高兴。</p>
<p>他下载了几个这样的服务器，其中一些是无法编译的，即使它们确实编译了，它们也必须正确配置才能运行，这并不容易。</p>
<p>突然，我们的程序员有了一种想法：他可能可以自己编写一个FTP服务器，而自己编写FTP服务器可能比查找和安装其他人编写的FTP服务器要快。</p>
<p>他问自己：“我想做什么呢?”。</p>
<p>“将远程目录的文件列出来，在本地和远程机器之间拷贝文件等等。”</p>
<p>然后他想起他正在做的项目使用了分布式Erlang。</p>
<p>他想：“这一定很容易”。他是对的。</p>
<p>然后…在服务器机器上，他输入了如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="variable">$erl</span> -name server -cookie ASDRTFERT</div><div class="line">1&gt; node().</div><div class="line"><span class="string">'server@host1.somenet.com'</span></div></pre></td></tr></table></figure>
<p>然后他在另一台机器上输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="variable">$erl</span> -name client1 -cookie ASDRTFERT</div><div class="line">1&gt; node().</div><div class="line"><span class="string">'client1@host23.somenet.com'</span></div></pre></td></tr></table></figure>
<p>现在他已经启动了两个Erlang节点。分布式Erlang的优点是你可以轻松地在任何节点上运行代码，因此要检查他是否能够从客户机节点访问服务器节点，程序员就会输入如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; rpc:call(server@host1.somenet.com',</div><div class="line">erlang, node, []).</div><div class="line">'server@host1.somenet.com'</div></pre></td></tr></table></figure>
<p>如果命令在第一台机器上发出，那将会发生什么。我们可以自己尝试一下。现在我们的程序员知道他可以就像在本地机器上一样调用远程机器上的任何功能。</p>
<p>例子如下：</p>
<p>如果本地命令是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; file:get_cwd()</div></pre></td></tr></table></figure>
<p>在服务器上执行这个命令时，他只需要调用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; rpc:call(server@host1.somenet.com',file, get_cwd, []).</div></pre></td></tr></table></figure>
<p>那么列出远程机器的文件，他输入如下命令即可：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; rpc:call(server@host1.somenet.com',</div><div class="line">     file, list_dir, [<span class="string">"."</span>]).</div><div class="line">&#123;ok, [<span class="string">"Makefile"</span>,</div><div class="line">  <span class="string">"readme"</span>,</div><div class="line"> ....</div></pre></td></tr></table></figure>
<p>然后他决定把远程机器的Makefile文件拷贝到他本地机器上，因此他写了如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; &#123;ok, Bin&#125; = rpc:call(server@host1.smenet.com',</div><div class="line">                file, read_file, [<span class="string">"Makefile"</span>]).</div><div class="line">&lt;&lt;<span class="string">".SUFFIXES: .erl .beam .yrl"</span> .....&gt;&gt;</div><div class="line"><span class="number">3</span>&gt; file:write_file(<span class="string">"Makefile"</span>, [Bin]).</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>此时，所有在shell中键入的内容变得冗长乏味，因此他启动了emacs并编写了如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(myftp)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([get_file/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">get_file</span><span class="params">(F)</span> -&gt;</span></div><div class="line">&#123;ok, B&#125; = rpc:call(server@host1.smenet.com',</div><div class="line">                  file, read_file, [F]),</div><div class="line">file:write_file(F ++ <span class="string">".copy"</span>, [B]).</div></pre></td></tr></table></figure>
<p>然后他编译并测试他的程序：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; c(myftp).</div><div class="line">&#123;ok,myftp&#125;</div><div class="line"><span class="number">5</span>&gt; myftp:get_file(<span class="string">"Makefile"</span>).</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>就这么简单，他搞定了。</p>
<h2 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h2><p>如果你有合适的工具，那么在从头开始实现一些东西比很麻烦地下载编译和安装别人写的东西更快。</p>
<p>这是一个真实的故事，只不过我刚刚写了这段代码。编写此代码和博客的时间与在我的机器上找到并安装一个FTP服务器差不多。</p>
<blockquote>
<p><em>原文链接：</em>  [<a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-often-implement-things-from.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com/2006/09/why-i-often-implement-things-from.html</a>]</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从前有一个Erlang程序员，他需要一个FTP服务器，运行在一个私有网络上的一个主机上。实际上，他不需要一个FTP服务器，他只需要在中央服务器和他的客户端机器之间传输文件，但是他认为他需要一个FTP服务器来完成这个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="rpc" scheme="http://szpzs.oschina.io/categories/Erlang/rpc/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="rpc" scheme="http://szpzs.oschina.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Mnesia表分片</title>
    <link href="http://szpzs.oschina.io/2017/05/30/Mnesia-Table-Fragmentation-erlangcentral/"/>
    <id>http://szpzs.oschina.io/2017/05/30/Mnesia-Table-Fragmentation-erlangcentral/</id>
    <published>2017-05-30T02:53:27.000Z</published>
    <updated>2017-05-30T03:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">概述</a></li>
<li><a href="#part-two">要求</a></li>
<li><a href="#part-three">分片表的样例</a></li>
<li><a href="#part-four">启动一个Erlang节点</a></li>
<li><a href="#part-five">用20个表创建分片表</a></li>
<li><a href="#part-six">数据操作</a></li>
<li><a href="#part-seven">添加记录</a></li>
<li><a href="#part-eight">选择有限的记录</a></li>
<li><a href="#part-nine">分片表的列表</a></li>
</ol>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><span id="part-one">概述</span></h1><p>本文描述如何创建Mnesia分片表以及如何使用它们。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a><span id="part-two">要求</span></h1><p>假如我必须做一个图书索引应用程序。我有一张表用来记录所有可用的图书馆书籍。表的记录结构如下节所述。因为数据量巨大，所以我想把这个表在一个单独的Erlang节点里分片。如果你想分布式处理这个分片的表，你可以参考<a href="http://erlangcentral.org/wiki/index.php?title=Distributing_a_Mnesia_schema" target="_blank" rel="external">这篇文章</a>来分布式处理Mnesia的表。与表分片的其他相关工作都保持不变。</p>
<h1 id="分片表的样例"><a href="#分片表的样例" class="headerlink" title="分片表的样例"></a><span id="part-three">分片表的样例</span></h1><p>我需要这张表是disk_copies模式。其他模式也以相同的方式操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-record</span><span class="params">(book_info, &#123;isbn, name, author, keywords, category, description&#125;)</span>.</div></pre></td></tr></table></figure>
<h1 id="启动一个Erlang节点"><a href="#启动一个Erlang节点" class="headerlink" title="启动一个Erlang节点"></a><span id="part-four">启动一个Erlang节点</span></h1><p>我们的例子节点foo@example默认的磁盘存储路径被设置为在当前路径下的Mnesia.foo@example目录。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -sname foo</div></pre></td></tr></table></figure>
<p>这个路径可以在启动一个Erlang节点的时候通过用 -mnesia dir ‘“/path/of/your/preference”‘ ‘ 启动参数来改写。</p>
<p>让我们创建一个基于磁盘的schema，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnesia:create_schema([node()]).</div></pre></td></tr></table></figure>
<h1 id="用20个表创建分片表"><a href="#用20个表创建分片表" class="headerlink" title="用20个表创建分片表"></a><span id="part-five">用20个表创建分片表</span></h1><p>在本例中，所有20个分片在相同的Erlang/Mnesia节点里。另外这些分片是disc_copies类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mnesia:create_table(book_info,</div><div class="line">   [&#123;frag_properties, [&#123;node_pool, [node()]&#125;, &#123;n_fragments, <span class="number">20</span>&#125;, &#123;n_disc_copies, <span class="number">1</span>&#125;]&#125;,</div><div class="line">   &#123;index, [name, keywords, category]&#125;,</div><div class="line">   &#123;attributes, record_info(fields, book_info)&#125;]),</div></pre></td></tr></table></figure>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a><span id="part-six">数据操作</span></h1><p>为了能够访问在一个分片表的记录，Mnesia必须确定该真实记录属于那个分片。这通过mnesia_frag模块来做到，这个模块实现了mnesia_access回调行为。mnesia_frag封装标准Mnesia操作函数到其函数里，并将其作为参数传递给mnesia:activity/4。</p>
<h1 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a><span id="part-seven">添加记录</span></h1><p>创建一个调用mnesia:write/3的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AddFun = <span class="keyword">fun</span>() -&gt;</div><div class="line">           mnesia:write(book_info, Record, write)</div><div class="line">          <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在如下所示在mnesia:activity/4里调用这个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = mnesia:activity(transaction, AddFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>注意，我已将活动访问上下文用作“事务”。事务可以确保操作要么全部成功要么全部失败（即保证操作的原子性）。我可以使用如下几个访问上下文：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;transaction, Retries&#125;</div><div class="line">sync_transaction</div><div class="line">&#123;sync_transaction, Retries&#125;</div><div class="line">async_dirty</div><div class="line">sync_dirty</div><div class="line">ets</div></pre></td></tr></table></figure>
<p>例如，你想用脏模式做以上的操作，你可以这么写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = mnesia:activity(async_dirty, AddFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>你可以参考mnesia:activity/4文档来获得更多信息。</p>
<h1 id="选择有限的记录"><a href="#选择有限的记录" class="headerlink" title="选择有限的记录"></a><span id="part-eight">选择有限的记录</span></h1><p>做为一个例子，让我们选择作者是steve的10条记录。记住10不是硬性限制。用mnesia:select/4函数创建一个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MatchHead = #book_info&#123;author = <span class="string">"steve"</span>, _ = '_'&#125;,</div><div class="line">Guard = [],</div><div class="line">Result = ['$_'],</div><div class="line">MatchSpec = [&#123;MatchHead, Guard, Result&#125;],</div><div class="line">SelFun = <span class="keyword">fun</span>() -&gt;</div><div class="line">          mnesia:select(book_info, MatchSpec, <span class="number">10</span>, read)</div><div class="line">         <span class="keyword">end</span>,</div></pre></td></tr></table></figure>
<p>现在如下所示在mnesia:activity/4里调用这个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result = mnesia:activity(transaction, SelFun, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>Result的结果类型是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result -&gt; '$end_of_table' | &#123;[Objects], Cont&#125; | transaction abort</div></pre></td></tr></table></figure>
<p>在一个分片的表里，如果上述Result结果是{[Objects], Cont}，并且返回的对象数量少于我们期望的（10个），那么你需要递归地用Cont（continuation）来调用mnesia:select/1，直到你得到期望数量的结果或者’$end_of_table’。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SelFun2 = <span class="keyword">fun</span>() -&gt;</div><div class="line">             mnesia:select(Cont)</div><div class="line">           <span class="keyword">end</span>,</div><div class="line">Result2 = mnesia:activity(transaction, SelFun2, [], mnesia_frag).</div></pre></td></tr></table></figure>
<p>Result2的结果类型是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Result2 -&gt; '$end_of_table' | &#123;[Objects], Cont&#125; | transaction abort</div></pre></td></tr></table></figure>
<h1 id="分片表的列表"><a href="#分片表的列表" class="headerlink" title="分片表的列表"></a><span id="part-nine">分片表的列表</span></h1><p>要获取分片表的列表，调用mnesia:table_info/2，并加上 frag_names 选项：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnesia:activity(async_dirty, mnesia:table_info/<span class="number">2</span>, [store, frag_names], mnesia_frag).</div></pre></td></tr></table></figure>
<p>本教程到此结束！现在你知道如何写一个基本的Mnesia分片表程序了。</p>
<blockquote>
<p><em>原文链接：</em>  [<a href="http://www2.erlangcentral.org/wiki/?title=Mnesia_Table_Fragmentation" target="_blank" rel="external">http://www2.erlangcentral.org/wiki/?title=Mnesia_Table_Fragmentation</a>]</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;分片表的样例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;启动一个Erlang节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;用20个表创建分片表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;数据操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;添加记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-eight&quot;&gt;选择有限的记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-nine&quot;&gt;分片表的列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Mnesia" scheme="http://szpzs.oschina.io/categories/Mnesia/"/>
    
      <category term="Fragmentation" scheme="http://szpzs.oschina.io/categories/Mnesia/Fragmentation/"/>
    
    
      <category term="Mnesia" scheme="http://szpzs.oschina.io/tags/Mnesia/"/>
    
      <category term="Fragmentation" scheme="http://szpzs.oschina.io/tags/Fragmentation/"/>
    
  </entry>
  
  <entry>
    <title>如何在运行时求值Erlang的代码字符串</title>
    <link href="http://szpzs.oschina.io/2017/03/16/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/"/>
    <id>http://szpzs.oschina.io/2017/03/16/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/</id>
    <published>2017-03-16T14:03:09.000Z</published>
    <updated>2017-03-16T14:13:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang有一种能力，在运行时读取一个代表一行代码的字符然后执行这行代码。</p>
<p>它可以解析这个字符串，执行它，然后返回结果。</p>
<ol>
<li><a href="#part-one">求值简单的表达式</a></li>
<li><a href="#part-two">安全注意事项</a><br> 2.1. <a href="#part-two-one">SQL注入攻击是什么？(请耐心看看)</a><br> 2.2 <a href="#part-two-two">与Erlang有关的安全问题是什么？！</a></li>
<li><a href="#part-three">拦截本地函数调用</a></li>
<li><a href="#part-four">拦截非本地函数调用</a></li>
<li><a href="#part-five">还有什么？</a></li>
</ol>
<a id="more"></a>
<h1 id="求值简单的表达式"><a href="#求值简单的表达式" class="headerlink" title="求值简单的表达式"></a><span id="part-one">求值简单的表达式</span></h1><p>最基本的，我们可以读取任何传入的表达式并执行它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),    <span class="comment">% 扫描代码为一些字符串标记</span></div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),     <span class="comment">% 解析这些字符串标记为一个抽象格式</span></div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, []),  <span class="comment">% 求值表达式，返回结果值</span></div><div class="line">    Result.</div></pre></td></tr></table></figure>
<p>尝试传递一些简单的算术表达式。很简单吧？</p>
<p>记住，语句用逗号结束，而函数用句号结束，所以你需要包括那些标点符号。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &gt; 2."</span>).</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4+2."</span>).</div><div class="line"><span class="number">6</span></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"A=7+2,A-4."</span>).</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>如果这就是你所需要的，真棒。</p>
<p>如果你有时间，你可能想要了解这开辟了潜在安全闸门。</p>
<h1 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a><span id="part-two">安全注意事项</span></h1><p>如果你只允许任何人执行任意一行代码，将会有一些很严重的问题，而且立刻就有更多的漏洞出现。</p>
<p>首先，要做一个比较…</p>
<h2 id="SQL注入攻击是什么？-请耐心看看"><a href="#SQL注入攻击是什么？-请耐心看看" class="headerlink" title="SQL注入攻击是什么？(请耐心看看)"></a><span id="part-two-one">SQL注入攻击是什么？(请耐心看看)</span></h2><p>我要转换一下话题，谈谈SQL注入攻击。</p>
<p>例如，我们已经一个web页面，用户可以在这个页面上只输入他们的用户名来查看关于他们自己的信息。在幕后，我们只是获取用户输入的用户名，然后将其插入一个查询语句中，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name = <span class="string">" + "</span>gwinney<span class="string">"</span></div></pre></td></tr></table></figure>
<p>只要用户规规矩矩地玩，一切都好。但是，如果他们输入的名字是 “gwinney; delete * from user_table” 呢？现在，这个查询语句变成如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name = <span class="string">" + "</span>gwinney; <span class="keyword">delete</span> * <span class="keyword">from</span> user_table<span class="string">"</span></div></pre></td></tr></table></figure>
<p>这个问题的解决方案（如果你把这样的代码提交到StackOverflow，至少一半的人会对你大吼大叫）是净化输入。我们应该检查一下以确保它做的是我们期望的，对于SQL来说，这通常意味着参数化查询。</p>
<p>我不想在此对这个问题进行太多的细述，但如果我们以正确的方式做的话，查询看起来更像下面这样，它这将查询失败，因为疯狂的用户名不存在。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="string">'gwinney; delete * from user_table'</span><span class="string">"</span></div></pre></td></tr></table></figure>
<h2 id="与Erlang有关的安全问题是什么？！"><a href="#与Erlang有关的安全问题是什么？！" class="headerlink" title="与Erlang有关的安全问题是什么？！"></a><span id="part-two-two">与Erlang有关的安全问题是什么？！</span></h2><p>相似地，我们可能会碰到表达式代码的安全问题。</p>
<p>我们被允许包含任何函数 – 本地函数、BIF（Erlang的内建函数）和在你创建的其他模块里暴露出来的函数 – 的调用，并且它将解析它们然后尝试执行它们。</p>
<p>如果我们让上述函数能被外界访问，即使是间接的，而且输入没有经过净化，那么我们就是给别人直接调用各种他们没有业务调用函数的能力。危险啊！</p>
<p>那么我们如何防止这样的危险呢？</p>
<h1 id="拦截本地函数调用"><a href="#拦截本地函数调用" class="headerlink" title="拦截本地函数调用"></a><span id="part-three">拦截本地函数调用</span></h1><p>我们可以给 erl_eval:exprs 提供一个函数，所有本地函数的调用都被传给它，我们就可以在这个函数里做一些额外的动作。</p>
<p>本地函数是那些在相同的模块里，它们可以不需要指定模块名而被调用。（虽然一些BIF，比如list_to_binary，不需要指定模块名，这是因为它们被系统自动导入了 – 它们仍然被认为是非本地的。）</p>
<p>在下面的代码里有一些新元素。一个叫做handle_local_function的函数和一个叫做get_random_number的本地函数（感谢<a href="https://xkcd.com/221/" target="_blank" rel="external">xkcd</a>）。这个处理函数输出一个相关信息然后处理传入给它的函数名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),</div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),</div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, [],</div><div class="line">                                        &#123;value, fun handle_local_function/2&#125;),</div><div class="line">    Result.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_local_function</span><span class="params">(FunctionName, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">        get_random_number -&gt; get_random_number();</div><div class="line">        what_time_is_it -&gt; calendar:universal_time();</div><div class="line">        are_we_there_yet -&gt; <span class="string">"no"</span>;</div><div class="line">        _ -&gt; <span class="string">"uh uh uh. you didn't say the magic word!"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> get_random_number<span class="params">()</span> -&gt; integer<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">get_random_number</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="number">4</span>.  <span class="comment">% 通过公平的骰子选择；保证是随机的</span></div></pre></td></tr></table></figure>
<p>现在再运行这个模块，传入一些新的表达式。</p>
<p>我们可以拦截这些本地函数（可能不是真的存在，但表达式求值器不知道），并且按照我们的要求重定向它们…或者如果用户试图做一些无效的事情，只会吐出一条消息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"get_random_number()."</span>).</div><div class="line">Local call to get_random_number with []</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"what_time_is_it()."</span>).</div><div class="line">Local call to what_time_is_it with []</div><div class="line">&#123;&#123;<span class="number">2017</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">15</span>,<span class="number">21</span>,<span class="number">53</span>&#125;&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"are_we_there_yet()."</span>).</div><div class="line">Local call to are_we_there_yet with []</div><div class="line"><span class="string">"no"</span></div><div class="line"></div><div class="line">parser:evaluate_expression(<span class="string">"break_the_system()."</span>).</div><div class="line">Local call to break_the_system with []</div><div class="line"><span class="string">"uh uh uh. you didn't say the magic word!"</span></div></pre></td></tr></table></figure>
<h1 id="拦截非本地函数调用"><a href="#拦截非本地函数调用" class="headerlink" title="拦截非本地函数调用"></a><span id="part-four">拦截非本地函数调用</span></h1><p>相似地，我们可以给 erl_eval:exprs 提供一个函数，所有非本地函数的调用都被传给它。（当前模块外的任何东西，包括BIF、甚至用于比较的运算符。）</p>
<p>如下代码被扩展来处理非本地函数。注意，我们如何必须显式处理属于Erlang模块的一部分的 &gt; 和 &lt; 比较运算符，我们如何能够把不存在的函数重导向到存在的函数，以及如果一个函数不被支持，我们如何能够输出一条消息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(parser)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">    evaluate_expression/<span class="number">1</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> evaluate_expression<span class="params">(string)</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">evaluate_expression</span><span class="params">(Expression)</span> -&gt;</span></div><div class="line">    &#123;ok, Tokens, _&#125; = erl_scan:string(Expression),</div><div class="line">    &#123;ok, Parsed&#125; = erl_parse:parse_exprs(Tokens),</div><div class="line">    &#123;value, Result, _&#125; = erl_eval:exprs(Parsed, [],</div><div class="line">                                        &#123;value, fun handle_local_function/2&#125;,</div><div class="line">                                        &#123;value, fun handle_non_local_function/2&#125;),</div><div class="line">    Result.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_local_function</span><span class="params">(FunctionName, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">        get_random_number -&gt; get_random_number();</div><div class="line">        what_time_is_it -&gt; calendar:universal_time();</div><div class="line">        are_we_there_yet -&gt; <span class="string">"no"</span>;</div><div class="line">        _ -&gt; <span class="string">"uh uh uh. you didn't say the magic word!"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> handle_non_local_function<span class="params">(atom(), list())</span> -&gt; any<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">handle_non_local_function</span><span class="params">(&#123;ModuleName,FunctionName&#125;, Arguments)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Non-local call to ~p with ~p~n"</span>, [FunctionName, Arguments]),</div><div class="line">    <span class="keyword">case</span> ModuleName <span class="keyword">of</span></div><div class="line">        erlang -&gt;</div><div class="line">            <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">                '&gt;' -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                '&lt;' -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                list_to_binary -&gt; apply(ModuleName, FunctionName, Arguments);</div><div class="line">                _ -&gt; <span class="string">"nope"</span></div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        calendar -&gt;</div><div class="line">            <span class="keyword">case</span> FunctionName <span class="keyword">of</span></div><div class="line">                universal_time -&gt; calendar:universal_time();</div><div class="line">                lets_pretend_this_returns_four -&gt; <span class="number">4</span>;</div><div class="line">                something_ridiculous -&gt; <span class="string">"what calendar are you using??"</span>;</div><div class="line">                _ -&gt; <span class="string">"notgonnahappen"</span></div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        _ -&gt; <span class="string">"don't think about it"</span></div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> get_random_number<span class="params">()</span> -&gt; integer<span class="params">()</span>.</div><div class="line"><span class="function"><span class="title">get_random_number</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="number">4</span>.  <span class="comment">% chosen by fair dice roll; guaranteed to be random</span></div></pre></td></tr></table></figure>
<p>大于和小于比较是允许的，但是等于却不允许。一些函数被允许，一些函数不被允许，一些函数被重定向。在上一个例子中，一个邪恶的用户尝试用他们邪恶的计划搞垮系统。但他被挫败了。:p</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&gt; c(parser).</div><div class="line">&#123;ok,parser&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &lt; 2."</span>).</div><div class="line">Non-local call to '&lt;' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="literal">false</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 &gt; 2."</span>).</div><div class="line">Non-local call to '&gt;' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"4 == 2."</span>).</div><div class="line">Non-local call to '==' with [<span class="number">4</span>,<span class="number">2</span>]</div><div class="line"><span class="string">"nope"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"list_to_binary(\"hi\")."</span>).</div><div class="line">Non-local call to list_to_binary with [<span class="string">"hi"</span>]</div><div class="line">&lt;&lt;<span class="string">"hi"</span>&gt;&gt;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"binary_to_list(&lt;&lt;\"hi\"&gt;&gt;)."</span>).</div><div class="line">Non-local call to binary_to_list with [&lt;&lt;<span class="string">"hi"</span>&gt;&gt;]</div><div class="line"><span class="string">"nope"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:universal_time()."</span>).</div><div class="line">Non-local call to universal_time with []</div><div class="line">&#123;&#123;<span class="number">2017</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">21</span>,<span class="number">4</span>,<span class="number">42</span>&#125;&#125;</div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:local_time()."</span>).</div><div class="line">Non-local call to local_time with []</div><div class="line"><span class="string">"notgonnahappen"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:lets_pretend_this_returns_four()."</span>).</div><div class="line">Non-local call to lets_pretend_this_returns_four with []</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"calendar:something_ridiculous()."</span>).</div><div class="line">Non-local call to something_ridiculous with []</div><div class="line"><span class="string">"what calendar are you using??"</span></div><div class="line"></div><div class="line">&gt; parser:evaluate_expression(<span class="string">"sys:terminate(some_process, \"buahaha\")."</span>).</div><div class="line">Non-local call to terminate with [some_process,<span class="string">"buahaha"</span>]</div><div class="line"><span class="string">"don't think about it"</span></div></pre></td></tr></table></figure>
<h1 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a><span id="part-five">还有什么？</span></h1><p>Erlang里的好例子很难得到，你在这里看到的是一些试验和错误。如果你发现自己试图解析代码，并在运行时执行它，也许这会让你理解得更深。</p>
<p>其他资源：</p>
<ul>
<li><a href="http://www2.erlangcentral.org/wiki/?title=String_Eval" target="_blank" rel="external">执行存储在字符串里的Erlang代码</a>（涉及到绑定变量，这个我在本文没有介绍）</li>
<li>官方文档：<a href="http://erlang.org/doc/man/erl_scan.html" target="_blank" rel="external">erl_scan</a>、<a href="http://erlang.org/doc/man/erl_parse.html" target="_blank" rel="external">erl_parse</a>、<a href="http://erlang.org/doc/man/erl_eval.html" target="_blank" rel="external">erl_eval</a>（一切都在那里…一壶咖啡准备好了）</li>
<li><a href="http://people.apache.org/~dennisbyrne/infoq/DSLs_in_Erlang.ppt" target="_blank" rel="external">Erlang里的领域特定语言</a>（ppt文档，你可以下载来看）</li>
<li><a href="http://stackoverflow.com/q/6786034/301857" target="_blank" rel="external">参数化语句能阻止所有SQL注入吗？</a>（如果你感兴趣的话，这是一个在Stackoverflow上关于SQL注入更多细节的贴子。）</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://grantwinney.com/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/" target="_blank" rel="external">https://grantwinney.com/how-to-evaluate-a-string-of-code-in-erlang-at-runtime/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang有一种能力，在运行时读取一个代表一行代码的字符然后执行这行代码。&lt;/p&gt;
&lt;p&gt;它可以解析这个字符串，执行它，然后返回结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;求值简单的表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;安全注意事项&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;SQL注入攻击是什么？(请耐心看看)&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#part-two-two&quot;&gt;与Erlang有关的安全问题是什么？！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;拦截本地函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;拦截非本地函数调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;还有什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="erl_scan erl_parse erl_eval" scheme="http://szpzs.oschina.io/categories/Erlang/erl-scan-erl-parse-erl-eval/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="erl_scan" scheme="http://szpzs.oschina.io/tags/erl-scan/"/>
    
      <category term="erl_parse" scheme="http://szpzs.oschina.io/tags/erl-parse/"/>
    
      <category term="erl_eval" scheme="http://szpzs.oschina.io/tags/erl-eval/"/>
    
  </entry>
  
  <entry>
    <title>Elixir的多态性</title>
    <link href="http://szpzs.oschina.io/2017/03/13/polymorphism-in-elixir/"/>
    <id>http://szpzs.oschina.io/2017/03/13/polymorphism-in-elixir/</id>
    <published>2017-03-13T06:17:46.000Z</published>
    <updated>2017-03-13T06:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>多态性是向不同类型的实体提供单一接口。本质上，它允许不同的数据类型响应相同的函数。因此，相同的函数为不同的数据类型完成相同的行为。Elixir语言有‘协议’和简洁的方式实现多态性。</p>
<a id="more"></a>
<p>让我们实现一个基本的协议，它将开氏和华氏温度转换为摄氏温度。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Kelvin</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Kelvin"</span>, <span class="symbol">symbol:</span> <span class="string">"K"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Fahrenheit</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Fahrenheit"</span>, <span class="symbol">symbol:</span> <span class="string">"°F"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Celsius</span></span> <span class="keyword">do</span></div><div class="line">  defstruct <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>, <span class="symbol">degree:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Temperature</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Convert Kelvin and Fahrenheit to Celsius degree</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(degree)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Temperature</span></span>, <span class="symbol">for:</span> Kelvin <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Deduct 273.15</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(kelvin) <span class="keyword">do</span></div><div class="line">    celsius_degree = kelvin.degree - <span class="number">273.15</span></div><div class="line">    %Celsius&#123;<span class="symbol">degree:</span> celsius_degree&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Temperature</span></span>, <span class="symbol">for:</span> Fahrenheit <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Deduct 32, then multiply by 5, then divide by 9</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_celsius</span></span>(fahrenheit) <span class="keyword">do</span></div><div class="line">    celsius_degree = (fahrenheit.degree - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></div><div class="line">    %Celsius&#123;<span class="symbol">degree:</span> celsius_degree&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，我们实现了开氏和华氏温度的转换。</p>
<p>让我们尝试一些转换：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; fahrenheit = %Fahrenheit&#123;<span class="symbol">degree:</span> <span class="number">45</span>&#125;</div><div class="line">%Fahrenheit&#123;<span class="symbol">degree:</span> <span class="number">45</span>, <span class="symbol">name:</span> <span class="string">"Fahrenheit"</span>, <span class="symbol">symbol:</span> <span class="string">"°F"</span>&#125;</div><div class="line">iex&gt; celsius = Temperature.to_celsius(fahrenheit)</div><div class="line">%Celsius&#123;<span class="symbol">degree:</span> <span class="number">7.22</span>, <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>&#125;</div><div class="line"></div><div class="line">iex&gt; kelvin = %Kelvin&#123;<span class="symbol">degree:</span> <span class="number">300</span>&#125;</div><div class="line">%Kelvin&#123;<span class="symbol">degree:</span> <span class="number">300</span>, <span class="symbol">name:</span> <span class="string">"Kelvin"</span>, <span class="symbol">symbol:</span> <span class="string">"K"</span>&#125;</div><div class="line">iex&gt; celsius = Temperature.to_celsius(kelvin)</div><div class="line">%Celsius&#123;<span class="symbol">degree:</span> <span class="number">26.85</span>, <span class="symbol">name:</span> <span class="string">"Celsius"</span>, <span class="symbol">symbol:</span> <span class="string">"°C"</span>&#125;</div></pre></td></tr></table></figure>
<p>让我们试着转换没有实现to_celsius函数的任何其他数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Temperature.to_celsius(%&#123;degree: 12&#125;)</div><div class="line">** (Protocol.UndefinedError) protocol Temperature not implemented for %&#123;degree: 12&#125;</div><div class="line">    iex:11: Temperature.impl_for!/1</div><div class="line">    iex:15: Temperature.to_celsius/1</div></pre></td></tr></table></figure>
<p>如果你想要转换所有数据类型，你可以为<strong>Any</strong>这个数据类型定义一个实现。最后，如果你有时间，请阅读 <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/enum.ex#L3096" target="_blank" rel="external"><strong>Enum</strong></a> 和 <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/string/chars.ex#L3" target="_blank" rel="external"><strong>String.Char</strong></a> 的源码，它们是Elixir核心代码里多态性的好例子。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929#.d09i4bf56" target="_blank" rel="external">https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929#.d09i4bf56</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态性是向不同类型的实体提供单一接口。本质上，它允许不同的数据类型响应相同的函数。因此，相同的函数为不同的数据类型完成相同的行为。Elixir语言有‘协议’和简洁的方式实现多态性。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="polymorphism" scheme="http://szpzs.oschina.io/categories/Elixir/polymorphism/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/categories/Elixir/polymorphism/protocol/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/tags/protocol/"/>
    
      <category term="polymorphism" scheme="http://szpzs.oschina.io/tags/polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>减少固定大小缓冲区的最大延迟</title>
    <link href="http://szpzs.oschina.io/2017/03/10/reducing-maximum-latency/"/>
    <id>http://szpzs.oschina.io/2017/03/10/reducing-maximum-latency/</id>
    <published>2017-03-10T03:10:28.000Z</published>
    <updated>2017-03-10T05:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在<a href="https://pusher.com/" target="_blank" rel="external">Pusher</a>的博客读到两篇很棒的文章：<a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/" target="_blank" rel="external">低延迟、大的工作集和GHC的垃圾收集器：三选二</a> 和 <a href="https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="external">Golang的实时GC的理论与实践</a> 。这两篇文章讲的是Pusher的工程师如何重新实现他们的消息总线的故事。第一篇是发生在Haskell里。在性能测试期间，他们发现在99%那个范围内有一些高延迟。在他们分析代码后，他们能够证明这些延时的尖峰是由GHC的 stop-the-world 垃圾收集器，再加上一个大的工作集（内存中的对象的数目）所造成的。该开发团队随后尝试了GO，得到好得多的结果，这得益于GO的并发垃圾收集器。</p>
<p>我强烈推荐这两篇文章。Pusher的测试是一个很棒的基准测试例子，因为它专注于解决一个真正的挑战，并且基于该项技术是否合适本工作来评估此技术。这是我喜欢的那种评估方式。我发现做一个简单的关键功能的实现非常有用，然后看看它在所需的负荷下的表现，而不是通过一些浅层的模拟基准测试来比较不同的技术，例如在环里传递令牌，或让一个Web服务器返回“200 OK”。这个方法应该能提供“我能用Y有效地解决X吗？”问题的答案。当我第一次评估Erlang的时候，我采用的就是这种方法。10 倍的预期负载模拟真实系统的12个小时测试让我相信这项技术比我所需要的绰绰有余。</p>
<a id="more"></a>
<h1 id="接受挑战"><a href="#接受挑战" class="headerlink" title="接受挑战"></a>接受挑战</h1><p>阅读Pusher的文章使得我很想知道这个问题的Elixir实现的性能如何。毕竟，底层的Erlang虚拟机（BEAM）一直是给我低的和可预测的延迟的印象，所以加上其他性质，如容错、大规模的并发性、可扩展性、分布式系统的支持，这似乎是一个为该工作令人信服的选择。</p>
<p>所以让我根据Pusher的文章来定义挑战。我将实现一个先进先出（FIFO）缓冲区，它可以处理两种操作：push 和 pull。这个缓冲区由最大尺寸来限定它的大小。如果这个缓冲区满了，push操作将覆盖队列里最老的元素。</p>
<p>目标是为了减少一个非常大的缓冲区（最大20万元素）的push和pull操作的最大延迟。把这最后的目标牢记在心是很重要的。我关心平滑缓冲区操作的延迟尖峰。我不在乎哪种语言给我更好的最坏情况的GC停顿。虽然Pusher的挑战的根本问题是由长GC停顿造成的，那并不意味着我仅仅是换其他的语言就能解决它。正如我将阐述的，依赖于Elixir/Erlang的一些技巧，我们可以完全旁路掉GC，并且将最大延迟带入到微秒区域。</p>
<h1 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h1><p>为了测量性能，我决定在一个独立的GenServer进程里运行缓冲区。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/server.ex" target="_blank" rel="external">这里</a>看到实现代码。</p>
<p>测量利用了Erlang的trace能力。一个独立的进程被启动，它设置了缓冲区进程的trace。它接收push和pull操作以及缓冲区垃圾回收的开始和结束时间。它收集那些时间，并且在被要求的时候生成最终结果。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer_tracer.ex" target="_blank" rel="external">这里</a>找到它的实现。</p>
<p>trace将导致一些性能损耗。当trace被使用的时候，整个基准测试将是平常花费的两倍时间。我不能说它对报告的时间有多大的影响，但我并不在意它。如果我能够在用trace的情况下获得好的结果，那么在不用trace的情况下，这样的实现足够满足要求了。:-)</p>
<p>如果你不熟悉Erlang，这里的进程指的是Erlang的进程 - 一个运行在同一个操作系统进程里的轻量并发程序，并且和其他Erlang进程没有共享数据。在操作系统层面，我们仍然还是只有一个进程，但是在Erlang虚拟机里，有很多Erlang进程独立地运行着。</p>
<p>这些进程没有共同点，没有共享内存，只能通过发送自己的消息进行通信。特别是，每个进程都有自己独立的堆，并且各自进行自己的垃圾回收。因此，不论tracer进程分配了什么数据都不会给缓冲区进程造成GC压力。只有那些我们确实压入到缓冲区的数据在缓冲区GC期间才被考虑，也因此会影响缓冲区操作的延时。这种方法展示了Erlang非常棒的好处。通过在隔离的进程里运行不同的程序，我们可以在系统中防止在一个进程里的GC压力影响其他进程。我不知道有任何其他轻量级的并发平台提供这样的保证。</p>
<p>测试首先从一个简短的“拉伸”热身开始。我创建了一个最大容量为20万元素（这个数字是Pusher的基准测试里使用的）的缓冲区。然后，我压入20万个元素，接着全部取出来，然后再压入20万个元素。热身结束之际，缓冲区内的数据达到了它的最大容量。</p>
<p>这个时候基准测试开始。我以15个push操作然后跟着5个pull操作为一个周期发起了两百万个请求。因此，缓冲区的大多数操作处于“溢出”模式下。总的来说，1百万个push操作执行在满的缓冲区上，而50万个push操作执行在几乎满的缓冲区上。被压入的元素是1024字节的Erlang二进制数据，而且每一个元素都互不相同，意思就是测试将产生1百50万个不同的元素。</p>
<p>基准测试代码在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/mix/tasks/buffer_prof.ex" target="_blank" rel="external">这里</a>。完整的项目文件在<a href="https://github.com/sasa1977/erlangelist/tree/master/examples/buffer" target="_blank" rel="external">这里</a>。我用 Erlang 19.1 和 Elixir 1.3.4 运行基准测试，我用 <a href="https://github.com/asdf-vm/asdf" target="_blank" rel="external">asdf</a> 版本管理器来安装它们。测试运行在我的2011年的iMac上（3.4 GHz Intel Core i7）。</p>
<h1 id="函数式实现"><a href="#函数式实现" class="headerlink" title="函数式实现"></a>函数式实现</h1><p>首先，我会尝试我所认为的符合Elixir和Erlang习惯的方法 - 基于 <a href="http://erlang.org/doc/man/queue.html" target="_blank" rel="external">:queue</a> 模块的纯函数实现。根据文档所说，这个模块以高效的方式实现双端先进先出（FIFO）队列，它的大多数操作有一个分摊的O(1)运行时间。这个模块的API提供了绝大多数我们所需要的函数。我可以用 :queue.in/2 和 :queue.out/2 来push和pull数据。它没有直接支持设置队列的最大尺寸，但是在 :queue 模块实现这个功能非常简单。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/queue.ex" target="_blank" rel="external">这里</a>找到我的实现。</p>
<p>当我最初读Pusher的文章的时候，我非常肯定，这样的实现会导致较大的延迟尖峰。虽然在Erlang里没有 stop-the-world 的GC，但是依然有 stop-the-process 的GC。一个Erlang进程启动的时候有一个相当小的堆（大约2Kb），如果它需要分配比这个更多的空间，那么进程被GC并且它的堆可能被扩展。要了解GC的更多细节，我推荐<a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html" target="_blank" rel="external">这篇文章</a>以及另<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">一篇文章</a>。</p>
<p>在我们的测试里，这意味着缓冲区进程将相当快扩展到很大的堆，因为它要容纳20万个元素。那么，当我们压入更多数据并产生更多垃圾，GC将有很多工作要做。因此，我们可以期待有一些显著的GC停顿发生，它们将导致延迟尖峰。让我们核实一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mix buffer.bench -m Buffer.Queue</div><div class="line"></div><div class="line">push/pull (2000000 <span class="built_in">times</span>, average: 6.9 μs)</div><div class="line">  99%: 17 μs</div><div class="line">  99.9%: 32 μs</div><div class="line">  99.99%: 74 μs</div><div class="line">  99.999%: 21695 μs</div><div class="line">  100%: 37381 μs</div><div class="line">  Longest 10 (μs): 27134 27154 27407 27440 27566 27928 28138 28899 33616 37381</div><div class="line"></div><div class="line">gc (274 <span class="built_in">times</span>, average: 8514.46 μs)</div><div class="line">  99%: 22780 μs</div><div class="line">  99.9%: 23612 μs</div><div class="line">  99.99%: 23612 μs</div><div class="line">  99.999%: 23612 μs</div><div class="line">  100%: 23612 μs</div><div class="line">  Longest 10 (μs): 21220 21384 21392 21516 21598 21634 21949 22233 22780 23612</div><div class="line"></div><div class="line">Buffer process memory: 35396 KB</div><div class="line">Total memory used: 330 MB</div></pre></td></tr></table></figure>
<p>这里有大量的数据，所以我将突出一些我发现的最有趣的数字。</p>
<p>我将从缓冲区操作的平均延迟开始。最近平均值这个概念得到一些坏名声，但我仍然觉得它们是有用的度量标准。观察到的平均延迟是6.9微秒，这告诉我，即使缓冲区完全满了，这个实现可以没有延迟地应付大约每秒145000次操作。如果我能容忍一些延迟的变化，而且也不期望更高的请求，那么 :queue 实现应该适合我的需求。</p>
<p>看一下延迟的分布，我们可以看到最大延迟大约37毫秒。这可能是不可接受的，又或者它可能是刚好合适的，这取决于特定的场景。武断地认为这个用 :queue 实现的缓冲区是糟糕的，或者断定它在所有场景下都是可行的，这两种看法都应该是错误的。如果我们知道手头上具体问题的规格和要求，我们就能解释这些数字。</p>
<p>如果你仔细观察push和pull操作的延迟分布，你可以看到在4个9和5个9之间延迟迅速增加，延迟从两位数的微秒区间过度到两位数的毫秒区间。在两百万操作里，意味着我们要经历小于200个延迟尖峰。同样，这是否可以被接受取决于特定问题的约束。</p>
<p>打印出来的GC状态只和缓冲区进程相关。我们可以看到274次GC发生在缓冲区进程里，而且有很高比例的延迟在两位数毫秒区间。不出所料，GC的次数和开始于4个9到5个9的延迟尖峰之间似乎有着很强的相关性。</p>
<p>最后，请注意缓冲区进程的堆大小为何是35MB。你可能期望它大约是200MB，因为缓冲区持有20万元素，每个元素是1024个字节。但是，在这个基准测试里，元素被叫做<a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#id67990" target="_blank" rel="external">引用计数二进制数据</a>，它的意思是它们被存储在单独的堆上。缓冲区进程只持有这些二进制数据的引用，而不是数据本身。</p>
<p>当然，缓冲区进程还是有20万引用在它自己的堆上，还和被删除的消息等任何垃圾一起，这些就是引起延迟尖峰的原因。因此如果我只看它和其他语言比较最坏的GC次数的话，Erlang就不够好，并且我可能错误地得到结论，它不适合这项工作。</p>
<h1 id="基于ETS的实现"><a href="#基于ETS的实现" class="headerlink" title="基于ETS的实现"></a>基于ETS的实现</h1><p>然而，我可以用ETS表来限制GC。ETS表有很多特色，但是本文我为了简单起见，只讲它们可以当做一个进程内的内存的键值存储来用。当涉及到语义，ETS表没有给表带来什么新的东西（没有双关语义）。你可以用普通的Erlang进程和数据结构来实现同样的功能。</p>
<p>然而，该表有几个有趣的特性，能使他们在某些情况下表现的很好。首先，ETS表的数据被存储在进程堆之外的独立内存空间里。因此，如果我们使用ETS表来存储数据，缓冲区进程就不再需要持有许多引用，这应该会减少它的GC次数。此外，ETS表里的数据在被删除后将立即被释放。这意味着我们可以完全避免在大集合数据上的GC。</p>
<p>我用ETS表来实现的缓冲区是根据Pusher的GO实现来做的。基本上，我用ETS表来模拟一个可变数组，存储 (index, value) 这样的键值对到表中。我维护着两个索引，一个决定我push下一个元素到哪个位置，另一个决定了我从哪个位置pull下一个元素。它们都是从零开始。然后，每次push存储一个(push_index, value)这样的键值对到表中，就将push的索引加一。如果push的索引达到缓冲区最大尺寸，它就被设置为零。同样地，当pull数据的时候，我根据 pull_index 键来读取值，并且增加pull索引的值。如果缓冲区已满，则pull操作将覆盖最老值并增加两个索引，从而确保下一个pull操作将从适当位置读取数据。全部实现代码在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/ets.ex" target="_blank" rel="external">这里</a>。</p>
<p>让我们看看它的性能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mix buffer.bench -m Buffer.Ets</div><div class="line"></div><div class="line">push/pull (2000000 <span class="built_in">times</span>, average: 6.53 μs)</div><div class="line">  99%: 27 μs</div><div class="line">  99.9%: 37 μs</div><div class="line">  99.99%: 50 μs</div><div class="line">  99.999%: 66 μs</div><div class="line">  100%: 308 μs</div><div class="line">  Longest 10 (μs): 76 80 83 86 86 96 106 186 233 308</div><div class="line"></div><div class="line">gc (97062 <span class="built_in">times</span>, average: 5.16 μs)</div><div class="line">  99%: 10 μs</div><div class="line">  99.9%: 20 μs</div><div class="line">  99.99%: 30 μs</div><div class="line">  99.999%: 44 μs</div><div class="line">  100%: 44 μs</div><div class="line">  Longest 10 (μs): 30 30 34 34 34 39 43 44 44 44</div><div class="line"></div><div class="line">Buffer process memory: 30 KB</div><div class="line">Total memory used: 312 MB</div></pre></td></tr></table></figure>
<p>6.53微秒的平均时间没有比用 :queue 模块实现的更好。不过，延迟尖峰现在小了很多。观测到的最长延迟是308微秒，同时，在5个9的区域，我们已经减到了两位数微秒区域。实际上，在两百万的操作里，只有4个操作的延迟时间大于100微秒。相当不错。:-)</p>
<p>充分披露：这个结果是我运行了几次测试中的最好一次结果。在我的机器上，最大延时有时候略大于1毫秒，而其他数字没有明显的变化。特别是，99.999%总是低于100微秒。</p>
<p>观察一下GC的状态，你可以看到缓冲区进程的GC次数大幅度增加。在用 :queue 模块的实现里，缓冲区进程触发了274次GC，但是这个实现里，我们观察到大约97000次GC。这是为什么呢？记住，缓冲区进程仍然在它自己的堆上管理着一些数据。其中包括了下一次push和pull操作的索引，以及对刚刚被push和pull的元素的临时引用。因此，大量请求到达缓冲区进程，它将产生大量垃圾。但是，给缓冲区的元素被存储在ETS表的单独堆上，缓冲区永远不会维护一个大的活跃的数据集。这与Pusher的结论相符。GC的延迟尖峰与产生的垃圾量无关，而是与活跃的工作数据集的数量有关。在这个实现里，我们减少工作的数据集，保持缓冲区进程的堆很小。因此，虽然我们将触发大量的GC，但是它们耗时都相当短。观察到的缓冲区进程的最长GC时间仅仅44微秒。</p>
<h1 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h1><p>因为Erlang的stop-the-process的GC特性，我们可能在一些进程里经历长时间停顿。但是我们有一些选项可以帮我们削减大的延迟尖峰。控制这些停顿的主要技巧就是保持进程的堆很小。一个大的活跃堆加上频繁的传入请求将对GC施加更多的压力，延迟将增加。</p>
<p>在这个特定的例子中，使用ETS帮我减少缓冲区进程的堆大小。虽然GC数量显著增加，但是GC停顿很短使得整体延迟稳定。虽然Erlang肯定不是最快的平台，但是它让我保持我的延迟是可预测的。我构建系统，调优它达到我想要的性能，并且我可以预测到在生产中较少的令人吃惊情况发生。</p>
<p>值得一提的另外两种技术可能会帮助您减少GC延迟尖峰。第一个是将管理一个大堆的进程分割成多个管理更小数据集的进程。这将导致碎片化的GC，并且可能削减GC延迟尖峰。</p>
<p>在某些情况下，你可以充分利用进程终止时立即释放进程内存的事实。如果你需要执行一个分配大量临时内存的一次性工作，你可以考虑使用<a href="https://hexdocs.pm/elixir/Process.html#spawn/2" target="_blank" rel="external">Process.spawn</a>，它允许你在启动进程时显式地预先分配一个大的堆给这个进程。这可能完全阻止GC在这个进程中发生。你做计算，输出结果，最后终止进程，因此它所有的内存被立即回收而从来没有被GC过。</p>
<p>最后，如果你不能在Erlang里使得你的系统的一些关键部分高效，那么你可以利用<a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/" target="_blank" rel="external">进程内的NIF的C编程</a>或者<a href="http://theerlangelist.com/article/outside_elixir" target="_blank" rel="external">进程外的端口机制</a>，而保持Erlang/Elixir作为你的系统的主平台和“控制面板”。许多选项都在桌面上，这给了我很大的信心，我将能够处理任何我遇到的挑战，无论它可能多么棘手。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://www.theerlangelist.com/article/reducing_maximum_latency" target="_blank" rel="external">http://www.theerlangelist.com/article/reducing_maximum_latency</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我在&lt;a href=&quot;https://pusher.com/&quot;&gt;Pusher&lt;/a&gt;的博客读到两篇很棒的文章：&lt;a href=&quot;https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/&quot;&gt;低延迟、大的工作集和GHC的垃圾收集器：三选二&lt;/a&gt; 和 &lt;a href=&quot;https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/&quot;&gt;Golang的实时GC的理论与实践&lt;/a&gt; 。这两篇文章讲的是Pusher的工程师如何重新实现他们的消息总线的故事。第一篇是发生在Haskell里。在性能测试期间，他们发现在99%那个范围内有一些高延迟。在他们分析代码后，他们能够证明这些延时的尖峰是由GHC的 stop-the-world 垃圾收集器，再加上一个大的工作集（内存中的对象的数目）所造成的。该开发团队随后尝试了GO，得到好得多的结果，这得益于GO的并发垃圾收集器。&lt;/p&gt;
&lt;p&gt;我强烈推荐这两篇文章。Pusher的测试是一个很棒的基准测试例子，因为它专注于解决一个真正的挑战，并且基于该项技术是否合适本工作来评估此技术。这是我喜欢的那种评估方式。我发现做一个简单的关键功能的实现非常有用，然后看看它在所需的负荷下的表现，而不是通过一些浅层的模拟基准测试来比较不同的技术，例如在环里传递令牌，或让一个Web服务器返回“200 OK”。这个方法应该能提供“我能用Y有效地解决X吗？”问题的答案。当我第一次评估Erlang的时候，我采用的就是这种方法。10 倍的预期负载模拟真实系统的12个小时测试让我相信这项技术比我所需要的绰绰有余。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/categories/Elixir/GC/"/>
    
      <category term="maximum latency" scheme="http://szpzs.oschina.io/categories/Elixir/GC/maximum-latency/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/tags/GC/"/>
    
      <category term="buffer" scheme="http://szpzs.oschina.io/tags/buffer/"/>
    
      <category term="maximum latency" scheme="http://szpzs.oschina.io/tags/maximum-latency/"/>
    
  </entry>
  
  <entry>
    <title>Elixir中的元编程－领域特定语言</title>
    <link href="http://szpzs.oschina.io/2017/02/27/elixir-getting-started-meta-domain-specific-languages/"/>
    <id>http://szpzs.oschina.io/2017/02/27/elixir-getting-started-meta-domain-specific-languages/</id>
    <published>2017-02-26T22:27:43.000Z</published>
    <updated>2017-02-28T08:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">前言</a></li>
<li><a href="#part-two">构建我们自己的测试用例</a></li>
<li><a href="#part-three">test宏</a></li>
<li><a href="#part-four">用属性存储信息</a></li>
</ol>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><span id="part-one">前言</span></h1><p>域特定语言 (DSL) 允许开发人员剪裁它们的应用到特定领域。你不需要为了有一个DSL而需要宏：在你的模块里定义的每个数据结构和每个函数是你的领域特定语言的一部分。</p>
<p>例如，假设我们想实现一个校验器模块，它提供一个数据校验领域特定语言。我们可以使用数据结构、函数或宏来实现它。让我们看看这些不同的DSL的样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 数据结构</span></div><div class="line">import Validator</div><div class="line">validate user, <span class="symbol">name:</span> [<span class="symbol">length:</span> <span class="number">1</span>..<span class="number">100</span>],</div><div class="line">               <span class="symbol">email:</span> [<span class="symbol">matches:</span> ~r/@/]</div><div class="line"></div><div class="line"><span class="comment"># 2. 函数</span></div><div class="line">import Validator</div><div class="line">user</div><div class="line">|&gt; validate_length(<span class="symbol">:name</span>, <span class="number">1</span>..<span class="number">100</span>)</div><div class="line">|&gt; validate_matches(<span class="symbol">:email</span>, ~r/@/)</div><div class="line"></div><div class="line"><span class="comment"># 3. 宏 + 模块</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyValidator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Validator</div><div class="line">  validate_length <span class="symbol">:name</span>, <span class="number">1</span>..<span class="number">100</span></div><div class="line">  validate_matches <span class="symbol">:email</span>, ~r/@/</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyValidator.validate(user)</div></pre></td></tr></table></figure>
<p>在上面所有的方法中，第一个绝对是最灵活的。如果我们的领域规则可以用数据结构进行编码，则它们是迄今为止最容易的撰写和实施，因为Elixir的标准库中充满了操纵不同数据类型的函数。</p>
<p>第二种方法使用函数调用，它更适合更复杂的API（例如，如果你需要传递很多选项）和Elixir里用管道运算符来更好地读。</p>
<p>第三种方法，使用宏，是迄今为止最复杂的。它将花更多行代码来实现，也难于测试（是和测试简单函数相比），它限制用户肯能如何使用库，因为所有校验需要被定义在一个模块里。</p>
<p>若要驱动该点，请假设只有在给定条件满足时才要验证某个属性。我们可以很容易地用第一种方案实现，通过操作相应结构的数据，或用第二种方案在调用函数之前用条件句（if/else）。但是，用宏的方法是不可能的，除非它的DSL被增强。</p>
<p>换句话说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data &gt; <span class="built_in">functions</span> &gt; macros</div></pre></td></tr></table></figure>
<p>也就是说，仍然有场景使用宏和模块来构建特定于域的语言。既然我们在入门指南已经探讨了数据结构和函数定义，那么本章将探讨如何使用宏和模块的属性来处理更复杂的DSL。</p>
<h1 id="构建我们自己的测试用例"><a href="#构建我们自己的测试用例" class="headerlink" title="构建我们自己的测试用例"></a><span id="part-two">构建我们自己的测试用例</span></h1><p>本章的目标是构建一个名为 TestCase 的模块，它允许我们按如下内容来写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> TestCase</div><div class="line"></div><div class="line">  test <span class="string">"arithmetic operations"</span> <span class="keyword">do</span></div><div class="line">    <span class="number">4</span> = <span class="number">2</span> + <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"list operations"</span> <span class="keyword">do</span></div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>] ++ [<span class="number">3</span>]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyTest.run</div></pre></td></tr></table></figure>
<p>在上面的例子里，通过使用 TestCase ，我们可以用 test 宏写测试用例，它定义了一个名为 run 的函数来为我们自动运行所有测试用例。我们的原型将依赖匹配运算符（=）作为一个种机制来做断言。</p>
<h1 id="test宏"><a href="#test宏" class="headerlink" title="test宏"></a><span id="part-three">test宏</span></h1><p>让我们从创建一个定义和导入test宏的模块开始：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">TestCase</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Callback invoked by `use`.</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># For now it returns a quoted expression that</span></div><div class="line">  <span class="comment"># imports the module itself into the user code.</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__using__</span></span>(_opts) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      import TestCase</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Defines a test case with the given description.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      test "arithmetic operations<span class="string">" do</span></div><div class="line">        4 = 2 + 2</div><div class="line">      end</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">test</span></span>(description, <span class="symbol">do:</span> block) <span class="keyword">do</span></div><div class="line">    function_name = String.to_atom(<span class="string">"test "</span> &lt;&gt; description)</div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(function_name)(), <span class="symbol">do:</span> unquote(block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>假设我们在文件 tests.exs 里定义了 TestCase ，我们可以通过运行 iex tests.exs 打开它，并且定义我们第一个测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="keyword">use</span> TestCase</div><div class="line">...&gt;</div><div class="line">...&gt;   test <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;     <span class="string">"hello"</span> = <span class="string">"world"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在我们没有一种机制来运行测试，但是我们知道一个名为 “test hello” 的函数被定义在后台。当我们调用它，它应该失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; MyTest.<span class="string">"test hello"</span>()</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"world"</span></div></pre></td></tr></table></figure>
<h1 id="用属性存储信息"><a href="#用属性存储信息" class="headerlink" title="用属性存储信息"></a><span id="part-four">用属性存储信息</span></h1><p>为了完成我们的 TestCase 实现，我们需要能够访问所有被定义的测试用例。在运行时通过 __MODULE__.__info__(:functions) 获取测试用例来做到这点，这个函数将返回给定模块的所有函数组成的列表。但是，考虑到我们可能想要存储除了每一个测试用例名字外更多的信息，一个更灵活的方法是我们需要的。</p>
<p>在前面章节讨论模块属性时，我们提到了如何将它们用作临时存储。这正是我们将在本节中使用的属性。</p>
<p>在 __using__/1 的实现里，我们将初始化名为 @tests 的模块属性为一个空列表，然后存储每一个定义好的测试用例的名字到这个属性里，所以测试用例可以在run函数里被调用。</p>
<p>下面是 TestCase 模块修改后的代码：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">TestCase</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__using__</span></span>(_opts) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      import TestCase</div><div class="line"></div><div class="line">      <span class="comment"># 初始化 @tests 为一个空列表</span></div><div class="line">      <span class="variable">@tests</span> []</div><div class="line"></div><div class="line">      <span class="comment"># 模块被编译前调用 TestCase.__before_compile__/1</span></div><div class="line">      <span class="variable">@before_compile</span> TestCase</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Defines a test case with the given description.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      test "arithmetic operations<span class="string">" do</span></div><div class="line">        4 = 2 + 2</div><div class="line">      end</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">test</span></span>(description, <span class="symbol">do:</span> block) <span class="keyword">do</span></div><div class="line">    function_name = String.to_atom(<span class="string">"test "</span> &lt;&gt; description)</div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="comment"># 插入新定义的测试到测试列表</span></div><div class="line">      <span class="variable">@tests</span> [unquote(function_name) | <span class="variable">@tests</span>]</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(function_name)(), <span class="symbol">do:</span> unquote(block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 这将在目标模块被编译前被立即调用</span></div><div class="line">  <span class="comment"># 给我们完美的机会注入'run/0'函数</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__before_compile__</span></span>(env) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span> <span class="keyword">do</span></div><div class="line">        Enum.each <span class="variable">@tests</span>, <span class="keyword">fn</span> name -&gt;</div><div class="line">          IO.puts <span class="string">"Running <span class="subst">#&#123;name&#125;</span>"</span></div><div class="line">          apply(__MODULE_<span class="number">_</span>, name, [])</div><div class="line">        <span class="keyword">end</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>启动一个新的IEx，我们现在可以定义我们的测试用例并运行它们：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="keyword">use</span> TestCase</div><div class="line">...&gt;</div><div class="line">...&gt;   test <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;     <span class="string">"hello"</span> = <span class="string">"world"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; MyTest.run</div><div class="line">Running test hello</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>虽然我们忽略了一些细节，但是这是在Elixir里创建领域特定模块的主要思想。宏允许我们返回在调用者中执行的引用表达式，然后我们可以通过模块属性来用它转换代码并存储相关信息到目标模块中。最后，像 @before_compile 这样的回调，当它的定义完成的时候，允许我们注入代码到模块里。</p>
<p>除了 @before_compile ，还有其他有用的模块属性，像 @on_definition 和 @after_compile ，你可以在 <a href="https://hexdocs.pm/elixir/Module.html" target="_blank" rel="external">Module 模块的文档</a>里读到跟多关于它们的内容。你也可以在 Macro module 和 Macro.Env 文档里找到关于宏和编译环境的有用信息。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/domain-specific-languages.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/domain-specific-languages.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;构建我们自己的测试用例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;test宏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;用属性存储信息&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/"/>
    
      <category term="domain-specific-language" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/domain-specific-language/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/tags/meta-programming/"/>
    
      <category term="domain-specific-language" scheme="http://szpzs.oschina.io/tags/domain-specific-language/"/>
    
  </entry>
  
  <entry>
    <title>Elixir中的元编程－宏</title>
    <link href="http://szpzs.oschina.io/2017/02/26/elixir-getting-started-meta-macros/"/>
    <id>http://szpzs.oschina.io/2017/02/26/elixir-getting-started-meta-macros/</id>
    <published>2017-02-25T23:08:59.000Z</published>
    <updated>2017-02-28T08:22:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">前言</a></li>
<li><a href="#part-two">我们第一个宏</a></li>
<li><a href="#part-three">宏的卫生</a></li>
<li><a href="#part-four">环境</a></li>
<li><a href="#part-five">私有宏</a></li>
<li><a href="#part-six">负责任地写宏</a></li>
</ol>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><span id="part-one">前言</span></h1><p>即使Elixir尽最大努力为宏提供一个安全的环境，但是用宏写干净的代码的主要责任落在开发者身上。宏比普通Elixir函数更难写，并且当它们不是必需的时候，使用它们被认为是一种坏的风格。所以要负责人地写宏。</p>
<p>Elixir已经通过使用它的数据结构和函数以一种简单和可读的方式提供了一种机制来写你每天的代码。宏只能作为最后的手段使用。记住，明确的优于暗示的。清晰代码优于简洁代码。</p>
<h1 id="我们第一个宏"><a href="#我们第一个宏" class="headerlink" title="我们第一个宏"></a><span id="part-two">我们第一个宏</span></h1><p>在Elixir里，宏通过 defmacro/2 定义。</p>
<blockquote>
<p>在本章，我们将使用文件来替代在IEx里运行代码样例。这是因为代码样例将跨多行而在IEx里输入它们将适得其反。你应该把代码样例保存在macros.exs文件里，用 elixir macros.exs 或 iex macros.exs 运行。</p>
</blockquote>
<p>为了更好地理解宏是如何工作的，让我们创建一个新模块分别用宏和函数来实现 unless ，也即 if 的相反功能：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Unless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun_unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">    if(!clause, <span class="symbol">do:</span> expression)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">macro_unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      if(!unquote(clause), <span class="symbol">do:</span> unquote(expression))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>函数接收入参然后传递给 if 。但是，如我们在<a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">前一章</a>所学，宏将接收引用表达式然后注入到引用，最后返回另一个引用表达式。</p>
<p>让我们用上面的模块来启动iex：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex macros.exs</div></pre></td></tr></table></figure>
<p>然后试一试那些定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; require Unless</div><div class="line">iex&gt; Unless.macro_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; Unless.fun_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div><div class="line"><span class="string">"this should never be printed"</span></div><div class="line"><span class="keyword">nil</span></div></pre></td></tr></table></figure>
<p>注意，在我们的宏实现了，句子没有被打印，而在我们的函数实现里，句子被打印了。那是因为传递给函数调用的入参在函数被调用前执行了。然而，宏不执行它们的入参。相反，它们接收入参作为引用表达式，然后转换为其他引用表达式。在本例子中，我们重写了 unless 宏，使得其实际上是一个 if 。</p>
<p>也就是说，当如下调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unless.macro_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div></pre></td></tr></table></figure>
<p>则我们的 macro_unless ，接收到如下所示内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macro_unless(<span class="keyword">true</span>, [<span class="symbol">do:</span> &#123;&#123;<span class="symbol">:</span>., [], [&#123;<span class="symbol">:__aliases__</span>, [<span class="symbol">alias:</span> <span class="keyword">false</span>], [<span class="symbol">:IO</span>]&#125;, <span class="symbol">:puts</span>]&#125;, [], [<span class="string">"this should never be printed"</span>]&#125;])</div></pre></td></tr></table></figure>
<p>然后它返回一个引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:if</span>, [],</div><div class="line"> [&#123;<span class="symbol">:</span>!, [], [<span class="keyword">true</span>]&#125;,</div><div class="line">  [<span class="symbol">do:</span> &#123;&#123;<span class="symbol">:</span>., [],</div><div class="line">     [&#123;<span class="symbol">:__aliases__</span>,</div><div class="line">       [], [<span class="symbol">:IO</span>]&#125;,</div><div class="line">      <span class="symbol">:puts</span>]&#125;, [], [<span class="string">"this should never be printed"</span>]&#125;]]&#125;</div></pre></td></tr></table></figure>
<p>我们可以用 Macro.expand_once/2 确认这个例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; expr = <span class="keyword">quote</span> <span class="symbol">do:</span> Unless.macro_unless(<span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span>)</div><div class="line">iex&gt; res  = Macro.expand_once(expr, __ENV_<span class="number">_</span>)</div><div class="line">iex&gt; IO.puts Macro.to_string(res)</div><div class="line">if(!<span class="keyword">true</span>) <span class="keyword">do</span></div><div class="line">  IO.puts(<span class="string">"this should never be printed"</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>Macro.expand_once/2 接收一个引用表达式然后依据当前环境扩展它。在本例子里，它扩展/调用 Unless.macro<em>unless/2 宏并且返回它的结果。我们然后继续转换返回的引用表达式为一个字符串并且打印它（我们将在这章后面讨论 \</em>_ENV__ ）。</p>
<p>这就是宏的所有内容。他们是关于接受引用表达式，并转化成其他东西。实际上，在Elixir里的 unless/2 就是用宏来实现的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defmacro</span> <span class="title">unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">  <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">    if(!unquote(clause), <span class="symbol">do:</span> unquote(expression))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>向 unless/2, defmacro/2, def/2, defprotocol/2 这样的结构，和在本教程中被使用的许多其他结构都是用纯Elixir实现的，经常是实现为一个宏。这意味着，用于构建语言的结构可以被开发人员用来将语言扩展到他们正在工作的领域。</p>
<p>我们可以定义一些函数和我们想要的宏，包括那些覆盖由Elixir提供的内置的定义。唯一的例外是Elixir的特殊形式，不用Elixir实现的，因此无法重写，<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary" target="_blank" rel="external">特殊形式的所有列表在Kernel.SpecialForms 里</a>。</p>
<h1 id="宏的卫生"><a href="#宏的卫生" class="headerlink" title="宏的卫生"></a><span id="part-three">宏的卫生</span></h1><p>Elixir宏有晚解决。它保证引用内定义的变量不会和宏展开的上下文里定义的变量冲突。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Hygiene</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">no_interference</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> a = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HygieneTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span></span> <span class="keyword">do</span></div><div class="line">    require Hygiene</div><div class="line">    a = <span class="number">13</span></div><div class="line">    Hygiene.no_interference</div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">HygieneTest.go</div><div class="line"><span class="comment"># =&gt; 13</span></div></pre></td></tr></table></figure>
<p>上述例子里，即使宏注入了 a = 1 ，它不会影响go函数里定义的变量 a。如果宏想明确地影响上下文，它可以用 var! ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Hygiene</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">interference</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> var!(a) = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HygieneTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span></span> <span class="keyword">do</span></div><div class="line">    require Hygiene</div><div class="line">    a = <span class="number">13</span></div><div class="line">    Hygiene.interference</div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">HygieneTest.go</div><div class="line"><span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>变量的卫生能运作只能是因为Elixir用上下文标注变量。例如，在一个模块的第三行定义的变量x将被表示成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:x</span>, [<span class="symbol">line:</span> <span class="number">3</span>], <span class="keyword">nil</span>&#125;</div></pre></td></tr></table></figure>
<p>但是，一个引用变量被表示成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">quoted</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Sample.quoted <span class="comment">#=&gt; &#123;:x, [line: 3], Sample&#125;</span></div></pre></td></tr></table></figure>
<p>注意，在引用变量里的第三个元素是原子 Sample ，而不是 nil ，这说明这个变量来自 Sample 模块。因此，Elixir认为这两个变量来自不同的模块和上下文，因此相应地分别处理它们。</p>
<p>Elixir为导入和别名也提供相似的机制。这保证了宏如它所在模块指定那样表现，而不会与它将被展开的所在模块发生冲突。Hygiene 可以在通过用像 var!/2 和 alias!/2 这样的宏特定的环境下被绕过，但是使用它们的时候必须要小心，因为它们直接修改用户环境。</p>
<p>有时候变量名字可以动态创建。在这种情况下，macro.var/2可以用来定义新的变量：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">initialize_to_char_count</span></span>(variables) <span class="keyword">do</span></div><div class="line">    Enum.map variables, <span class="keyword">fn</span>(name) -&gt;</div><div class="line">      var = Macro.var(name, <span class="keyword">nil</span>)</div><div class="line">      length = name |&gt; Atom.to_string |&gt; String.length</div><div class="line">      <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">        unquote(var) = unquote(length)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span> <span class="keyword">do</span></div><div class="line">    initialize_to_char_count [<span class="symbol">:red</span>, <span class="symbol">:green</span>, <span class="symbol">:yellow</span>]</div><div class="line">    [red, green, yellow]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">&gt; Sample.run <span class="comment">#=&gt; [3, 5, 6]</span></div></pre></td></tr></table></figure>
<p>注意 Macro.var/2 的第二个入参。这是正在使用的上下文，将决定在下一节描述的卫生。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><span id="part-four">环境</span></h1><p>在本章稍早前调用 Macro.expand<em>once/2 的时候，我们使用特别的形式 \</em>_ENV__。</p>
<p>__ENV__ 返回 Macro.Env 结构的一个实例，它含有有关编译环境的有用信息，包括当前模块、文件和行，所有在当前范围定义的变量，以及导入和需求等等：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; __ENV_<span class="number">_</span>.<span class="keyword">module</span></div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.file</div><div class="line"><span class="string">"iex"</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.requires</div><div class="line">[IEx.Helpers, Kernel, Kernel.Typespec]</div><div class="line">iex&gt; require Integer</div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.requires</div><div class="line">[IEx.Helpers, Integer, Kernel, Kernel.Typespec]</div></pre></td></tr></table></figure>
<p>Macro 模块里的许多函数期望有一个环境。你可以在 <a href="https://hexdocs.pm/elixir/Macro.html" target="_blank" rel="external">Macro 模块文档</a>里读到跟多有关这些函数的内容，也可以在 <a href="https://hexdocs.pm/elixir/Macro.Env.html" target="_blank" rel="external">Macro.Env 文档</a>里学到更多有关编译环境的知识。</p>
<h1 id="私有宏"><a href="#私有宏" class="headerlink" title="私有宏"></a><span id="part-five">私有宏</span></h1><p>Elixir用 defmacrop 也支持私有宏。像私有函数，这样的宏只能在定义它们的模块里有效，也只能在编译时有效。</p>
<p>宏在使用之前定义是很重要的。在调用之前不定义宏会在运行时引发错误，因为宏不会被扩展，将被转换为函数调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">...&gt;  <span class="function"><span class="keyword">def</span> <span class="title">four</span></span>, <span class="symbol">do:</span> two + two</div><div class="line">...&gt;  defmacrop two, <span class="symbol">do:</span> <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) <span class="symbol">iex:</span><span class="number">2</span>: function two/<span class="number">0</span> undefined</div></pre></td></tr></table></figure>
<h1 id="负责任地写宏"><a href="#负责任地写宏" class="headerlink" title="负责任地写宏"></a><span id="part-six">负责任地写宏</span></h1><p>宏是一个功能强大的结构并且Elixir提供了许多机制来确保他们被负责任地使用。</p>
<ul>
<li>宏是卫生的：默认情况下，宏中定义的变量不会影响用户代码。此外，函数调用和在宏观背景下可用的别名是不会泄漏到用户上下文。</li>
<li>宏是有词法范围的：在全局中注入代码或宏是不可能的。为了使用宏，你需要明确地需要或导入定义宏的模块。</li>
<li>宏是明确的：不明确调用宏是不可能运行宏的。例如，一些语言允许开发人员完全重写后台的功能，通常是通过解析变换或通过一些反射机制。在Elixir里，必须在编译时在调用者里明确地调用宏。</li>
<li>宏语言是清晰的：许多语言提供引用和非引用的语法快捷方式。在Elixir，为了清楚地划定一个宏的定义和引用表达式的界限，我们喜欢有明确的说明。</li>
</ul>
<p>即使有了这样的保证，开发者在负责编写宏时也扮演了重要角色。如果你有信心需要采用宏，请记住宏不是你的API。保持你的宏定义短，包括它们的引用内容。例如，不要像下面这样写宏：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyModule</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">my_macro</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      do_this(unquote(a))</div><div class="line">      ...</div><div class="line">      do_that(unquote(b))</div><div class="line">      ...</div><div class="line">      and_that(unquote(c))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>而是像下面这样写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyModule</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">my_macro</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="comment"># Keep what you need to do here to a minimum</span></div><div class="line">      <span class="comment"># and move everything else to a function</span></div><div class="line">      do_this_that_and_that(unquote(a), unquote(b), unquote(c))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">do_this_that_and_that</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    do_this(a)</div><div class="line">    ...</div><div class="line">    do_that(b)</div><div class="line">    ...</div><div class="line">    and_that(c)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这使你的代码更清晰，更容易测试和维，并且你可以直接调用和测试do_this_that_and_that / 3。它还有助于你为开发人员设计不想依赖宏的实际的API。</p>
<p>有了这些教程，我们完成了对宏的介绍。下一章讨论DSL，显示我们如何可以混合宏和模块属性来诠释和扩展模块和函数。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/macros.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/macros.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;我们第一个宏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;宏的卫生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;私有宏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;负责任地写宏&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/macro/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/tags/meta-programming/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Elixir中的元编程－Quote 和 Unquote</title>
    <link href="http://szpzs.oschina.io/2017/02/25/elixir-getting-started-meta-quote-and-unquote/"/>
    <id>http://szpzs.oschina.io/2017/02/25/elixir-getting-started-meta-quote-and-unquote/</id>
    <published>2017-02-25T08:20:29.000Z</published>
    <updated>2017-02-28T08:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Quoting</a></li>
<li><a href="#part-two">Unquoting</a></li>
<li><a href="#part-three">Escaping</a></li>
</ol>
<p>一个Elixir程序可以由Elixir自己的数据结构表示。在本章里，我们将学习那些数据结构看起来是什么样的，以及如何组成它们。在本章中学习的概念是宏的构建块，我们将在下一章中更深入地研究它。</p>
<a id="more"></a>
<h1 id="Quoting"><a href="#Quoting" class="headerlink" title="Quoting"></a><span id="part-one">Quoting</span></h1><p>一个Elixir程序的构建块上一个三元素的元组。例如，一个函数调用 sum(1, 2, 3) 被内部表示为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<p>你通过使用 quote 宏得到任何表达式的表示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<p>第一个元素是函数名，第二个元素是一个包含元数据的关键字列表，第三个元素是参数列表。</p>
<p>运算符也可以表示为这样的元组：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">1</span> + <span class="number">2</span></div><div class="line">&#123;<span class="symbol">:+</span>, [<span class="symbol">context:</span> Elixir, <span class="symbol">import:</span> Kernel], [<span class="number">1</span>, <span class="number">2</span>]&#125;</div></pre></td></tr></table></figure>
<p>甚至一个映射被表示为对 %{} 的调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> %&#123;<span class="number">1</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>变量也可以用这样的三元素的元组来表示，其最后一个元素不是一个列表而是一个原子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> x</div><div class="line">&#123;<span class="symbol">:x</span>, [], Elixir&#125;</div></pre></td></tr></table></figure>
<p>当引用更负责的表达式，我们可以看到代码用这样的元组来表示，这样的元组经常彼此嵌套为一个像一颗树的结构。许多语言叫这样的表示为抽象语法树（AST）。Elixir叫它们为被引用的表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, &#123;<span class="symbol">:+</span>, [<span class="symbol">context:</span> Elixir, <span class="symbol">import:</span> Kernel], [<span class="number">2</span>, <span class="number">3</span>]&#125;, <span class="number">4</span>]&#125;</div></pre></td></tr></table></figure>
<p>有时使用引用表达式时，返回代码的文本表示可能是有用的。这可以用 Macro.to_string/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span>, <span class="number">4</span>))</div><div class="line"><span class="string">"sum(1, 2 + 3, 4)"</span></div></pre></td></tr></table></figure>
<p>总的来说，以上元组按以下格式构造：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;atom | tuple, list, list | atom&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一个元素是一个原子或是相同表示格式的另一个元组。</li>
<li>第二个元素是一个包含元数据，比如数字和上下文，的关键字列表。</li>
<li>第三个元素是一个函数调用的参数列表或者一个原子。当这个元素是一个原子，则意味着这个元组表示一个变量。</li>
</ul>
<p>除了上述定义的元组，有五个Elixir字面量，当被引用的时候，返回的是它们自己（而不是一个元组）。它们是：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:sum</span>         <span class="comment">#=&gt; 原子</span></div><div class="line"><span class="number">1.0</span>          <span class="comment">#=&gt; 数字</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]       <span class="comment">#=&gt; 列表</span></div><div class="line"><span class="string">"strings"</span>    <span class="comment">#=&gt; 字符串</span></div><div class="line">&#123;key, value&#125; <span class="comment">#=&gt; 两个元素的元组</span></div></pre></td></tr></table></figure>
<p>大多数Elixir代码有一个它的底层引用表达式的直接翻译。我们建议你尝试不同的代码样例然后看看结果是怎么样的。例如，String.upcase(“foo”) 展开后是什么样子？我们也学到了 if(true, do: :this, else: :that) 和 if true do :this else :that end 是一样的。这个肯定是如何用引用表达式支持的？</p>
<h1 id="Unquoting"><a href="#Unquoting" class="headerlink" title="Unquoting"></a><span id="part-two">Unquoting</span></h1><p>quote是关于获取一些特指代码块的内部表示。但是，有时候可能必须注入一些其他特指代码块到我们想要获取的表示里。</p>
<p>例如，你有一个包含数字的变量number，你想要把它注入到一个引用表达式里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; number = <span class="number">13</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">11</span> + number)</div><div class="line"><span class="string">"11 + number"</span></div></pre></td></tr></table></figure>
<p>这不是我们想要的，因为number变量的值没有被注入并且number已经被引入表达式。为了注入number变量的值，unquote必须被使用在被引用的描述里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; number = <span class="number">13</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">11</span> + unquote(number))</div><div class="line"><span class="string">"11 + 13"</span></div></pre></td></tr></table></figure>
<p>unquote甚至可以被用于注入函数名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = <span class="symbol">:hello</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> unquote(fun)(<span class="symbol">:world</span>))</div><div class="line"><span class="string">"hello(:world)"</span></div></pre></td></tr></table></figure>
<p>在一些场景里，可能必须注入许多值在一个列表里。例如，假设你有一个列表 [1, 2, 6] 并且你想把 [3, 4, 5] 注入进去。使用 unquote 不会长生想要的结果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; inner = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> [<span class="number">1</span>, <span class="number">2</span>, unquote(inner), <span class="number">6</span>])</div><div class="line"><span class="string">"[1, 2, [3, 4, 5], 6]"</span></div></pre></td></tr></table></figure>
<p>这个时候就要使用 unquote_splicing ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; inner = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> [<span class="number">1</span>, <span class="number">2</span>, unquote_splicing(inner), <span class="number">6</span>])</div><div class="line"><span class="string">"[1, 2, 3, 4, 5, 6]"</span></div></pre></td></tr></table></figure>
<p>当使用宏的时候，Unquoting 非常有用。当写宏的时候，开发者能够接收代码块并且注入它们到其他代码块里，这能被用来转换代码或者写代码，在编译期间生成代码。</p>
<h1 id="Escaping"><a href="#Escaping" class="headerlink" title="Escaping"></a><span id="part-three">Escaping</span></h1><p>正如我们在本章开始的时候所见，在Elixir里只有一些值是有效引用表达式。例如，一个映射不是一个有效引用表达式。有四个元素的元组也不是。但是，这样的值可以被表达为一个引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> %&#123;<span class="number">1</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>在一些场景下，你可能需要注入这样的值到引用表达式里。为了这么做，我们需要首先用 Macro.escape/1 帮主来转义那些值为引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">hello:</span> <span class="symbol">:world</span>&#125;</div><div class="line">iex&gt; Macro.escape(map)</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [<span class="symbol">hello:</span> <span class="symbol">:world</span>]&#125;</div></pre></td></tr></table></figure>
<p>宏接收引用表达式并且必须返回引用表达式。然后，有些时候，在宏执行期间，你可能需要使用值并且使得值和将被需求的引用表达式之间有差别。</p>
<p>换句话说，使得一个普通Elixir值（像一个列表、一个映射、一个进程、一个引用等等）和一个引用表达式之间有差别是很重要的。一些值，比如，整数、原子和字符串，有一个引用表达式等于值的本身。其他值，像映射，需要被明确地转换。最后，像函数和引用这样的值完全不能被转换为引用表达式。</p>
<p>在 <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html" target="_blank" rel="external">Kernel.SpecialForms 模块</a>里，你可以阅读到跟多关于 quote 和 unquote 的内容。Macro.escape/1 和其他与引用表达式相关的函数的文档可以在 <a href="https://hexdocs.pm/elixir/Macro.html" target="_blank" rel="external">Macro 模块</a>里找到。</p>
<p>在这篇介绍文章里，我们已经为最终写我们的第一个宏奠定了基础，所以让我们开始下一章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/quote-and-unquote.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Quoting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Unquoting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Escaping&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个Elixir程序可以由Elixir自己的数据结构表示。在本章里，我们将学习那些数据结构看起来是什么样的，以及如何组成它们。在本章中学习的概念是宏的构建块，我们将在下一章中更深入地研究它。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/"/>
    
      <category term="quote unquote" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/quote-unquote/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/tags/meta-programming/"/>
    
      <category term="quote" scheme="http://szpzs.oschina.io/tags/quote/"/>
    
      <category term="unquote" scheme="http://szpzs.oschina.io/tags/unquote/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－分布式任务和配置</title>
    <link href="http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/"/>
    <id>http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/</id>
    <published>2017-02-24T04:23:14.000Z</published>
    <updated>2017-02-24T04:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个分布式代码</a></li>
<li><a href="#part-two">异步/等待</a></li>
<li><a href="#part-three">分布式任务</a></li>
<li><a href="#part-four">路由层</a></li>
<li><a href="#part-five">测试过滤器和标签</a></li>
<li><a href="#part-six">应用环境和配置</a></li>
<li><a href="#part-seven">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<a id="more"></a>
<p>在这最后一章，我们将回到 :kv 应用并增加一个路由层，这个路由层将允许我们基于bucket名字在节点间分布请求。</p>
<p>路由层将接收如下格式的一张路由表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line"> &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>路由器将根据表检查bucket名字的第一个字节然后据此来派发到合适的节点。例如，以字母“a”开头的一个bucket（?a表示字母“a”的Unicode代码点）将被派发到节点 foo@computer-name 。</p>
<p>如果匹配的条目指向处理请求的节点，那么我们就已经完成了路由，并且这个节点将执行请求的操作。如果匹配的条目指向一个不同的节点，我们将传递请求给这个节点，它将查询自己的路由表（可能与第一个节点的不同）并且做响应的动作。如果没有条目匹配，则一个错误将抛出。</p>
<p>你可能想知道为什么我们不告诉我们在我们的路由表找到的节点直接执行被请求的操作，而是传递路由请求给那个节点处理。尽管路由表和上面的那样简单，但在所有节点之间都可以合理地共享，这样当我们的应用程序增长时用这种方式传递路由请求使路由表变得更小。也许在某个时候，foo@computer-name 只是负责路由bucket的请求，而bucket被派发给不同的节点。用这种方式，bar@computer-name 不需要知道任何这些改变。</p>
<blockquote>
<p>注意：我们将在本章在同一个机器上使用两个节点。你可以自由地使用两台（或更多）不同的机器在同一网络，但你需要做一些准备工作。首先，你需要确认所有机器有一个有完全相同值的 ~/.erlang.cookie 文件。其次，你需要保证 <a href="http://www.erlang.org/doc/man/epmd.html" target="_blank" rel="external">epmd</a> 正运行在一个没有阻塞的端口（你可以运行 epmd -d 来输出调试信息）。最后，如果你想大体上学习更多分布式的知识，我们建议看 <a href="http://learnyousomeerlang.com/distribunomicon" target="_blank" rel="external">Learn You Some Erlang 里很棒的分布式章节</a>。</p>
</blockquote>
<h1 id="我们第一个分布式代码"><a href="#我们第一个分布式代码" class="headerlink" title="我们第一个分布式代码"></a><span id="part-one">我们第一个分布式代码</span></h1><p>Elixir自带了工具来链接节点以及在它们之间交换信息。实际上，当在一个分布式环境工作的时候，我们用进程、消息传递和接收消息相同的概念，因为Elixir进程是<em>位置透明的</em>。这就是说当发送一个消息的时候，不用关心接收进程是在同一个节点还是在另一个节点，虚拟机将能够在这两种情况下传递消息。</p>
<p>要运行分布式代码，我们需要用一个名字来启动虚拟机。名字可以是短的（当在同一个网络里）或长的（需要完整的计算机地址）。让我们启动一个新的IEx会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo</div></pre></td></tr></table></figure>
<p>你现在可以看到提示符有一点不同，显示了节点名字和计算机名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex(foo<span class="variable">@jv</span>)<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>
<p>我的机器名是 jv ，所以在上面的例子里我看到 foo@jv ，不过你将得到一个不同的结果。在后续的例子里我们将使用 foo@computer-name，当使用这些代码的时候，你应该相应地修改它们。</p>
<p>让我们在shell里定义一个叫Hello的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Hello</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">world</span></span>, <span class="symbol">do:</span> IO.puts <span class="string">"hello world"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你在同一个网络里的其他机器上已经装好了Erlang和Elixir，你可以在它上面启动另外一个IEx会话。否则，你可以在另一个终端启动另一个IEx会话。在这两种情况，给它一个短名叫做bar：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar</div></pre></td></tr></table></figure>
<p>注意，在这个新的IEx会话里，我们无法访问 Hello.world/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Hello.world</div><div class="line">** (UndefinedFunctionError) undefined <span class="symbol">function:</span> Hello.world/<span class="number">0</span></div><div class="line">    Hello.world()</div></pre></td></tr></table></figure>
<p>但是我们可以从 bar@computer-name 在 foo@computer-name 上创建一个新进程！让我们来试一试（@computer-name 是依据你自己的机器名字来写的）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt; Hello.world <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>Elixir在其他节点上启动一个进程并返回它的pid。代码在 Hello.world/0 函数所在的节点上被执行。注意：结果“hello world”打印在节点bar上而不是节点foo上。也就是说，被打印的消息从foo节点传回给bar节点。这是因为创建在其他节点（foo）上的进程仍然是有节点bar的组领导。我们已经简单地在<a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html#processes-and-group-leaders" target="_blank" rel="external">IO那一章</a>介绍了组领导的概念。</p>
<p>我们和往常一样可以与Node.spawn_link/2返回的pid进行消息的发送和接收操作。让我们尝试一个快速ping-pong例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   receive <span class="keyword">do</span></div><div class="line">...&gt;     &#123;<span class="symbol">:ping</span>, client&#125; -&gt; send client, <span class="symbol">:pong</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:ping</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:ping</span>, <span class="comment">#PID&lt;0.73.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:pong</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>从我们的快速探索，我们可以得出这样的结论：每一次我们需要做一个分布式计算的时候，我们应该用node.spawn_link/2在远程节点上创建进程。但是，我们已经从本教程学到，应该尽可能避免在监督树外创建进程，所以我们需要寻找其他方式。</p>
<p>有三种比 Node.spawn_link/2 更好的方式，我们在我们的实现里可以使用它们：</p>
<ol>
<li>我们可以使用Erlang的 <a href="http://www.erlang.org/doc/man/rpc.html" target="_blank" rel="external">:rpc模块</a>在远程节点上执行函数。在上面例子的bar@computer-name shell里，你可以调用 :rpc.call(:”foo@computer-name”, Hello, :world, []) ，它将打印“hello world”。</li>
<li>我们可以有一个运行在其他节点的服务，然后通过 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> API发送请求到那个节点。例如，你可以用 GenServer.call({name, node}, arg) 调用远程节点上的一个服务，或者传递远程进程的PID作为此函数的第一个入参。</li>
<li>我们可以使用我们在<a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">前一章</a>学到的<a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a>，因为它们可以在本地和远程节点被启动。</li>
</ol>
<p>上述三种选项有不同的特点。:rpc 和使用 GenServer 都是在一个单独服务器里顺序执行你的请求，而 Task 在远程节点上高效地异步运行，它唯一的顺序点是被监督者创建的时候。</p>
<p>对于我们的路由层，我们将使用Task，但是其他方式也可以去尝试。</p>
<h1 id="异步-等待"><a href="#异步-等待" class="headerlink" title="异步/等待"></a><span id="part-two">异步/等待</span></h1><p>到目前为止，我们已经探索了独立启动和运行的任务而不考虑它们的返回值。但是，有时候运行一个任务，然后在稍后读取它的值是有用的使用方式。为此，Task也提供了 async/await 模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task = Task.async(<span class="keyword">fn</span> -&gt; compute_something_expensive <span class="keyword">end</span>)</div><div class="line">res  = compute_something_else()</div><div class="line">res + Task.await(task)</div></pre></td></tr></table></figure>
<p>async/await 提供了一个种非常简单的机制并发地计算某些值。不仅如此，async/await 也可以被用于我们前面章节学到的 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 。我们只需要用 Task.Supervisor.async/2 替换 Task.Supervisor.start_child/2 然后稍后用 Task.await/2 读取结果。</p>
<h1 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a><span id="part-three">分布式任务</span></h1><p>分布式任务和被监督任务是一样的。唯一的区别是，我们在监督者上创建任务的时候传递的是节点名。打开 :kv 应用的 lib/kv/supervisor.ex 。让我们加入一个任务监督者作为监督树的最后一个孩子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KV.RouterTasks]]),</div></pre></td></tr></table></figure>
<p>现在，我们在 :kv 应用里启动两个命名的节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo -S mix</div><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>在 bar@computer-name 里，我们现在可以通过监督者在其他节点直接创建一个任务：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, node()&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.88.0&gt;, ref: #Reference&lt;0.0.0.400&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;</div></pre></td></tr></table></figure>
<p>我们的第一个分布式任务获取任务运行节点的名字。注意，我们给了一个匿名函数给 Task.Supervisor.async/2 ，但是， 在分布式场景里，最好是明确地指定模块、函数和函数的入参：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, Kernel, <span class="symbol">:node</span>, []</div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.89.0&gt;, ref: #Reference&lt;0.0.0.404&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line"><span class="symbol">:<span class="string">"foo@computer-name"</span></span></div></pre></td></tr></table></figure>
<p>这两者的区别是：匿名函数需要目标节点和调用者有一样的代码版本。使用模块、函数和函数入参更健壮，因为你只需要在给定的模块里找到匹配函数参数个数的函数。</p>
<p>有了这方面的知识，最后让我们来写路由代码。</p>
<h1 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a><span id="part-four">路由层</span></h1><p>创建一个有如下内容的文件 lib/kv/router.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Router <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Dispatch the given `mod`, `fun`, `args` request</div><div class="line">  to the appropriate node based on the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">route</span></span>(bucket, mod, fun, args) <span class="keyword">do</span></div><div class="line">    <span class="comment"># Get the first byte of the binary</span></div><div class="line">    first = <span class="symbol">:binary</span>.first(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># Try to find an entry in the table() or raise</span></div><div class="line">    entry =</div><div class="line">      Enum.find(table(), <span class="keyword">fn</span> &#123;enum, _node&#125; -&gt;</div><div class="line">        first <span class="keyword">in</span> enum</div><div class="line">      <span class="keyword">end</span>) || no_entry_error(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># If the entry node is the current node</span></div><div class="line">    if elem(entry, <span class="number">1</span>) == node() <span class="keyword">do</span></div><div class="line">      apply(mod, fun, args)</div><div class="line">    else</div><div class="line">      &#123;KV.RouterTasks, elem(entry, <span class="number">1</span>)&#125;</div><div class="line">      |&gt; Task.Supervisor.async(KV.Router, <span class="symbol">:route</span>, [bucket, mod, fun, args])</div><div class="line">      |&gt; Task.await()</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">no_entry_error</span></span>(bucket) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"could not find entry for <span class="subst">#&#123;inspect bucket&#125;</span> in table <span class="subst">#&#123;inspect table()&#125;</span>"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  The routing table.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># Replace computer-name with your local machine name.</span></div><div class="line">    [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">     &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>让我们写一个测试来验证我们的路由器是否正常。创建一个名为 test/kv/router_test.exs 文件，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RouterTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div><div class="line">    assert KV.Router.route(<span class="string">"hello"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"foo@computer-name"</span></span></div><div class="line">    assert KV.Router.route(<span class="string">"world"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"bar@computer-name"</span></span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"raises on unknown entries"</span> <span class="keyword">do</span></div><div class="line">    assert_raise RuntimeError, ~r/could <span class="keyword">not</span> find entry/, <span class="keyword">fn</span> -&gt;</div><div class="line">      KV.Router.route(&lt;&lt;<span class="number">0</span>&gt;&gt;, Kernel, <span class="symbol">:node</span>, [])</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个测试用例调用 Kernel.node/0 ，它将返回基于bucket的名字是 “hello” 和 “world”的当前节点的名字。根据我们目前的路由表，我们应该分别获得 foo@computer-name 和 bar@computer-name 作为响应。</p>
<p>第二个测试检查未知条目引起的代码异常。</p>
<p>为了运行第一个测试，我们需要两个节点来运行。来到 apps/kv 目录，启动一个名叫 bar 节点，它将被用来运行测试用例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>然后运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>测试将通过。</p>
<h1 id="测试过滤器和标签"><a href="#测试过滤器和标签" class="headerlink" title="测试过滤器和标签"></a><span id="part-five">测试过滤器和标签</span></h1><p>虽然我们的测试通过了，但是我们的测试结构变得越来越复杂。特别是，在我们的测试套件里只用 mix test 运行测试引起失败，因为我们的测试需要链接另一个节点。</p>
<p>幸运地，ExUnit有一个工具用来标签测试，允许我们运行指定的回调函数或者甚至完全基于那些标签过滤测试。我们已经在前面的章节里使用了 :capture_log 标签，它有被ExUnit指定的自己的语义。</p>
<p>这次让我们增加一个标签到 test/kv/router_test.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@tag</span> <span class="symbol">:distributed</span></div><div class="line">test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div></pre></td></tr></table></figure>
<p>写 @tag :distributed 等价于写 @tag distributed: true 。</p>
<p>测试被正确地标签，我们现在可以检查节点是否活在在网络里，如果没有节点没有在网络里活着，我们可以不考虑所有分布式测试。在 :kv 应用里打开 test/test_helper.exs ，然后加入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exclude =</div><div class="line">  if Node.alive?, <span class="symbol">do:</span> [], <span class="symbol">else:</span> [<span class="symbol">distributed:</span> <span class="keyword">true</span>]</div><div class="line"></div><div class="line">ExUnit.start(<span class="symbol">exclude:</span> exclude)</div></pre></td></tr></table></figure>
<p>现在用 mix test 运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div><div class="line">Excluding tags: [distributed: <span class="literal">true</span>]</div><div class="line"></div><div class="line">.......</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.1 seconds (0.1s on load, 0.01s on tests)</div><div class="line">7 tests, 0 failures, 1 skipped</div></pre></td></tr></table></figure>
<p>这一次所有测试都通过了并且ExUnit警告我们，分布式测试被忽略了。如果你用 $ elixir --sname foo -S mix test 运行测试，只要 bar@computer-name 这个节点可用，则刚才被忽略的那个测试将被运行并成功通过。</p>
<p>mix test 命令也允许我们动态包括和排除标签。例如，我们可以运行 $ mix test --include distributed 来运行分布式测试，而不管 test/test_helper.exs 里设置的值。我们也可以传递 --exclude 从命令行排除特定的标签。最后，--only 可以被用来运行只有特别标签的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case 模块文档</a>里阅读到更多的过滤器、标签和默认标签的内容。</p>
<h1 id="应用环境和配置"><a href="#应用环境和配置" class="headerlink" title="应用环境和配置"></a><span id="part-six">应用环境和配置</span></h1><p>目前我们硬编码路由表在 KV.Router 模块里。但是，我们想使得路由表是动态的。这不仅让我们配置开发/测试/生产环境，也允许不同节点在路由表里有不同内容。有一个OTP特性正好做这个事情：应用环境。</p>
<p>每一个应用有一个环境通过键来存储应用的特定配置。例如，我们可以存储路由表在 :kv 应用环境里，给它一个默认值，并且让其他应用在需要的时候修改这个表。</p>
<p>打开 apps/kv/mix.exs ，修改 application/0 函数返回如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">env:</span> [<span class="symbol">routing_table:</span> []],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们增加了一个新的键 :env 到应用里。它返回应用的默认环境，默认环境里有一个键为 :routing_table 的条目，其值为一个空的列表。应用程序环境与空表一起工作是有意义的，因为特定的路由表依赖于测试/部署结构。</p>
<p>为了在我们的代码里使用应用环境，我们需要用下面的内容来替换 KV.Router.table/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">The routing table.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">  Application.fetch_env!(<span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用 Application.fetch_env!/2 来读取 :kv 的环境的 :routing_table 条目。你可以在 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application 模块文档</a>里找到更多操作应用环境的信息和其他函数。</p>
<p>因为我们的路由表现在是空的，我们的分布式测试将会失败。重启应用并且重新运行测试来看它的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>应用环境有趣的是，它不仅被配置为当前应用，而是可以被配置为所有应用。这样的设置可以用 config/config.exs 文件来做到。例如，我们可以配置来修改IEx的默认提示符为其他值。只要打开 apps/kv/config/config.exs ，增加如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">config <span class="symbol">:iex</span>, <span class="symbol">default_prompt:</span> <span class="string">"&gt;&gt;&gt;"</span></div></pre></td></tr></table></figure>
<p>用 iex -S mix 启动IEx，你可以看到IEx的提示符已经改变。</p>
<p>这意味着，我们也可以在 apps/kv/config/config.exs 文件里直接配置我们的 :routing_table ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用你的本地节点替换 computer-name 。</span></div><div class="line">config <span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>,</div><div class="line">       [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">        &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>重启节点并再次运行分布式测试。现在它们应该全部通过。</p>
<p>从 Elixir v1.2 开始，所有伞型应用共享它们的配置，由于在伞型应用的根目录的 config/config.exs 文件里的如下一行，装载所有子应用的配置：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import_config <span class="string">"../apps/*/config/config.exs"</span></div></pre></td></tr></table></figure>
<p>mix run 命令也接收 --config 标签，允许配置文件按需提供。这个方法可以用来启动不同的节点，每个节点有它自己特定的配置（例如，不同的路由表）。</p>
<p>总体而言，内置配置应用的能力以及我们已经建立了我们的软件作为一个伞应用的事实，给我们在部署软件的时候提供了很多选择。</p>
<p>我们可以：</p>
<ul>
<li>部署伞型应用在一个节点将使得它既作为TCP服务器也作为键值存储。</li>
<li>部署 :kv_server 应用只作为TCP服务器只要路由表指向其他节点。</li>
<li>当我们想一个节点只作为一个存储（没有TCP访问）的时候，则只不是 :kv 应用。</li>
</ul>
<p>当我们在将来添加更多的应用程序时，我们可以继续使用粒度相同的级别来控制我们的部署，也可以继续选择用哪个配置给将要在生产上运行的应用。</p>
<p>我们也可以考虑用一个像<a href="https://github.com/bitwalker/distillery" target="_blank" rel="external">Distillery</a>的工具构建多发布版本，Distillery将打包被选择的应用和配置，包括当前安装的Erlang和Elixir安装，所以我们可以部署应用即使运行时没有预先在目标系统里被安装。</p>
<p>最后，我们在本章也学到一些新的东西，并且它也可以被应用到 :kv_server 。我们将留下一步作为一个练习：</p>
<ul>
<li>修改 :kv_server 应用从它的应用环境读取端口号而不是用硬编码值 4040 。</li>
<li>修改和配置 :kv_server 应用使用路由功能而不是直接派发给本地 KV.Registry 。为了 :kv_server 的测试，你可以使得路由表指向它自己的当前节点。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-seven">总结</span></h1><p>在本章，我们构建了一个简单的路由器作为一个方法来探索Elixir和Erlang虚拟机的分布式特性，也学会了如果配置它的路由表。这是我们的Mix和OTP教程的最后一章。</p>
<p>通过这个教程，我们已经构建一个简单的分布式键值存储当做一个机会来探索许多结构，像通用服务器、监督者、任务、agent、应用以及其他事物。不仅如此，我们为整个应用写了测试，熟悉 ExUnit ，并学习如何用 Mix 这个构建工具来完成很多任务。</p>
<p>如果你正在找用于生产的一个分布式键值存储，那么应该你一定去看看<a href="http://basho.com/riak/" target="_blank" rel="external">Riak</a>，它也运行在Erlang虚拟机里。在Riak里，bucket被复制，避免数据丢失；不是用路由表，它们而是使用 <a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="external">一致性哈希</a> 映射一个bucket到一个节点。当存储bucket的新的节点被加入到你的基础设施的时候，一致性哈希有助于减少需要被迁移的数据量。</p>
<p>这里有更多的课程可以学，希望目前为止你玩得开心！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个分布式代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;异步/等待&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;分布式任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;路由层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;测试过滤器和标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;应用环境和配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="distributed-task configuration" scheme="http://szpzs.oschina.io/categories/Elixir/distributed-task-configuration/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="distributed-task" scheme="http://szpzs.oschina.io/tags/distributed-task/"/>
    
      <category term="configuration" scheme="http://szpzs.oschina.io/tags/configuration/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Docs、tests 和 with</title>
    <link href="http://szpzs.oschina.io/2017/02/23/elixir-getting-started-mix-otp-docs-tests-and-with/"/>
    <id>http://szpzs.oschina.io/2017/02/23/elixir-getting-started-mix-otp-docs-tests-and-with/</id>
    <published>2017-02-22T21:23:46.000Z</published>
    <updated>2017-02-22T21:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Doctests</a></li>
<li><a href="#part-two">with</a></li>
<li><a href="#part-three">运行命令</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将实现代码来分析我们在第一章描述的命令：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk <span class="number">1</span></div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs <span class="number">3</span></div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line"><span class="number">1</span></div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>分析做完后，我们将修改我们的服务器来派发被分析的命令给我们前面已经构建的 :kv 应用。</p>
<a id="more"></a>
<h1 id="Doctests"><a href="#Doctests" class="headerlink" title="Doctests"></a><span id="part-one">Doctests</span></h1><p>在Elixir语言首页，我们提到，Elixir使得文档在语言里作为第一类公民。我们已经在本指南探索这个概念多次，这些探索都是通过 mix help 或在IEx控制台上输入 h Enum 或 h 其他模块 来做到的。</p>
<p>在本节，我们将用 doctests 实现分析功能，它让我们直接在注释文档里写测试用例。这帮助我们提供有精确样例代码的注释文档。</p>
<p>让我们在 lib/kv_server/command.ex 创建我们的命令分析器，并用 doctest 启动：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Command <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">  Parses the given `line` into a command.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      iex&gt; KVServer.Command.parse "CREATE shopping\r\n<span class="string">"</span></div><div class="line">      &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:not_implemented</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Doctest通过在注释文档字符串里的缩进四个空格在紧跟 iex&gt; 提示符来指定。如果一个命令跨多行，你可以使用 …&gt; 作为在IEx里。期望的结果在 iex&gt; 或 …&gt; 行的下一行，用一个新行或新的 iex&gt; 前缀作为结束。</p>
<p>也要注意：我们用 @doc ~S””” 开始注释文档字符串。~S 阻止 \r\n 被转换为回车和换行，直到它们在测试里被计算。</p>
<p>为了运行我们的doctest，我们创建一个文件：test/kv_server/command_test.exs ，并且在测试用例里调用 doctest KVServer.Command ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.CommandTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line">  doctest KVServer.Command</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>运行这个测试，doctest将失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> doc at KVServer.Command.parse/1 (1) (KVServer.CommandTest)</div><div class="line">   <span class="built_in">test</span>/kv_server/command_test.exs:3</div><div class="line">   Doctest failed</div><div class="line">   code: KVServer.Command.parse <span class="string">"CREATE shopping\r\n"</span> === &#123;:ok, &#123;:create, <span class="string">"shopping"</span>&#125;&#125;</div><div class="line">   lhs:  :not_implemented</div><div class="line">   stacktrace:</div><div class="line">     lib/kv_server/command.ex:11: KVServer.Command (module)</div></pre></td></tr></table></figure>
<p>不错！</p>
<p>现在让我们使得 doctest 通过。让我们来实现 parse/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> String.split(line) <span class="keyword">do</span></div><div class="line">    [<span class="string">"CREATE"</span>, bucket] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:create</span>, bucket&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的实现用空格分割一行字符串，然后把命令和一个列表匹配起来。使用 String.split/1 意味着我们的命令将是空格不敏感的。前导和尾随空格无关紧要了，词与词之间的连续的空格也无关紧要。让我们加入一些新的doctest，用其他命令来测试这个行为模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">Parses the given `line` into a command.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "CREATE shopping\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "CREATE  shopping  \r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "PUT shopping milk <span class="number">1</span>\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:put, "shopping<span class="string">", "</span>milk<span class="string">", "</span><span class="number">1</span><span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "GET shopping milk\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:get, "shopping<span class="string">", "</span>milk<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "DELETE shopping eggs\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:delete, "shopping<span class="string">", "</span>eggs<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">Unknown commands or commands with the wrong number of</div><div class="line">arguments return an error:</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "UNKNOWN shopping eggs\r\n<span class="string">"</span></div><div class="line">    &#123;:error, :unknown_command&#125;</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "GET shopping\r\n<span class="string">"</span></div><div class="line">    &#123;:error, :unknown_command&#125;</div><div class="line"></div><div class="line">"<span class="string">""</span></div></pre></td></tr></table></figure>
<p>有了doctest，轮到你来使得测试通过了！一旦你准备好了，你可以比较你的实现和我们下面的解决方案：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> String.split(line) <span class="keyword">do</span></div><div class="line">    [<span class="string">"CREATE"</span>, bucket] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:create</span>, bucket&#125;&#125;</div><div class="line">    [<span class="string">"GET"</span>, bucket, key] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:get</span>, bucket, key&#125;&#125;</div><div class="line">    [<span class="string">"PUT"</span>, bucket, key, value] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:put</span>, bucket, key, value&#125;&#125;</div><div class="line">    [<span class="string">"DELETE"</span>, bucket, key] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:delete</span>, bucket, key&#125;&#125;</div><div class="line">    <span class="number">_</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：我们是如何能够优雅地分析命令，而不需要用大量的 if/else 分支来检查命令名字和参数个数！</p>
<p>最后，你可能已经观察到每一个doctest被认为是我们测试用例里的不同测试，因为我们的测试套件报告一共有7个测试。这是因为ExUnit认为如下所示是定义两个不同测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.Command.parse <span class="string">"UNKNOWN shopping eggs\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line"></div><div class="line">iex&gt; KVServer.Command.parse <span class="string">"GET shopping\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div></pre></td></tr></table></figure>
<p>而如下所示，中间没有新行，则ExUnit则编译它为一个单独的测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.Command.parse <span class="string">"UNKNOWN shopping eggs\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line">iex&gt; KVServer.Command.parse <span class="string">"GET shopping\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.DocTest.html" target="_blank" rel="external">ExUnit.DocTest 文档</a>里阅读更多关于doctest的内容。</p>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a><span id="part-two">with</span></h1><p>因为我们现在能够分析命令，我们终于可以开始实现逻辑来运行命令。现在让我们为这个函数添加一个存根（stub）定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Command <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Runs the given command.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(command) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在我们实现这个函数之前，让我们修改我们的服务器开始使用我们新的 parse/1 和 run/1 函数。记住：当客户端关闭套接字的时候，我们的 read_line/1 函数也崩溃，所以我们也找个机会修复它。打开 lib/kv_server.ex ，其内容如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  socket</div><div class="line">  |&gt; read_line()</div><div class="line">  |&gt; write_line(socket)</div><div class="line"></div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">  data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用如下内容替换它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  msg =</div><div class="line">    <span class="keyword">case</span> read_line(socket) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, data&#125; -&gt;</div><div class="line">        <span class="keyword">case</span> KVServer.Command.parse(data) <span class="keyword">do</span></div><div class="line">          &#123;<span class="symbol">:ok</span>, command&#125; -&gt;</div><div class="line">            KVServer.Command.run(command)</div><div class="line">          &#123;<span class="symbol">:error</span>, <span class="number">_</span>&#125; = err -&gt;</div><div class="line">            err</div><div class="line">        <span class="keyword">end</span></div><div class="line">      &#123;<span class="symbol">:error</span>, <span class="number">_</span>&#125; = err -&gt;</div><div class="line">        err</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">  write_line(socket, msg)</div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:ok</span>, text&#125;) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, text)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 已知错误。写到客户端。</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"UNKNOWN COMMAND\r\n"</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(_socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:closed</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 链接关闭，友好地退出。</span></div><div class="line">  exit(<span class="symbol">:shutdown</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, error&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 未知错误。写到客户端并退出。</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"ERROR\r\n"</span>)</div><div class="line">  exit(error)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果我们启动我们的服务器，我们现在可以发送命令给它。现在我们将得到两种不同的响应：当命令是已知的，是“OK”；否则，是“UNKNOWN COMMAND”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line">HELLO</div><div class="line">UNKNOWN COMMAND</div></pre></td></tr></table></figure>
<p>这意味着我们的实现在正确的方向上进行，不过它看起来不是很优雅，是吗？</p>
<p>以前的实现使用管道，使逻辑直截了当地前进。然而，现在我们需要处理不同的错误代码在前进的道路上，我们的服务器逻辑嵌套在许多case调用里。</p>
<p>幸运地是，Elixir v1.2 引入 with 结构，它允许你简化像上面的代码，有一个匹配分支链来替换嵌套的call调用。让我们用with重写serve/1：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  msg =</div><div class="line">    with &#123;<span class="symbol">:ok</span>, data&#125; &lt;- read_line(socket),</div><div class="line">         &#123;<span class="symbol">:ok</span>, command&#125; &lt;- KVServer.Command.parse(data),</div><div class="line">         <span class="symbol">do:</span> KVServer.Command.run(command)</div><div class="line"></div><div class="line">  write_line(socket, msg)</div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>好多了！with将获取 &lt;- 右边返回的值与 &lt;- 左边的模式进行匹配。如果值匹配上模式，则with继续移动到下一个表达式。如果没有匹配，则返回非匹配值。</p>
<p>也就是说，我们转换每一个给予 case/2 的表达式作为 with 里的一步。只要任何一步的返回值不能匹配 {:ok, x} ，则with终止，并且返回非匹配值。</p>
<p>你可以在<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">我们的文档</a>里读到更多关于with的内容。</p>
<h1 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a><span id="part-three">运行命令</span></h1><p>最后一步是实现 KVServer.Command.run/1 ，来运行分析好的对应于 :kv 应用的命令。它的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Runs the given command.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(command)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:create</span>, bucket&#125;) <span class="keyword">do</span></div><div class="line">  KV.Registry.create(KV.Registry, bucket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:get</span>, bucket, key&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    value = KV.Bucket.get(pid, key)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"<span class="subst">#&#123;value&#125;</span>\r\nOK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:put</span>, bucket, key, value&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    KV.Bucket.put(pid, key, value)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:delete</span>, bucket, key&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    KV.Bucket.delete(pid, key)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">lookup</span></span>(bucket, callback) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> KV.Registry.lookup(KV.Registry, bucket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt; callback.(pid)</div><div class="line">    <span class="symbol">:error</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>每一个函数分支派发合适的命令到 KV.Registry 服务器，这个服务器我们在 :kv 应用启动的时候注册了。由于我们的 :kv_server 取决于 :kv 应用，它是完全可以依靠它提供的服务。</p>
<p>注意：我们也提供了一个名为 lookup/2 的私有函数，它帮助查找一个bucket，如果此bucket存在则返回其pid，否则，返回 {:error, :not_found} 。</p>
<p>顺便说一句，既然我们现在将返回 {:error, :not_found} ，我们就应该修改 KVServer里的 write_line/2 函数，让它也打印这样的错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"NOT FOUND\r\n"</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的服务器功能几乎完成了。这剩下测试没完成。这次，我们最后剩下测试因为有一些重要考虑要做。</p>
<p>KVServer.Command.run/1的实现是直接发送命令给被 :kv 应用注册的名为 KV.Registry 的服务器。这意味着这个服务器是全局的，如果我们有两个测试用例同时发送消息给它，我们的测试用例将彼此冲突（并且可能失败）。我们需要在隔离和可以异步运行的单元测试之间做出决定，或者编写在全局状态之上工作的集成测试，但是在应用程序中执行我们的应用程序的完整堆栈，因为它意味着要在生产中进行操作。</p>
<p>到目前为止，我们只编写了单元测试，通常直接测试单个模块。然而，为了使kvserver.command.run/1作为一个可测试单元，我们需要改变它的实现，不能直接将命令发送到 KV.Registry 进程而是通过传递一个服务器作为参数。例如，我们将修改 run 函数的签名为 def run(command, pid) ，然后响应地修改所有分支：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:create</span>, bucket&#125;, pid) <span class="keyword">do</span></div><div class="line">  KV.Registry.create(pid, bucket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># ... 其他 run 函数分支 ...</span></div></pre></td></tr></table></figure>
<p>去做上面的修改，写一些单元测试。目的是你的测试用例将启动一个 KV.Registry 实例并且把它作为参数传递给 run/2 而不是依赖全局 KV.Registry 。这有利于保持我们的测试异步，因为没有共享状态。</p>
<p>由于这是我们迄今为止在测试中所做的方法，我们将尝试一些不同的方法。让我们来写集成测试，它依赖全局服务器名来运用从TCP服务器到bucket的整个栈。我们的集成测试将依赖全局状态并且必须是同步的。通过集成测试，我们得到了覆盖在我们应用中组件如何一起工作的测试性能的成本。它们通常用于测试应用程序中的主要流程。例如，我们应该避免使用集成测试来测试在我们的命令解析实现的边缘情况。</p>
<p>我们的集成测试将用一个TCP客户端发送命令给我们的服务器，然后断言我们将得到想要的响应。</p>
<p>让我们在 test/kv_server_test.exs 里实现集成测试，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServerTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    Application.stop(<span class="symbol">:kv</span>)</div><div class="line">    <span class="symbol">:ok</span> = Application.start(<span class="symbol">:kv</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    opts = [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>]</div><div class="line">    &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.connect(<span class="string">'localhost'</span>, <span class="number">4040</span>, opts)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">socket:</span> socket&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"server interaction"</span>, %&#123;<span class="symbol">socket:</span> socket&#125; <span class="keyword">do</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"UNKNOWN shopping\r\n"</span>) ==</div><div class="line">           <span class="string">"UNKNOWN COMMAND\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) ==</div><div class="line">           <span class="string">"NOT FOUND\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"CREATE shopping\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"PUT shopping eggs 3\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    <span class="comment"># GET 返回两行</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) == <span class="string">"3\r\n"</span></div><div class="line">    assert send_and_recv(socket, <span class="string">""</span>) == <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"DELETE shopping eggs\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    <span class="comment"># GET 返回两行</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) == <span class="string">"\r\n"</span></div><div class="line">    assert send_and_recv(socket, <span class="string">""</span>) == <span class="string">"OK\r\n"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">send_and_recv</span></span>(socket, command) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.send(socket, command)</div><div class="line">    &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>, <span class="number">1000</span>)</div><div class="line">    data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的集成测试检查所有服务器交互，包括未知命令和not found错误。值得注意的是，因为有ETS表和被链接进程，没有必要关闭套接字。一旦测试进程退出，套接字自动关闭。</p>
<p>这次因为我们的测试依赖全局数据，所有我们没有给 ExUnit.Case 设置 async: true 。另外，为了保证我们的测试总是在一个干净的状态中，在每一个测试用例前我们停止然后启动 :kv 应用。实际上，停止 :kv 应用甚至在终端打印一条警告信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">18:12:10.698 [info] Application kv exited: :stopped</div></pre></td></tr></table></figure>
<p>为了避免在测试期间打印日志消息，ExUnit提供了一个方便的特性，叫做 :capture_log 。通过在每一个测试用例前设置 @tag :capture_log 或为整个测试设置 @moduletag :capture_log ，ExUnit 将捕获在测试运行的时候记录的任何日志。如果我们的测试失败，被捕获的日志将和ExUnit报告一起被打印出来。</p>
<p>在 use ExUnit.Case 和 setup 之间增加如下调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@moduletag</span> <span class="symbol">:capture_log</span></div></pre></td></tr></table></figure>
<p>如果测试崩溃，你将看到如下的报告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>) test server interaction (KVServerTest)</div><div class="line">   test/kv_server_test.<span class="symbol">exs:</span><span class="number">17</span></div><div class="line">   ** (RuntimeError) oops</div><div class="line">   <span class="symbol">stacktrace:</span></div><div class="line">     test/kv_server_test.<span class="symbol">exs:</span><span class="number">29</span></div><div class="line"></div><div class="line">   The following output was <span class="symbol">logged:</span></div><div class="line"></div><div class="line">   <span class="number">13</span><span class="symbol">:</span><span class="number">44</span><span class="symbol">:</span><span class="number">10.035</span> [info]  Application kv <span class="symbol">exited:</span> <span class="symbol">:stopped</span></div></pre></td></tr></table></figure>
<p>通过这个简单的集成测试，我们开始明白为什么集成测试可能是缓慢的。 这个集成测试不仅不能异步运行，它还需要停止和启动 :kv 应用这样的耗时步骤。</p>
<p>最后，由你和你的团队为你们的应用制定出最好的测试策略。你需要平衡代码质量、信心和测试套件运行时。例如，我们可能一开始只有集成测试服务器的测试，但是如果服务器继续在将来的版本中成长，或它成为频繁的错误应用的一部分，重要的是要考虑分解集成测试，写更多的单元测试，无须集成测试这么重。</p>
<p>在下一章，我们通过增加一个bucket路由机制最终使得我们的系统成为分布式。我们也将学习应用配置。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Doctests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;with&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;运行命令&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将实现代码来分析我们在第一章描述的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;分析做完后，我们将修改我们的服务器来派发被分析的命令给我们前面已经构建的 :kv 应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Docstest with" scheme="http://szpzs.oschina.io/categories/Elixir/Docstest-with/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Docstest" scheme="http://szpzs.oschina.io/tags/Docstest/"/>
    
      <category term="with" scheme="http://szpzs.oschina.io/tags/with/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Task和gen_tcp</title>
    <link href="http://szpzs.oschina.io/2017/02/22/elixir-getting-started-mix-otp-task-and-gen-tcp/"/>
    <id>http://szpzs.oschina.io/2017/02/22/elixir-getting-started-mix-otp-task-and-gen-tcp/</id>
    <published>2017-02-21T23:02:22.000Z</published>
    <updated>2017-02-21T23:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Echo服务器</a></li>
<li><a href="#part-two">Tasks</a></li>
<li><a href="#part-three">Tasks监督者</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将学习如何使用<a href="http://www.erlang.org/doc/man/gen_tcp.html" target="_blank" rel="external">Erlang的 :gen_tcp 模块</a>来处理请求。这提供一个很好的机会来探索Elixir的Task模块。在将来的章节我们将扩展我们的服务器以便使得它可以真正地处理命令。</p>
<a id="more"></a>
<h1 id="Echo服务器"><a href="#Echo服务器" class="headerlink" title="Echo服务器"></a><span id="part-one">Echo服务器</span></h1><p>我们将首先实现一个echo服务器来开始我们的TCP服务器。它将发送一个响应，响应内容是它接收到的请求的文本。我们将慢慢地改善我们的服务器，一直到它被监督并且准备好处理多链接。</p>
<p>从广义的角度来看，在一个 TCP 服务器执行以下步骤︰</p>
<ol>
<li>侦听一个端口，直到端口可用，并获取套接字</li>
<li>在那个端口等待客户端链接并接受它</li>
<li>读取客户端的请求并写响应回去</li>
</ol>
<p>让我们来实现这些步骤。来到 apps/kv_server 应用，打开 lib/kv_server.ex ，然后增加如下的函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">require Logger</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(port) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 下面的选项的意思：</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># 1. `:binary` - 以二进制数据方式接收数据（而不是列表）</span></div><div class="line">  <span class="comment"># 2. `packet: :line` - 一行行地接收数据</span></div><div class="line">  <span class="comment"># 3. `active: false` - 阻塞在 `:gen_tcp.recv/2` 一直到有数据可用</span></div><div class="line">  <span class="comment"># 4. `reuseaddr: true` - 如果侦听者崩溃，允许我们重用地址</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.listen(port,</div><div class="line">                    [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>, <span class="symbol">reuseaddr:</span> <span class="keyword">true</span>])</div><div class="line">  Logger.info <span class="string">"Accepting connections on port <span class="subst">#&#123;port&#125;</span>"</span></div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  serve(client)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  socket</div><div class="line">  |&gt; read_line()</div><div class="line">  |&gt; write_line(socket)</div><div class="line"></div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">  data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将通过调用 KVServer.accept(4040) 来启动我们的服务器，4040是一个端口。accept/1 里的第一步是侦听一个端口一直到套接字可用，接着调用 loop_acceptor/1 。loop_acceptor/1 是一个接收客户端链接的循环。对于每一个接收到的链接，我们调用 serve/1 。</p>
<p>serve/1 是另一个循环，它从套接字读取一行数据然后把这些数据写回给套接字。注意：serve/1 函数用了 <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" target="_blank" rel="external">管道运算符 |&gt;</a> 来表达操作的数据流。管道运算符计算其左边的表达式并将其结果作为第一个入参传递给其右边的函数。上述例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket |&gt; read_line() |&gt; write_line(socket)</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">write_line(read_line(socket), socket)</div></pre></td></tr></table></figure>
<p>read_line/1 用 :gen_tcp.recv/2 实现从套接字接收数据，而write_line/2 用 :gen_tcp.send/2 写数据到套接字。</p>
<p>注意：serve/1 在 loop_acceptor/1 里被顺序地无限循环地调用，所以对 loop_acceptor/1 的尾调用永远不会到达，因此应该被避免。但是，正如我们将看到的，我们将需要在一个隔离的进程里执行 serve/1 ，所以我们很快就需要这样的尾调用。</p>
<p>这几乎是实现我们echo服务器所有需要的内容。让我们来试一下！</p>
<p>在 kv_server 应用里用 iex -S mix 启动一个IEx会话。在IEx里运行：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.accept(<span class="number">4040</span>)</div></pre></td></tr></table></figure>
<p>服务器现在正在运行，你甚至会注意到控制台被阻塞。让我们用<a href="https://en.wikipedia.org/wiki/Telnet" target="_blank" rel="external">一个telnet客户端</a>来访问我们的服务器。大多数操作系统上都有客户端，它们的命令行大致相同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">hello</div><div class="line">hello</div><div class="line">is it me</div><div class="line">is it me</div><div class="line">you are looking <span class="keyword">for</span>?</div><div class="line">you are looking <span class="keyword">for</span>?</div></pre></td></tr></table></figure>
<p>输入“hello”，按下回车键，你将得到回复的“hello”。完美！</p>
<p>我的特别的telnet客户端可以通过输入 ctrl + ] ，接着输入 quit ，再按下回车键 来退出，但是你的客户端可能需要不同的步骤。</p>
<p>一旦你退出了telnet客户端，你将可能在IEx会话里看到一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> &#123;<span class="symbol">:error</span>, <span class="symbol">:closed</span>&#125;</div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">45</span>: KVServer.read_line/<span class="number">1</span></div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">37</span>: KVServer.serve/<span class="number">1</span></div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">30</span>: KVServer.loop_acceptor/<span class="number">1</span></div></pre></td></tr></table></figure>
<p>这是因为我们期望从 :gen_tcp.recv/2 获得数据，但是客户端关闭了链接。在我们服务器将来的修订版里我们需要更好地处理这样的情况。</p>
<p>现在我们有一个更重要的bug需要去修复：如果我们的TCP接收者崩溃会发生什么？因为没有监督，服务器死掉而我们将不能服务更多请求，因为服务器不能被重启。这就是为什么我们必须把我们的服务器移到一颗监督树里的原因。</p>
<h1 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a><span id="part-two">Tasks</span></h1><p>我们已经学习了agent，通用服务器和监督者。它们都可以处理多消息或者管理状态。当我们只是需要执行一些任务的时候我们用哪个而它又是什么？</p>
<p><a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task模块</a>提供了这个功能。例如，它有一个 start_link/3 函数，此函数接收一个模块、函数和函数的参数作为入参，让我们运行一个给定的函数作为一个监督树的一部分。</p>
<p>让我们试试它。打开 lib/kv_server/application.ex ，让我们修改 start/2 函数里的监督者，修改如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">  import Supervisor.Spec</div><div class="line"></div><div class="line">  children = [</div><div class="line">    worker(Task, [KVServer, <span class="symbol">:accept</span>, [<span class="number">4040</span>]])</div><div class="line">  ]</div><div class="line"></div><div class="line">  opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">  Supervisor.start_link(children, opts)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>经过这个修改，我们说我们想运行 KVServer.accept(4040) 作为一个工作者。现在我们硬编码端口号，不过稍后我们将讨论修改这种方式。</p>
<p>现在服务器是监督树的一部分，当我们启动应用的时候它将自动启动。在终端里输入 mix run –no-halt ，然后再次使用 telnet 客户端来确认所有事情都依然运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">say you</div><div class="line">say you</div><div class="line">say me</div><div class="line">say me</div></pre></td></tr></table></figure>
<p>对的，它运行着！如果你杀掉客户端，整个服务器也崩溃。但是你将看到另一个服务器马上起来。但是，它的扩展性如何？</p>
<p>尝试同时链接两个telnet客户端。当你这么做的时候，你将注意到第二个客户端没有回声消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">hello</div><div class="line">hello?</div><div class="line">HELLOOOOOO?</div></pre></td></tr></table></figure>
<p>它好像没有完全正确运行。这是因为我们在接收链接的进程里处理请求。当一个客户端被链接了，我们就不能再接收另一个客户端。</p>
<h1 id="Tasks监督者"><a href="#Tasks监督者" class="headerlink" title="Tasks监督者"></a><span id="part-three">Tasks监督者</span></h1><p>为了使得我们的服务器处理同时发生的链接，我们需要有一个作为接收者的进程创建其他进程来处理请求。一个解决方案是将如下所示内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  serve(client)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>改为用 Task.start_link/1 ，它和 Task.start_link/3  相似，不过它接收一个匿名函数而不是模块、函数和函数的参数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  Task.start_link(<span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们从接收者进程直接启动一个被链接的任务。但是我们已经犯了一次错。你还记得吗？</p>
<p>这个错与当我们从registry直接调用 KV.Bucket.start_link/0 造成的错误相似。这意味着在任何一个bucket的错误将把整个registry搞垮。</p>
<p>上面的代码有同样的瑕疵：如果我们链接 serve(client) 这个任务到接收者，当它处理请求的时候崩溃，则会导致接收者乃至其他所有链接崩溃。</p>
<p>我们通过用 :simple_one_for_one 这种监督者来为registry修复这个问题。我们将使用相同的策略，除了这个模式是如此常见，Task已经有一个解决方案：一个 :simple_one_for_one 监督者启动临时任务作为我们的监督树的一部分。</p>
<p>让我们再次修改 start/2 ，增加一个监督者到我们的监督树：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">  import Supervisor.Spec</div><div class="line"></div><div class="line">  children = [</div><div class="line">    supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KVServer.TaskSupervisor]]),</div><div class="line">    worker(Task, [KVServer, <span class="symbol">:accept</span>, [<span class="number">4040</span>]])</div><div class="line">  ]</div><div class="line"></div><div class="line">  opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">  Supervisor.start_link(children, opts)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们现在将用 KVServer.TaskSupervisor 这个名字启动一个 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 进程。记住：因为接收者任务依赖这个监督者，因此这个监督者必须先启动。</p>
<p>现在我们需要修改 loop_acceptor/1 使用 Task.Supervisor 来处理每一个请求：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, pid&#125; = Task.Supervisor.start_child(KVServer.TaskSupervisor, <span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">  <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.controlling_process(client, pid)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你可能注意到我们增加了一行，:ok = :gen_tcp.controlling_process(client, pid) 。这使得子进程成为 client 这个套接字进程的“控制进程”。如果我们不这么做，如果接收者崩溃，它将把所有客户端都搞崩溃，因为套接字被绑定到接收它们的进程（这是默认的行为）。</p>
<p>用 mix run –no-halt 启动一个新的服务器，然后我们现在可以打开许多并发的telnet客户端。你也将注意到，退出一个客户端，不会把接收者搞崩溃。非常好！</p>
<p>下面是整个echo服务器的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span> <span class="keyword">do</span></div><div class="line">  require Logger</div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts accepting connections on the given `port`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(port) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.listen(port,</div><div class="line">                      [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>, <span class="symbol">reuseaddr:</span> <span class="keyword">true</span>])</div><div class="line">    Logger.info <span class="string">"Accepting connections on port <span class="subst">#&#123;port&#125;</span>"</span></div><div class="line">    loop_acceptor(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = Task.Supervisor.start_child(KVServer.TaskSupervisor, <span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.controlling_process(client, pid)</div><div class="line">    loop_acceptor(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">    socket</div><div class="line">    |&gt; read_line()</div><div class="line">    |&gt; write_line(socket)</div><div class="line"></div><div class="line">    serve(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">    data</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们已经修改了监督者规格说明，我们要问：我们的监督策略还正确吗？</p>
<p>在现在的情况下，答案是：正确。如果接收者崩溃，无需崩溃已经存在的链接。在另一方面，如果任务监督者崩溃，也不需要崩溃接收者。</p>
<p>在下一章，我们将开始分析客户端请求和发送响应，并结束我们的服务器。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Echo服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Tasks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Tasks监督者&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将学习如何使用&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang的 :gen_tcp 模块&lt;/a&gt;来处理请求。这提供一个很好的机会来探索Elixir的Task模块。在将来的章节我们将扩展我们的服务器以便使得它可以真正地处理命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Task gen_tcp" scheme="http://szpzs.oschina.io/categories/Elixir/Task-gen-tcp/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="gen_tcp" scheme="http://szpzs.oschina.io/tags/gen-tcp/"/>
    
      <category term="Task" scheme="http://szpzs.oschina.io/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－依赖和伞型项目</title>
    <link href="http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/"/>
    <id>http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/</id>
    <published>2017-02-20T22:25:27.000Z</published>
    <updated>2017-02-20T22:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">外部依赖</a></li>
<li><a href="#part-two">内部依赖</a></li>
<li><a href="#part-three">伞型项目</a></li>
<li><a href="#part-four">伞型项目里的依赖</a></li>
<li><a href="#part-five">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将讨论用Mix如何管理依赖。</p>
<p>我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。</p>
<p>构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。</p>
<a id="more"></a>
<h1 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a><span id="part-one">外部依赖</span></h1><p>外包依赖是没有绑定到你的业务领域的。例如，如果你需要为你的分布式 kv 应用提供HTTP API，你可以用 <a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a> 项目作为一个外包依赖。</p>
<p>安装外部依赖是简单的。最常见的，我们通过在我们的mix.exs文件里的deps函数内列出依赖来使用 <a href="https://hex.pm/" target="_blank" rel="external">Hex包管理器</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="string">"~&gt; 1.0"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个依赖指向已经发布到Hex的Plug的1.x.x版本系列的最新版本。这由版本号数字前的 ~&gt; 符号表示。有关指定版本要求的更多信息，请参见<a href="https://hexdocs.pm/elixir/Version.html" target="_blank" rel="external">版本模块的文档</a>。</p>
<p>通常，稳定版本被发布到Hex。如果你想依赖一个还处于开发中的外部依赖，Mix也能够管理git依赖：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="symbol">git:</span> <span class="string">"git://github.com/elixir-lang/plug.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你将注意到，当你增加一个依赖到你的项目，Mix生成一个mix.lock文件来保证<em>可重复构建</em>。这个lock文件必需被提交到你的版本控制系统，以便保证所有使用这个项目的人将使用和你一样的依赖版本。</p>
<p>Mix提供很多任务来处理依赖，这些任务可以用 mix help 来列出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">help</span></div><div class="line">mix deps              <span class="comment"># 列出依赖和它们的状态</span></div><div class="line">mix deps.clean        <span class="comment"># 删除给定的依赖文件</span></div><div class="line">mix deps.compile      <span class="comment"># 编译依赖</span></div><div class="line">mix deps.get          <span class="comment"># 获取所有过时的依赖</span></div><div class="line">mix deps.tree         <span class="comment"># 打印依赖树</span></div><div class="line">mix deps.unlock       <span class="comment"># 解锁给定的依赖</span></div><div class="line">mix deps.update       <span class="comment"># 更新给定的依赖</span></div></pre></td></tr></table></figure>
<p>最常用的任务是 mix deps.get 和 mix deps.update 。一旦被获取到，依赖被自动编译。你可以通过输入 mix help deps 和在 <a href="https://hexdocs.pm/mix/Mix.Tasks.Deps.html" target="_blank" rel="external">Mix.Tasks.Deps 模块文档</a>里读到更多关于依赖的内容。</p>
<h1 id="内部依赖"><a href="#内部依赖" class="headerlink" title="内部依赖"></a><span id="part-two">内部依赖</span></h1><p>内部依赖项是特定于你的项目的依赖。它们通常在你的项目/公司/组织范围之外是没有意义的。大多数时候，你想让他们私有化，无论是由于技术，经济或商业原因。</p>
<p>如果你有一个内部依赖，Mix支持两种方法与它一起工作：git仓库和伞型项目。</p>
<p>例如，如果你推送 kv 应用到一个git仓库，你将需要在你的依赖代码里列出它以便使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">git:</span> <span class="string">"https://github.com/YOUR_ACCOUNT/kv.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果仓库是私有的，您可能需要指定私有URL git@github.com:YOUR_ACCOUNT/kv.git 。在任何情况下，Mix将能够把它拿来给你，只要你有适当的凭据。</p>
<p>在Elixir里不鼓励使用git依赖作为内部依赖。记住：运行时和Elixir生态已经提供了应用这个概念。因此，我们希望你经常将你的代码分解成可以被逻辑地组织的应用，即使在单个项目中也是如此。</p>
<p>然而，如果你把每个应用作为一个独立的项目放入一个git仓库，那么你的项目可能非常难以维护，因为你将花费大量时间来管理那些git仓库而不是写你代码。</p>
<p>因为这个原因，Mix支持“伞型项目”。伞型项目允许你创建一个项目，它拥有许多项目，而且保持它们在一个单独源码仓库里。这正是下一节我们将要探索的风格。</p>
<p>让我们创建一个新的Mix项目。我们将创造性地命名它为 kv_umbrella ，这个新项目里面将拥有已经存在的 kv 应用和新的 kv_server 应用。目录结构将如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>关于这个方法令人感兴趣的事情是，Mix有许多遍历措施来处理这样的项目，诸如用一个命令将apps里的所有应用都编译和测试的能力。但是，尽管它们都在apps目录里，它们依然是彼此解耦的，所以，如果你想的话，你就可以独立地构建、测试和部署每一个应用。</p>
<p>所以让我们开始吧！</p>
<h1 id="伞型项目"><a href="#伞型项目" class="headerlink" title="伞型项目"></a><span id="part-three">伞型项目</span></h1><p>让我们用 mix new 开始一个新项目。这个新项目将被命名为 kv_umbrella ，并且在创建它的时候，我们需要传递 --umbrella 参数。不要在已经存在的 kv 项目里创建这个新项目！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix new kv_umbrella --umbrella</div><div class="line">* creating .gitignore</div><div class="line">* creating README.md</div><div class="line">* creating mix.exs</div><div class="line">* creating apps</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div></pre></td></tr></table></figure>
<p>从打印出来的信息我们可以看到生成的文件少了很多。生成的mix.exs文件也不同。让我们看一看这个文件（注释已经被删除）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KvUmbrella</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">apps_path:</span> <span class="string">"apps"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>使得这个项目与前面的项目不同的是在项目定义里有一个 apps_path: “apps” 条目。它的意思是这个项目将表现得像一把伞。这样的项目既没有源码文件也没有测试用例，但是它们可以有它们自己的依赖。每一个子应用必须定义在apps目录里。</p>
<p>让我们进入apps目录里开始构建 kv_server 。这一次，我们将传递 --sup 标志，它将告诉Mix自动为我们生成一颗监督树，替代在前面章节里如我们所做的手工构建监督树：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv_umbrella/apps</div><div class="line">$ mix new kv_server --module KVServer --sup</div></pre></td></tr></table></figure>
<p>生成的文件与我们第一次为 kv 所生成的相似，有一些不同。让我们打开 mix.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv_server</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line">     <span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line">     <span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line">     <span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.4"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">     <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>首先，因为我们在kv_umbrella/apps里创建这个项目，Mix自动监测到伞型结构并且增加四行到项目定义里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>这些选项的意思是，所有选项将被放置到 kv_umbrella/deps ，并且它们将共享同样的构建、配置和锁文件。这确保为整个伞型结构，依赖将被获取并被编译一次，而不是每一个伞型应用一次。</p>
<p>第二个改变是在 mix.exs 里的 application 函数中：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们传递了 --sup 标志，Mix自动增加了 mod: {KVServer.Application, []} ，指明 KVServer.Application 是我们的应用回调模块。KVServer.Application 将启动我们的应用监督树。</p>
<p>事实上，让我们打开 lib/kv_server/application.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Application <span class="keyword">do</span></div><div class="line">  <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Application.html</span></div><div class="line">  <span class="comment"># for more information on OTP Applications</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    import Supervisor.Spec, <span class="symbol">warn:</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">    <span class="comment"># Define workers and child supervisors to be supervised</span></div><div class="line">    children = [</div><div class="line">      <span class="comment"># Starts a worker by calling: KVServer.Worker.start_link(arg1, arg2, arg3)</span></div><div class="line">      <span class="comment"># worker(KVServer.Worker, [arg1, arg2, arg3]),</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Supervisor.html</span></div><div class="line">    <span class="comment"># for other strategies and supported options</span></div><div class="line">    opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">    Supervisor.start_link(children, opts)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：它定义了应用回调函数，start/2，而不是使用 Supervisor 模块定义一个名为 KVServer.Supervisor 的监督者，它便捷地在行内定义了监督者！你可以通过阅读<a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor模块文档</a>获得更多这样的监督者的内容。</p>
<p>我们已经可以试试我们第一个伞型子应用。我们可以在 apps/kv_server 里运行测试，但是那样不好玩。相反，到伞型项目的根目录，运行 mix test ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>它正常运行！</p>
<p>因为我们想让 kv_server 最终使用我们在 kv 里定义的功能，因此我们需要将 kv 作为一个依赖加入我们的应用。</p>
<h1 id="伞型项目里的依赖"><a href="#伞型项目里的依赖" class="headerlink" title="伞型项目里的依赖"></a><span id="part-four">伞型项目里的依赖</span></h1><p>Mix支持一种简单的机制使得一个伞型子应用依赖于另一个伞型子应用。打开 apps/kv_server/mix.exs 并且按如下所示修改 deps/0 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">in_umbrella:</span> <span class="keyword">true</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述代码使得 :kv作为 :kv_server 里的一个可用依赖并且在启动 :kv_server 前自动启动 :kv 应用。</p>
<p>最后，拷贝我们已经构建好的 kv 应用到我们新的伞型项目的 apps 目录里。最终的目录结构和我们前面提到的结构匹配上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>我们现在需要修改 apps/kv/mix.exs 让其包含我们已经在 apps/kv_server/mix.exs 所见到的伞型相关条目。打开 apps/kv/mix.exs 并将如下内容加入 project 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>现在你可以从伞型项目根目录用 mix test 运行两个应用的测试。太棒了！</p>
<p>请记住，伞型项目是一个方便工具用来帮助你组织和管理你的应用。apps 目录里的应用仍然是彼此解耦的。它们之间的依赖必须明确地列出来。这允许它们被一起开发，但是如果需要的话，独立地编译、测试和部署。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-five">总结</span></h1><p>在这一章，我们学到了更多关于Mix依赖和伞型项目的内容。我们决定构建一个伞型项目，因为我们认为 kv 和 kv_server 是内部依赖的，其重要性只存在于这个项目的上下文里。</p>
<p>在将来，你将写应用并且你将注意到它们可以被提取到一个简洁的单元，这个单元能被不同的项目使用。在这种情况下，使用Git或Hex依赖是要走的路。</p>
<p>这里有几个问题，当你使用依赖的时候你可以问自己。问题是：这个应用在这个项目之外有意义吗？</p>
<ul>
<li>如果没有，则使用一个有伞型子应用的伞型项目。</li>
<li>如果有，则这个项目在你的公司或组织外部可以被共享吗？<ul>
<li>不可以， 则使用一个私有git仓库。</li>
<li>如果可以，则推送你的代码到一个git仓库并且用Hex做频繁的发布。</li>
</ul>
</li>
</ul>
<p>我们的伞型项目构建好并运行了，是时候开始写我们的服务器了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;外部依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;内部依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;伞型项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;伞型项目里的依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将讨论用Mix如何管理依赖。&lt;/p&gt;
&lt;p&gt;我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs 3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。&lt;/p&gt;
&lt;p&gt;构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Dependency Umbrella-Apps" scheme="http://szpzs.oschina.io/categories/Elixir/Dependency-Umbrella-Apps/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Dependency" scheme="http://szpzs.oschina.io/tags/Dependency/"/>
    
      <category term="Umbrella-Apps" scheme="http://szpzs.oschina.io/tags/Umbrella-Apps/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－ETS</title>
    <link href="http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/"/>
    <id>http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/</id>
    <published>2017-02-20T05:41:49.000Z</published>
    <updated>2017-02-20T06:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">ETS作为缓存</a></li>
<li><a href="#part-two">竞争条件</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！</p>
<p>在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。</p>
<blockquote>
<p>警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。</p>
</blockquote>
<a id="more"></a>
<h1 id="ETS作为缓存"><a href="#ETS作为缓存" class="headerlink" title="ETS作为缓存"></a><span id="part-one">ETS作为缓存</span></h1><p>ETS允许我们存储任何Elixir数据到一个内存表里。与ETS表交互是通过Erlang :ets 模块做到的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:set</span>, <span class="symbol">:protected</span>])</div><div class="line"><span class="number">8207</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(table, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>当创建一个ETS表的时候，需要两个入参：一个表名字和一个选项集合。从可用选项中，我们选择传递表类型和它的访问规则。我们选择了 :set 类型，这意味着键不能是重复的。我们也设置表的访问规则为 :protected ，这意味着只有创建表的进程能写这个表，不过其他进程可以从表里读取数据。这两个选项实际上是默认值，所以从现在开始我们将忽略它们。</p>
<p>ETS表可以被命名，允许我们通过给定的名字访问它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:named_table</span>])</div><div class="line"><span class="symbol">:buckets_registry</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(<span class="symbol">:buckets_registry</span>, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(<span class="symbol">:buckets_registry</span>, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>让我们修改 KV.Registry 来使用ETS表。因为我们的registry需要一个名字作为入参，我们计划用与registry相同的名字来命名ETS表。ETS的名字和进程的名字存储在不同的地方，因此没有冲突的可能。</p>
<p>打开 lib/kv/registry.ex ，让我们修改它的实现。我们增加注释到源码中来强调我们所做的修改：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry with the given `name`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 1. 传递名字给GenServer的init回调函数</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, name, <span class="symbol">name:</span> name)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">when</span> is_atom(server) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 2. 查询现在直接在ETS里做，没有访问服务器</span></div><div class="line">    <span class="keyword">case</span> <span class="symbol">:ets</span>.lookup(server, name) <span class="keyword">do</span></div><div class="line">      [&#123;^name, pid&#125;] -&gt; &#123;<span class="symbol">:ok</span>, pid&#125;</div><div class="line">      [] -&gt; <span class="symbol">:error</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Stops the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">    GenServer.stop(server)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(table) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 3. 我们已经用ETS表替换名字映射</span></div><div class="line">    names = <span class="symbol">:ets</span>.new(table, [<span class="symbol">:named_table</span>, <span class="symbol">read_concurrency:</span> <span class="keyword">true</span>])</div><div class="line">    refs  = %&#123;&#125;</div><div class="line">    &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 4. 原来为查询服务的handle_call回调函数被删除</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 5. 读写ETS表而不是映射</span></div><div class="line">    <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, _pid&#125; -&gt;</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">      <span class="symbol">:error</span> -&gt;</div><div class="line">        &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">        ref = Process.monitor(pid)</div><div class="line">        refs = Map.put(refs, ref, name)</div><div class="line">        <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 6. 从ETS表而不是从映射删除</span></div><div class="line">    &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">    <span class="symbol">:ets</span>.delete(names, name)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：在我们修改前， KV.Registry.lookup/2 发送请求给服务器，但是现在它直接从ETS表里读取，ETS表被所有进程共享。这是我们实现的缓存机制背后的主要思想。</p>
<p>为了让缓存机制工作，被创建的ETS表需要有 :protected 访问规则（访问规则的默认值），因此所有客户端可以从它读取数据，而只有 KV.Registry 进程可以写数据到这个表里。当表启动的时候，我们已经设置 read_concurrency: true ，这样就优化了表的并发读取操作的通用场景。</p>
<p>我们上面的修改已经使得我们的测试失败，因为我们原来是用registry进程的pid来做所有操作，而现在registry查询需要ETS表的名字。但是，ETS表的名字和registry进程的名字相同，这个问题就很容易修复。如下所示修改 test/kv/registry_test.exs 的setup函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> context.test&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们修改 setup ，一些测试用例将继续失败。你可能甚至注意到，在不同的运行之间，测试的通过和失败也不是一致的。例如：“spawns buckets”测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">  assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>可能在这一行失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div></pre></td></tr></table></figure>
<p>如果我们刚刚在上一行创建了bucket，这一行为何会失败？</p>
<p>那些发生的失败的原因是因为为了教学目的，我们已经犯两个错误：</p>
<ol>
<li>我们过早地优化（通过增加这个缓存层）</li>
<li>我们使用 cast/2 （但是我们应该使用 call/2 ）</li>
</ol>
<h1 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a><span id="part-two">竞争条件</span></h1><p>在Elixir里做开发不会使得你的代码免于竞争条件。然而，Elixir的简单抽象，默认情况下不共享数据，更容易发现竞争条件的根本原因。</p>
<p>在我们测试里所发生的是，在一个操作和我们可以观察到在ETS表里这个改变的时间之间有一个延迟。下面是我们所期望的事件发生步骤：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>registry创建bucket并修改缓存表</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 {:ok, bucket}</li>
</ol>
<p>但是，因为 KV.Registry.create/2 是一个 cast 操作，这个命令在我们实际写表前返回。换句话说，实际发生的步骤如下：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 :error</li>
<li>registry创建bucket并修改缓存表</li>
</ol>
<p>要修复这个错误，我们需要通过用 call/2 替代 cast/2 来使得 KV.Registry.create/2 成为同步操作。这将保证在修改被写入表后客户端才继续执行。让我们如下所示修改这个函数和它的回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">  GenServer.call(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, _from, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt;</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="symbol">:error</span> -&gt;</div><div class="line">      &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">      ref = Process.monitor(pid)</div><div class="line">      refs = Map.put(refs, ref, name)</div><div class="line">      <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将回调函数从 handle_cast/2 改为 handle_call/3，并且修改它用被创建的bucket的pid作为返回结果。总的来说，Elixir开发者喜欢用 call/2 而不是 cast/2 ，因为 call/2 也提供反压（你被阻塞一直到你获得响应）。在不必要的时候使用 cast/2 也可以被认为是一种过早优化。</p>
<p>让我们再次运行测试，这次，我们将传递 --trace 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> --trace</div></pre></td></tr></table></figure>
<p>当你的测试有死锁或有竞争条件的时候 --trace 选项有用，因为它同步地运行所有测试（async: true 无效了）并且显示每一个测试详细信息。这次我们将减少到一到两个不连续的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes buckets on <span class="built_in">exit</span> (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:19</div><div class="line">   Assertion with == failed</div><div class="line">   code: KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == :error</div><div class="line">   lhs:  &#123;:ok, <span class="comment">#PID&lt;0.109.0&gt;&#125;</span></div><div class="line">   rhs:  :error</div><div class="line">   stacktrace:</div><div class="line">     <span class="built_in">test</span>/kv/registry_test.exs:23</div></pre></td></tr></table></figure>
<p>根据失败消息，我们期望bucket不再存在表里，但是它依然还在！这个问题和我们刚才解决的问题相反：已经解决的问题是在创建bucket的命令和修改表之间有延迟，现在的这个问题是bucket进程死亡和它的信息从表里删除之间存在延迟。</p>
<p>不幸的是，这次我们不能简单地修改负责清理ETS表的 handle_info/2 函数 为同步操作。相反，我们要找到一个方法保证registry已经处理了当bucket崩溃的时候发送给它的 :DOWN 通知。</p>
<p>一个简单的方法来做到这点，就是通过发送一个同步请求给registry：因为消息按顺序被处理，如果registry响应了一个在Agent.stop调用后发送的请求，这就说明 :DOWN 消息已经被处理了。让我们通过创建一个“假的”bucket来做到这点，它是一个在Agent.stop后的同步请求，在两个测试用例里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Kill the bucket and wait for the notification</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Wait until the bucket is dead</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试用例现在应该（一直）通过！</p>
<p>到此我们的优化章节结束。我们用ETS作为一个缓存机制，读取可以从任何进程发起，但是写入依然只能通过一个单独的进程顺序执行。更重要的是，我们也学到，一旦数据可以被异步读取，我们需要明白它可能引入竞争条件。</p>
<p>下一章我们将讨论外部和内部的依赖以及Mix如何帮助我们管理大型代码库。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/ets.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/ets.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;ETS作为缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;竞争条件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！&lt;/p&gt;
&lt;p&gt;在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Elixir/ETS/"/>
    
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－监督者和应用</title>
    <link href="http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/"/>
    <id>http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/</id>
    <published>2017-02-19T11:02:53.000Z</published>
    <updated>2017-02-20T05:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个监督者</a></li>
<li><a href="#part-two">理解应用</a><br> 2.1. <a href="#part-two-one">启动应用</a><br> 2.2. <a href="#part-two-two">应用的回调函数</a><br> 2.3. <a href="#part-two-three">项目或者应用？</a></li>
<li><a href="#part-three">简单的一对一监督者</a></li>
<li><a href="#part-four">监督树</a></li>
<li><a href="#part-five">Observer</a></li>
<li><a href="#part-six">测试里的共享状态</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。</p>
<p>当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。</p>
<p>在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。</p>
<a id="more"></a>
<h1 id="我们第一个监督者"><a href="#我们第一个监督者" class="headerlink" title="我们第一个监督者"></a><span id="part-one">我们第一个监督者</span></h1><p>创建一个监督者和创建一个GenServer没有太大的不同。我们将在文件 lib/kv/supervisor.ex 里定义一个名为 KV.Supervisor 的模块，它将使用 Supervisor 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Registry, [KV.Registry])</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的监督者目前只有一个孩子：registry。如下格式的一个工作者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker(KV.Registry, [KV.Registry])</div></pre></td></tr></table></figure>
<p>将用下面的调用启动一个进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KV.Registry.start_link(KV.Registry)</div></pre></td></tr></table></figure>
<p>我们传递给start_link的入参是这个进程的名字。给在监督树下的进程命名是通用的做法，这样使得其他进程不需要知道它们的pid就可以通过名字来访问它们。这是有用的，因为一个被监督的进程可能崩溃，这样的话，当监督者重启它时，它的pid将改变。通过使用一个名字，我们可以保证新的被重启的进程将注册到同样的名字下，而不用一定获取最新的pid。注意，用定义它的相同的模块的名字来注册进程也是通用的做法，这使得在调试或监测一个运行的系统时更方便直接。</p>
<p>最后，我们用孩子列表和策略 :one_for_one 作为入参调用 supervise/2 。</p>
<p>监督策略规定，当一个孩子进程发生崩溃的时候会发生什么。:one_for_one 的意思是，如果一个孩子进程死了，只有它一个将被重启。因为我们只有一个孩子进程，所有这些就是我们所需的。Supervisor行为支持许多不同的策略，我们将在本章中讨论它们。</p>
<p>因为现在KV.Registry.start_link/1期望有一个入参，我们需要改变我们的实现来接收这样的入参。打开 lib/kv/registry.ex 并替换 start_link/0 的实现如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Starts the registry with the given `name`.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">  GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> name)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们也需要修改我们的测试用例，当启动一个registry的时候给它一个名字。用下面的内容替换 test/kv/registry_test.exs 里的setup回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>setup/2也可以接收测试上下文，和test/3相似。除了我们在设置块中添加的任何值外，上下文还包含一些默认键，例如：:case， :test，:file 和 :line。我们用当前运行的测试的相同名字作为快捷方式来启动一个registry。</p>
<p>现在我们的测试通过，我们可以带我们的监督者兜兜风。如果我们在我们的项目目录里用 iex -S mix 启动一个控制台，我们可以手工启动一个监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Registry.create(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>当我们启动监督者，registry工作者自动被启动，允许我们创建bucket而不需要手工去启动它。</p>
<p>在实践中，我们很少手动启动应用的监督者。相反，它被作为应用的回调的一部分启动。</p>
<h1 id="理解应用"><a href="#理解应用" class="headerlink" title="理解应用"></a><span id="part-two">理解应用</span></h1><p>在这整个时间里我们一直在一个应用里工作。每次我们修改完一个文件并运行 mix compile ，我们会看到在编译输出里有一个 Generated kv app 的消息。</p>
<p>我们可以找到这个被创建的 .app 文件，它在 _build/dev/lib/kv/ebin/kv.app 。让我们看看它的内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;application,kv,</div><div class="line">             [&#123;registered,[]&#125;,</div><div class="line">              &#123;description,<span class="string">"kv"</span>&#125;,</div><div class="line">              &#123;applications,[kernel,stdlib,elixir,logger]&#125;,</div><div class="line">              &#123;vsn,<span class="string">"0.0.1"</span>&#125;,</div><div class="line">              &#123;modules,[<span class="string">'Elixir.KV'</span>,<span class="string">'Elixir.KV.Bucket'</span>,</div><div class="line">                        <span class="string">'Elixir.KV.Registry'</span>,<span class="string">'Elixir.KV.Supervisor'</span>]&#125;]&#125;.</div></pre></td></tr></table></figure>
<p>这个文件包含Erlang数据（用Erlang语法写的）。即使我们不熟悉Erlang，也很容易猜出这个文件有我们应用的定义。它包含我们应用的版本，由它定义的所有模块，以及我们依赖的应用的列表，比如：Erlang的kernel、elixir它自己和在mix.exs文件里的应用列表里指定的logger。</p>
<p>每次我们增加一个新的模块到我们的应用都要手工修改这个文件将会是非常麻烦的。这就是为什么Mix帮我们生成并维护它的原因。</p>
<p>我们也可以通过在我们mix.exs项目文件里自定义 application/0 的返回值来配置被创建的 .app 文件。我们马上将做我们第一个自定义的应用。</p>
<h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a><span id="part-two-one">启动应用</span></h2><p>当我们定义了一个应用规格说明文件：.app 文件，我们就能把应用当做一个整体来启动和停止。目前我们不需要关注这个文件是因为有两个原因：</p>
<ol>
<li>Mix自动为我们启动我们当前的应用。</li>
<li>即使Mix没有启动我们的应用程序，我们的应用程序还没有做任何事情当它启动的时候。</li>
</ol>
<p>不管怎样，让我们看看Mix如何为我们启动应用。让我们用 iex -S mix 启动一个项目的控制台并且进行如下操作：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:already_started</span>, <span class="symbol">:kv</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>哇！它已经启动了。Mix通常启动在我们项目的 mix.exs 文件所定义的整个应用层级的应用；如果这些应用依赖其他应用，它也会同样地为这些所依赖的应用做相同的事情。</p>
<p>我们可以传递一个选项给Mix要求它不要启动我们的应用。让我们运行 iex -S mix run --no-start 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们可以停止我们的 :kv 应用和 :logger应用，:logger应用是由Elixir默认启动的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.stop(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Application.stop(<span class="symbol">:logger</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然后让我们再次启动我们的应用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:not_started</span>, <span class="symbol">:logger</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们得到了一个错误因为 :kv 应用依赖的 :logger 应用没有启动。我们需要按正确顺序手工启动每一个应用或如下所示调用 Application.ensure_all_started ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.ensure_all_started(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, [<span class="symbol">:logger</span>, <span class="symbol">:kv</span>]&#125;</div></pre></td></tr></table></figure>
<p>没有什么真正值得兴奋的，不过它展现了我们如何能控制我们的应用。</p>
<blockquote>
<p>当你运行 iex -S mix 的时候，它相当于运行 iex -S mix run 。所以当你启动IEx无论何时你需要传递更多选项给Mix，一定运行 iex -S mix run ，然后传递任何选项给run命令接收。你可以在你的shell里运行mix help run找到更多关于run的信息。</p>
</blockquote>
<h2 id="应用的回调函数"><a href="#应用的回调函数" class="headerlink" title="应用的回调函数"></a><span id="part-two-two">应用的回调函数</span></h2><p>既然我们花了所有时间来谈论应用如何启动和停止，则必定有方法在应用启动的时候做一些有用的事情。而事实上，有！</p>
<p>我们可以指定一个应用的回调函数。这个函数将在应用启动的时候被调用。这个函数必须返回格式为 {:ok, pid} 的结果，pid是监督者进程的进程标识符。</p>
<p>我们可以用两个步骤来设置应用的回调函数。首先，打开 mix.exs 文件，然后，按如下所示改变 def application ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:mod 选项指定了“应用回调模块”，它后面的参数将在应用启动的时候被传递。应用回调模块可以是任何实现了 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application</a> 行为的模块。</p>
<p>现在我们已经指定了 KV 作为模块回调，我们需要修改定义在 lib/kv.ex 的 KV 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    KV.Supervisor.start_link</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们 use Application 时，我们需要定义一些函数，和当我们使用 Supervisor 或 GenServer 时相似。这次我们只是需要定义一个 start/2 函数。如果我们想在应用结束时指定自定义的行为，我们可以定义一个 stop/1 函数。</p>
<p>让我们再次用 iex -S mix 来启动我们项目的控制台。我们将看到一个名为 KV.Registry 的进程已经在运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create(KV.Registry, &quot;shopping&quot;)</div><div class="line">:ok</div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, &quot;shopping&quot;)</div><div class="line">&#123;:ok, #PID&lt;0.88.0&gt;&#125;</div></pre></td></tr></table></figure>
<p>我们如何知道它是正常运行的？毕竟，我们创建了一个bucket然后查询它；当然，它应该正常运行，对吗？好的，记得 KV.Registry.create/2 使用 GenServer.cast/2 ，因此将返回 :ok ，而不管消息是否找到它的目标。在这个时候，我们不知道监督者和服务器是否起来了，以及bucket是否被创建了。但是， KV.Registry.lookup/2 使用 GenServer.call/3 ，而且将阻塞并等待从服务器返回的结果。我的确得到了正确的响应，所以我们知道所有事情都起来并运行着。</p>
<p>做一个实验，尝试用 GenServer.call/3 替代来重新实现 KV.Registry.create/2 ，并且短暂地使得应用回调不可用。在控制台再次运行上面的代码，你会立即看到创建步骤失败。</p>
<p>记得在继续教程前恢复代码。</p>
<h2 id="项目或者应用？"><a href="#项目或者应用？" class="headerlink" title="项目或者应用？"></a><span id="part-two-three">项目或者应用？</span></h2><p>Mix区分项目和应用。基于我们的mix.exs文件内容，我们可以说我们有一个Mix项目，它定义了一个 :kv 应用。正如我们将在后面章节所看到的，有的项目没有定义任何应用。</p>
<p>当我们说“项目”的时候，你应该考虑Mix。Mix是一种工具，它管理你的项目。它知道如何编译你的项目，测试你的项目等等。它也知道如何编译和启动与你的项目相关的应用程序。</p>
<p>当我们谈论应用的时候，我们谈论的是OTP。应用程序是由运行时作为一个整体来启动和停止的实体。你可以从<a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application的官方文档</a>里学到更多关于应用的内容，也可以通过运行 mix help compile.app 来学到更多在 def application 里被支持的选项。</p>
<h1 id="简单的一对一监督者"><a href="#简单的一对一监督者" class="headerlink" title="简单的一对一监督者"></a><span id="part-three">简单的一对一监督者</span></h1><p>我们现在已经成功地定义了我们的监督者，它作为我们应用生命周期的一部分被自动地启动（和结束）。</p>
<p>然而我们记得在 handle_cast/2 回调函数里，我们的 KV.Registry 同时链接和监测着bucket进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>链接是双向的，这暗示着bucket的崩溃会导致registry的崩溃。虽然我们现在有监督者，它保证registry将被恢复并运行，但是崩溃registry意味着我们丢失所有bucket名字与它们相应进程的关联数据。</p>
<p>换句话说，我们希望registy继续运行，即使一个bucket溃。让我们写一个新的registry测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 用非正常原因停止bucket</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 等待一直到bucket死亡</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个测试用例和“removes bucket on exit”测试用例相似，不同点是我们有点苛刻地发送 :shutdown 作为退出原因替代 :normal 。和 Agent.stop/1 相反，Process.exit/2 是一个异步操作，因此我们不能简单地在发送退出信号后立即调用 KV.Registry.lookup/2 来查询，因为那时还无法保证bucket已死。为解决这个问题，我们在测试期间也监测bucket，一旦我们确认它死掉了，我们才查询registry，这样就避免了条件竞争。</p>
<p>因为bucket被链接到registry，而registry被链接到测试进程，那么杀掉bucket导致registry崩溃，从而导致测试进程也崩溃：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes bucket on crash (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:52</div><div class="line">   ** (EXIT from <span class="comment">#PID&lt;0.94.0&gt;) shutdown</span></div></pre></td></tr></table></figure>
<p>这个问题有一个解决办法，提供一个调用 Agent.start/1 的 KV.Bucket.start/0  ，然后在registry里使用它，删除bucket和registry之间的链接。但是，这是一个坏主意，因为这么修改了后，bucket将不会和任何一个进程链接。这就意味着，如果有人停止 :kv 应用，所有的bucket因为无法被访问而继续存活。不仅如此，如果一个进程是不可被访问的，它们就更难被监测。</p>
<p>我们将通过定义一个新的创建和监督所有bucket的监督者来解决这个问题。有一个监督者策略，叫做 :simple_one_for_one ，它特别适合这样的场景：它允许我们指定一个工作者模板并监督许多基于这个模板的子进程。使用这个策略，没有一个工作者在监督者初始化的时候被启动，而每次通过调用 start_child/2 启动一个新的工作者。</p>
<p>让我们在 lib/kv/bucket/supervisor.ex 文件里定义我们的 KV.Bucket.Supervisor ，内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="comment"># 一个存储监督者名字的简单模块属性</span></div><div class="line">  <span class="variable">@name</span> KV.Bucket.Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> <span class="variable">@name</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_bucket</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_child(<span class="variable">@name</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Bucket, [], <span class="symbol">restart:</span> <span class="symbol">:temporary</span>)</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:simple_one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>和第一个监督者相比这个监督者有三处改变。</p>
<p>首先，我们决定给这个监督者一个本地名字 KV.Bucket.Supervisor 。我们也定义了一个 start_bucket/0 函数，它将启动一个bucket作为叫做 KV.Bucket.Supervisor 监督者的子进程。我们将在registry里直接调用 start_bucket/0 来替换对 KV.Bucket.start_link 的调用。</p>
<p>最后，在 init/1 回调函数里，我们标注工作者是 :temporary 。这意味着，如果一个bucket死了，它不会被重启。这是因为我们只是想用监督者作为一种聚集bucket的机制。</p>
<p>运行 iex -S mix  ，我们来试试我们新的监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Bucket.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(bucket, <span class="string">"eggs"</span>, <span class="number">3</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(bucket, <span class="string">"eggs"</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>让我们修改registry，用KV.Bucket.Supervisor 来重写bucket如何被重启：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们按上述所示进行了修改，我们的测试用例将失败，因为没有bucket监督者。让我们来自动启动bucket监督者作为我们主监督树的一部分来替代每次测试都直接地启动bucket监督者。</p>
<h1 id="监督树"><a href="#监督树" class="headerlink" title="监督树"></a><span id="part-four">监督树</span></h1><p>为了在我们的应用里使用bucket监督者，我们需要把它加进 KV.Supervisor 的子进程了。注意：我们开始有监督其他监督者的监督者，形成所谓的“监督树”。</p>
<p>打开 lib/kv/supervisor.ex ，按如下所示修改 init/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这次我们增加一个监督者作为一个子进程，没有用参数来启动它。重新运行测试套件，现在所有测试用例都将通过。</p>
<p>因为我们增加了更多的子进程给监督者，所以评估 :one_for_one 监督策略是否依然正确也很重要。有一个瑕疵马上显现出来，就是 KV.Registry 工作者进程和 KV.Bucket.Supervisor 监督者进程之间的关系。如果 KV.Registry 死了，所有链接 KV.Bucket 名字到 KV.Bucket 进程的信息丢失，而且因此 KV.Bucket.Supervisor 也必须死，否则，它管理的 KV.Bucket 进程将成为孤儿。</p>
<p>根据这一观察，我们应该考虑转移到另一个监督策略。另外两个候选者是：:one_for_all 和 :rest_for_one 。一个监督者使用 :one_for_all 策略，则无论何时它任何一个子进程死亡，它将杀掉和重启它所有的子进程。乍一看，这似乎适合我们的使用情况，但它似乎也有点霸道，因为如果 KV.Bucket.Supervisor 死了，KV.Registry 是完全能够清理它自己的。在这种情况下，:rest_for_one 策略就派上用场了：当一个进程崩溃了，监督者将只是杀掉和重启在崩溃子进程后启动的子进程。让我们重写我们的监督树，用这个策略来替代原来的策略：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:rest_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，如果 KV.Registry 工作者崩溃，则 KV.Registry 和 KV.Supervisor 的“剩余”子进程（即 KV.Bucket.Supervisor ）将被重启。但是，如果 KV.Bucket.Supervisor 崩溃了，KV.Registry 将不会被重启，因为它先于 KV.Bucket.Supervisor 启动。</p>
<p>还有其他的策略和其他的选项可以给 worker/2，supervisor/2 和 supervise/2 函数，所以不要忘了仔细阅读 <a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor</a> 和 <a href="https://hexdocs.pm/elixir/Supervisor.Spec.html" target="_blank" rel="external">Supervisor.Spec</a> 模块的文档。</p>
<p>为了帮助开发者记住如何使用 Supervisor 和它方便的函数，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a> 已经创建了 <a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/Supervisor_CheatSheet.pdf" target="_blank" rel="external">Supervisor备忘录</a> 。</p>
<p>在我们转到下一章前还剩下两个话题。</p>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><span id="part-five">Observer</span></h1><p>现在我们已经定义了我们的监督树，这是一个很好的机会介绍Erlang自带的Observer工具。用 iex -S mix 启动你的应用，然后在里面输入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:observer</span>.start</div></pre></td></tr></table></figure>
<p>一个包含我们系统的所有各类信息的图形界面弹出来，信息包括从总的统计到负载图，也有所有运行的进程和应用的列表。</p>
<p>在应用标签卡里，你将看到你的系统里的所有当前运行的应用以及它们的监督树。你可以选择 kv 应用来进一步浏览它：</p>
<p><img src="/images/getting-started-mix-otp-supervisor-and-application-kv-observer.png" style="border:0;"></p>
<p>不仅如此，当你在终端创建一个新的bucket的时候，你将在Observer里看到被新创建的进程在监督树里展示出来。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create KV.Registry, <span class="string">"shopping"</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们将留给你进一步探索Observer提供了什么。记住，你可以双击监督树里的任何进程来获取这个进程的更多信息，也可以右击一个进程来发送“一个杀死信号”，这是一个完美的方式来模拟失败并看看你的监督者是否如预期地响应。</p>
<p>在一天结束之际，像Observer这样的工具是你想要总是在监督树内启动进程，即使他们是暂时的，以确保它们总是可以到达和监测的主要原因之一。</p>
<h1 id="测试里的共享状态"><a href="#测试里的共享状态" class="headerlink" title="测试里的共享状态"></a><span id="part-six">测试里的共享状态</span></h1><p>到目前为止，我们已经为每一个测试用例启动一个registry来确保它们是被隔离的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>既然我们现在已经改变了我们的registry来使用 KV.Bucket.Supervisor ，它被全局注册，我们的测试现在依靠这个共享、全局的监督者，尽管每个测试用例都有自己的registry。问题是：我们应该这样做吗？</p>
<p>这取决于只要我们只依赖于这个状态的非共享部分，就可以依赖共享的全局状态。例如，每次我们用给定的名字注册一个进程，我们就是正在对应于一个共享了名字的registry来注册一个进程。然而，只要我们通过使用像 context.test 这样的结构来保证这个名字对于每一个测试用例都是特定的，我们就不会在测试用例之间有并发或者数据依赖的问题。</p>
<p>类似的推理应适用于我们的bucket监督者。虽然在共享的bucket监督者上多个registry可能启动bucket，但是那些bucket和registry是彼此隔离的。如果我们使用像 Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数，我们只会遇到并发问题；Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数从所有registry统计所有的bucket数量，当测试用例并发地运行的时候，潜在获得不同结果的问题。</p>
<p>因为我们目前只依赖bucket监督者的非共享部分，因此在我们的测试套件里我们不需要担心并发问题。万一它成为一个问题，我们可以每一个测试用例启动一个监督者并且把它作为入参传递给registry的start_link函数。</p>
<p>现在，我们的应用得到适当的监督和测试，让我们看看如何可以加快速度。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个监督者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;理解应用&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;启动应用&lt;/a&gt;&lt;br&gt; 2.2. &lt;a href=&quot;#part-two-two&quot;&gt;应用的回调函数&lt;/a&gt;&lt;br&gt; 2.3. &lt;a href=&quot;#part-two-three&quot;&gt;项目或者应用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;简单的一对一监督者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;监督树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Observer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;测试里的共享状态&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。&lt;/p&gt;
&lt;p&gt;当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。&lt;/p&gt;
&lt;p&gt;在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Supervisor Application" scheme="http://szpzs.oschina.io/categories/Elixir/Supervisor-Application/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Supervisor" scheme="http://szpzs.oschina.io/tags/Supervisor/"/>
    
      <category term="Application" scheme="http://szpzs.oschina.io/tags/Application/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－GenServer</title>
    <link href="http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/"/>
    <id>http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/</id>
    <published>2017-02-18T04:05:34.000Z</published>
    <updated>2017-02-20T05:50:29.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个GenServer</a></li>
<li><a href="#part-two">测试一个GenServer</a></li>
<li><a href="#part-three">监测的必要性</a></li>
<li><a href="#part-four">call、cast还是info？</a></li>
<li><a href="#part-five">监测还是链接？</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在<a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">上一章</a>我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>, <span class="symbol">name:</span> <span class="symbol">:shopping</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而<strong>我们不应该将用户输入转换为原子</strong>。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！</p>
<p>在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。</p>
<p>我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。</p>
<p>注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。</p>
<p>我们将使用一个 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。</p>
<a id="more"></a>
<h1 id="我们第一个GenServer"><a href="#我们第一个GenServer" class="headerlink" title="我们第一个GenServer"></a><span id="part-one">我们第一个GenServer</span></h1><p>一个GenServer被实现为两部分：客户端API和服务端回调函数。你既可以把这两部分合并到一个单独的模块里，也可以把它们分拆到一个客户端模块和一个服务端模块。客户端和服务端分别运行在隔离的进程里，客户端和服务端来回传递消息，而服务器在内部基于收到的消息而调用相关的函数。本文我们将用一个单独的模块来容纳客户端API和服务端回调函数。</p>
<p>创建一个文件 lib/kv/registry.ex ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## Client API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.call(server, &#123;<span class="symbol">:lookup</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server Callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, %&#123;&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, names) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), names&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, names) <span class="keyword">do</span></div><div class="line">    if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:noreply</span>, names&#125;</div><div class="line">    else</div><div class="line">      &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">      &#123;<span class="symbol">:noreply</span>, Map.put(names, name, bucket)&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个函数是 start_link/3 ，它接收三个入参来启动一个新的GenServer：</p>
<ol>
<li>服务端回调函数被实现所在模块，本例子里是 __MODULE__ ，意思就是当前模块。</li>
<li>初始化参数，本例子里是原子 :ok 。</li>
<li>一个选项列表，它可以被用来指定一些事项，比如服务器名字。本例子里我们传递了一个空列表。</li>
</ol>
<p>有两种类型请求你可以发送给一个GenServer：call 和 cast。call是同步的，服务端<strong>必须</strong>发送一个响应给这一个的请求。cast是异步的，服务端不需要返回响应。</p>
<p>接下来的两个函数，lookup/2 和 create/2 负责发送这些请求给服务端。在本例子中，我们分别用 {:lookup, name} 和 {:create, name} 作为请求消息。请求消息常常被指定为元组，就像本例一样，是为了在第一个参数位置提供多于一个“参数”。通常指定请求的动作作为元组的第一个元素，而剩下的元素作为该动作的参数。注意：请求必需匹配 handle_call/3 或 handle_cast/2 的第一个入参。</p>
<p>上面讲的就是客户端API。在服务器这边，我们可以实现各种各样的回调函数来保证服务器的初始化、终止和处理请求。那些回调函数是可选的，目前我们只实现我们所关心的。</p>
<p>第一个是 init/1 回调函数，它接收传给 GenServer.start_link/3 的参数并且返回 {:ok, state} ，此处的状态是一个新的映射。我们可能已经注意到GenServer的API是如何使得客户端和服务端隔离的更明显的。start_link/3 在客户端，而它所对应的回调函数 init/1 运行在服务端。</p>
<p>对应于 call/2 的请求，我们实现一个 handle_call/3 回调函数来接收它的请求、请求的来源进程（_from），以及当前服务器状态（state）。handle_call/3 回调函数返回一个格式为 {:reply, reply, new_state} 的元组。这个元组的第一个元素，:reply ，表明服务器将发送一个应答给客户端。第二个元素，reply，就是发送给客户端的应答。而第三个元素，new_state，是一个新的服务器状态。</p>
<p>对应于 cast/2 的请求，我们实现了一个 handle_cast/2 回调函数来接收它的请求和当前服务器状态（state）。handle_cast/2  回调函数返回一个格式为 {:noreply, new_state} 的元组。注意：在一个真实的应用里，可能应该用同步调用的方式为 :create 实现回调函数来替换异步的cast函数。我们在本例里这么做是为了说明如何实现一个cast函数的回调。</p>
<p>handle_call/3 和 handle_cast/2 函数还有其他格式的返回元组。也有其他的回调函数我们可以实现，比如：terminate/2 和 code_change/3 。欢迎你探索<a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">整个GenServer文档</a>以了解关于这方面的更多内容。</p>
<p>现在，让我们写一些测试来保证我们的GenServer如我们所期望地工作。</p>
<h1 id="测试一个GenServer"><a href="#测试一个GenServer" class="headerlink" title="测试一个GenServer"></a><span id="part-two">测试一个GenServer</span></h1><p>测试一个GenServer和测试一个Agent没有太大的不同。我们将在测试的setup回调函数里创建一个服务器，并在我们整个测试中使用它。创建一个文件：test/kv/registry_test.exs ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RegistryTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">    KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">    assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试应该毫无阻碍地通过！</p>
<p>你不需要明确地停掉registry，因为当我们的测试结束的时候，它将收到一个 :shutdown 信号。虽然这么处理相应的测试来说没问题。但是如果需要将停止一个GenServer作为一个应用里逻辑的一部分，那么你可以使用 GenServer.stop/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Stops the registry.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">  GenServer.stop(server)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="监测的必要性"><a href="#监测的必要性" class="headerlink" title="监测的必要性"></a><span id="part-three">监测的必要性</span></h1><p>我们的registry几乎完成了。仅剩的问题是，如果一个bucket停止或崩溃了，registry的数据可能会变得过时。让我们增加一个测试用例到 KV.RegistryTest 来揭示这个bug：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的测试用例将在最后的断言处失败，因为bucket的名字还保留在registry里，即使在我们停止了bucket进程后。</p>
<p>为了修复这个bug，我们需要registry监测每一个由它创建的bucket。一旦我们设置了监测，每次bucket退出的时候，registry将收到一个通知，允许我们来清理字典。</p>
<p>让我们用 iex -S mix 启动一个新的控制台，先来玩一下监测：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; Process.monitor(pid)</div><div class="line"><span class="comment">#Reference&lt;0.0.0.551&gt;</span></div><div class="line">iex&gt; Agent.stop(pid)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; flush()</div><div class="line">&#123;<span class="symbol">:DOWN</span>, <span class="comment">#Reference&lt;0.0.0.551&gt;, :process, #PID&lt;0.66.0&gt;, :normal&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Process.monitor(pid) 返回一个唯一的引用，这允许我们匹配将要到来的消息，从而监测引用。我们停止Agent后，我们可以 flush/0 所有消息，注意到：一个 :DOWN 消息到达，带着与monitor返回的一样的引用，告诉我们，bucket进程因为 :normal 原因退出。</p>
<p>让我们重新实现服务端回调函数来修复这个bug并使得测试通过。首先，我们将修改GenServer的状态为两个字典：一个包含 name -&gt; pid ，另一个包含 ref -&gt; name。然后我们需要在 handle_cast/2 里监测bucket，也实现一个 handle_info/2 回调函数来处理监测消息。所有服务端回调函数的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 服务端回调函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  names = %&#123;&#125;</div><div class="line">  refs  = %&#123;&#125;</div><div class="line">  &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, &#123;names, <span class="number">_</span>&#125; = state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), state&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">  names = Map.delete(names, name)</div><div class="line">  &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意，我们能够在不改变任何客户端API的情况下，大幅度地改变服务器实现。这就是明确地隔离服务器和客户端的好处之一。</p>
<p>最后，不同于其他回调函数，我们为 handle_info/2 回调函数定义了一个“catch-all”分支，它丢弃任何未知的消息。想知道为什么，请移步下一节。</p>
<h1 id="call、cast还是info？"><a href="#call、cast还是info？" class="headerlink" title="call、cast还是info？"></a><span id="part-four">call、cast还是info？</span></h1><p>我们已经用了三个回调函数：handle_call/3，handle_cast/2 和 handle_info/2。现在我们要考虑什么时候决定和什么时候使用它们：</p>
<ol>
<li>handle_call/3 必须用于同步请求。这应该是等待服务器的回复是一个有用的反压机制的默认选择。</li>
<li>handle_cast/2 必须用于异步请求，而且当你不关心响应的时候。cast甚至不保证服务端收到了消息，因此，它应该尽量少用。例如，本章我们已经定义的 create/2 函数应该使用 call/2 。我们使用 cast/2 是为了教学目的。</li>
<li>handle_info/2 必须用于服务端接收到的不是GenServer.call/2 或 GenServer.cast/2发送的其他所有消息，包括了用send/2发送的普通消息。监测消息 :DOWN 就是其中的例子。</li>
</ol>
<p>因为任何消息，包括send/2方式的消息都由handle_info/2处理，则有机会不期望的消息到达服务器。因此，如果我们没有定义catch-all分支，那些消息将导致我们的registry崩溃，因为没有分支可以匹配它们。但是我们却不用担心这样的情况发生在handle_call/3 和 handle_cast/2。call和cast只能通过GenServer的API来做，所以一个未知消息就十分可能是由开发者的错误造成。</p>
<p>为了帮助开发者记住call，cast 和 info之间的区别，它们支持的返回值以及其他知识，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a>已经创建了非常棒的<a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf" target="_blank" rel="external">GenServer备忘录</a>.</p>
<h1 id="监测还是链接？"><a href="#监测还是链接？" class="headerlink" title="监测还是链接？"></a><span id="part-five">监测还是链接？</span></h1><p>我们已经在Process这章学习了链接。现在，我们完成了registry模块，我们可能想知道：什么时候我们应该用监测而什么时候我们应该用链接？</p>
<p>链接是双向的。如果你链接了两个进程，其中一个进程崩溃，则另一个进程也将崩溃（除非它捕获了退出信号）。监测是单向的：只有监测的进程才收到关于被监测进程的通知。也就是说：当你想链接崩溃的时候使用链接，而当你只是想获得崩溃、退出等的信息的时候就使用检测。</p>
<p>回到我们的 handle_cast/2 实现，你可以看到registry既链接也监测bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>这是一个坏注意，因为我们不想我们的registry在bucket崩溃的时候也崩溃！我们通常避免直接创建进程，而是把这个责任委托给监督者。正如我们将在下一章所见，监督者依赖于链接，这就解释了为什么基于链接的API（spawn_link，start_link，等）在Elixir和OTP里很普遍。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/genserver.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个GenServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;测试一个GenServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;监测的必要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;call、cast还是info？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;监测还是链接？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/agent.html&quot;&gt;上一章&lt;/a&gt;我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; Agent.start_link(&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; -&amp;gt; %&amp;#123;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;:ok&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;#PID&amp;lt;0.43.0&amp;gt;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; KV.Bucket.put(&lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;milk&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;:ok&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; KV.Bucket.get(&lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;milk&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而&lt;strong&gt;我们不应该将用户输入转换为原子&lt;/strong&gt;。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！&lt;/p&gt;
&lt;p&gt;在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。&lt;/p&gt;
&lt;p&gt;我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。&lt;/p&gt;
&lt;p&gt;注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。&lt;/p&gt;
&lt;p&gt;我们将使用一个 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="GenServer" scheme="http://szpzs.oschina.io/categories/Elixir/GenServer/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="GenServer" scheme="http://szpzs.oschina.io/tags/GenServer/"/>
    
  </entry>
  
</feed>
