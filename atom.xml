<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2016-11-22T03:19:35.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang(和Elixir)无epmd之分布式</title>
    <link href="http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/"/>
    <id>http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/</id>
    <published>2016-11-22T02:50:54.000Z</published>
    <updated>2016-11-22T03:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：</p>
<ul>
<li>epmd（Erlang端口映射守护进程）端口4369，</li>
<li>Erlang节点自己的端口，一个不可预知的大数字端口。</li>
</ul>
<p>这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的<a href="http://erlang.org/doc/man/kernel_app.html" target="_blank" rel="external">kernel文档</a>里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。</p>
<a id="more"></a>
<p>但是如果我们限制了Erlang节点在一个单独的端口，那么我们还真的需要一个端口映射吗？运行epmd有以下几个潜在的缺点：</p>
<ul>
<li>我们可能想要以运行Erlang节点的用户来运行epmd，但是正如我们将见到的，这个很难得到保证。</li>
<li>我们可能想要配置epmd监听一个特定的端口，但是这依赖于在本机上我们如何第一次运行epmd。</li>
<li>任何人无需身份验证可以连接epmd并且可以列出本地的所有Erlang节点。</li>
<li>与epmd的连接都没有加密，即使你按 <a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">Erlang distribution over TLS</a> 这篇文章的方法去做，与epmd的连接也是不受保护的，并且有被中间人攻击的潜在风险。</li>
<li>虽然epmd很稳定，它也有发生崩溃的可能。一旦它崩溃了，任何已经存在的分布式Erlang节点将继续运行，即使epmd恢复了，这些节点也不会重新连接empd。这意味着存在的分布式连接继续工作着，但是与这些节点的新的连接将不起作用。阅读俄文博客 <a href="https://habrahabr.ru/post/49535/" target="_blank" rel="external">Экстренная реанимация epmd</a> 可能可以在不重启epmd的情况下解决这个问题。</li>
</ul>
<p>那么我们来研究一下epmd是如何工作的，然后我们如何做就可以在不用epmd的情况下运行一个Erlang集群。</p>
<h1 id="epmd是如何第一次启动的？"><a href="#epmd是如何第一次启动的？" class="headerlink" title="epmd是如何第一次启动的？"></a>epmd是如何第一次启动的？</h1><p>让我们来读读源码！epmd是在<a href="https://github.com/erlang/otp/blob/OTP-19.1.1/erts/etc/common/erlexec.c#L1234-L1279" target="_blank" rel="external">erlexec.c文件的start_epmd函数</a>里被启动的。实际上，每一次一个Erlang分布式节点启动epmd都无条件地被启动。如果一个epmd实例已经在运行，新的epmd在侦听端口4369的时候将失败，它将因此悄无声息地结束运行。</p>
<p>事实上，这就是即使由另一个用户启动的epmd实例存在系统将发生的事情。任何epmd实例都非常乐意为由任何用户启动的Erlang节点服务，因此这个通常不会引起任何问题。</p>
<h1 id="那么谁可以连接epmd？"><a href="#那么谁可以连接epmd？" class="headerlink" title="那么谁可以连接epmd？"></a>那么谁可以连接epmd？</h1><p>任何人都可以！默认情况下，epmd侦听在所有有效的接口上，并且响应关于当前有哪些节点以及这些节点所侦听的端口的查询。一听到这个场景，系统管理员应该有点紧张。</p>
<p>你可以在epmd启动前通过手工指定 -address 选项或设定ERL_EPMD_ADDRESS 环境变量启动epmd来改变上述情况。这个方法在<a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="external">官方文档</a>里有描述。这个方法需要在你第一次启动epmd的时候来做，否则，已经存在的epmd实例将不受影响地继续运行。</p>
<h1 id="为什么我们需要一个端口映射守护进程？"><a href="#为什么我们需要一个端口映射守护进程？" class="headerlink" title="为什么我们需要一个端口映射守护进程？"></a>为什么我们需要一个端口映射守护进程？</h1><p>很明显，epmd就是一个中间人。我们可以绕过这个中间人吗？</p>
<p>我们可以让每个Erlang节点侦听在一个大家熟知的端口–如果我们打算去除掉epmd的话，我们可以用empd默认保留的端口，4369。但是这就意味着我们只能够在每个主机上运行一个Erlang节点（当然，在某些场景下这就足够了）。</p>
<p>那么让我们指定一些其他端口。前面我们提到变量 inet_dist_listen_min 和 inet_dist_listen_max 。这两个变量定义一个端口范围，不过如果我们设置它们为相同的值，我们就把范围缩小到一个端口：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">erl -sname foo \</div><div class="line">    -kernel inet_dist_listen_min <span class="number">4370</span> \</div><div class="line">            inet_dist_listen_max <span class="number">4370</span></div></pre></td></tr></table></figure>
<p>这个方法不错，不过我们也需要告诉其他节点不要再去询问epmd来获取端口号，而是只用这个端口号来代替。如果我们在同一个主机上有几个节点，我们需要为这些节点配置不同的端口号。</p>
<h1 id="用别的方法"><a href="#用别的方法" class="headerlink" title="用别的方法"></a>用别的方法</h1><p>在Erlang/OTP 19.0里，有两个新的命令行选项：</p>
<ul>
<li>当我们指定 -start_epmd false，Erlang将不会在启动一个分布式节点的时候尝试去启动epmd；</li>
<li>选项 -epmd_module foo 让你指定一个不同的模块替代默认的模块erl_epmd，用来节点名字注册和查询。</li>
</ul>
<p>接下来我们来构建一些代码！</p>
<p>我想用一个无状态的方式来实现这个方法：既然发起连接的节点知道了它要连接的节点的名字，那么我就用这个名字作为资源来得到相应的端口号。我选择4370这个端口作为基准端口，它比epmd的端口大一。接着我从节点名称的“节点”部分抽取出数字，比如节点名称为 myapp3@foo.example.com 抽取的数字是3。最后我把这个数字和基准端口相加。由此得知，节点 myapp3@foo.example.com 侦听在端口4373。如果节点名字最后不是数字，我这种情况将处理为0。这意味着节点 myapp3 和 myotherapp3 不能运行在同一个主机上，但是我准备好了处理对这种场景。（感谢 Luca Favatella 的完美建议）</p>
<p>为此我们来写一个小模块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([dist_port/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% 返回被一个指定节点使用的端口号。</span></div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_atom</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    dist_port(atom_to_list(Name));</div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_list</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 获取基端口号。如果没有在 kernel 的环境变量</span></div><div class="line">    <span class="comment">%% inet_dist_base_port 里指定, 则默认为</span></div><div class="line">    <span class="comment">%% 4370, 比epmd端口大1。</span></div><div class="line">    BasePort = application:get_env(kernel, inet_dist_base_port, <span class="number">4370</span>),</div><div class="line"></div><div class="line">    <span class="comment">%% 现在，算出我们相对于基端口号的偏移值。</span></div><div class="line">    <span class="comment">%% 这个偏移值就是我们节点名的@符号左边的数字。</span></div><div class="line">    <span class="comment">%% 如果这个数字不存在，则偏移量设置为0。</span></div><div class="line">    <span class="comment">%%</span></div><div class="line">    <span class="comment">%% 同时我们也处理主机名没有指定的情况。</span></div><div class="line">    NodeName = re:replace(Name, <span class="string">"@.*$"</span>, <span class="string">""</span>),</div><div class="line">    Offset =</div><div class="line">        <span class="keyword">case</span> re:run(NodeName, <span class="string">"[0-9]+$"</span>, [&#123;capture, first, list&#125;]) <span class="keyword">of</span></div><div class="line">            nomatch -&gt;</div><div class="line">                <span class="number">0</span>;</div><div class="line">            &#123;match, [OffsetAsString]&#125; -&gt;</div><div class="line">                list_to_integer(OffsetAsString)</div><div class="line">        <span class="keyword">end</span>,</div><div class="line"></div><div class="line">    BasePort + Offset.</div></pre></td></tr></table></figure>
<p>同时我们还要写一个模块用作 -epmd_module。有一点小复杂就是因为OTP19.0期望这个模块导出 register_node/2 函数，而从OTP19.1开始则是期望导出 register_node/3 函数。我们把这两个函数都包含进去。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_epmd_client)</span>.</div><div class="line"></div><div class="line"><span class="comment">%% epmd_module 回调函数</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>,</span></div><div class="line">         register_node/<span class="number">2</span>,</div><div class="line">         register_node/<span class="number">3</span>,</div><div class="line">         port_please/<span class="number">2</span>,</div><div class="line">         names/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="comment">%% 监督者模块 erl_distribution 尝试着把我们当做一个被监督的子进程。</span></div><div class="line"><span class="comment">%% 我们不需要子进程，所以返回 ignore 。</span></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    ignore.</div><div class="line"></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(_Name, _Port)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 本函数是我们连接epmd并告诉它我们监听哪个端口，</span></div><div class="line">    <span class="comment">%% 不过因为我们是无epmd的，所以我们不需要做这些。</span></div><div class="line"></div><div class="line">    <span class="comment">%% 需要返回一个1到3的 ”creation” 数字。</span></div><div class="line">    Creation = rand:uniform(<span class="number">3</span>),</div><div class="line">    &#123;ok, Creation&#125;.</div><div class="line"></div><div class="line"><span class="comment">%% 从Erlang/OTP19.1开始，register_node/3函数替代register_node/2函数，</span></div><div class="line"><span class="comment">%% 该函数多了一个地址族的入参，取值为 ‘inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line"><span class="comment">%% 这一点对我们来说没有多大的改动。</span></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(Name, Port, _Family)</span> -&gt;</span></div><div class="line">    register_node(Name, Port).</div><div class="line"></div><div class="line"><span class="function"><span class="title">port_please</span><span class="params">(Name, _IP)</span> -&gt;</span></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line">    <span class="comment">%% 分布式协议版本从Erlang/OTP16开始就是5。</span></div><div class="line">    Version = <span class="number">5</span>,</div><div class="line">    &#123;port, Port, Version&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">names</span><span class="params">(_Hostname)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 因为我们没有epmd，所以我们真的不知道此处是否有其他节点。</span></div><div class="line">    &#123;error, address&#125;.</div></pre></td></tr></table></figure>
<p>正如你所见，大多数事情基本完成了。</p>
<p>当这个模块被加为 erl_distribution 监督者的子进程的时候，start_link/0 将被调用。我们并不需要在这个启动一个进程，因此我们只是返回 ignore。</p>
<p>register_node函数通常会连接epmd并告诉它我们使用哪一个端口。epmd将返回一个“creation”数字。“creation”数字上一个介于1和3的整数。epmd跟踪每一个节点名字的“creation”数字并且当一个确定名字的节点重连的时候增加这个数字。这意味着它可以区分先前某一个节点“存活期间”的进程id。</p>
<p>既然我们没有epmd，那么我们就没有获得它跟踪节点生命周期的好处。在这里我们返回一个随机数，它有三分之二的机会不同于前面的“creation”数字。</p>
<p>port_please/2 获取远程主机的IP地址以便连接它的epmd，但是我们不关心这些；我们用我们自己的算法来算出我们的端口号。</p>
<p>我们也需要返回一个分布式协议版本号。从Erlang/OTP 6开始它就是5（参阅 <a href="http://erlang.org/doc/apps/erts/erl_dist_protocol.html" target="_blank" rel="external">分布式协议官方文档</a> ），就这么简单。</p>
<p>最后，names/1 函数被调用来返回某个主机上的Erlang节点列表。我们没有办法知道这些信息，所以让我们假装我们连接不上这个主机。</p>
<p>目前为止，一起都顺利。但是我们需要一个方法来确认我们正侦听在合适的端口上。我认为最好的方法是写一个新的分布式协议模块，该模块仅是设置端口号而让真正的协议模块做它自己的事情：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_dist)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([listen/<span class="number">1</span>,</span></div><div class="line">         select/<span class="number">1</span>,</div><div class="line">         accept/<span class="number">1</span>,</div><div class="line">         accept_connection/<span class="number">5</span>,</div><div class="line">         setup/<span class="number">5</span>,</div><div class="line">         close/<span class="number">1</span>,</div><div class="line">         childspecs/<span class="number">0</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">listen</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 在此处我们算出我们想要侦听在什么端口。</span></div><div class="line"></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line"></div><div class="line">    <span class="comment">%% 设置 “最小” 和 “最大” 两个变量，强制侦听端口为一个值。</span></div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_min, Port),</div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_max, Port),</div><div class="line"></div><div class="line">    <span class="comment">%% 最后运行真正的函数！</span></div><div class="line">    inet_tcp_dist:listen(Name).</div><div class="line"></div><div class="line"><span class="function"><span class="title">select</span><span class="params">(Node)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:select(Node).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept_connection</span><span class="params">(AcceptPid, Socket, MyNode, Allowed, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">setup</span><span class="params">(Node, Type, MyNode, LongOrShortNames, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:setup(Node, Type, MyNode, LongOrShortNames, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">close</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:close(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">childspecs</span><span class="params">()</span> -&gt;</span></div><div class="line">    inet_tcp_dist:childspecs().</div></pre></td></tr></table></figure>
<p>几乎所有的代码都在这。listen/1函数在将控制权交给真正的处理模块inet_tcp_dist前，根据我们的节点名来设置inet_dist_listen_min和inet_dist_listen_max两个变量。</p>
<p>（请注意：虽然inet_tcp_dist是默认的处理模块，但是它仅提供基于IPv4上的未加密连接。如果你想用IPv6，你应该用inet6_tcp_dist，而如果你想用<a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">基于TLS上的Erlang分布式功能</a>，那就应该选择inet_tsl_dist或inet6_tsl_dist。增加这些弹性的尝试留给读者自己练习。）</p>
<p>我们准备好了！现在我们启动两个节点，foo1和foo2，并且使它们彼此互连：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo1</div><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo2</div></pre></td></tr></table></figure>
<p>系统能正常运行吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(foo2@poki-sona-sin)<span class="number">1</span>&gt; net_adm:ping('foo1@poki-sona-sin').</div><div class="line">pong</div></pre></td></tr></table></figure>
<p>看起来没问题！</p>
<h1 id="接着在Elixir下尝试"><a href="#接着在Elixir下尝试" class="headerlink" title="接着在Elixir下尝试"></a>接着在Elixir下尝试</h1><p>当然，因为Erlang和Elixir都运行在同样的虚拟机上，那么就没有什么可以阻止我们在Elixir里实现上述功能了。</p>
<p>在Elixir里，我们可以将所有代码放在一个单独文件里，编译器会将它编译成我们需要的不同的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个包含根据一个节点名来决定端口号的函数的模块。</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_atom(name) <span class="keyword">do</span></div><div class="line">    dist_port Atom.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_list(name) <span class="keyword">do</span></div><div class="line">    dist_port List.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_binary(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 算出基端口。如果没有指定则用</span></div><div class="line">    <span class="comment"># inet_dist_base_port 这个kernel的环境变量,</span></div><div class="line">    <span class="comment"># 默认值是4370, 比epmd的端口大1。</span></div><div class="line">    base_port = <span class="symbol">:application</span>.get_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_base_port</span>, <span class="number">4370</span></div><div class="line"></div><div class="line">    <span class="comment"># 现在，基于基端口算出我们的“偏移量”。</span></div><div class="line">    <span class="comment"># 偏移量就是一个我们节点名@符号左边的整数。</span></div><div class="line">    <span class="comment"># 如果这个整数不存在，则偏移量是0。</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># 也处理主机名没有指定的情况。</span></div><div class="line">    node_name = Regex.replace ~r/@.*<span class="variable">$/</span>, name, <span class="string">""</span></div><div class="line">    offset =</div><div class="line">      <span class="keyword">case</span> Regex.run ~r/[<span class="number">0</span>-<span class="number">9</span>]+<span class="variable">$/</span>, node_name <span class="keyword">do</span></div><div class="line">    <span class="keyword">nil</span> -&gt;</div><div class="line">      <span class="number">0</span></div><div class="line">    [offset_as_string] -&gt;</div><div class="line">      String.to_integer offset_as_string</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    base_port + offset</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_dist</span></span> <span class="keyword">do</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 此处我们算出我们想要侦听的端口。</span></div><div class="line"></div><div class="line">    port = Epmdless.dist_port name</div><div class="line"></div><div class="line">    <span class="comment"># 设置“min”和“max”变量，强制两个端口为一个值。</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_min</span>, port</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_max</span>, port</div><div class="line"></div><div class="line">    <span class="comment"># 最后运行真正的函数！</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.listen name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(node) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.select node</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept_connection</span></span>(accept_pid, socket, my_node, allowed, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept_connection accept_pid, socket, my_node, allowed, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>(node, type, my_node, long_or_short_names, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.setup node, type, my_node, long_or_short_names, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.close listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">childspecs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.childspecs</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_epmd_client</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># erl_distribution想要我们启动一个工作进程，然而我们并不需要。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ignore</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 因为Erlang/OTP 19.1用register_node/3来替换register_node/2，</span></div><div class="line">  <span class="comment"># 只是多传了一个参数：地址族，’inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line">  <span class="comment"># 这对于我们来说没什么问题。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(name, port, _family) <span class="keyword">do</span></div><div class="line">    register_node(name, port)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(_name, _port) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 在此处我们应该连接epmd并告诉它哪个是我们侦听的端口，</span></div><div class="line">    <span class="comment"># 但是因为我们是无epmd的，所以我们不需要这么做。</span></div><div class="line"></div><div class="line">    <span class="comment"># 需要返回一个介于1和3的"creation”数字。</span></div><div class="line">    creation = <span class="symbol">:rand</span>.uniform <span class="number">3</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, creation&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">port_please</span></span>(name, _ip) <span class="keyword">do</span></div><div class="line">    port = Epmdless.dist_port name</div><div class="line">    <span class="comment"># 分布式协议版本数字从Erlang/OTP R6开始就是5。</span></div><div class="line">    version = <span class="number">5</span></div><div class="line">    &#123;<span class="symbol">:port</span>, port, version&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">names</span></span>(_hostname) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 既然我们没有epmd，那么我们就不真正需要知道其他节点。</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:address</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们启动Elixir，我们需要用 - -erl 来传递一些参数来使得功能启用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --erl <span class="string">"-proto_dist Elixir.Epmdless -start_epmd false -epmd_module Elixir.Epmdless_epmd_client"</span> --sname foo3</div></pre></td></tr></table></figure>
<p>让我们ping我们前面已经启动的两个节点：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">1</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo1@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">2</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo2@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div></pre></td></tr></table></figure>
<p>它们都连通了并且没有epmd参与！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文描述的只是其中一种不需要epmd的Erlang分布式方式；我相信你可以用别的办法来更好地符合你的需求。我希望上述的示例代码是有用的指南！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epmd（Erlang端口映射守护进程）端口4369，&lt;/li&gt;
&lt;li&gt;Erlang节点自己的端口，一个不可预知的大数字端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的&lt;a href=&quot;http://erlang.org/doc/man/kernel_app.html&quot;&gt;kernel文档&lt;/a&gt;里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="distribution" scheme="http://szpzs.oschina.io/categories/Erlang/distribution/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="epmd" scheme="http://szpzs.oschina.io/tags/epmd/"/>
    
  </entry>
  
  <entry>
    <title>Erlang快速安装</title>
    <link href="http://szpzs.oschina.io/2016/09/28/erlang-quick-install/"/>
    <id>http://szpzs.oschina.io/2016/09/28/erlang-quick-install/</id>
    <published>2016-09-28T14:01:48.000Z</published>
    <updated>2016-10-13T12:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/erlang-logo.png" style="border:0;"><br>在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的<a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank" rel="external">完全安装指引</a>。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。</p>
<ul>
<li><a href="#part1">在Mac OS X上安装Erlang</a></li>
<li><a href="#part2">在Linux上安装Erlang</a></li>
<li><a href="#part3">在Windows上安装Erlang</a></li>
<li><a href="#part4">用最新版本预编译包安装Erlang</a></li>
<li><a href="#part5">从源码编译安装Erlang</a></li>
</ul>
<a id="more"></a>
<h2 id="在Mac-OS-X上安装Erlang"><a href="#在Mac-OS-X上安装Erlang" class="headerlink" title="在Mac OS X上安装Erlang"></a><span id="part1">在Mac OS X上安装Erlang</span></h2><p><strong>使用HomeBrew来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install erlang</div></pre></td></tr></table></figure>
<p><strong>用MacPorts来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install erlang</div></pre></td></tr></table></figure>
<h2 id="在Linux上安装Erlang"><a href="#在Linux上安装Erlang" class="headerlink" title="在Linux上安装Erlang"></a><span id="part2">在Linux上安装Erlang</span></h2><p>大多数操作系统在它们的包管理系统里有预构建的Erlang发行版本。</p>
<p><strong>在Ubuntu和Debian下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install erlang</div></pre></td></tr></table></figure>
<p><strong>在Fedora下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<p><strong>在FreeBSD下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pkg update</div><div class="line">sudo pkg install erlang</div></pre></td></tr></table></figure>
<h2 id="在Windows上安装Erlang"><a href="#在Windows上安装Erlang" class="headerlink" title="在Windows上安装Erlang"></a><span id="part3">在Windows上安装Erlang</span></h2><p><a href="http://www.erlang.org/download.html" target="_blank" rel="external">直接下载安装程序来安装</a></p>
<h2 id="用最新版本预编译包安装Erlang"><a href="#用最新版本预编译包安装Erlang" class="headerlink" title="用最新版本预编译包安装Erlang"></a><span id="part4">用最新版本预编译包安装Erlang</span></h2><p>你在寻找最新的稳定Erlang版本或者前一个Erlang版本吗？<a href="https://www.erlang-solutions.com/" target="_blank" rel="external">Erlang Solutions</a> 给OS X，Windows，Ubuntu，Debian，Fedora，CentOS，Raspbian 以及其他平台都提供了一个<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp" target="_blank" rel="external">预编译安装包</a>。它们也提供了一个企业级Erlang发行版。</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="external">从Erlang Solutions下载</a></p>
<h2 id="从源码编译安装Erlang"><a href="#从源码编译安装Erlang" class="headerlink" title="从源码编译安装Erlang"></a><span id="part5">从源码编译安装Erlang</span></h2><p>你可以用Kerl脚本在你自己的机器上从源码来构建Erlang。Kerl是一个脚本，它使得你用几个命令就轻松地构建不同版本的Erlang。</p>
<p><strong>下载Kerl指令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O https://raw.githubusercontent.com/spawngrid/kerl/master/kerl</div><div class="line">chmod +x kerl</div></pre></td></tr></table></figure>
<p>选择一个可用的Erlang源码发行版本并且像如下指令一样来构建它（在这个例子里，我们选择18.0版本并且命名它为mybuild-18.0）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list releases</div><div class="line">./kerl build 18.0 mybuild-18.0</div></pre></td></tr></table></figure>
<p>选择一个目录来安装，例如 ~/erlang-r16b03</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list builds</div><div class="line">./kerl install mybuild-18.0 ~/erlang-18.0</div></pre></td></tr></table></figure>
<p>最后，把目录 ~/erlang-18.0/bin 加到你的环境变量 $PATH 里。</p>
<p><strong>搞定！</strong></p>
<p>在你的终端运行erl来启动一个Erlang shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 18 [erts-7.0] [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.0  (abort with ^G)</div><div class="line">1&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634" target="_blank" rel="external">https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/erlang-logo.png&quot; style=&quot;border:0;&quot;/&gt;&lt;br&gt;在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的&lt;a href=&quot;http://www.erlang.org/doc/installation_guide/INSTALL.html&quot;&gt;完全安装指引&lt;/a&gt;。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#part1&quot;&gt;在Mac OS X上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part2&quot;&gt;在Linux上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part3&quot;&gt;在Windows上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part4&quot;&gt;用最新版本预编译包安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part5&quot;&gt;从源码编译安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/categories/Erlang/install/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/tags/install/"/>
    
      <category term="HomeBrew" scheme="http://szpzs.oschina.io/tags/HomeBrew/"/>
    
      <category term="MacPorts" scheme="http://szpzs.oschina.io/tags/MacPorts/"/>
    
      <category term="Kerl" scheme="http://szpzs.oschina.io/tags/Kerl/"/>
    
  </entry>
  
  <entry>
    <title>往Elixir里的Map塞东西</title>
    <link href="http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/"/>
    <id>http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/</id>
    <published>2016-09-27T10:57:03.000Z</published>
    <updated>2016-09-27T11:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Elixir的<a href="http://elixir-lang.org/docs/stable/elixir/Map.html" target="_blank" rel="external">Map</a>模块提供了一些不同的函数来操作map数据结构。其中一个函数就是<a href="http://elixir-lang.org/docs/stable/elixir/Map.html#put/3" target="_blank" rel="external">Map.put/3</a> 。这个函数允许你将一个健值对放入一个map中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">9</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">10</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果这个键对于此map来说是新的话，这个键值对就简单地加入map。如果这个键对于此map来说是已存在的，那么对应的老的值则被新的值替换。</p>
<p>同样的效果可以用Map.merge/2来实现。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">10</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">11</span>, <span class="symbol">bulbasaur:</span> <span class="number">14</span>&#125;)</div><div class="line">%&#123;<span class="symbol">bulbasaur:</span> <span class="number">14</span>, <span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">11</span>&#125;</div></pre></td></tr></table></figure>
<p>Map.merge/2的优势是它的灵活性。它能够更容易地在不同情况下使用。它甚至允许一次增加并且替换多个健值对。因为两个入参都是map，它让我们感觉到更容易阅读。</p>
<p>也有一个语法糖的方法，就是用map字面符号和一个管道来替换已经存在的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = %&#123;pokemon | <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>这个是最简洁的方法，但是，它仅仅是用来替换一个健值对。如果这个键不存在map中，则一个错误将发生。</p>
<p>除此之外当然还有其他函数来设置值到map中，包括 <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/3" target="_blank" rel="external">Kernel.put_in/3</a> 和 <a href="http://elixir-lang.org/docs/stable/elixir/Map.html#get_and_update/3" target="_blank" rel="external">Map.get_and_update/3</a> 。然而上述几个方法是我自己最经常接触到的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/" target="_blank" rel="external">http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elixir的&lt;a href=&quot;http://elixir-lang.org/docs/stable/elixir/Map.html&quot;&gt;Map&lt;/a&gt;模块提供了一些不同的函数来操作map数据结构。其中一个函数就是&lt;a href=&quot;http://elixir-lang.org/docs/stable/elixir/Map.html#put/3&quot;&gt;Map.put/3&lt;/a&gt; 。这个函数允许你将一个健值对放入一个map中。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = %&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = Map.put(pokemon, &lt;span class=&quot;symbol&quot;&gt;:squirtle&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;squirtle:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = Map.put(pokemon, &lt;span class=&quot;symbol&quot;&gt;:squirtle&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;squirtle:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Map" scheme="http://szpzs.oschina.io/categories/Elixir/Map/"/>
    
    
      <category term="merge" scheme="http://szpzs.oschina.io/tags/merge/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Map" scheme="http://szpzs.oschina.io/tags/Map/"/>
    
      <category term="put" scheme="http://szpzs.oschina.io/tags/put/"/>
    
  </entry>
  
  <entry>
    <title>原子之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/09/20/eli5-atoms/"/>
    <id>http://szpzs.oschina.io/2016/09/20/eli5-atoms/</id>
    <published>2016-09-20T15:36:59.000Z</published>
    <updated>2016-09-21T00:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img alt="Atom Table" src="/images/eli5-atom-tab.png" style="border: 0;"><br><a id="more"></a><br>原子表是一个全局表，它将原子内部值（一个整数值）映射到一个字符串。同时也有一个反向的查询表，它将一个字符串映射到一个原子内部值。原子表有一个固定的记录条数上限：1048576。如果它一旦到达了这个上限，当前节点将崩溃 －－ 这就是为什么在运行时动态创建原子是很危险的做法。原子表的记录条数上限可以通过给erl命令指定 +t 标签来设置。</p>
<p>原子是在运行时不能改变它的值的一个符号。当一个新的原子被创建，它得到一个唯一的值来给当前节点来使用。原子在系统内部仅仅是指向原子表对应记录索引的整数值。这就是为什么原子的操作如此廉价的原因。</p>
<p>BEAM装载器例程读取原子值并且在原子表里查询它们。它将它们的整数值标记为原子<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>来替代原子名称。然后代码只是操作这些立即数而不是它们的名称。</p>
<p>这些内部值不能当做整数（通过网络或磁盘）离开节点。这是因为其他节点对于相通的原子有不同的内部值。因此当原子离开当前节点的时候都被转换为字符串。这会影响到BEAM文件，外部pid，外部port，Mnesia或DETS里的原子等等。这就是为什么一些开发者更喜欢给数据库字段名使用短原子名称的原因 －－ 它们将以字符串的形式出现在数据库数据中。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img alt=&quot;Atom Table&quot; src=&quot;/images/eli5-atom-tab.png&quot; style=&quot;border: 0;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/categories/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/categories/BEAM/Atom/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/tags/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>BEAM虚拟机之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/09/20/eli5-vm/"/>
    <id>http://szpzs.oschina.io/2016/09/20/eli5-vm/</id>
    <published>2016-09-20T15:30:05.000Z</published>
    <updated>2016-09-20T15:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。</p>
<a id="more"></a>
<h2 id="寄存器和调用"><a href="#寄存器和调用" class="headerlink" title="寄存器和调用"></a>寄存器和调用</h2><p>作为一个寄存器虚拟机就意味着在函数调用的时候不是通过栈而是用寄存器来传递参数。它们与我们所理解的CPU架构中的寄存器不一样，而只是一个Erlang数据结构的值所组成的数组。这样的寄存器有1024个，但是有这么多入参的函数几乎不存在，所以通常虚拟机仅仅使用了前面3到10个寄存器。</p>
<p>例如，当调用一个有三个入参的函数的时候，寄存器x0，x1和x2分别被设置为三个入参值。如果我们需要进行递归调用，我们将不得不改写寄存器并丢失它们的原始值。在这种情况下，我们将需要保存旧的值到栈中。除了栈帧外没有动态栈分配，这是由编译器决定的。</p>
<p>每一个进程有自己的寄存器集。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>BEAM指令集包含大约158个基本指令，它们中的大部分可以通过调用 erlc -S yourfile.erl 生成汇编文件来查看到。每一个指令有零或多个参数。不同的技巧用来在便携方式和紧凑方式编码参数。例如，代码中的位置定位（也叫做标签）是用它们的索引来编码的，并且代码装载器后续会把它们翻译成内存地址。</p>
<p>在BEAM代码装载过程中，一些混合的操作码被更快的操作码替换。这个优化的技巧叫做超级指令。对于每一个操作码，在beam_emu.c文件中都有一个C标签对应的一段代码。一个C标签组成的数组存储在同一个虚拟机循环例程的尾部并且被当作查询表来使用。</p>
<p>请参见：<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-file.html" target="_blank" rel="external">BEAM文件格式</a>。<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-instructions.html" target="_blank" rel="external">BEAM指令代码</a>。</p>
<h2 id="线程虚拟机循环"><a href="#线程虚拟机循环" class="headerlink" title="线程虚拟机循环"></a>线程虚拟机循环</h2><p>装载操作码被标签地址替换后，紧跟着它们的是参数。例如，操作码 ＃1，一个来自标签数组第一索引元素被置于在代码内存。</p>
<p>这种方式很容易跳转到处理下一个操作码的 C 代码中的某个位置。只需要读一个 void* 指针并执行一个goto *p 的动作。此功能是C和C++编译器的一个扩展。这种类型的虚拟机循环称为直接线程调度虚拟机循环。</p>
<p>其他虚拟机循环的类型有：</p>
<ul>
<li>切换调度虚拟机（如果C编译器拒绝支持标签扩展，则这种类型被BEAM虚拟机源使用）。它也比直接线程调度虚拟机慢20%至30%；</li>
<li>直接调用线程</li>
<li><a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html" target="_blank" rel="external">其他</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-vm.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-vm.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。&lt;/p&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/categories/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.oschina.io/categories/BEAM/VM/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/tags/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.oschina.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>我最喜欢的erlang程序</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/</id>
    <published>2016-09-20T15:17:15.000Z</published>
    <updated>2016-09-20T15:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。</p>
<p>他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。</p>
<a id="more"></a>
<h1 id="通用服务器"><a href="#通用服务器" class="headerlink" title="通用服务器"></a>通用服务器</h1><p>一般来说服务器都是做特定的事情的。一个HTTP服务器响应HTTP请求而一个FTP服务器响应FTP请求，等等。那么什么是通用服务器呢？我们肯定能归纳出一个服务器的概念，然后做出一个通用服务器，并且我们可以在晚些时候让它变成一个特定的服务器。</p>
<p>下面就是我的通用服务器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">universal_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;become, F&#125; -&gt;</div><div class="line">            F()</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个服务器相当简单。一旦我创建了一个通用服务器，它只是呆在那里等待一个 {become, F}消息，收到这样的消息后，他就变成了F服务器。</p>
<h1 id="阶乘服务器"><a href="#阶乘服务器" class="headerlink" title="阶乘服务器"></a>阶乘服务器</h1><p>一个阶乘服务器就是等待一个整数然后返回这个整数的阶乘。下面就是非常简单的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">factorial_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;From, N&#125; -&gt;</div><div class="line">            From ! factorial(N),</div><div class="line">            factorial_server()</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(N)</span> -&gt;</span> N * factorial(N-<span class="number">1</span>).</div></pre></td></tr></table></figure>
<p>现在我们已经准备好high起来了。</p>
<h1 id="把它们集成起来"><a href="#把它们集成起来" class="headerlink" title="把它们集成起来"></a>把它们集成起来</h1><p>我将写一个小函数来创建一个通用服务器，然后给它发送“变成阶乘服务器”消息，接着我将发送一个整数给它，等它返回结果并打印出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></div><div class="line">    Pid = spawn(fun universal_server/0), Pid ! &#123;become, fun factorial_server/0&#125;,</div><div class="line">    Pid ! &#123;self(), <span class="number">50</span>&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        X -&gt;</div><div class="line">            X</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这些函数都属于这个模块  <a href="http://joearms.github.io/code/fav1.erl" target="_blank" rel="external">/code/fav1.erl</a>.</p>
<p>现在我们需要做的就是启动一个Erlang shell并运行这个测试程序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line"><span class="number">1</span> &gt; c(fav1).</div><div class="line">&#123;ok, fav1&#125;</div><div class="line"><span class="number">2</span> &gt; fav1:test().</div><div class="line"><span class="number">30414093201713378043612608166064768844377641568960512000000000000</span></div></pre></td></tr></table></figure>
<h1 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h1><p>多年前当我在SICS的时候，我接触到 <a href="http://www.planet-lab.org/" target="_blank" rel="external">Planet 实验室</a>。Planet 实验室是一个有9000台计算机的研究网络。加入Planet实验室很容易，你所要做的是买一台标准PC，将它连接到网络并捐献它的使用给Planet实验室组织。你捐献你的机器给这个网络，相应的你可以使用Planet实验室里的所有其他机器。</p>
<p>Planet实验室是一个为分布式应用的真实世界的测试环境，它当前有1171个节点在562个站上。</p>
<p>当时我要用Planet实验室来做什么呢？我也不知道。最终我做的是写一些脚本在所有Planet实验的机器上安装了空转的通用服务器（和本文的代码很相似）。然后我设计了一套goosip算法来给这个网络发送 <strong>become</strong> 消息。这样我就有了一个空转的网络，我可以在数秒内将它变成我想要的任何服务器。</p>
<p>大概一年后，我必须要写一篇论文。作为一个研究者，最不划算的一个事情就是为了挣钱养家你必须要写关于这样或那样的论文，这样的论文所写的从来不是你当时感兴趣的，但是却一定是关于资助你研究的项目所期望读到的。</p>
<p>我已经在Planet实验室上建立了我的gossip网络，我可以让它成为任何服务器，因此我让它成为一个内容分发网络并且用一个gossip算法来将一个同样的文件拷贝到这个网络上的所有机器上。最后我把这件事写成一篇论文然后大家都哈皮了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html" target="_blank" rel="external">http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。&lt;/p&gt;
&lt;p&gt;他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的事件驱动应用</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/</id>
    <published>2016-09-20T14:42:13.000Z</published>
    <updated>2016-09-20T15:16:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://en.wikipedia.org/wiki/Event_%28computing%29" target="_blank" rel="external">事件</a> 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门<a href="http://www.erlang.org/doc/design_principles/events.html" target="_blank" rel="external">一章</a>是关于事件的，还有一种 <a href="http://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="external">事件驱动架构</a> 可以让你的代码和架构更牛X：</p>
<ul>
<li>它更易于将你的代码真正地解耦。</li>
<li>它打开了一扇门，通往令人感兴趣的新的架构模式，比如 <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="external">CQRS</a>（命令查询职责分离模式），<a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="external">event sourcing</a>（事件源模式），和<br><a href="http://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="external">event collaboration</a>（事件合作模式）。</li>
<li>应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。</li>
<li>事件和命令能够被非常小的事件处理器来处理。</li>
<li>如果你真的要用事件来开发系统，那么就可能像<a href="http://www.rabbitmq.com/" target="_blank" rel="external">rabbitmq</a>，<a href="http://www.zeromq.org/" target="_blank" rel="external">0mq</a>一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：</li>
<li>系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。</li>
<li>为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。</li>
<li>一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。</li>
</ul>
<a id="more"></a>
<p>Erlang已经提供了一种方式来实现事件驱动架构：gen_event 行为。<a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event</a> 是 Erlang/OTP 自带的<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id59741" target="_blank" rel="external">默认行为</a>之一。对我来说，它也是Erlang/OTP最酷的特性之一，因为你在许多语言或环境里都无法得到这样开箱即用（并且免费）的特性，因此这真的是非常棒。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>Gen_event 有一个或多个事件管理器、事件处理器，来派发和处理事件：</p>
<p><strong>事件管理器</strong>：一个事件管理器是一个 gen_event 进程。<br><strong>事件处理器</strong>：事件处理器是正真处理事件的回调模块，并且被注册到一个或多个事件管理器。<br><strong>事件</strong>：一个事件是任何erlang term，比如一个元组，一个原子，一个列表，等等。</p>
<p>在某些方面，gen_event 用起来像<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>里的<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external">EventEmitter</a>类，在概念上说也像<a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>。这个概念是有某种事件总线（事件管理器）负责接收来自系统的事件并且将它们路由到相应的监听者。其基本的工作流如下：</p>
<ul>
<li>创建一个或者多个实现 <a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event<br>行为</a><br>的回调模块。在本文末尾的<strong>附录B</strong>里有完整的例子。</li>
<li>启动一个事件管理器进程。</li>
<li>注册一个或者多个事件处理器到事件管理器上。</li>
<li>通过事件管理器派发事件。</li>
<li>在你的事件处理器里异步（同步）处理派发过来的事件。</li>
</ul>
<p>现在让我们按顺序研究上述每一步。</p>
<h1 id="启动一个事件管理器"><a href="#启动一个事件管理器" class="headerlink" title="启动一个事件管理器"></a>启动一个事件管理器</h1><p>这就是调用如下函数一样简单：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start().</div></pre></td></tr></table></figure>
<p>或者你计划把你的事件管理器包含在一个<a href="http://www.erlang.org/doc/design_principles/sup_princ.html" target="_blank" rel="external">监督树</a>里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link().</div></pre></td></tr></table></figure>
<h2 id="用一个给定的名字注册一个事件管理器"><a href="#用一个给定的名字注册一个事件管理器" class="headerlink" title="用一个给定的名字注册一个事件管理器"></a>用一个给定的名字注册一个事件管理器</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start(my_event_bus).</div></pre></td></tr></table></figure>
<p>或者也可以：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link(my_event_bus).</div></pre></td></tr></table></figure>
<p>这些函数与start/0以及start_link/0的目的一样，只是它们允许你用一个指定的名字注册一个新的事件管理器。引述<a href="http://www.erlang.org/doc/man/gen_event.html#start_link-1" target="_blank" rel="external">官方文档</a>如下：</p>
<p>如果 EventMgrName={local, Name}，这个事件管理器被以Name为名字用 register/2 本地注册。</p>
<p>如果 EventMgrName={global, GlobalName}，这个事件管理器被以GlobalName为名字用 global:register_name/2 全局注册。</p>
<p>如果没有名字提供，则这个事件管理器不能被注册。</p>
<p>如果 EventManager={via, Module, ViaName}，这个事件管理器将被Module注册到系统。这个回调模块Module应该导出如下函数 register_name/2 ，unregister_name/1 ，whereis_name/1 and send/2，这些函数和global模块里的相应函数的行为一样。因此，{via, global, GlobalName} 是一个有效的引用。</p>
<h1 id="注册事件处理器"><a href="#注册事件处理器" class="headerlink" title="注册事件处理器"></a>注册事件处理器</h1><p>一旦你已经有了你的事件管理器并且把它运行起来了，就该通过用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_handler/3</a> 来添加一些事件处理器了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>上述函数将添加一个新的事件处理器到指定的事件管理器（你传入的第一个入参所指的）。事件管理器可以用如下几种方式指定：</p>
<ul>
<li>进程PID。</li>
<li>Name，如果事件管理器是本地注册的。</li>
<li>{Name, Node}，如果事件管理器是在另一个节点本地注册的，或者 {global,<br>GlobalName}，如果事件管理器是全局注册的。</li>
<li>{via, Module, ViaName}，如果事件管理器的注册是通过一个替代进程注册的。</li>
</ul>
<p>第二个入参指定事件处理器的模块名，不过它也可以是{Module, Id}，Module是回调模块的名字，而当有多个事件处理器用同一个回调模块的时候，Id则用于识别指定的事件处理器。</p>
<p>紧接着my_event_handler里的回调函数 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:init-1" target="_blank" rel="external">init/1</a> 被调用，传给 add_handler/3 的第三个入参将原封不动地传给 init/1 做入参。init/1 可能返回：</p>
<p>如果成功，函数将返回{ok, State} 或 {ok, State, hibernate}，State是事件处理器内部初始状态。</p>
<p>如果返回{ok, State, hibernate}，事件管理器将通过调用 proc_lib:hibernate/3 进入冬眠状态，一直等到下一个事件发生。</p>
<h2 id="被监督的事件处理器"><a href="#被监督的事件处理器" class="headerlink" title="被监督的事件处理器"></a>被监督的事件处理器</h2><p>你可以用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_sup_handler/3</a> 在调用进程（也就是注册新事件处理器的进程）和事件处理器自己之间建立某种形式的监测（或监督）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_sup_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>正如官方文档描述：</p>
<p>如果调用进程后续因为原因Reason而终止，事件管理器将通过用 {stop, Reason} 作为入参调用 Module:terminate/2 来删除事件处理器。</p>
<p>如果事件处理器后来被删除，事件管理器给调用进程发送一个消息 {gen_event_EXIT, Handler, Reason}。Reaseon是下列之一：</p>
<pre><code>normal，如果事件处理器因为 delete_handler/3 的调用而被删除，或者被一个回调函数（见下面段落）返回 remove_handler 。

shutdown，如果事件处理器因为事件管理器结束而被删除。

{swapped, NewHandler, Pid}，如果进程Pid已经调用 swap_handler/3 或 swap_sup_handler/3 来用另一个事件处理器 NewHandler 替换了当前事件处理器。一个term，如果事件处理器因为一个错误而被删除。term的值是依据错误而来的。
</code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>事件处理器是按顺序执行的，所以要尽量保持它的代码短小。如果你需要有上千个事件处理器，那么实现某种<a href="https://gist.github.com/1230182" target="_blank" rel="external">转发器</a>是更好的选择。转发器的思路是有好几个子gen_event订阅一个主gen_event。这样将负载分发给所有感兴趣的监听者。</p>
<p>另一方面，如果你必需要在一个事件处理器里做费时的操作，你应该尝试用一个 <a href="https://gist.github.com/4474770" target="_blank" rel="external">gen_event caster</a>，他将监听事件并派发独特的（普通的）erlang消息。</p>
<p>我们也要注意，当一个被监督的事件处理器退出的时候，gen_event讲给所有的事件处理器<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L319" target="_blank" rel="external">发送消息</a>，因此要准备好如何处理这些消息。</p>
<h1 id="派发事件"><a href="#派发事件" class="headerlink" title="派发事件"></a>派发事件</h1><p>通过事件管理器派发一个事件实际上是相当简单的，仅仅需要调用 <a href="http://www.erlang.org/doc/man/gen_event.html#notify-2" target="_blank" rel="external">gen_event:notify/2</a> 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>你可以在本文的<strong>附录A</strong>里看到gen_event如何派发一个事件的具体细节。</p>
<p>这个函数将异步地派发这个事件。这意味着这个函数调用将不会阻塞而是立即返回。也有同步派发事件的方式，就是使用函数 <a href="http://www.erlang.org/doc/man/gen_event.html#sync_notify-2" target="_blank" rel="external">gen_event:sync_notify/2</a>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:sync_notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>同步在这里的意思是这个函数的调用将阻塞并仅在所有事件处理器已经被调用并且处理了这个事件后才返回。</p>
<h2 id="用消息替代-Notify-2"><a href="#用消息替代-Notify-2" class="headerlink" title="用消息替代 Notify/2"></a>用消息替代 Notify/2</h2><p>另一种方式来调用事件处理器是通过派发普通消息给事件管理器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pid ! &#123;new_user_created&#125;</div></pre></td></tr></table></figure>
<p>这将调用<strong>所有</strong>注册的事件处理器的 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数，gen_event官方文档说明如下：</p>
<p>当一个事件管理器接收到不是事件或者一个同步请求（或者一个系统消息）的任何其他消息时，每一个已经安装在这个事件管理器上的事件处理器的这个函数被调用。</p>
<h1 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h1><p>为了处理由notify/2派发的事件，你的回调模块需要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_event-2" target="_blank" rel="external">handle_event/2</a> 函数，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div></pre></td></tr></table></figure>
<p>另外，为了处理消息，要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(Info, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"Got message: ~p"</span>, [Info]),</div><div class="line">  &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>上面两个例子里的State是由 init/1 返回的数据。</p>
<p>上述两个函数返回值如下所述（当然我们还是引用官方文档）：</p>
<p>如果这个函数返回 {ok, NewState} 或者 {ok, NewState, hibernate} ，这个事件处理器将留在事件管理器里并且带着可能被修改过的内部状态NewState。</p>
<p>如果{ok, NewState, hibernate} 返回，事件管理器也将进入冬眠状态（通过调用 proc_lib:hibernate/3），并等待下一个事件的发生。只要一个事件处理器返回{ok, NewState, hibernate} 则整个事件管理器进程进入冬眠状态。</p>
<p>如果函数返回 {swap_handler, Args1, NewState, Handler2, Args2}，这个事件处理器将被 Handler2 替代，替换过程首先是调用 Module:terminate(Args1, NewState)，然后再调用 Module2:init({Args2, Term}) ，这里的Term是 Module:terminate/2 的返回值。更多信息可以查看 gen_event:swap_handler/3 。</p>
<p>如果函数返回 remove_handler ，这个事件处理器将通过调用 Module:terminate(remove_handler, State)来被删除。</p>
<h1 id="额外事项"><a href="#额外事项" class="headerlink" title="额外事项"></a>额外事项</h1><h2 id="停止事件管理器"><a href="#停止事件管理器" class="headerlink" title="停止事件管理器"></a>停止事件管理器</h2><p>停止事件管理器有时候是必须的并且通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#stop-1" target="_blank" rel="external">stop/1</a> 很容易就做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:stop(my_event_bus).</div></pre></td></tr></table></figure>
<p>这也会引起在所有已经注册的事件处理器上调用 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 。</p>
<h2 id="在一个事件处理器上调用函数"><a href="#在一个事件处理器上调用函数" class="headerlink" title="在一个事件处理器上调用函数"></a>在一个事件处理器上调用函数</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-3" target="_blank" rel="external">call/3</a> 来确切地调用一个事件处理器上指定的函数，就像你在 gen_server上做的一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;).</div></pre></td></tr></table></figure>
<p>和gen_server一样，你可以在调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-4" target="_blank" rel="external">call/4</a> 到时候指定一个超时时间：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;, <span class="number">5000</span>).</div></pre></td></tr></table></figure>
<p>gen_event将调用事件处理器模块的 handle_call/2 回调函数。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, this_is_my_reply, State&#125;.</div></pre></td></tr></table></figure>
<h2 id="删除事件处理器"><a href="#删除事件处理器" class="headerlink" title="删除事件处理器"></a>删除事件处理器</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#delete_handler-3" target="_blank" rel="external">delete_handler/3</a> 来删除你的事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:delete_handler(my_event_bus, my_event_handler, [arg1, arg2]).</div></pre></td></tr></table></figure>
<p>这个函数将从事件管理器删除这个事件处理器，而且也会将第三个参数传给 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 并调用它并将将调用结果返回。</p>
<p>列出所有已经注册的事件处理器</p>
<p>为了列出一个事件管理器当前注册的所有事件处理器，可以调用 <a href="http://www.erlang.org/doc/man/gen_event.html#which_handlers-1" target="_blank" rel="external">which_handlers/1</a> ：</p>
<p>gen_event:which_handlers(my_event_bus).</p>
<h2 id="替换-交换-事件处理器"><a href="#替换-交换-事件处理器" class="headerlink" title="替换 (交换) 事件处理器"></a>替换 (交换) 事件处理器</h2><p>通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_handler-3" target="_blank" rel="external">swap_handler/3</a> 也可以在运行时更换事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:swap_handler(my_event_bus, &#123;my_event_handler, [arg1]&#125;, &#123;my_new_event_handler, [arg2]&#125;).</div></pre></td></tr></table></figure>
<p>整个过程是：首先调用 my_event_handler:terminate([arg1], State) 然后调用 my_new_event_handler:init([arg2])，用一个新的事件处理器替换一个久的事件处理器。</p>
<p>如果老的事件处理器是被监督的，则新的事件处理器也被监督。你当然可以直接用同样的参数调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_sup_handler-3" target="_blank" rel="external">swap_sup_handler/3</a> 来做到。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>再一次我要感谢 <a href="https://github.com/elbrujohalcon" target="_blank" rel="external">Fernando “El Brujo” Benavides</a> 对本文的总体思考，关于gen_event缺陷的评论，以及他分享的gen_event转发器和caster。</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Marcelo Gornstein <a href="marcelo@inakanetworks.com">marcelo@inakanetworks.com</a></p>
<p>Github: <a href="https://github.com/marcelog" target="_blank" rel="external">marcelog</a></p>
<p>Homepage: <a href="http://marcelog.github.com/" target="_blank" rel="external">http://marcelog.github.com</a></p>
<h1 id="附录-A-gen-event实际上是如何派发一个事件的"><a href="#附录-A-gen-event实际上是如何派发一个事件的" class="headerlink" title="附录 A: gen_event实际上是如何派发一个事件的"></a>附录 A: gen_event实际上是如何派发一个事件的</h1><p>函数 notify/2 的实际调用最终在你的erlang/otp源码的 <a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl" target="_blank" rel="external">lib/stdlib/src/gen_event.erl</a> 文件的504行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="keyword">catch</span> Mod1:Func(Event, State) <span class="keyword">of</span></div></pre></td></tr></table></figure>
<p>Func是原子 handle_event 或 handle_info。所以如果你的事件处理器崩溃或不知何故失败了，事件管理器是不会崩溃的。</p>
<p>如果运行一个被监督的事件处理器（用add_sup_handler/3启动的），在同一个文件的<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L635" target="_blank" rel="external">635行</a>的 terminate/2 函数被调用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Res = (<span class="keyword">catch</span> Mod:terminate(Args, State)),</div></pre></td></tr></table></figure>
<p>另外，被监督的事件处理器，在<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L648" target="_blank" rel="external">648行</a>一个消息被发送给这个事件处理器注册到的进程</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Handler#handler.supervised <span class="keyword">of</span></div><div class="line">  <span class="literal">false</span> -&gt;</div><div class="line">      ok;</div><div class="line">  Pid -&gt;</div><div class="line">      Pid ! &#123;gen_event_EXIT,handler(Handler),Reason&#125;,</div><div class="line">      ok</div><div class="line">  <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="附录-B-回调模块样例"><a href="#附录-B-回调模块样例" class="headerlink" title="附录 B: 回调模块样例"></a>附录 B: 回调模块样例</h1><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_event_handler)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">  init/<span class="number">1</span>, terminate/<span class="number">2</span>, handle_info/<span class="number">2</span>,</div><div class="line">  handle_call/<span class="number">2</span>, code_change/<span class="number">3</span>, handle_event/<span class="number">2</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  &#123;ok, []&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, not_implemented, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(_Event, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Arg, _State)</span> -&gt;</span></div><div class="line">  ok.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://inaka.net/blog/2013/01/21/erlang-event-driven/" target="_blank" rel="external">http://inaka.net/blog/2013/01/21/erlang-event-driven/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Event_%28computing%29&quot;&gt;事件&lt;/a&gt; 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门&lt;a href=&quot;http://www.erlang.org/doc/design_principles/events.html&quot;&gt;一章&lt;/a&gt;是关于事件的，还有一种 &lt;a href=&quot;http://en.wikipedia.org/wiki/Event-driven_architecture&quot;&gt;事件驱动架构&lt;/a&gt; 可以让你的代码和架构更牛X：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它更易于将你的代码真正地解耦。&lt;/li&gt;
&lt;li&gt;它打开了一扇门，通往令人感兴趣的新的架构模式，比如 &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;（命令查询职责分离模式），&lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;event sourcing&lt;/a&gt;（事件源模式），和&lt;br&gt;&lt;a href=&quot;http://martinfowler.com/eaaDev/EventCollaboration.html&quot;&gt;event collaboration&lt;/a&gt;（事件合作模式）。&lt;/li&gt;
&lt;li&gt;应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。&lt;/li&gt;
&lt;li&gt;事件和命令能够被非常小的事件处理器来处理。&lt;/li&gt;
&lt;li&gt;如果你真的要用事件来开发系统，那么就可能像&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;rabbitmq&lt;/a&gt;，&lt;a href=&quot;http://www.zeromq.org/&quot;&gt;0mq&lt;/a&gt;一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：&lt;/li&gt;
&lt;li&gt;系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。&lt;/li&gt;
&lt;li&gt;为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。&lt;/li&gt;
&lt;li&gt;一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="event-driven" scheme="http://szpzs.oschina.io/categories/Erlang/event-driven/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="event-driven" scheme="http://szpzs.oschina.io/tags/event-driven/"/>
    
      <category term="application" scheme="http://szpzs.oschina.io/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS的查询、分页和并发的数据插入</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</id>
    <published>2016-09-20T14:18:06.000Z</published>
    <updated>2016-09-20T14:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">上星期的Erlang Thursday</a>的结尾，我说我们将继续研究ets模块的select函数的特性。</p>
<p>所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">TestOrderedSetTable = ets:new(ordered_set_table, [public, ordered_set]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line"><span class="comment">% 20499</span></div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:give_away(TestOrderedSetTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>接着我们给我们的测试ETS表装载一些测试数据，在数据的序列中留出一些空隙，为了后面我们填补这些空隙。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>然后我们从表里查询所有数据，我们可以看到不同类型的表的数据排序是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;]</span></div></pre></td></tr></table></figure>
<p>ets模块也有一个函数 <a href="http://erlang.org/doc/man/ets.html#select_reverse-2" target="_blank" rel="external">ets:select_reverse</a> ，我们停下来看一看它能做些什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select_reverse(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select_reverse(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;]</span></div></pre></td></tr></table></figure>
<p>我们比较 ets:select/2 和 ets:select_reverse/2 的结果，TestTable的结果是一样的，而TestOrderedSetTable的结果刚好是反序，这个结果和官方文档对 ets:select_reverse/2 描述一样。其实我们思考一下也就明白了。</p>
<p>结束了这个简单的小插曲，我们接着运行我们上面相同的匹配规则只是结果集限制在5个纪录，同时我们得到一个continuation。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;Result, Continuation&#125; = ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;19,19&#125;,&#123;29,29&#125;,&#123;27,27&#125;,&#123;17,17&#125;,&#123;5,5&#125;],</span></div><div class="line"><span class="comment">% &#123;20499,214,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">&#123;OrdSetResult, OrdSetContinuation&#125; = ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;3,3&#125;,&#123;5,5&#125;,&#123;7,7&#125;,&#123;9,9&#125;],&#123;16402,9,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>有了这些continuation，我们看看我们取回来的下一个结果集是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;23,23&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;9,9&#125;],&#123;20499,111,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;11,11&#125;,&#123;13,13&#125;,&#123;15,15&#125;,&#123;17,17&#125;,&#123;19,19&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,19,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>还记得我们用来创建元组的数字序列里留的那些间隙吗？</p>
<p>现在来看看我们填上那些序列间隙，同时我们用已经获取的continuation来查询数据会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>现在我们用前面获取到的continuation重新运行 ets:select/1 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;12,12&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;10,10&#125;,&#123;9,9&#125;],</span></div><div class="line"><span class="comment">%  &#123;20499,224,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;10,10&#125;,&#123;11,11&#125;,&#123;12,12&#125;,&#123;13,13&#125;,&#123;14,14&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,14,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们比较以前的结果，我们看到现在的结果里有了偶数元素在列表里。对于我们的 TestTable ，如果我们看上面的Continuation变量的值，它有一个continuation 的点，值是214，因为它是当前continuation和调用 ets:select(Countinuation) 后的结果continuation里唯一变化的值，所以通过这个值我们很难推断continuation的变化。</p>
<p>另一方面，OrdsetContinuation，它的第二个元素的值是9，也就是ETS表id 16402 后面的元素。而后面其它的continuation的这个值分别是19和14也碰巧和对应结果集的最后元素匹配上。因此在有序集合的情况下，我们能推断作为ordered_set类型的ETS表的continuation的一部分，这个continuation告诉我们返回结果集里最后纪录的键，我们可以不管任何同时插入动作发生而继续从这个纪录开始获取数据。</p>
<p>下次我们将看看 ets:is_compiled_ms/1 这个函数，并基于对官方文档的该函数的阅读，我们如何将匹配规则应用在continuation上。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;的结尾，我说我们将继续研究ets模块的select函数的特性。&lt;/p&gt;
&lt;p&gt;所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/select/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - 限制返回结果的ETS查询</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-using-ets-select-with-a-limit/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-using-ets-select-with-a-limit/</id>
    <published>2016-09-20T14:10:28.000Z</published>
    <updated>2016-09-20T14:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">上星期的Erlang Thursday</a>我们继续研究 ets:select/2 并且用 ets:fun2ms/1生成匹配规则来和它配合使用。</p>
<p>这个星期我们将看看ets模块提供的select函数的其它版本。</p>
<a id="more"></a>
<p>还是老样子，我们将设置好我们新的ETS表的环境，以便我们的shell崩溃了我们的表不会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = fun() -&gt; receive after infinity -&gt; ok end end.</div><div class="line">% #Fun&lt;erl_eval.20.54118792&gt;</div><div class="line">SomeProcess = spawn(Fun).</div><div class="line">% &lt;0.52.0&gt;</div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line">% 16402</div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>接下来我们将装载我们的测试ETS表，它是一些测试“产品”。为了例子的简单，我们将仅用一个数字代表一个产品id，然后用一个100以内的随机整数加上0.99作为价格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;ProductId, random:uniform(100) + 0.99&#125;)</div><div class="line">  || ProductId &lt;- lists:seq(1, 10000) ]].</div><div class="line">% [[true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true|...]]</div></pre></td></tr></table></figure>
<p>我们将创建一个匹配规则（价格在19.99至30之间）来查找数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ProductsInTheTwenties = ets:fun2ms(fun(&#123;Product, Price&#125;)</div><div class="line">                                     when Price &gt;= 19.99 andalso Price &lt; 30</div><div class="line">                                     -&gt; &#123;Product, Price&#125;</div><div class="line">                                   end).</div><div class="line">% [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;,</div><div class="line">%   [&#123;&apos;andalso&apos;,&#123;&apos;&gt;=&apos;,&apos;$2&apos;,19.99&#125;,&#123;&apos;&lt;&apos;,&apos;$2&apos;,30&#125;&#125;],</div><div class="line">%   [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;&#125;]&#125;]</div></pre></td></tr></table></figure>
<p>如果我们用 ets:select/2 和上面这个匹配规则在我们的表上，我们在一个查询里得到所有结果就和前面我们看到的一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties).</div><div class="line">% [&#123;4351,29.99&#125;,</div><div class="line">%  &#123;635,19.99&#125;,</div><div class="line">%  &#123;6005,20.99&#125;,</div><div class="line">%  &#123;3742,27.99&#125;,</div><div class="line">%  &#123;5956,29.99&#125;,</div><div class="line">%  &#123;3753,28.99&#125;,</div><div class="line">%  &#123;6653,25.99&#125;,</div><div class="line">%  &#123;5151,28.99&#125;,</div><div class="line">%  &#123;2693,27.99&#125;,</div><div class="line">%  &#123;4253,21.99&#125;,</div><div class="line">%  &#123;7636,23.99&#125;,</div><div class="line">%  &#123;1935,19.99&#125;,</div><div class="line">%  &#123;9044,22.99&#125;,</div><div class="line">%  &#123;7797,22.99&#125;,</div><div class="line">%  &#123;2147,23.99&#125;,</div><div class="line">%  &#123;2574,26.99&#125;,</div><div class="line">%  &#123;7575,29.99&#125;,</div><div class="line">%  &#123;2130,28.99&#125;,</div><div class="line">%  &#123;4908,27.99&#125;,</div><div class="line">%  &#123;2218,22.99&#125;,</div><div class="line">%  &#123;9848,21.99&#125;,</div><div class="line">%  &#123;7632,26.99&#125;,</div><div class="line">%  &#123;3562,21.99&#125;,</div><div class="line">%  &#123;3130,27.99&#125;,</div><div class="line">%  &#123;575,26.99&#125;,</div><div class="line">%  &#123;4622,28.99&#125;,</div><div class="line">%  &#123;5678,25.99&#125;,</div><div class="line">%  &#123;4022,...&#125;,</div><div class="line">%  &#123;...&#125;|...]</div></pre></td></tr></table></figure>
<p>不过ets模块也给我们一个限制结果集的方式如果我们愿意的话，用 ets:select/3 并传入一个要一次返回结果数的限制。</p>
<p>那么我们来用 ets:select/3 并给它的限制是10，然后看看结果是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们的结果是一个元组而不是一个结果的列表。第一个元组元素是一个我们期望的10个结果组成的列表，第二个元素是一个奇怪的元组，我们查阅官方文档中 ets:select/3 的描述，这个奇怪的元组表示一个概念：continuation 。</p>
<p>所以我们再运行我们的查询，这次我们把结果绑定到变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;Results, Continuation&#125; = ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们有了这个continuation，不过它是什么？它对我们来说有什么用？</p>
<p>简而言之，它可以被认为是一个不可变的书签。它不仅表示我们在查询结果的哪一页，也表示我们正在读的内容（我们的查询）。</p>
<p>它允许我们把这个continuation传给 <a href="http://www.erlang.org/doc/man/ets.html#select-1" target="_blank" rel="external">ets:select/1</a> ，就能快速获取我们前面看过的结果内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>因为它是我们的特殊的不可变的书签，每次我们用这个书签它都带我们到这同样书的相同的地方，并且我们仅能读到我们原先设置的每页最大纪录数。</p>
<p>所以不管我们在我们同一个continuation上调用多少次 ets:select/1 ，每次我们都将获得相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>而如果我们仔细看结果的元组，我们看到得到一个不同的下一个continuation的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;SecondResults, SecondContinuation&#125; = ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们可以用这个新的continuation用在我们下一次调用 ets:select/1 上，来得到下一个结果集和另一个continuation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(SecondContinuation).</div><div class="line">% &#123;[&#123;8569,19.99&#125;,</div><div class="line">%   &#123;1805,28.99&#125;,</div><div class="line">%   &#123;6819,23.99&#125;,</div><div class="line">%   &#123;9313,28.99&#125;,</div><div class="line">%   &#123;9527,27.99&#125;,</div><div class="line">%   &#123;1737,29.99&#125;,</div><div class="line">%   &#123;700,26.99&#125;,</div><div class="line">%   &#123;142,25.99&#125;,</div><div class="line">%   &#123;6792,29.99&#125;,</div><div class="line">%   &#123;9295,29.99&#125;],</div><div class="line">%  &#123;16402,513,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果我们在获取完结果集后再执行一次查询，我们得到一个 ‘$end_of_table’ 原子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;&apos;$1&apos;, &apos;$2&apos;&#125;, [&#123;&apos;&lt;&apos;, &apos;$2&apos;, 0&#125;], [&apos;$$&apos;]&#125;], 10).</div><div class="line">% &apos;$end_of_table&apos;</div></pre></td></tr></table></figure>
<p>指定一个限制并有一个continuation的能力也可以用在 ets:match/3 和 ets:match/1 上，同时也可以用在 ets:match_object/3 和 ets:match_object/1 上。</p>
<p>下星期，我们将继续研究ets模块里的不同select函数，同时看看它们的行为方式和有序集合，将比较一下 select 函数和 select_reverse函数的不同，也研究一下如果我们当我们用一个continuation的时候在结果集里插入一些数据，continuation将会怎样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;我们继续研究 ets:select/2 并且用 ets:fun2ms/1生成匹配规则来和它配合使用。&lt;/p&gt;
&lt;p&gt;这个星期我们将看看ets模块提供的select函数的其它版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/select/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS，匹配规则和函数</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-match-specs-and-functions/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-match-specs-and-functions/</id>
    <published>2016-09-20T14:03:29.000Z</published>
    <updated>2016-09-20T14:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">上星期的Erlang Thursday</a>我展示了怎样通过使用ets:select带来的好处而且使我们的查询更丰富的优势来结束文章。</p>
<p>首先我们将需要一个新的ETS表，那么我们以一个新的public类型的“产品”表开始，并且按我们的标准来创建一个进程然后将表的所有权转移给它。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">Products = ets:new(products, [public]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">ets:give_away(Products, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>下一步我们将装载我们的“产品”进入表里。</p>
<p>在我们这个例子里，我们只是创建一个产品，用一个二进制数据当做产品的名字并用一个整数当做“共同世界货币里的价格”。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(Products, &#123;integer_to_binary(X), X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">100</span>) ]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>和我们在上星期一样，我们可以手工创建一个元组列表到匹配规则里去运行我们的查询，说是获取小于10CWC的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"8"&gt;&gt;,&lt;&lt;"6"&gt;&gt;,&lt;&lt;"5"&gt;&gt;,&lt;&lt;"3"&gt;&gt;,&lt;&lt;"7"&gt;&gt;,&lt;&lt;"1"&gt;&gt;,&lt;&lt;"4"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"9"&gt;&gt;,&lt;&lt;"2"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>我们也可以查询到那些大于10CWC并且小于25CWC的产品名称。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&gt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;, &#123;'&lt;', '$<span class="number">2</span>', <span class="number">25</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"11"&gt;&gt;,&lt;&lt;"15"&gt;&gt;,&lt;&lt;"23"&gt;&gt;,&lt;&lt;"20"&gt;&gt;,&lt;&lt;"21"&gt;&gt;,&lt;&lt;"14"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"12"&gt;&gt;,&lt;&lt;"13"&gt;&gt;,&lt;&lt;"16"&gt;&gt;,&lt;&lt;"19"&gt;&gt;,&lt;&lt;"17"&gt;&gt;,&lt;&lt;"18"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"22"&gt;&gt;,&lt;&lt;"24"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>但是这样并不一定清晰明了，因为我们正在使用元组里的元素的数值以及在它们里面元组列表的元组列表。</p>
<p>这个时候 <a href="http://www.erlang.org/doc/man/ets.html#fun2ms-1" target="_blank" rel="external">ets:fun2ms/1</a> 来解救我们。</p>
<p>ets:fun2ms/1 的入参是一个函数并且将把这个函数转换成一个匹配规则。</p>
<p>这就允许我们写一个函数，这个函数入参是一个产品和价格组成的元组，然后它返回价格小于10的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &lt; <span class="number">10</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&lt;','$2',10&#125;],['$1']&#125;]</span></div></pre></td></tr></table></figure>
<p>我们也能在传递给 ets:fun2ms/1 的这个函数的判断分支里用一个组合检查，相当于分支类型语句，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Between_25_And_35_CWC = ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">25</span>, Cost &lt; <span class="number">35</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&gt;','$2',25&#125;,&#123;'&lt;','$2',35&#125;],['$1']&#125;]</span></div><div class="line">ets:select(Products, Between_25_And_35_CWC).</div><div class="line"><span class="comment">% [&lt;&lt;"30"&gt;&gt;,&lt;&lt;"33"&gt;&gt;,&lt;&lt;"32"&gt;&gt;,&lt;&lt;"29"&gt;&gt;,&lt;&lt;"28"&gt;&gt;,&lt;&lt;"26"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"34"&gt;&gt;,&lt;&lt;"27"&gt;&gt;,&lt;&lt;"31"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>或者也可以是类型分支语句。</p>
<p>虽然这个函数有用，但是它还是有它的限制，因为这是在函数上解析转换，所以你不能像在普通函数上一样用任何东西。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">90</span> -&gt; lists:reverse(binary:bin_to_list(Product)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% Error: Unknown error code &#123;122,lists,reverse&#125;</span></div><div class="line"><span class="comment">% &#123;error,transform_error&#125;</span></div></pre></td></tr></table></figure>
<p>但是，匹配规则的结果部分也是不支持任何高级函数功能的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', <span class="number">90</span>, '$<span class="number">2</span>'&#125;], [binary:bin_to_list('$<span class="number">1</span>')]&#125;]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  binary:bin_to_list/1</span></div><div class="line"><span class="comment">%         called as binary:bin_to_list('$1')</span></div></pre></td></tr></table></figure>
<p>即使有这些限制，ets:fun2ms/1 依然帮助我们做了更富表现力的ETS查询。我们不仅能用有意义的变量名替代那些 $X 变量来引用一个函数，也用判断分支语句来替代判断元组，而且我们也可以在我们的结果里用这些变量名同时做基本的格式化作为函数的一部分。</p>
<p>请确认在下周回来，因为我们将继续研究 ets:select 的不同版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;我展示了怎样通过使用ets:select带来的好处而且使我们的查询更丰富的优势来结束文章。&lt;/p&gt;
&lt;p&gt;首先我们将需要一个新的ETS表，那么我们以一个新的public类型的“产品”表开始，并且按我们的标准来创建一个进程然后将表的所有权转移给它。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/match/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="match-specs" scheme="http://szpzs.oschina.io/tags/match-specs/"/>
    
      <category term="match-functions" scheme="http://szpzs.oschina.io/tags/match-functions/"/>
    
      <category term="fun2ms" scheme="http://szpzs.oschina.io/tags/fun2ms/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – 更多的ETS数据匹配和查询</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-more-ets-data-matching-and-querying/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-more-ets-data-matching-and-querying/</id>
    <published>2016-09-20T13:54:22.000Z</published>
    <updated>2016-09-20T14:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续上周开始的从ETS获取数据研究。</p>
<p>我们已经有一个模块 markov_words ，本周我们将添加一个函数 markov_words:create_word_triples/1 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>,</span></div><div class="line">         create_word_triples/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_triples<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_triples(Words, []).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([_Word, _SecondWord | []], WordTriples)</span> -&gt;</span></div><div class="line">    WordTriples;</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([FirstWord | Words], WordTriples)</span> -&gt;</span></div><div class="line">    [SecondWord, Following | _] = Words,</div><div class="line">    UpdatedWordTriples = [&#123;FirstWord, SecondWord, Following&#125; | WordTriples],</div><div class="line">    create_word_triples(Words, UpdatedWordTriples).</div></pre></td></tr></table></figure>
<p>添加新函数的原因是它将允许我们得到更精确的马尔科夫链，这是通过能看到后续两个词的复合键的情形而提高获取下一个单词的概率。</p>
<p>修改和重新定义我们的模块后，我们回到Erlang shell，编译我们的模块并转载我们的介绍文本给一个变量，测试开始。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line"></div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>本周我们创建新的ETS表，创建一个新的进程并且把表转移给它（在例子中我们输入一些错误的东西来引起当前的shell进程崩溃）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MarkovWords = ets:new(markov_word_tuples, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div><div class="line">ets:give_away(MarkovWords, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这周，除了添加我们的词对元组到ETS，我们也将添加新的词三元组到ETS的同样的表里。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(MarkovWords, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"></div><div class="line">[[ ets:insert(MarkovWords, WordTriple) || WordTriple &lt;- markov_words:create_word_triples(ToTC)]].</div></pre></td></tr></table></figure>
<p>既然我们已经有词对和三词组在同一个ETS表中，我们可以用 ets:match_object/2 函数并指定一个匹配模式仅获得二元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者指定另一个匹配模式仅获得三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;]</span></div></pre></td></tr></table></figure>
<p>而如果我们用 ets:lookup/2 函数并传入键，那么我们得到这个键的所有数据而不管它是二元组还是三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:lookup(MarkovWords, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>和 ets:lookup/2 不一样，ets:match_object/2 可以匹配元组中的任何元素而不仅是键。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>和 ets:match_object/2 一样，ets:match/2 也可以如此匹配元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(MarkovWords, &#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>但有时候我们可能想要对如何返回结果给我们有更细粒度的控制能力，比如用一个元素单列表而不是一个字符串嵌套列表。或者我们甚至有一些标准是我们想要的真正作为我们选择的数据的一部分。</p>
<p>让我们开始研究 <a href="http://www.erlang.org/doc/man/ets.html#select-2" target="_blank" rel="external">ets:select/2</a> 。</p>
<p>ets:select/2 第一个入参是一个表，第二个入参是一个匹配规则。</p>
<p>这个匹配规则是一个三元组列表，元组的第一个元素是一个匹配模式，第二个元素是一个判断语句元组的列表，最后一个元素是一个表示每个匹配的结果。</p>
<p>如果我们想让调用 ets:select/2 结果和 ets:match/2 相似，就如像下面输出一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], [['$<span class="number">1</span>']]&#125;]).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>第二个入参是一个匹配规则列表，它只有一个元素，这个元素的组成是：<br>1）一个{“was”, “the”, ‘$1’}样式的匹配模式，它和我们传给 ets:match/2 的一样<br>2）一个空的条件判断元组列表3）一个返回结果的term： [[‘$1’]]，它是我们想要的结果格式列表，在本例子里我们想要每个结果都在它自己的列表里。</p>
<p>如果我们只是想得到一个词组成的列表，我们可以修改匹配规则的返回结果的term为[‘$1’]。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% ["winter","spring","season","season","epoch","epoch","age",</span></div><div class="line"><span class="comment">%  "age","worst","best"]</span></div></pre></td></tr></table></figure>
<p>如果我们想让返回结果看起来更像是一个 ets:match<em>object/2 返回的结果集，我们可以使用 ‘$</em>‘作为结果term，它表示整个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>如果你想要只是匹配某些元素并且提取元组中其它元素，我们可以用 ‘$$’ 作为结果term，它将返回所有匹配变量到一个列表里，返回列表里元素的顺序是按匹配模式里匹配变量的数值排序。</p>
<p>用 ets:select/2 我们也可以有指定多个匹配规则的能力。这样就允许我们查找到所有中间的词是 of 或 the 的三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;, &#123;&#123;'$<span class="number">1</span>', <span class="string">"of"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"some","of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"preserves","of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"worst","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"winter","of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"degree","of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"spring","of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"best","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>使用判断分支，我们可以找到在三元组数据里第一个元素是 was ，而且第二个词在字典排序上小于第三个词这样的第三个词。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;], ['$<span class="number">2</span>']&#125;]).</div><div class="line"><span class="comment">% ["than","winter","worst"]</span></div></pre></td></tr></table></figure>
<p>本周的文章我们已经学到使用 ets:match/2 和 ets:match_object/2 函数的其它方式，以及他们能克服使用 ets:lookup/2 的时候只能指定一个键的弱点，也可以能够通过使用 ets:select/2 来获得更强的查询能力。</p>
<p>下周，我们将研究 ets:select/2 的更多使用方式，以及我们怎样用ets模块的其它函数来帮助创建查询来更容易地快速解构数据。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续上周开始的从ETS获取数据研究。&lt;/p&gt;
&lt;p&gt;我们已经有一个模块 markov_words ，本周我们将添加一个函数 markov_words:create_word_triples/1 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/match/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/tags/match/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
      <category term="query" scheme="http://szpzs.oschina.io/tags/query/"/>
    
      <category term="lookup" scheme="http://szpzs.oschina.io/tags/lookup/"/>
    
      <category term="match_object" scheme="http://szpzs.oschina.io/tags/match-object/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS 数据匹配</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-data-matching/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-data-matching/</id>
    <published>2016-09-20T13:45:12.000Z</published>
    <updated>2016-09-20T13:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday开始从介绍系列文章改为专门讲ETS，开始用ETS存储一些数据然后在ETS里做一些数据的检索。</p>
<p>首先我们需要在ETS有一些数据，所以我们回到马尔科夫链这个问题上。</p>
<a id="more"></a>
<p>马尔科夫链是一个状态机，它是基于概率而不是特定的输入来转换状态的。它的一个普通的例子就是人们熟悉的智能手机里的“日常使用”的预测输入功能，也就是下一个词或字母会被预测并提供给使用者，而被选择的预测单词是遵循预测它跟随当前单词的历史有关的可能性。</p>
<p>首先我们将创建一个模块，该模块有一个函数将接收一个文本字符串，它返回的是一个元组列表，而这个元组的元素是由一个词和该词的后续词组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div></pre></td></tr></table></figure>
<p>上述代码输入的是一个文本字符串，然后基于空格、tab和新行字符作为词的边界将文本分割成词列表。基于这个词列表，我们创建一个列表，该列表元素是由词和词的后续词组成的元组，而这些元组将被我们插入我们的ETS表中。</p>
<p>是时候打开Erlang shell开始我们的试验了。</p>
<p>首先我们需要编译我们的模块，然后我们将创建一个变量来持有我们的文本，这个文本是为我们的马尔科夫链准备的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>我们将创建一个新进程并把我们的ETS表转移给它，以防万一我们的Erlang shell崩溃。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.60.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个ETS表，它将用来存储数据，这些数据为我们用来作为我们的马尔科夫链生成器的一部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WordPairs = ets:new(word_pairs, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:give_away(WordPairs, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们设置表为 public，因为我们想让不再是表的所有者的shell进程可以添加数据到表里，同时我们设置表的类型为 duplicate bag。</p>
<p>设为 duplicate_bag 是为了演示的原因。我们希望能有相同键的多个数据，因为我们很可能会看到任何词多次，而且有些词对的词的集合很常见，所以我们希望能捕获（以及保留）那些重复的词。</p>
<p>为了方便从shell里生成数据，我们将用列表解析把我们从文本创建的每一个词对元组通过调用 ets:insert/2 函数来插入到我们的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(WordPairs, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>现在我们已经有了一些数据在我们的ETS表里，是时候看看我们怎样才能访问我们的数据。为访问数据，我们开始介绍函数 ets:match/2 ，它的入参是一个要查询的表以及一个模式。</p>
<p>模式是由一个Erlang term组成用来匹配：_ ，匹配任意数据而且不做绑定；或者模式变量，它的格式是$N，N是任意正整数。ets:match/2 的返回结果是一个列表，这个是由模式变量的值组成的，它们按照模式变量名的序列排序。</p>
<p>所以有了这些知识，我们可以尝试查询这些词对来找到所有跟在 of 后的词。如果我们写一个模式匹配，它可能看起来像 {“of”, Following}，但是使用ETS，我们需要用一个模式变量按规范来写成：{“of”, ‘$1’}.</p>
<p>让我们在shell里运行。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["loaves"],</span></div><div class="line"><span class="comment">%  ["the"],</span></div><div class="line"><span class="comment">%  ["France."],</span></div><div class="line"><span class="comment">%  ["England;"],</span></div><div class="line"><span class="comment">%  ["comparison"],</span></div><div class="line"><span class="comment">%  ["its"],</span></div><div class="line"><span class="comment">%  ["despair,"],</span></div><div class="line"><span class="comment">%  ["hope,"],</span></div><div class="line"><span class="comment">%  ["Darkness,"],</span></div><div class="line"><span class="comment">%  ["Light,"],</span></div><div class="line"><span class="comment">%  ["incredulity,"],</span></div><div class="line"><span class="comment">%  ["belief,"],</span></div><div class="line"><span class="comment">%  ["foolishness,"],</span></div><div class="line"><span class="comment">%  ["wisdom,"],</span></div><div class="line"><span class="comment">%  ["times,"],</span></div><div class="line"><span class="comment">%  ["times,"]]</span></div></pre></td></tr></table></figure>
<p>我们看到结果是一个由变量匹配数据的列表组成的列表，在本例子中，就是 ‘$1’ 匹配的。</p>
<p>为了好玩和探索，让我们确认一下在我们的双城记介绍文本里跟在 it 后面的词都有什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"it"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"]]</span></div></pre></td></tr></table></figure>
<p>就是一堆 was ，这刚好是这本书的头两段里的情况。</p>
<p>然后我们仔细检查看看跟在 Scrooge 后的词是什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"Scrooge"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>如果我们想得到整个元组，我们应该用 ets:match_object/2 ，它将返回满足匹配的整个对象。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者，在这个例子里，我们可以用 ets:lookup/2 ，它将返回所有键匹配的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>所以为了采取一个从马尔科夫链简短绕道的例子，为什么我们想要使用 ets:lookup/2 或 ets:match_object/2 而不是其它函数？为了回答这个问题我们用一个例子，让我们添加另一种数据到我们的马尔科夫链表里，它是一个三元素元组。</p>
<p>To start with, we will insert 100_000 items into our ETS tables and see what the resulting memory size becomes. We will insert a new tuple of {X, X}, for all numbers from 1 to 100_000.（译者注：这一段应该是作者手误，从另外一篇文章错误地拷贝粘贴过来的，这一段和本文无关。）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(WordPairs, &#123;<span class="string">"of"</span>, <span class="string">"times,"</span>, <span class="string">"it"</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>如果我们调用 ets:lookup/2 ，我们将得到指定键的所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>,<span class="string">"it"</span>&#125;]</div></pre></td></tr></table></figure>
<p>但是如果我们用 ets:match_object/2 ，并且用了一个两元组，因为我们只是想得到词对，我们在结果里将不会得到那个三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '_'&#125;).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;]</div></pre></td></tr></table></figure>
<p>回到马尔科夫链的场景，我们可以开始看看我们是怎样遵循马尔科夫链规则能够获得一些文本。</p>
<p>我们从一个给定的词得到匹配的潜在的词，并且我们从后续词列表里均匀随机抓取一个结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PotentialChoices = ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line">[NextWord] = lists:nth(random:uniform(length(PotentialChoices)), PotentialChoices).</div></pre></td></tr></table></figure>
<p>我们可以写一个函数，让它重复上面的这些步骤，直到终结为止。一些终结状态的例子应该是一个词而且没有后续词；我们得到一定数量的词来拼装我们的文本；或者我们得到一定的总长度，使得它符合社交网络和Tweet的要求。</p>
<p>本文里，我们已经开始将一些“真实”的数据加入ETS里，并且为一些给定的模式来匹配数据。下个星期我们将继续看看在这个例子里用其它方式从我们ETS表取出数据放到一些地方，在那里这些数据可能被更好的消费。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-data-matching/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-data-matching/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday开始从介绍系列文章改为专门讲ETS，开始用ETS存储一些数据然后在ETS里做一些数据的检索。&lt;/p&gt;
&lt;p&gt;首先我们需要在ETS有一些数据，所以我们回到马尔科夫链这个问题上。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/match/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/tags/match/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第五篇：keypos，compressed，read_conncurrency 和 write_concurren</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-5-keypos-compressed-read-conncurrency-and-write-concurrency/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-5-keypos-compressed-read-conncurrency-and-write-concurrency/</id>
    <published>2016-09-20T13:37:31.000Z</published>
    <updated>2016-09-20T13:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且就<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">上星期我所预告的</a>，要研究ETS表的 keypos 设置以及其他一下设置。</p>
<p>首先我们来看看 keypos 设置。</p>
<a id="more"></a>
<p>keypos是被存储的元组的基于1的索引，并且将被作为表的数据项的键。如果你记得我们<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">第三篇介绍ETS的关于不同表类型的文章</a>所描述，表用这个索引作为它们的键进行比较来决定数据是否唯一。</p>
<p>如果我们创建一个新表而不指定它的 keypos 选项，则 keypos 默认是1。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>为了显示keypos的作用，我们将创建一些数据插入到我们的ETS表，这样我们就能看到keypos的作用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div><div class="line">Item4 = &#123;a, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;a,"a"&#125;</span></div><div class="line">Item5 = &#123;<span class="string">"a"</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;"a",a&#125;</span></div></pre></td></tr></table></figure>
<p>上述数据，我们在二元素元组里既有第一元素重复的也有第二元素重复的。</p>
<p>我们将继续依次把所有元素插入表中，我们要记住这个表是set类型的，所以任何新数据插入都会覆盖与它有相同键的前面插入的数据值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ets:insert(Table, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(Table, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;"a",a&#125;,&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们如上例子插入Item3，它覆盖表中的Item1，因为它们的元组第一个元素都是1。</p>
<p>我们现在创建一个kepos是2的新表，然后看看按上述例子同样的步骤来插入数据会有什么样的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">KeyPosTwo = ets:new(key_pos_2, [&#123;keypos, <span class="number">2</span>&#125;]).</div><div class="line"><span class="comment">% 24595</span></div><div class="line">ets:insert(KeyPosTwo, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;"a",a&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，当插入Item4时，就发生了覆盖，因为Item2和Item4的第二个元素都是“a”。然后插入Item5时，会覆盖Item1，因为它们的第二个元素都是原子a。</p>
<p>如果我们设置的keypos是其他值，比如说3，然后我们尝试插入一个元素小于3的元组，我们会得到一个bag argument异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">KeyPosThree = ets:new(key_pos_3, [&#123;keypos, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% 28692</span></div><div class="line">ets:insert(KeyPosThree, Item1).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(28692,&#123;1,a&#125;)</span></div></pre></td></tr></table></figure>
<p>现在我们来看看创建表的时候用compressed选项。</p>
<p>当创建一个新表，默认是不压缩的，因为我们可以从下面例子里看到表信息显示{compressed, false}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UncompressedTable = ets:new(uc, []).</div><div class="line"><span class="comment">% 32786</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新表，用了compressed选项，然后用ets:info/1查看表信息，我们看到{compressed, true}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CompressedTable = ets:new(uc, [compressed]).</div><div class="line"><span class="comment">% 45074</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>至少根据官方文档的说法，compressed选项会使得数据以更压缩的格式存储而减少内存的消耗。文档也警告这也会造成获取元素元组的操作更慢，并且键是不压缩存储的，至少在当前的版本里是这样。</p>
<p>让我们来看看compressed对内存的消耗有什么样的不同。</p>
<p>我们将给两种表分别插入100000条记录，然后看它们的内存大小。插入纪录的格式是{X, X}，X从1到100000。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,714643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,814643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>有意思！</p>
<p>压缩表的内存大小是814643，而非压缩表的内存大小却小一点，是714643。</p>
<p>可能是对整数值的压缩效果不好，所以我们再做一次，这次是用字符串替换元组的第二个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,914644&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,1692433&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>用字符串替换元素第二元素后，压缩表内存大小是914644，而非压缩表的内存大小是1692433。</p>
<p>所以当你要决定是否使用压缩表的时候除了要更仔细的考虑你将用何种方式如何匹配数据外，你还要考虑你将要放入ETS表的数据是什么样的类型。</p>
<p>最后两个要讨论的选项是 read_concurrency 和 write_concurrency。</p>
<p>read_concurrency 默认被设置为false，根据官方文档的说法这个选项在“读比写操作频繁很多，或者当并发读写的量非常巨大的时候”最适合设置为true。</p>
<p>因此如果你有一个表有大量的读操作，而写操作零零散散，这个时候你应该设置read_concurrency为true，因为官方文档的说法是在读和写之间切换是很昂贵的。</p>
<p>write_concurrency 默认被设置为false，这会使得当一个写操作正在进行的时候会造成其它并发的写操作阻塞。当把该选项设置为true，则同一个表的不同的元组可以通过并发进程写入，并且不影响任何ordered_set类型表。</p>
<p>ETS的一系列介绍文章到此告一段路。下星期我们将开始研究用ETS和ETS表进行不同的操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍ETS并且就&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/&quot;&gt;上星期我所预告的&lt;/a&gt;，要研究ETS表的 keypos 设置以及其他一下设置。&lt;/p&gt;
&lt;p&gt;首先我们来看看 keypos 设置。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第四篇：ETS的访问保护</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-4-ets-access-protections/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-4-ets-access-protections/</id>
    <published>2016-09-20T13:20:20.000Z</published>
    <updated>2016-09-20T13:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并研究ETS支持的不同访问级别。</p>
<p>ETS支持的不同访问级别：public，protected和private。</p>
<a id="more"></a>
<p>在创建一个新ETS表的时候可以传入不同访问类型的任意一个，不过我们先看看当我们不指定访问级别的时候ETS表的访问级别是哪一个？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20501</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>从上面的输出可以看到不指定访问级别的话默认就是protected。</p>
<p>那么一个ETS表是被保护的意味着什么呢？官方文档说明被保护的表只可以被所有者进程写入，但是其他进程可以读取。</p>
<p>现在让我们一起看看它是如何工作的。</p>
<p>首先我们创建一个进程以便我们可以把ETS表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的ETS表并指定它是被保护的，同时也指定它是有名字的以方便后续操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ProtectedNamedETS = ets:new(protected_named_ets, [protected, named_table]).</div><div class="line"><span class="comment">% protected_named_ets</span></div></pre></td></tr></table></figure>
<p>函数的输出是 protected_name_ets 而不是像前面调用 ets:new/2 那样输出的是数字，这样一来我们能够用表的名字替代表标识码访问这个表。</p>
<p>我们将插入一条数据到这个ETS表里，并且我们将用这个ETS表的名字作为它的引用因为我们创建表的时候指定了 named_table 选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;foobar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>ets:insert/2 返回true，那么现在我们应该有一些数据在表里。让我们用ets:match/2把数据取出来，而且通过用一个$1的模式匹配出所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>那么作为这个ETS表的所有者进程，因为这个表是由这个进程创建的，所有我们能读写这个表。</p>
<p>现在我们把这个表转移给另外的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(protected_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>既然官方文档说表是可读的，我们在刚刚转移所有权后做同样的match操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>我们读取到我们的数据。<br>那么尝试写会发生什么？因为官方文档说只有所有者进程才能有写的权限，并且在调用 ets:insert/2 的时候总是返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;barbaz, foo&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(protected_named_ets,&#123;barbaz,foo&#125;)</span></div></pre></td></tr></table></figure>
<p>上面的例子返回了一个异常，异常的类型是 bag argument，也就是说它不允许非所有者进程写数据入表，但是这个异常没有确切地说明到底发生了什么。</p>
<p>如果我们尝试调用 ets:insert/2 往不存在的表插入数据将会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(no_such_table, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(no_such_table,&#123;foo,bar&#125;)</span></div></pre></td></tr></table></figure>
<p>一样的异常和一样的错误提示格式，仅仅是表名和元组不同。</p>
<p>仔细想想这些现象，这两种不同的情况有一样的错误是有意义的。当一个进程尝试去做一个插入而如果没有表存在或者如果表被设置为 protected，则就是要让正在调用插入动作的这个进程知道这样的表不存在。总之，就是调用者将一个错的ETS表的引用传给ets:insert/2 。</p>
<p>所以我们现在已经知道 protected 的行为，它是默认的访问级别，那么下面让我们看看 public 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PublicNamedETS = ets:new(public_named_ets, [public, named_table]).</div><div class="line"><span class="comment">% public_named_ets</span></div></pre></td></tr></table></figure>
<p>我们将从我们当前的进程，也就是表的所有者插入一条数据并且获取所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;]]</span></div></pre></td></tr></table></figure>
<p>一切正常。</p>
<p>官方文档说public的表允许任何进程读和写，所以让我们把这个public表转给进程 SomeProcess 并且尝试去读和写。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(public_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在我们已经将表转移出去，是时候来尝试添加一条新的数据到表里，同时来看看我们能否将写入的内容读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;bar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;],[&#123;bar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>完全没问题。我们已经插入新数据到那个表里，并且当我们调用 ets:match/2 获取所有数据的时候，我们看到新数据在结果集里。</p>
<p>现在让我们创建一个 private 表。官方文档说对于 private 的ETS表，只有表的所有者才被允许读写这个ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PrivateNamedETS = ets:new(private_named_ets, [private, named_table]).</div><div class="line">private_named_ets</div></pre></td></tr></table></figure>
<p>当进程还拥有这个表的时候，我们添加一条数据并读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;fizz, buzz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;fizz,buzz&#125;]]</span></div></pre></td></tr></table></figure>
<p>然后我们又把表转移给进程 SomeProcess。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(private_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在这个ETS表属于另一个进程了，我们再来尝试读取它的数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:match/2</span></div><div class="line"><span class="comment">%         called as ets:match(private_named_ets,'$1')</span></div></pre></td></tr></table></figure>
<p>又是 bad argument 异常，就像前面例子我们尝试在一个 protected ETS表上用 ets:insert/2 函数，而当时那个表属于另外一个进程。<br>再来看看写的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;buzz, fizz&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(private_named_ets,&#123;buzz,fizz&#125;)</span></div></pre></td></tr></table></figure>
<p>也是 bad argument 异常，现在这样的情况不会让人奇怪了，因为 protected 表的写以及这个 private 表的读都造成一样的异常。</p>
<p>总之，在所有到目前为止的ETS的介绍文章里，我们已经见过了ETS表的类型、访问级别、表命名、继承人和所有者这些属性的设置以及它们之间的关系。</p>
<p>下星期，我们将通过介绍ETS表的键位置的设置和其他一些设置来结束ETS介绍系列文章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍ETS并研究ETS支持的不同访问级别。&lt;/p&gt;
&lt;p&gt;ETS支持的不同访问级别：public，protected和private。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第三篇：ETS表类型</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-3-ets-table-types/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-3-ets-table-types/</id>
    <published>2016-09-20T13:14:05.000Z</published>
    <updated>2016-09-20T13:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且研究一下ETS支持的不同存储策略类型。</p>
<p>ETS支持的不同存储类型是：set，ordered_set，bag，和duplicate bag。</p>
<a id="more"></a>
<p>每种类型都可以在创建一个新ETS表的时候传给创建函数，不过我们来看看创建ETS表的时候不指定任何类型的话ETS表是什么类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ETS_Empty = ets:new(ets_empty, []).</div><div class="line"><span class="comment">% 36886</span></div><div class="line">ets:info(ETS_Empty).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,ets_empty&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>上面的输出中，type 标签元组显示类型是 set。</p>
<p>为了研究不同类型的ETS表如何工作的，我们将创建三个元组加入不同ETS表里来看看它们是如何存储的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div></pre></td></tr></table></figure>
<p>我们有两个第一元素都是1的元组，还有一个第一元素是1.0的元组，这是为了看看在相同的键情况下不同类型ETS表如何处理。</p>
<p>为什么有1和1.0两个键？因为根据使用的比较操作符的不同，它们可以被看作相同的也可以被看作不相同的，所以把它们当作一种相同键的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> == <span class="number">1.0</span>.</div><div class="line"><span class="comment">% true</span></div><div class="line"><span class="number">1</span> =:= <span class="number">1.0</span>.</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>首先我们看看一个set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Set = ets:new(ets_set, [set]).</div><div class="line"><span class="number">40978</span></div></pre></td></tr></table></figure>
<p>我们插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Set, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>set类型的ETS表把1和1.0当作不同的键。那么我们插入Item3也就是插入一个已经存在的键会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>原先1为键的元组已经被我们刚刚插入的Item3元组替换了。</p>
<p>我们再来看看ordered_set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_OrdSet = ets:new(ets_ordset, [ordered_set]).</div><div class="line"><span class="comment">% 45075</span></div></pre></td></tr></table></figure>
<p>我们还是插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_OrdSet, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，1.0被认为和先插入的1是相等的，所以它覆盖了第一个插入的元素。</p>
<p>我们再插入Iterm3，结果是它也覆盖了1.0那个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们来看看bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Bag = ets:new(ets_bag, [bag]).</div><div class="line"><span class="comment">% 49172</span></div></pre></td></tr></table></figure>
<p>我们还是给表里加入Item1和Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Bag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>从 ets:tab2list/1 的输出我们看到bag类型的ETS表把Item1和Item2当作两个不同的元素。</p>
<p>再将Item3加入表里看看会有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>在这个bag类型的ETS表中，我们有了Item2以及Item1和Item3三个元素，甚至Item1和Item3有相同当键。</p>
<p>最后我们来看看duplicate_bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_DupBag = ets:new(ets_dupbag, [duplicate_bag]).</div><div class="line"><span class="comment">% 53269</span></div></pre></td></tr></table></figure>
<p>像前面几种类型的ETS表一样，我们插入Item1再插入Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_DupBag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>也和前面的例子一样，我们接着插入Item3。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是我们在这个duplicate_bag表中有所有三个元素。</p>
<p>如果我们比较bag和duplicate_bag两种表，我们发现它们似乎有一样的行为。</p>
<p>那么它们两者之间有什么不同呢？</p>
<p>如果你深入挖掘官方文档，仔细阅读 ets:new/2 函数中关于表类型的描述，它说明一个bag表允许有重复键，但是只不允许两个一样的一个元素存在，而duplicate_bag允许相同元素存在即时它们的键值都相同。</p>
<p>为验证这个结论，我们往bag表和duplicate_bag表都加入Item1，看看结果是什么。</p>
<p>首先是bag表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果和原来没有不同，所以往bag里添加已经存在的元素不会改变表的内容。</p>
<p>那么duplicate_bag表呢？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是元组{1, a}有两份，因为我们调用 ets:insert/2 将这个元素插入了两次。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍ETS并且研究一下ETS支持的不同存储策略类型。&lt;/p&gt;
&lt;p&gt;ETS支持的不同存储类型是：set，ordered_set，bag，和duplicate bag。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第二篇</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-2/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-2/</id>
    <published>2016-09-20T13:07:34.000Z</published>
    <updated>2016-09-20T13:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍 <a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 模块以及ETS的概况。</p>
<p>上次我们看到ETS表在其父进程崩溃的时候被删除了，那么问题来了，我们怎么能够在其父进程崩溃的时候依然保持ETS表活着呢？</p>
<a id="more"></a>
<p>为解决这个问题，我们将研究函数 ets:give_away/3 以及在创建表的时候指定的参数 heir 。</p>
<p>首先我们创建一个函数，它将代表一个进程，而我们可以将表的所有权赋予它的。这个函数只是等待消息而且永远不超时。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div></pre></td></tr></table></figure>
<p>现在我们创建一个运行该函数的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Process = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.53.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个新的ETS表，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(table, []).</div><div class="line"><span class="comment">% 20498</span></div></pre></td></tr></table></figure>
<p>并且将它赋予我们刚刚创建的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(Table, Process, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我查看表信息可以看到表的所有者是我们创建的进程，因为这个进程的PID和表消息里的所有者元组的PID一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.53.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们已经进行了所谓的所有权转移，那么是时候将原来的所有者进程也就是我们当前的shell进程崩溃掉。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.58.0&gt;</div></pre></td></tr></table></figure>
<p>我们检查我们创建的进程是否还活着，绝大多数情况下应该是活着的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">is_process_alive</span><span class="params">(Process)</span>.</span></div><div class="line">% <span class="title">true</span></div></pre></td></tr></table></figure>
<p>在检查表的信息，看看它是否还活着。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.53.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>它依然还活着！！！我们已经转移了所有权，所以如果我们自己的进程崩溃的话，ETS表依然是活着的。</p>
<p>是时候杀掉那个进程了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exit</span><span class="params">(Process, <span class="string">"Because"</span>)</span>.</span></div><div class="line">% <span class="title">true</span></div><div class="line"><span class="title">is_process_alive</span><span class="params">(Process)</span>.</div><div class="line">% <span class="title">false</span></div></pre></td></tr></table></figure>
<p>然后表就消失了…</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% undefined</span></div></pre></td></tr></table></figure>
<p>这一次，让我们在创建一个ETS表的时候用 heir 选项，来利用ETS表的所有权转移给一个继承人的魔法。</p>
<p>在这次场景里，当所有者进程死掉的时候shell将是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TableWithHeir = ets:new(table, [&#123;heir, self(), <span class="string">"something went wrong"</span>&#125;]).</div><div class="line"><span class="comment">% 24594</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的进程，然后将ETS表的所有权赋予这个新的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Process2 = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.71.0&gt;</span></div><div class="line">ets:give_away(TableWithHeir, Process2, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们检查表的信息，我们可以看到表的所有者是新的进程，而它的继承人是我们当前的shell进程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">self().</div><div class="line">% &lt;0.58.0&gt;</div><div class="line">ets:info(TableWithHeir).</div><div class="line">% [&#123;read_concurrency,false&#125;,</div><div class="line">%  &#123;write_concurrency,false&#125;,</div><div class="line">%  &#123;compressed,false&#125;,</div><div class="line">%  &#123;memory,349&#125;,</div><div class="line">%  &#123;owner,&lt;0.71.0&gt;&#125;,</div><div class="line">%  &#123;heir,&lt;0.58.0&gt;&#125;,</div><div class="line">%  &#123;name,table&#125;,</div><div class="line">%  &#123;size,0&#125;,</div><div class="line">%  &#123;node,nonode@nohost&#125;,</div><div class="line">%  &#123;named_table,false&#125;,</div><div class="line">%  &#123;type,set&#125;,</div><div class="line">%  &#123;keypos,1&#125;,</div><div class="line">%  &#123;protection,protected&#125;]</div></pre></td></tr></table></figure>
<p>现在再次杀掉所有者进程了……</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exit</span><span class="params">(Process2, <span class="string">"Because"</span>)</span>.</span></div><div class="line">% <span class="title">true</span></div><div class="line"><span class="title">is_process_alive</span><span class="params">(Process2)</span>.</div><div class="line">% <span class="title">false</span></div></pre></td></tr></table></figure>
<p>我们在检查表的信息，我们可以看到当前的shell进程既是所有者又是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableWithHeir).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,349&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的进程，然后我们把表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Process3 = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.78.0&gt;</span></div><div class="line">ets:give_away(TableWithHeir, Process3, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>所有者变成了新的进程，我们当前的shell进程依然是继承人。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableWithHeir).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,349&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.78.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,&lt;0.58.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>通过利用指定继承人的能力，同时用 ets:give_away/3 函数，我们可以帮助ETS表长生不死。</p>
<p>一种可能利用的方式是，我们有一个监督进程，它创建一个“继承人”进程，然后创建一个子进程，这个子进程拥有ETS表，如果这个子进程死掉，它将转移所有权给继承人进程。直到新的所有者进程被重新创建，然后继承人进程便可以将ETS表的所有权转移给这个新创建的进程。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;ets&lt;/a&gt; 模块以及ETS的概况。&lt;/p&gt;
&lt;p&gt;上次我们看到ETS表在其父进程崩溃的时候被删除了，那么问题来了，我们怎么能够在其父进程崩溃的时候依然保持ETS表活着呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第一篇</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-1/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-1/</id>
    <published>2016-09-20T12:59:53.000Z</published>
    <updated>2016-09-20T13:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday开始介绍 <a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 模块以及ETS的概况。</p>
<p>ETS是 Erlang Term Storage的缩写，是Erlang term（各种Erlang数据类型）的内存存储，它提供对存储的数据恒定的访问时间。</p>
<a id="more"></a>
<p>ETS可以被认为是一种键值对存储类型的存储，并且它用表的概念来组织数据。</p>
<p>第一个很有用的知识点是，ETS表是被一个进程创建的，这个表的创建者就是这个表的所有者，除非它把表转移给别的进程。</p>
<p>一旦所有者进程死掉，这个表也就被删除，而且再也不能被访问。</p>
<p>让我们看一下这会是什么样子。</p>
<p>首先，在启动了一个新的Erlang shell后，我们先看看我们所在shell的PID（进程标识符）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.34.0&gt;</div></pre></td></tr></table></figure>
<p>接着创建一个新的ETS表。我们在以后的文章里会专门详细介绍各种创建新表的方式，而今天我们只是仅仅指定一个名字和一个空的参数列表来创建一个新表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TableId = ets:new(table, []).</div><div class="line"><span class="comment">% 20496</span></div></pre></td></tr></table></figure>
<p>获得表的id后，我们用 ets:info/1 函数来看看表的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ets:info(TableId).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.34.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,table&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>是时候来让所有者进程崩溃了。在这个场景，我们用一个错误的模式匹配来引起一个错误匹配异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div></pre></td></tr></table></figure>
<p>现在我们检查PID变量和当前shell的进程是否匹配来证实Erlang真的启动了一个新的shell进程让我们使用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.40.0&gt;</div></pre></td></tr></table></figure>
<p>很明显，当前的shell的PID和我们第一次调用self()获得的PID不一样。</p>
<p>再来看看我们刚才创建的表的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:info(TableId).</div><div class="line"><span class="comment">% undefined</span></div></pre></td></tr></table></figure>
<p>结果是 undefined 。因此我们再也找不到那个表id所指的表了。</p>
<p>接下来我们用 ets:all/0 是否能看到虽然用 ets:info/1 找不到的表在某个地方藏着呢。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>还是没找到。让我们用和前面同样的名字创建另外一个表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Table2Id = ets:new(table, []).</div><div class="line"><span class="comment">% 24592</span></div></pre></td></tr></table></figure>
<p>创建成功而且没有报这个名字已经存在的错误。</p>
<p>我们再用 ets:all/0 来看看，这回能看到刚才 ets:new/2 返回的id。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [24592,8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>我们再让shell崩溃一次。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> = <span class="number">2</span>.</div><div class="line"><span class="comment">% ** exception error: no match of right hand side value 2</span></div></pre></td></tr></table></figure>
<p>我们注意到我们又有了新的shell进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">self</span><span class="params">()</span>.</span></div><div class="line">% &lt;0.47.0&gt;</div></pre></td></tr></table></figure>
<p>如果我们再调用 ets:all/0 ，前面我们刚刚创建的表的id又没有了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:all().</div><div class="line"><span class="comment">% [8207,file_io_servers,inet_hosts_file_byaddr,</span></div><div class="line"><span class="comment">%  inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span></div><div class="line"><span class="comment">%  inet_cache,inet_db,global_pid_ids,global_pid_names,</span></div><div class="line"><span class="comment">%  global_names_ext,global_names,global_locks,4098,1,ac_tab]</span></div></pre></td></tr></table></figure>
<p>上述就是我们对ETS的初始印象，我们演示了所有者进程崩溃会删除表，我们也预览了ets模块的一些函数，特别是 ets:new/2 ，ets:info/1 和 ets:all/0 。</p>
<p>我们将继续在后面几篇文章里浏览ETS，并且在大概预览一些ets模块的函数后，我们会深入研究ets模块里与众不同的函数。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday开始介绍 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;ets&lt;/a&gt; 模块以及ETS的概况。&lt;/p&gt;
&lt;p&gt;ETS是 Erlang Term Storage的缩写，是Erlang term（各种Erlang数据类型）的内存存储，它提供对存储的数据恒定的访问时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – digraph:del_path/3</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-del-path-3/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-del-path-3/</id>
    <published>2016-09-20T12:54:04.000Z</published>
    <updated>2016-09-20T12:59:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#del_path-3" target="_blank" rel="external">digraph:del_path/3</a>.</p>
<p>我们继续使用上次文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a>  一样的有向图。</p>
<a id="more"></a>
<p><img src="/images/digraph-del-path01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>digraph:del_path/3 有三个入参，一个有向图，一个源节点，一个目标节点，函数将删除有向图中从源节点到目标节点的每一条路径上的所有边，直到源节点和目标节点之间没有路径为止。</p>
<p>digraph:del_path/3 的返回值总是true。</p>
<p>我们将调用 digraph:del_path/3 传入上面例子的有向图，节点V1作为源节点，节点V4作为目标节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:del_path(Graph, V1, V4).</div><div class="line"><span class="comment">% true</span></div><div class="line">digraph:vertices(Graph).</div><div class="line"><span class="comment">% [['$v'|2],['$v'|1],['$v'|0],['$v'|3]]</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|1],['$e'|2],['$e'|4]]</span></div></pre></td></tr></table></figure>
<p>根据边的名字来看，从节点1到节点2点边已经被删除，从节点2到节点4点边也被删除。</p>
<p>那么Erlang是怎么得到这样的结果的？</p>
<p>它的结果一开始让我困惑，因为结果并不是我所预期的两种结果之一。我预期的结果是：除了从节点4到节点1的边其他边全部删除，或者仅删除从节点1到节点2的边。</p>
<p>为了解惑，我找到托管在Github上的Erlang源码来阅读 <a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/stdlib/src/digraph.erl" target="_blank" rel="external">digraph</a> 模块，在代码里我终于明白了其中缘由。</p>
<p>首先 digraph:del_path 调用 digraph:get_path/3 ，并且删除路径上所有的边，然后递归执行直到没有再找到路径。</p>
<p>这就是为什么Erlang只删除那些边对原因。</p>
<p>当我们在原始样例有向图上调用 digraph:get_path/3 ，我们得到的路径是 V1 -&gt; V2 -&gt; V4 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">digraph:get_path(Graph, V1, V4).</div><div class="line">[['$v'|<span class="number">0</span>],['$v'|<span class="number">1</span>],['$v'|<span class="number">3</span>]]</div></pre></td></tr></table></figure>
<p>Erlang将路径里的边都删除，然后再递归调用 digraph:del_path/3 ，而这个函数再一次调用 digraph:get_path/3 ，但是因为节点1和节点2之间的边已经被删除，所以没有找到路径，整个处理过程就此结束。</p>
<p>这就是为什么我们看到更多的边被删除，如果我们再次重置样例有向图（退出erlang shell，然后重新打开一个erlang shell，把初始化样例有向图的语句重新执行一遍），然后将节点2和节点4传给 digraph:del_path/3 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:del_path(Graph, V2, V4).</div><div class="line"><span class="comment">% true</span></div><div class="line">digraph:edges(Graph).</div><div class="line"><span class="comment">% [['$e'|0],['$e'|4]]</span></div></pre></td></tr></table></figure>
<p>这个场景有两个路径：V2 -&gt; V4 和 V2 -&gt; V3 -&gt; V4 ，如果我们删除路径V2 -&gt; V4路径，与这条路径的所有相关的边都被删除但是不会中断路径V2 -&gt; V3 -&gt; V4，所以函数也可以删除这条路径上的所有边。</p>
<p>所以在官方文档没有很清晰说明白函数内部机制的这个场景，我们可以通过开源的Erlang标准库来彻底了解其中奥妙，因为我们可以获取Erlang的源码来研究它底层的实现机制。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-del_path-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-del_path-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/digraph.html#del_path-3&quot;&gt;digraph:del_path/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我们继续使用上次文章 &lt;a href=&quot;http://www.proctor-it.com/erlang-thursday-digraph-get_path-3&quot;&gt;digraph:get_path/3&lt;/a&gt;  一样的有向图。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="digraph" scheme="http://szpzs.oschina.io/categories/Erlang/digraph/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="digraph" scheme="http://szpzs.oschina.io/tags/digraph/"/>
    
      <category term="del_path" scheme="http://szpzs.oschina.io/tags/del-path/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – digraph:get_cycle/2</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-get-cycle-2/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-get-cycle-2/</id>
    <published>2016-09-20T12:43:04.000Z</published>
    <updated>2016-09-20T12:53:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#get_cycle-2" target="_blank" rel="external">digraph:get_cycle/2</a>.</p>
<p>我们将继续在上一篇文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a> 用的有向图上讲解。</p>
<a id="more"></a>
<p><img src="/images/digraph-get-cycle01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>digraph:get_cycle/2 两个入参分别是一个有向图G，一个节点V，该函数尝试在有向图中找到一条路径使得节点V在其中并且形成一个环。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:get_cycle(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_cycle(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|3],['$v'|0],['$v'|1]]</span></div></pre></td></tr></table></figure>
<p>接着我们增加一个新节点V5，并且新增一条从节点V4发出到节点V5的边。</p>
<p>然后我们调用 digraph:get_cycle/2 第二个入参是V5，我们会得到一个false，因为在图中没有一个环使得V5在其中。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">V5 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|4]</span></div><div class="line">E6 = digraph:add_edge(Graph, V4, V5).</div><div class="line"><span class="comment">% ['$e'|5]</span></div><div class="line">digraph:get_cycle(Graph, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>digraph模块还有一个函数 <a href="http://www.erlang.org/doc/man/digraph.html#get_short_cycle-2" target="_blank" rel="external">digraph:get_short_cycle/2</a> 。</p>
<p>digraph:get_short_cycle/2 尝试为节点V在图G中找到一条最短的环。</p>
<p>官方文档解释 digraph:get_short_cycle/2 的原话是：</p>
<p>尝试在有向图G上找到尽可能短的通过节点V的简单环。</p>
<p>因此这取决于你如何理解这句话，可能不能保证返回最短的环，而只是返回更短的一个环，这可能取决于有向图的整体大小和复杂度。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">digraph:get_short_cycle(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|0],['$v'|1],['$v'|3],['$v'|0]]</span></div><div class="line">digraph:get_short_cycle(Graph, V5).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-get_cycle-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-get_cycle-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/digraph.html#get_cycle-2&quot;&gt;digraph:get_cycle/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我们将继续在上一篇文章 &lt;a href=&quot;http://www.proctor-it.com/erlang-thursday-digraph-get_path-3&quot;&gt;digraph:get_path/3&lt;/a&gt; 用的有向图上讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="digraph" scheme="http://szpzs.oschina.io/categories/Erlang/digraph/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="digraph" scheme="http://szpzs.oschina.io/tags/digraph/"/>
    
      <category term="get_cycle" scheme="http://szpzs.oschina.io/tags/get-cycle/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – digraph:in_neighbors/2</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-in-neighbors-2/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-digraph-in-neighbors-2/</id>
    <published>2016-09-20T12:25:52.000Z</published>
    <updated>2016-09-20T12:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/digraph.html#in_neighbors-2" target="_blank" rel="external">digraph:in_neighbors/2</a>.</p>
<p>digraph:in_neighbors/2 第一个入参是一个有向图G，第二个入参是一个节点V，函数将返回一个由若干节点组成的列表，而且有从这些节点发出并进入节点V的边。</p>
<a id="more"></a>
<p>我们继续用上个星期的文章 <a href="http://www.proctor-it.com/erlang-thursday-digraph-get_path-3" target="_blank" rel="external">digraph:get_path/3</a> 里的例子基础上进行讲解。</p>
<p><img src="/images/digraph-in-neighbors01.png" alt="有向图"></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Graph = digraph:new().</div><div class="line"><span class="comment">% &#123;digraph,20498,24595,28692,true&#125;</span></div><div class="line">V1 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|0]</span></div><div class="line">V2 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|1]</span></div><div class="line">V3 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|2]</span></div><div class="line">V4 = digraph:add_vertex(Graph).</div><div class="line"><span class="comment">% ['$v'|3]</span></div><div class="line">E1 = digraph:add_edge(Graph, V1, V2).</div><div class="line"><span class="comment">% ['$e'|0]</span></div><div class="line">E2 = digraph:add_edge(Graph, V2, V3).</div><div class="line"><span class="comment">% ['$e'|1]</span></div><div class="line">E3 = digraph:add_edge(Graph, V3, V4).</div><div class="line"><span class="comment">% ['$e'|2]</span></div><div class="line">E4 = digraph:add_edge(Graph, V2, V4).</div><div class="line"><span class="comment">% ['$e'|3]</span></div><div class="line">E5 = digraph:add_edge(Graph, V4, V1).</div><div class="line"><span class="comment">% ['$e'|4]</span></div></pre></td></tr></table></figure>
<p>图和相关元素都设置好后，我们可以开始在我们的图里找不同节点的入站邻居节点 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:in_neighbours(Graph, V4).</div><div class="line"><span class="comment">% [['$v'|1],['$v'|2]]</span></div><div class="line">digraph:in_neighbours(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|3]]</span></div><div class="line">digraph:in_neighbours(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|0]]</span></div></pre></td></tr></table></figure>
<p>上述输出我们可以看到对于节点4函数返回值是[[‘$v’ | 1],[[‘$v’ | 2]]]，也就是节点2和节点3。对于节点1，我们得到一个 inbound 邻居节点4，而对于节点2，我们得到inbound邻居节点1。</p>
<p><strong>digraph:out_neighbors/2</strong></p>
<p>digraph模块也包含函数 <a href="http://www.erlang.org/doc/man/digraph.html#out_neighbours-2" target="_blank" rel="external">digraph:out_neighbors/2</a> ，它的返回值是由从入参节点发出的边相应的所有节点组成的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">digraph:out_neighbours(Graph, V2).</div><div class="line"><span class="comment">% [['$v'|3],['$v'|2]]</span></div><div class="line">digraph:out_neighbours(Graph, V4).</div><div class="line"><span class="comment">% [['$v'|0]]</span></div><div class="line">digraph:out_neighbours(Graph, V1).</div><div class="line"><span class="comment">% [['$v'|1]]</span></div></pre></td></tr></table></figure>
<p>我们从上图看到节点2有“指向”节点3和节点4的边，而我们再看 digraph:out_neighbors/2 的输出，得到的结果就是节点3和节点4。</p>
<p>这个例子里我们得到的节点列表是节点4在节点3点前面，但是这个顺序是不确定的，正如官方文档所讲的，“边是没有特定的顺序的”，这个情况对于 digraph:in_neighbors/2 也一样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-digraph-in_neighbors-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-digraph-in_neighbors-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/digraph.html#in_neighbors-2&quot;&gt;digraph:in_neighbors/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;digraph:in_neighbors/2 第一个入参是一个有向图G，第二个入参是一个节点V，函数将返回一个由若干节点组成的列表，而且有从这些节点发出并进入节点V的边。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="digraph" scheme="http://szpzs.oschina.io/categories/Erlang/digraph/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="digraph" scheme="http://szpzs.oschina.io/tags/digraph/"/>
    
      <category term="in_neighbors" scheme="http://szpzs.oschina.io/tags/in-neighbors/"/>
    
  </entry>
  
</feed>
