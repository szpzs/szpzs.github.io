<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2017-03-10T05:52:16.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>减少固定大小缓冲区的最大延迟</title>
    <link href="http://szpzs.oschina.io/2017/03/10/reducing-maximum-latency/"/>
    <id>http://szpzs.oschina.io/2017/03/10/reducing-maximum-latency/</id>
    <published>2017-03-10T03:10:28.000Z</published>
    <updated>2017-03-10T05:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在<a href="https://pusher.com/" target="_blank" rel="external">Pusher</a>的博客读到两篇很棒的文章：<a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/" target="_blank" rel="external">低延迟、大的工作集和GHC的垃圾收集器：三选二</a> 和 <a href="https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="external">Golang的实时GC的理论与实践</a> 。这两篇文章讲的是Pusher的工程师如何重新实现他们的消息总线的故事。第一篇是发生在Haskell里。在性能测试期间，他们发现在99%那个范围内有一些高延迟。在他们分析代码后，他们能够证明这些延时的尖峰是由GHC的 stop-the-world 垃圾收集器，再加上一个大的工作集（内存中的对象的数目）所造成的。该开发团队随后尝试了GO，得到好得多的结果，这得益于GO的并发垃圾收集器。</p>
<p>我强烈推荐这两篇文章。Pusher的测试是一个很棒的基准测试例子，因为它专注于解决一个真正的挑战，并且基于该项技术是否合适本工作来评估此技术。这是我喜欢的那种评估方式。我发现做一个简单的关键功能的实现非常有用，然后看看它在所需的负荷下的表现，而不是通过一些浅层的模拟基准测试来比较不同的技术，例如在环里传递令牌，或让一个Web服务器返回“200 OK”。这个方法应该能提供“我能用Y有效地解决X吗？”问题的答案。当我第一次评估Erlang的时候，我采用的就是这种方法。10 倍的预期负载模拟真实系统的12个小时测试让我相信这项技术比我所需要的绰绰有余。</p>
<a id="more"></a>
<h1 id="接受挑战"><a href="#接受挑战" class="headerlink" title="接受挑战"></a>接受挑战</h1><p>阅读Pusher的文章使得我很想知道这个问题的Elixir实现的性能如何。毕竟，底层的Erlang虚拟机（BEAM）一直是给我低的和可预测的延迟的印象，所以加上其他性质，如容错、大规模的并发性、可扩展性、分布式系统的支持，这似乎是一个为该工作令人信服的选择。</p>
<p>所以让我根据Pusher的文章来定义挑战。我将实现一个先进先出（FIFO）缓冲区，它可以处理两种操作：push 和 pull。这个缓冲区由最大尺寸来限定它的大小。如果这个缓冲区满了，push操作将覆盖队列里最老的元素。</p>
<p>目标是为了减少一个非常大的缓冲区（最大20万元素）的push和pull操作的最大延迟。把这最后的目标牢记在心是很重要的。我关心平滑缓冲区操作的延迟尖峰。我不在乎哪种语言给我更好的最坏情况的GC停顿。虽然Pusher的挑战的根本问题是由长GC停顿造成的，那并不意味着我仅仅是换其他的语言就能解决它。正如我将阐述的，依赖于Elixir/Erlang的一些技巧，我们可以完全旁路掉GC，并且将最大延迟带入到微秒区域。</p>
<h1 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h1><p>为了测量性能，我决定在一个独立的GenServer进程里运行缓冲区。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/server.ex" target="_blank" rel="external">这里</a>看到实现代码。</p>
<p>测量利用了Erlang的trace能力。一个独立的进程被启动，它设置了缓冲区进程的trace。它接收push和pull操作以及缓冲区垃圾回收的开始和结束时间。它收集那些时间，并且在被要求的时候生成最终结果。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer_tracer.ex" target="_blank" rel="external">这里</a>找到它的实现。</p>
<p>trace将导致一些性能损耗。当trace被使用的时候，整个基准测试将是平常花费的两倍时间。我不能说它对报告的时间有多大的影响，但我并不在意它。如果我能够在用trace的情况下获得好的结果，那么在不用trace的情况下，这样的实现足够满足要求了。:-)</p>
<p>如果你不熟悉Erlang，这里的进程指的是Erlang的进程 - 一个运行在同一个操作系统进程里的轻量并发程序，并且和其他Erlang进程没有共享数据。在操作系统层面，我们仍然还是只有一个进程，但是在Erlang虚拟机里，有很多Erlang进程独立地运行着。</p>
<p>这些进程没有共同点，没有共享内存，只能通过发送自己的消息进行通信。特别是，每个进程都有自己独立的堆，并且各自进行自己的垃圾回收。因此，不论tracer进程分配了什么数据都不会给缓冲区进程造成GC压力。只有那些我们确实压入到缓冲区的数据在缓冲区GC期间才被考虑，也因此会影响缓冲区操作的延时。这种方法展示了Erlang非常棒的好处。通过在隔离的进程里运行不同的程序，我们可以在系统中防止在一个进程里的GC压力影响其他进程。我不知道有任何其他轻量级的并发平台提供这样的保证。</p>
<p>测试首先从一个简短的“拉伸”热身开始。我创建了一个最大容量为20万元素（这个数字是Pusher的基准测试里使用的）的缓冲区。然后，我压入20万个元素，接着全部取出来，然后再压入20万个元素。热身结束之际，缓冲区内的数据达到了它的最大容量。</p>
<p>这个时候基准测试开始。我以15个push操作然后跟着5个pull操作为一个周期发起了两百万个请求。因此，缓冲区的大多数操作处于“溢出”模式下。总的来说，1百万个push操作执行在满的缓冲区上，而50万个push操作执行在几乎满的缓冲区上。被压入的元素是1024字节的Erlang二进制数据，而且每一个元素都互不相同，意思就是测试将产生1百50万个不同的元素。</p>
<p>基准测试代码在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/mix/tasks/buffer_prof.ex" target="_blank" rel="external">这里</a>。完整的项目文件在<a href="https://github.com/sasa1977/erlangelist/tree/master/examples/buffer" target="_blank" rel="external">这里</a>。我用 Erlang 19.1 和 Elixir 1.3.4 运行基准测试，我用 <a href="https://github.com/asdf-vm/asdf" target="_blank" rel="external">asdf</a> 版本管理器来安装它们。测试运行在我的2011年的iMac上（3.4 GHz Intel Core i7）。</p>
<h1 id="函数式实现"><a href="#函数式实现" class="headerlink" title="函数式实现"></a>函数式实现</h1><p>首先，我会尝试我所认为的符合Elixir和Erlang习惯的方法 - 基于 <a href="http://erlang.org/doc/man/queue.html" target="_blank" rel="external">:queue</a> 模块的纯函数实现。根据文档所说，这个模块以高效的方式实现双端先进先出（FIFO）队列，它的大多数操作有一个分摊的O(1)运行时间。这个模块的API提供了绝大多数我们所需要的函数。我可以用 :queue.in/2 和 :queue.out/2 来push和pull数据。它没有直接支持设置队列的最大尺寸，但是在 :queue 模块实现这个功能非常简单。你可以在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/queue.ex" target="_blank" rel="external">这里</a>找到我的实现。</p>
<p>当我最初读Pusher的文章的时候，我非常肯定，这样的实现会导致较大的延迟尖峰。虽然在Erlang里没有 stop-the-world 的GC，但是依然有 stop-the-process 的GC。一个Erlang进程启动的时候有一个相当小的堆（大约2Kb），如果它需要分配比这个更多的空间，那么进程被GC并且它的堆可能被扩展。要了解GC的更多细节，我推荐<a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html" target="_blank" rel="external">这篇文章</a>以及另<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">一篇文章</a>。</p>
<p>在我们的测试里，这意味着缓冲区进程将相当快扩展到很大的堆，因为它要容纳20万个元素。那么，当我们压入更多数据并产生更多垃圾，GC将有很多工作要做。因此，我们可以期待有一些显著的GC停顿发生，它们将导致延迟尖峰。让我们核实一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mix buffer.bench -m Buffer.Queue</div><div class="line"></div><div class="line">push/pull (2000000 <span class="built_in">times</span>, average: 6.9 μs)</div><div class="line">  99%: 17 μs</div><div class="line">  99.9%: 32 μs</div><div class="line">  99.99%: 74 μs</div><div class="line">  99.999%: 21695 μs</div><div class="line">  100%: 37381 μs</div><div class="line">  Longest 10 (μs): 27134 27154 27407 27440 27566 27928 28138 28899 33616 37381</div><div class="line"></div><div class="line">gc (274 <span class="built_in">times</span>, average: 8514.46 μs)</div><div class="line">  99%: 22780 μs</div><div class="line">  99.9%: 23612 μs</div><div class="line">  99.99%: 23612 μs</div><div class="line">  99.999%: 23612 μs</div><div class="line">  100%: 23612 μs</div><div class="line">  Longest 10 (μs): 21220 21384 21392 21516 21598 21634 21949 22233 22780 23612</div><div class="line"></div><div class="line">Buffer process memory: 35396 KB</div><div class="line">Total memory used: 330 MB</div></pre></td></tr></table></figure>
<p>这里有大量的数据，所以我将突出一些我发现的最有趣的数字。</p>
<p>我将从缓冲区操作的平均延迟开始。最近平均值这个概念得到一些坏名声，但我仍然觉得它们是有用的度量标准。观察到的平均延迟是6.9微秒，这告诉我，即使缓冲区完全满了，这个实现可以没有延迟地应付大约每秒145000次操作。如果我能容忍一些延迟的变化，而且也不期望更高的请求，那么 :queue 实现应该适合我的需求。</p>
<p>看一下延迟的分布，我们可以看到最大延迟大约37毫秒。这可能是不可接受的，又或者它可能是刚好合适的，这取决于特定的场景。武断地认为这个用 :queue 实现的缓冲区是糟糕的，或者断定它在所有场景下都是可行的，这两种看法都应该是错误的。如果我们知道手头上具体问题的规格和要求，我们就能解释这些数字。</p>
<p>如果你仔细观察push和pull操作的延迟分布，你可以看到在4个9和5个9之间延迟迅速增加，延迟从两位数的微秒区间过度到两位数的毫秒区间。在两百万操作里，意味着我们要经历小于200个延迟尖峰。同样，这是否可以被接受取决于特定问题的约束。</p>
<p>打印出来的GC状态只和缓冲区进程相关。我们可以看到274次GC发生在缓冲区进程里，而且有很高比例的延迟在两位数毫秒区间。不出所料，GC的次数和开始于4个9到5个9的延迟尖峰之间似乎有着很强的相关性。</p>
<p>最后，请注意缓冲区进程的堆大小为何是35MB。你可能期望它大约是200MB，因为缓冲区持有20万元素，每个元素是1024个字节。但是，在这个基准测试里，元素被叫做<a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#id67990" target="_blank" rel="external">引用计数二进制数据</a>，它的意思是它们被存储在单独的堆上。缓冲区进程只持有这些二进制数据的引用，而不是数据本身。</p>
<p>当然，缓冲区进程还是有20万引用在它自己的堆上，还和被删除的消息等任何垃圾一起，这些就是引起延迟尖峰的原因。因此如果我只看它和其他语言比较最坏的GC次数的话，Erlang就不够好，并且我可能错误地得到结论，它不适合这项工作。</p>
<h1 id="基于ETS的实现"><a href="#基于ETS的实现" class="headerlink" title="基于ETS的实现"></a>基于ETS的实现</h1><p>然而，我可以用ETS表来限制GC。ETS表有很多特色，但是本文我为了简单起见，只讲它们可以当做一个进程内的内存的键值存储来用。当涉及到语义，ETS表没有给表带来什么新的东西（没有双关语义）。你可以用普通的Erlang进程和数据结构来实现同样的功能。</p>
<p>然而，该表有几个有趣的特性，能使他们在某些情况下表现的很好。首先，ETS表的数据被存储在进程堆之外的独立内存空间里。因此，如果我们使用ETS表来存储数据，缓冲区进程就不再需要持有许多引用，这应该会减少它的GC次数。此外，ETS表里的数据在被删除后将立即被释放。这意味着我们可以完全避免在大集合数据上的GC。</p>
<p>我用ETS表来实现的缓冲区是根据Pusher的GO实现来做的。基本上，我用ETS表来模拟一个可变数组，存储 (index, value) 这样的键值对到表中。我维护着两个索引，一个决定我push下一个元素到哪个位置，另一个决定了我从哪个位置pull下一个元素。它们都是从零开始。然后，每次push存储一个(push_index, value)这样的键值对到表中，就将push的索引加一。如果push的索引达到缓冲区最大尺寸，它就被设置为零。同样地，当pull数据的时候，我根据 pull_index 键来读取值，并且增加pull索引的值。如果缓冲区已满，则pull操作将覆盖最老值并增加两个索引，从而确保下一个pull操作将从适当位置读取数据。全部实现代码在<a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/ets.ex" target="_blank" rel="external">这里</a>。</p>
<p>让我们看看它的性能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mix buffer.bench -m Buffer.Ets</div><div class="line"></div><div class="line">push/pull (2000000 <span class="built_in">times</span>, average: 6.53 μs)</div><div class="line">  99%: 27 μs</div><div class="line">  99.9%: 37 μs</div><div class="line">  99.99%: 50 μs</div><div class="line">  99.999%: 66 μs</div><div class="line">  100%: 308 μs</div><div class="line">  Longest 10 (μs): 76 80 83 86 86 96 106 186 233 308</div><div class="line"></div><div class="line">gc (97062 <span class="built_in">times</span>, average: 5.16 μs)</div><div class="line">  99%: 10 μs</div><div class="line">  99.9%: 20 μs</div><div class="line">  99.99%: 30 μs</div><div class="line">  99.999%: 44 μs</div><div class="line">  100%: 44 μs</div><div class="line">  Longest 10 (μs): 30 30 34 34 34 39 43 44 44 44</div><div class="line"></div><div class="line">Buffer process memory: 30 KB</div><div class="line">Total memory used: 312 MB</div></pre></td></tr></table></figure>
<p>6.53微秒的平均时间没有比用 :queue 模块实现的更好。不过，延迟尖峰现在小了很多。观测到的最长延迟是308微秒，同时，在5个9的区域，我们已经减到了两位数微秒区域。实际上，在两百万的操作里，只有4个操作的延迟时间大于100微秒。相当不错。:-)</p>
<p>充分披露：这个结果是我运行了几次测试中的最好一次结果。在我的机器上，最大延时有时候略大于1毫秒，而其他数字没有明显的变化。特别是，99.999%总是低于100微秒。</p>
<p>观察一下GC的状态，你可以看到缓冲区进程的GC次数大幅度增加。在用 :queue 模块的实现里，缓冲区进程触发了274次GC，但是这个实现里，我们观察到大约97000次GC。这是为什么呢？记住，缓冲区进程仍然在它自己的堆上管理着一些数据。其中包括了下一次push和pull操作的索引，以及对刚刚被push和pull的元素的临时引用。因此，大量请求到达缓冲区进程，它将产生大量垃圾。但是，给缓冲区的元素被存储在ETS表的单独堆上，缓冲区永远不会维护一个大的活跃的数据集。这与Pusher的结论相符。GC的延迟尖峰与产生的垃圾量无关，而是与活跃的工作数据集的数量有关。在这个实现里，我们减少工作的数据集，保持缓冲区进程的堆很小。因此，虽然我们将触发大量的GC，但是它们耗时都相当短。观察到的缓冲区进程的最长GC时间仅仅44微秒。</p>
<h1 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h1><p>因为Erlang的stop-the-process的GC特性，我们可能在一些进程里经历长时间停顿。但是我们有一些选项可以帮我们削减大的延迟尖峰。控制这些停顿的主要技巧就是保持进程的堆很小。一个大的活跃堆加上频繁的传入请求将对GC施加更多的压力，延迟将增加。</p>
<p>在这个特定的例子中，使用ETS帮我减少缓冲区进程的堆大小。虽然GC数量显著增加，但是GC停顿很短使得整体延迟稳定。虽然Erlang肯定不是最快的平台，但是它让我保持我的延迟是可预测的。我构建系统，调优它达到我想要的性能，并且我可以预测到在生产中较少的令人吃惊情况发生。</p>
<p>值得一提的另外两种技术可能会帮助您减少GC延迟尖峰。第一个是将管理一个大堆的进程分割成多个管理更小数据集的进程。这将导致碎片化的GC，并且可能削减GC延迟尖峰。</p>
<p>在某些情况下，你可以充分利用进程终止时立即释放进程内存的事实。如果你需要执行一个分配大量临时内存的一次性工作，你可以考虑使用<a href="https://hexdocs.pm/elixir/Process.html#spawn/2" target="_blank" rel="external">Process.spawn</a>，它允许你在启动进程时显式地预先分配一个大的堆给这个进程。这可能完全阻止GC在这个进程中发生。你做计算，输出结果，最后终止进程，因此它所有的内存被立即回收而从来没有被GC过。</p>
<p>最后，如果你不能在Erlang里使得你的系统的一些关键部分高效，那么你可以利用<a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/" target="_blank" rel="external">进程内的NIF的C编程</a>或者<a href="http://theerlangelist.com/article/outside_elixir" target="_blank" rel="external">进程外的端口机制</a>，而保持Erlang/Elixir作为你的系统的主平台和“控制面板”。许多选项都在桌面上，这给了我很大的信心，我将能够处理任何我遇到的挑战，无论它可能多么棘手。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://www.theerlangelist.com/article/reducing_maximum_latency" target="_blank" rel="external">http://www.theerlangelist.com/article/reducing_maximum_latency</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我在&lt;a href=&quot;https://pusher.com/&quot;&gt;Pusher&lt;/a&gt;的博客读到两篇很棒的文章：&lt;a href=&quot;https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/&quot;&gt;低延迟、大的工作集和GHC的垃圾收集器：三选二&lt;/a&gt; 和 &lt;a href=&quot;https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/&quot;&gt;Golang的实时GC的理论与实践&lt;/a&gt; 。这两篇文章讲的是Pusher的工程师如何重新实现他们的消息总线的故事。第一篇是发生在Haskell里。在性能测试期间，他们发现在99%那个范围内有一些高延迟。在他们分析代码后，他们能够证明这些延时的尖峰是由GHC的 stop-the-world 垃圾收集器，再加上一个大的工作集（内存中的对象的数目）所造成的。该开发团队随后尝试了GO，得到好得多的结果，这得益于GO的并发垃圾收集器。&lt;/p&gt;
&lt;p&gt;我强烈推荐这两篇文章。Pusher的测试是一个很棒的基准测试例子，因为它专注于解决一个真正的挑战，并且基于该项技术是否合适本工作来评估此技术。这是我喜欢的那种评估方式。我发现做一个简单的关键功能的实现非常有用，然后看看它在所需的负荷下的表现，而不是通过一些浅层的模拟基准测试来比较不同的技术，例如在环里传递令牌，或让一个Web服务器返回“200 OK”。这个方法应该能提供“我能用Y有效地解决X吗？”问题的答案。当我第一次评估Erlang的时候，我采用的就是这种方法。10 倍的预期负载模拟真实系统的12个小时测试让我相信这项技术比我所需要的绰绰有余。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/categories/Elixir/GC/"/>
    
      <category term="maximum latency" scheme="http://szpzs.oschina.io/categories/Elixir/GC/maximum-latency/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/tags/GC/"/>
    
      <category term="buffer" scheme="http://szpzs.oschina.io/tags/buffer/"/>
    
      <category term="maximum latency" scheme="http://szpzs.oschina.io/tags/maximum-latency/"/>
    
  </entry>
  
  <entry>
    <title>Elixir中的元编程－领域特定语言</title>
    <link href="http://szpzs.oschina.io/2017/02/27/elixir-getting-started-meta-domain-specific-languages/"/>
    <id>http://szpzs.oschina.io/2017/02/27/elixir-getting-started-meta-domain-specific-languages/</id>
    <published>2017-02-26T22:27:43.000Z</published>
    <updated>2017-02-28T08:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">前言</a></li>
<li><a href="#part-two">构建我们自己的测试用例</a></li>
<li><a href="#part-three">test宏</a></li>
<li><a href="#part-four">用属性存储信息</a></li>
</ol>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><span id="part-one">前言</span></h1><p>域特定语言 (DSL) 允许开发人员剪裁它们的应用到特定领域。你不需要为了有一个DSL而需要宏：在你的模块里定义的每个数据结构和每个函数是你的领域特定语言的一部分。</p>
<p>例如，假设我们想实现一个校验器模块，它提供一个数据校验领域特定语言。我们可以使用数据结构、函数或宏来实现它。让我们看看这些不同的DSL的样子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 数据结构</span></div><div class="line">import Validator</div><div class="line">validate user, <span class="symbol">name:</span> [<span class="symbol">length:</span> <span class="number">1</span>..<span class="number">100</span>],</div><div class="line">               <span class="symbol">email:</span> [<span class="symbol">matches:</span> ~r/@/]</div><div class="line"></div><div class="line"><span class="comment"># 2. 函数</span></div><div class="line">import Validator</div><div class="line">user</div><div class="line">|&gt; validate_length(<span class="symbol">:name</span>, <span class="number">1</span>..<span class="number">100</span>)</div><div class="line">|&gt; validate_matches(<span class="symbol">:email</span>, ~r/@/)</div><div class="line"></div><div class="line"><span class="comment"># 3. 宏 + 模块</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyValidator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Validator</div><div class="line">  validate_length <span class="symbol">:name</span>, <span class="number">1</span>..<span class="number">100</span></div><div class="line">  validate_matches <span class="symbol">:email</span>, ~r/@/</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyValidator.validate(user)</div></pre></td></tr></table></figure>
<p>在上面所有的方法中，第一个绝对是最灵活的。如果我们的领域规则可以用数据结构进行编码，则它们是迄今为止最容易的撰写和实施，因为Elixir的标准库中充满了操纵不同数据类型的函数。</p>
<p>第二种方法使用函数调用，它更适合更复杂的API（例如，如果你需要传递很多选项）和Elixir里用管道运算符来更好地读。</p>
<p>第三种方法，使用宏，是迄今为止最复杂的。它将花更多行代码来实现，也难于测试（是和测试简单函数相比），它限制用户肯能如何使用库，因为所有校验需要被定义在一个模块里。</p>
<p>若要驱动该点，请假设只有在给定条件满足时才要验证某个属性。我们可以很容易地用第一种方案实现，通过操作相应结构的数据，或用第二种方案在调用函数之前用条件句（if/else）。但是，用宏的方法是不可能的，除非它的DSL被增强。</p>
<p>换句话说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data &gt; <span class="built_in">functions</span> &gt; macros</div></pre></td></tr></table></figure>
<p>也就是说，仍然有场景使用宏和模块来构建特定于域的语言。既然我们在入门指南已经探讨了数据结构和函数定义，那么本章将探讨如何使用宏和模块的属性来处理更复杂的DSL。</p>
<h1 id="构建我们自己的测试用例"><a href="#构建我们自己的测试用例" class="headerlink" title="构建我们自己的测试用例"></a><span id="part-two">构建我们自己的测试用例</span></h1><p>本章的目标是构建一个名为 TestCase 的模块，它允许我们按如下内容来写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> TestCase</div><div class="line"></div><div class="line">  test <span class="string">"arithmetic operations"</span> <span class="keyword">do</span></div><div class="line">    <span class="number">4</span> = <span class="number">2</span> + <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"list operations"</span> <span class="keyword">do</span></div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>] ++ [<span class="number">3</span>]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyTest.run</div></pre></td></tr></table></figure>
<p>在上面的例子里，通过使用 TestCase ，我们可以用 test 宏写测试用例，它定义了一个名为 run 的函数来为我们自动运行所有测试用例。我们的原型将依赖匹配运算符（=）作为一个种机制来做断言。</p>
<h1 id="test宏"><a href="#test宏" class="headerlink" title="test宏"></a><span id="part-three">test宏</span></h1><p>让我们从创建一个定义和导入test宏的模块开始：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">TestCase</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Callback invoked by `use`.</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># For now it returns a quoted expression that</span></div><div class="line">  <span class="comment"># imports the module itself into the user code.</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__using__</span></span>(_opts) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      import TestCase</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Defines a test case with the given description.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      test "arithmetic operations<span class="string">" do</span></div><div class="line">        4 = 2 + 2</div><div class="line">      end</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">test</span></span>(description, <span class="symbol">do:</span> block) <span class="keyword">do</span></div><div class="line">    function_name = String.to_atom(<span class="string">"test "</span> &lt;&gt; description)</div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(function_name)(), <span class="symbol">do:</span> unquote(block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>假设我们在文件 tests.exs 里定义了 TestCase ，我们可以通过运行 iex tests.exs 打开它，并且定义我们第一个测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="keyword">use</span> TestCase</div><div class="line">...&gt;</div><div class="line">...&gt;   test <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;     <span class="string">"hello"</span> = <span class="string">"world"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在我们没有一种机制来运行测试，但是我们知道一个名为 “test hello” 的函数被定义在后台。当我们调用它，它应该失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; MyTest.<span class="string">"test hello"</span>()</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"world"</span></div></pre></td></tr></table></figure>
<h1 id="用属性存储信息"><a href="#用属性存储信息" class="headerlink" title="用属性存储信息"></a><span id="part-four">用属性存储信息</span></h1><p>为了完成我们的 TestCase 实现，我们需要能够访问所有被定义的测试用例。在运行时通过 __MODULE__.__info__(:functions) 获取测试用例来做到这点，这个函数将返回给定模块的所有函数组成的列表。但是，考虑到我们可能想要存储除了每一个测试用例名字外更多的信息，一个更灵活的方法是我们需要的。</p>
<p>在前面章节讨论模块属性时，我们提到了如何将它们用作临时存储。这正是我们将在本节中使用的属性。</p>
<p>在 __using__/1 的实现里，我们将初始化名为 @tests 的模块属性为一个空列表，然后存储每一个定义好的测试用例的名字到这个属性里，所以测试用例可以在run函数里被调用。</p>
<p>下面是 TestCase 模块修改后的代码：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">TestCase</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__using__</span></span>(_opts) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      import TestCase</div><div class="line"></div><div class="line">      <span class="comment"># 初始化 @tests 为一个空列表</span></div><div class="line">      <span class="variable">@tests</span> []</div><div class="line"></div><div class="line">      <span class="comment"># 模块被编译前调用 TestCase.__before_compile__/1</span></div><div class="line">      <span class="variable">@before_compile</span> TestCase</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Defines a test case with the given description.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      test "arithmetic operations<span class="string">" do</span></div><div class="line">        4 = 2 + 2</div><div class="line">      end</div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">test</span></span>(description, <span class="symbol">do:</span> block) <span class="keyword">do</span></div><div class="line">    function_name = String.to_atom(<span class="string">"test "</span> &lt;&gt; description)</div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="comment"># 插入新定义的测试到测试列表</span></div><div class="line">      <span class="variable">@tests</span> [unquote(function_name) | <span class="variable">@tests</span>]</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">unquote</span></span>(function_name)(), <span class="symbol">do:</span> unquote(block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 这将在目标模块被编译前被立即调用</span></div><div class="line">  <span class="comment"># 给我们完美的机会注入'run/0'函数</span></div><div class="line">  <span class="variable">@doc</span> <span class="keyword">false</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">__before_compile__</span></span>(env) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span></span> <span class="keyword">do</span></div><div class="line">        Enum.each <span class="variable">@tests</span>, <span class="keyword">fn</span> name -&gt;</div><div class="line">          IO.puts <span class="string">"Running <span class="subst">#&#123;name&#125;</span>"</span></div><div class="line">          apply(__MODULE_<span class="number">_</span>, name, [])</div><div class="line">        <span class="keyword">end</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>启动一个新的IEx，我们现在可以定义我们的测试用例并运行它们：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyTest</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="keyword">use</span> TestCase</div><div class="line">...&gt;</div><div class="line">...&gt;   test <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;     <span class="string">"hello"</span> = <span class="string">"world"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; MyTest.run</div><div class="line">Running test hello</div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>虽然我们忽略了一些细节，但是这是在Elixir里创建领域特定模块的主要思想。宏允许我们返回在调用者中执行的引用表达式，然后我们可以通过模块属性来用它转换代码并存储相关信息到目标模块中。最后，像 @before_compile 这样的回调，当它的定义完成的时候，允许我们注入代码到模块里。</p>
<p>除了 @before_compile ，还有其他有用的模块属性，像 @on_definition 和 @after_compile ，你可以在 <a href="https://hexdocs.pm/elixir/Module.html" target="_blank" rel="external">Module 模块的文档</a>里读到跟多关于它们的内容。你也可以在 Macro module 和 Macro.Env 文档里找到关于宏和编译环境的有用信息。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/domain-specific-languages.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/domain-specific-languages.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;构建我们自己的测试用例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;test宏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;用属性存储信息&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/"/>
    
      <category term="domain-specific-language" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/domain-specific-language/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/tags/meta-programming/"/>
    
      <category term="domain-specific-language" scheme="http://szpzs.oschina.io/tags/domain-specific-language/"/>
    
  </entry>
  
  <entry>
    <title>Elixir中的元编程－宏</title>
    <link href="http://szpzs.oschina.io/2017/02/26/elixir-getting-started-meta-macros/"/>
    <id>http://szpzs.oschina.io/2017/02/26/elixir-getting-started-meta-macros/</id>
    <published>2017-02-25T23:08:59.000Z</published>
    <updated>2017-02-28T08:22:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">前言</a></li>
<li><a href="#part-two">我们第一个宏</a></li>
<li><a href="#part-three">宏的卫生</a></li>
<li><a href="#part-four">环境</a></li>
<li><a href="#part-five">私有宏</a></li>
<li><a href="#part-six">负责任地写宏</a></li>
</ol>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><span id="part-one">前言</span></h1><p>即使Elixir尽最大努力为宏提供一个安全的环境，但是用宏写干净的代码的主要责任落在开发者身上。宏比普通Elixir函数更难写，并且当它们不是必需的时候，使用它们被认为是一种坏的风格。所以要负责人地写宏。</p>
<p>Elixir已经通过使用它的数据结构和函数以一种简单和可读的方式提供了一种机制来写你每天的代码。宏只能作为最后的手段使用。记住，明确的优于暗示的。清晰代码优于简洁代码。</p>
<h1 id="我们第一个宏"><a href="#我们第一个宏" class="headerlink" title="我们第一个宏"></a><span id="part-two">我们第一个宏</span></h1><p>在Elixir里，宏通过 defmacro/2 定义。</p>
<blockquote>
<p>在本章，我们将使用文件来替代在IEx里运行代码样例。这是因为代码样例将跨多行而在IEx里输入它们将适得其反。你应该把代码样例保存在macros.exs文件里，用 elixir macros.exs 或 iex macros.exs 运行。</p>
</blockquote>
<p>为了更好地理解宏是如何工作的，让我们创建一个新模块分别用宏和函数来实现 unless ，也即 if 的相反功能：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Unless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun_unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">    if(!clause, <span class="symbol">do:</span> expression)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">macro_unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      if(!unquote(clause), <span class="symbol">do:</span> unquote(expression))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>函数接收入参然后传递给 if 。但是，如我们在<a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">前一章</a>所学，宏将接收引用表达式然后注入到引用，最后返回另一个引用表达式。</p>
<p>让我们用上面的模块来启动iex：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex macros.exs</div></pre></td></tr></table></figure>
<p>然后试一试那些定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; require Unless</div><div class="line">iex&gt; Unless.macro_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; Unless.fun_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div><div class="line"><span class="string">"this should never be printed"</span></div><div class="line"><span class="keyword">nil</span></div></pre></td></tr></table></figure>
<p>注意，在我们的宏实现了，句子没有被打印，而在我们的函数实现里，句子被打印了。那是因为传递给函数调用的入参在函数被调用前执行了。然而，宏不执行它们的入参。相反，它们接收入参作为引用表达式，然后转换为其他引用表达式。在本例子中，我们重写了 unless 宏，使得其实际上是一个 if 。</p>
<p>也就是说，当如下调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unless.macro_unless <span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span></div></pre></td></tr></table></figure>
<p>则我们的 macro_unless ，接收到如下所示内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">macro_unless(<span class="keyword">true</span>, [<span class="symbol">do:</span> &#123;&#123;<span class="symbol">:</span>., [], [&#123;<span class="symbol">:__aliases__</span>, [<span class="symbol">alias:</span> <span class="keyword">false</span>], [<span class="symbol">:IO</span>]&#125;, <span class="symbol">:puts</span>]&#125;, [], [<span class="string">"this should never be printed"</span>]&#125;])</div></pre></td></tr></table></figure>
<p>然后它返回一个引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:if</span>, [],</div><div class="line"> [&#123;<span class="symbol">:</span>!, [], [<span class="keyword">true</span>]&#125;,</div><div class="line">  [<span class="symbol">do:</span> &#123;&#123;<span class="symbol">:</span>., [],</div><div class="line">     [&#123;<span class="symbol">:__aliases__</span>,</div><div class="line">       [], [<span class="symbol">:IO</span>]&#125;,</div><div class="line">      <span class="symbol">:puts</span>]&#125;, [], [<span class="string">"this should never be printed"</span>]&#125;]]&#125;</div></pre></td></tr></table></figure>
<p>我们可以用 Macro.expand_once/2 确认这个例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; expr = <span class="keyword">quote</span> <span class="symbol">do:</span> Unless.macro_unless(<span class="keyword">true</span>, <span class="symbol">do:</span> IO.puts <span class="string">"this should never be printed"</span>)</div><div class="line">iex&gt; res  = Macro.expand_once(expr, __ENV_<span class="number">_</span>)</div><div class="line">iex&gt; IO.puts Macro.to_string(res)</div><div class="line">if(!<span class="keyword">true</span>) <span class="keyword">do</span></div><div class="line">  IO.puts(<span class="string">"this should never be printed"</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>Macro.expand_once/2 接收一个引用表达式然后依据当前环境扩展它。在本例子里，它扩展/调用 Unless.macro<em>unless/2 宏并且返回它的结果。我们然后继续转换返回的引用表达式为一个字符串并且打印它（我们将在这章后面讨论 \</em>_ENV__ ）。</p>
<p>这就是宏的所有内容。他们是关于接受引用表达式，并转化成其他东西。实际上，在Elixir里的 unless/2 就是用宏来实现的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defmacro</span> <span class="title">unless</span></span>(clause, <span class="symbol">do:</span> expression) <span class="keyword">do</span></div><div class="line">  <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">    if(!unquote(clause), <span class="symbol">do:</span> unquote(expression))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>向 unless/2, defmacro/2, def/2, defprotocol/2 这样的结构，和在本教程中被使用的许多其他结构都是用纯Elixir实现的，经常是实现为一个宏。这意味着，用于构建语言的结构可以被开发人员用来将语言扩展到他们正在工作的领域。</p>
<p>我们可以定义一些函数和我们想要的宏，包括那些覆盖由Elixir提供的内置的定义。唯一的例外是Elixir的特殊形式，不用Elixir实现的，因此无法重写，<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary" target="_blank" rel="external">特殊形式的所有列表在Kernel.SpecialForms 里</a>。</p>
<h1 id="宏的卫生"><a href="#宏的卫生" class="headerlink" title="宏的卫生"></a><span id="part-three">宏的卫生</span></h1><p>Elixir宏有晚解决。它保证引用内定义的变量不会和宏展开的上下文里定义的变量冲突。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Hygiene</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">no_interference</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> a = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HygieneTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span></span> <span class="keyword">do</span></div><div class="line">    require Hygiene</div><div class="line">    a = <span class="number">13</span></div><div class="line">    Hygiene.no_interference</div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">HygieneTest.go</div><div class="line"><span class="comment"># =&gt; 13</span></div></pre></td></tr></table></figure>
<p>上述例子里，即使宏注入了 a = 1 ，它不会影响go函数里定义的变量 a。如果宏想明确地影响上下文，它可以用 var! ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Hygiene</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">interference</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> var!(a) = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">HygieneTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span></span> <span class="keyword">do</span></div><div class="line">    require Hygiene</div><div class="line">    a = <span class="number">13</span></div><div class="line">    Hygiene.interference</div><div class="line">    a</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">HygieneTest.go</div><div class="line"><span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>变量的卫生能运作只能是因为Elixir用上下文标注变量。例如，在一个模块的第三行定义的变量x将被表示成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:x</span>, [<span class="symbol">line:</span> <span class="number">3</span>], <span class="keyword">nil</span>&#125;</div></pre></td></tr></table></figure>
<p>但是，一个引用变量被表示成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">quoted</span></span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Sample.quoted <span class="comment">#=&gt; &#123;:x, [line: 3], Sample&#125;</span></div></pre></td></tr></table></figure>
<p>注意，在引用变量里的第三个元素是原子 Sample ，而不是 nil ，这说明这个变量来自 Sample 模块。因此，Elixir认为这两个变量来自不同的模块和上下文，因此相应地分别处理它们。</p>
<p>Elixir为导入和别名也提供相似的机制。这保证了宏如它所在模块指定那样表现，而不会与它将被展开的所在模块发生冲突。Hygiene 可以在通过用像 var!/2 和 alias!/2 这样的宏特定的环境下被绕过，但是使用它们的时候必须要小心，因为它们直接修改用户环境。</p>
<p>有时候变量名字可以动态创建。在这种情况下，macro.var/2可以用来定义新的变量：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">initialize_to_char_count</span></span>(variables) <span class="keyword">do</span></div><div class="line">    Enum.map variables, <span class="keyword">fn</span>(name) -&gt;</div><div class="line">      var = Macro.var(name, <span class="keyword">nil</span>)</div><div class="line">      length = name |&gt; Atom.to_string |&gt; String.length</div><div class="line">      <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">        unquote(var) = unquote(length)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span> <span class="keyword">do</span></div><div class="line">    initialize_to_char_count [<span class="symbol">:red</span>, <span class="symbol">:green</span>, <span class="symbol">:yellow</span>]</div><div class="line">    [red, green, yellow]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">&gt; Sample.run <span class="comment">#=&gt; [3, 5, 6]</span></div></pre></td></tr></table></figure>
<p>注意 Macro.var/2 的第二个入参。这是正在使用的上下文，将决定在下一节描述的卫生。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><span id="part-four">环境</span></h1><p>在本章稍早前调用 Macro.expand<em>once/2 的时候，我们使用特别的形式 \</em>_ENV__。</p>
<p>__ENV__ 返回 Macro.Env 结构的一个实例，它含有有关编译环境的有用信息，包括当前模块、文件和行，所有在当前范围定义的变量，以及导入和需求等等：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; __ENV_<span class="number">_</span>.<span class="keyword">module</span></div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.file</div><div class="line"><span class="string">"iex"</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.requires</div><div class="line">[IEx.Helpers, Kernel, Kernel.Typespec]</div><div class="line">iex&gt; require Integer</div><div class="line"><span class="keyword">nil</span></div><div class="line">iex&gt; __ENV_<span class="number">_</span>.requires</div><div class="line">[IEx.Helpers, Integer, Kernel, Kernel.Typespec]</div></pre></td></tr></table></figure>
<p>Macro 模块里的许多函数期望有一个环境。你可以在 <a href="https://hexdocs.pm/elixir/Macro.html" target="_blank" rel="external">Macro 模块文档</a>里读到跟多有关这些函数的内容，也可以在 <a href="https://hexdocs.pm/elixir/Macro.Env.html" target="_blank" rel="external">Macro.Env 文档</a>里学到更多有关编译环境的知识。</p>
<h1 id="私有宏"><a href="#私有宏" class="headerlink" title="私有宏"></a><span id="part-five">私有宏</span></h1><p>Elixir用 defmacrop 也支持私有宏。像私有函数，这样的宏只能在定义它们的模块里有效，也只能在编译时有效。</p>
<p>宏在使用之前定义是很重要的。在调用之前不定义宏会在运行时引发错误，因为宏不会被扩展，将被转换为函数调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Sample</span></span> <span class="keyword">do</span></div><div class="line">...&gt;  <span class="function"><span class="keyword">def</span> <span class="title">four</span></span>, <span class="symbol">do:</span> two + two</div><div class="line">...&gt;  defmacrop two, <span class="symbol">do:</span> <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) <span class="symbol">iex:</span><span class="number">2</span>: function two/<span class="number">0</span> undefined</div></pre></td></tr></table></figure>
<h1 id="负责任地写宏"><a href="#负责任地写宏" class="headerlink" title="负责任地写宏"></a><span id="part-six">负责任地写宏</span></h1><p>宏是一个功能强大的结构并且Elixir提供了许多机制来确保他们被负责任地使用。</p>
<ul>
<li>宏是卫生的：默认情况下，宏中定义的变量不会影响用户代码。此外，函数调用和在宏观背景下可用的别名是不会泄漏到用户上下文。</li>
<li>宏是有词法范围的：在全局中注入代码或宏是不可能的。为了使用宏，你需要明确地需要或导入定义宏的模块。</li>
<li>宏是明确的：不明确调用宏是不可能运行宏的。例如，一些语言允许开发人员完全重写后台的功能，通常是通过解析变换或通过一些反射机制。在Elixir里，必须在编译时在调用者里明确地调用宏。</li>
<li>宏语言是清晰的：许多语言提供引用和非引用的语法快捷方式。在Elixir，为了清楚地划定一个宏的定义和引用表达式的界限，我们喜欢有明确的说明。</li>
</ul>
<p>即使有了这样的保证，开发者在负责编写宏时也扮演了重要角色。如果你有信心需要采用宏，请记住宏不是你的API。保持你的宏定义短，包括它们的引用内容。例如，不要像下面这样写宏：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyModule</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">my_macro</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      do_this(unquote(a))</div><div class="line">      ...</div><div class="line">      do_that(unquote(b))</div><div class="line">      ...</div><div class="line">      and_that(unquote(c))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>而是像下面这样写：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyModule</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">my_macro</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    <span class="keyword">quote</span> <span class="keyword">do</span></div><div class="line">      <span class="comment"># Keep what you need to do here to a minimum</span></div><div class="line">      <span class="comment"># and move everything else to a function</span></div><div class="line">      do_this_that_and_that(unquote(a), unquote(b), unquote(c))</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">do_this_that_and_that</span></span>(a, b, c) <span class="keyword">do</span></div><div class="line">    do_this(a)</div><div class="line">    ...</div><div class="line">    do_that(b)</div><div class="line">    ...</div><div class="line">    and_that(c)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这使你的代码更清晰，更容易测试和维，并且你可以直接调用和测试do_this_that_and_that / 3。它还有助于你为开发人员设计不想依赖宏的实际的API。</p>
<p>有了这些教程，我们完成了对宏的介绍。下一章讨论DSL，显示我们如何可以混合宏和模块属性来诠释和扩展模块和函数。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/macros.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/macros.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;我们第一个宏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;宏的卫生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;私有宏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;负责任地写宏&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/macro/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/tags/meta-programming/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Elixir中的元编程－Quote 和 Unquote</title>
    <link href="http://szpzs.oschina.io/2017/02/25/elixir-getting-started-meta-quote-and-unquote/"/>
    <id>http://szpzs.oschina.io/2017/02/25/elixir-getting-started-meta-quote-and-unquote/</id>
    <published>2017-02-25T08:20:29.000Z</published>
    <updated>2017-02-28T08:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Quoting</a></li>
<li><a href="#part-two">Unquoting</a></li>
<li><a href="#part-three">Escaping</a></li>
</ol>
<p>一个Elixir程序可以由Elixir自己的数据结构表示。在本章里，我们将学习那些数据结构看起来是什么样的，以及如何组成它们。在本章中学习的概念是宏的构建块，我们将在下一章中更深入地研究它。</p>
<a id="more"></a>
<h1 id="Quoting"><a href="#Quoting" class="headerlink" title="Quoting"></a><span id="part-one">Quoting</span></h1><p>一个Elixir程序的构建块上一个三元素的元组。例如，一个函数调用 sum(1, 2, 3) 被内部表示为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<p>你通过使用 quote 宏得到任何表达式的表示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<p>第一个元素是函数名，第二个元素是一个包含元数据的关键字列表，第三个元素是参数列表。</p>
<p>运算符也可以表示为这样的元组：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">1</span> + <span class="number">2</span></div><div class="line">&#123;<span class="symbol">:+</span>, [<span class="symbol">context:</span> Elixir, <span class="symbol">import:</span> Kernel], [<span class="number">1</span>, <span class="number">2</span>]&#125;</div></pre></td></tr></table></figure>
<p>甚至一个映射被表示为对 %{} 的调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> %&#123;<span class="number">1</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>变量也可以用这样的三元素的元组来表示，其最后一个元素不是一个列表而是一个原子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> x</div><div class="line">&#123;<span class="symbol">:x</span>, [], Elixir&#125;</div></pre></td></tr></table></figure>
<p>当引用更负责的表达式，我们可以看到代码用这样的元组来表示，这样的元组经常彼此嵌套为一个像一颗树的结构。许多语言叫这样的表示为抽象语法树（AST）。Elixir叫它们为被引用的表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">&#123;<span class="symbol">:sum</span>, [], [<span class="number">1</span>, &#123;<span class="symbol">:+</span>, [<span class="symbol">context:</span> Elixir, <span class="symbol">import:</span> Kernel], [<span class="number">2</span>, <span class="number">3</span>]&#125;, <span class="number">4</span>]&#125;</div></pre></td></tr></table></figure>
<p>有时使用引用表达式时，返回代码的文本表示可能是有用的。这可以用 Macro.to_string/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> sum(<span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span>, <span class="number">4</span>))</div><div class="line"><span class="string">"sum(1, 2 + 3, 4)"</span></div></pre></td></tr></table></figure>
<p>总的来说，以上元组按以下格式构造：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;atom | tuple, list, list | atom&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一个元素是一个原子或是相同表示格式的另一个元组。</li>
<li>第二个元素是一个包含元数据，比如数字和上下文，的关键字列表。</li>
<li>第三个元素是一个函数调用的参数列表或者一个原子。当这个元素是一个原子，则意味着这个元组表示一个变量。</li>
</ul>
<p>除了上述定义的元组，有五个Elixir字面量，当被引用的时候，返回的是它们自己（而不是一个元组）。它们是：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:sum</span>         <span class="comment">#=&gt; 原子</span></div><div class="line"><span class="number">1.0</span>          <span class="comment">#=&gt; 数字</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]       <span class="comment">#=&gt; 列表</span></div><div class="line"><span class="string">"strings"</span>    <span class="comment">#=&gt; 字符串</span></div><div class="line">&#123;key, value&#125; <span class="comment">#=&gt; 两个元素的元组</span></div></pre></td></tr></table></figure>
<p>大多数Elixir代码有一个它的底层引用表达式的直接翻译。我们建议你尝试不同的代码样例然后看看结果是怎么样的。例如，String.upcase(“foo”) 展开后是什么样子？我们也学到了 if(true, do: :this, else: :that) 和 if true do :this else :that end 是一样的。这个肯定是如何用引用表达式支持的？</p>
<h1 id="Unquoting"><a href="#Unquoting" class="headerlink" title="Unquoting"></a><span id="part-two">Unquoting</span></h1><p>quote是关于获取一些特指代码块的内部表示。但是，有时候可能必须注入一些其他特指代码块到我们想要获取的表示里。</p>
<p>例如，你有一个包含数字的变量number，你想要把它注入到一个引用表达式里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; number = <span class="number">13</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">11</span> + number)</div><div class="line"><span class="string">"11 + number"</span></div></pre></td></tr></table></figure>
<p>这不是我们想要的，因为number变量的值没有被注入并且number已经被引入表达式。为了注入number变量的值，unquote必须被使用在被引用的描述里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; number = <span class="number">13</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> <span class="number">11</span> + unquote(number))</div><div class="line"><span class="string">"11 + 13"</span></div></pre></td></tr></table></figure>
<p>unquote甚至可以被用于注入函数名：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; fun = <span class="symbol">:hello</span></div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> unquote(fun)(<span class="symbol">:world</span>))</div><div class="line"><span class="string">"hello(:world)"</span></div></pre></td></tr></table></figure>
<p>在一些场景里，可能必须注入许多值在一个列表里。例如，假设你有一个列表 [1, 2, 6] 并且你想把 [3, 4, 5] 注入进去。使用 unquote 不会长生想要的结果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; inner = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> [<span class="number">1</span>, <span class="number">2</span>, unquote(inner), <span class="number">6</span>])</div><div class="line"><span class="string">"[1, 2, [3, 4, 5], 6]"</span></div></pre></td></tr></table></figure>
<p>这个时候就要使用 unquote_splicing ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; inner = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">iex&gt; Macro.to_string(<span class="keyword">quote</span> <span class="symbol">do:</span> [<span class="number">1</span>, <span class="number">2</span>, unquote_splicing(inner), <span class="number">6</span>])</div><div class="line"><span class="string">"[1, 2, 3, 4, 5, 6]"</span></div></pre></td></tr></table></figure>
<p>当使用宏的时候，Unquoting 非常有用。当写宏的时候，开发者能够接收代码块并且注入它们到其他代码块里，这能被用来转换代码或者写代码，在编译期间生成代码。</p>
<h1 id="Escaping"><a href="#Escaping" class="headerlink" title="Escaping"></a><span id="part-three">Escaping</span></h1><p>正如我们在本章开始的时候所见，在Elixir里只有一些值是有效引用表达式。例如，一个映射不是一个有效引用表达式。有四个元素的元组也不是。但是，这样的值可以被表达为一个引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">quote</span> <span class="symbol">do:</span> %&#123;<span class="number">1</span> =&gt; <span class="number">2</span>&#125;</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [&#123;<span class="number">1</span>, <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>在一些场景下，你可能需要注入这样的值到引用表达式里。为了这么做，我们需要首先用 Macro.escape/1 帮主来转义那些值为引用表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; map = %&#123;<span class="symbol">hello:</span> <span class="symbol">:world</span>&#125;</div><div class="line">iex&gt; Macro.escape(map)</div><div class="line">&#123;<span class="symbol">:%</span>&#123;&#125;, [], [<span class="symbol">hello:</span> <span class="symbol">:world</span>]&#125;</div></pre></td></tr></table></figure>
<p>宏接收引用表达式并且必须返回引用表达式。然后，有些时候，在宏执行期间，你可能需要使用值并且使得值和将被需求的引用表达式之间有差别。</p>
<p>换句话说，使得一个普通Elixir值（像一个列表、一个映射、一个进程、一个引用等等）和一个引用表达式之间有差别是很重要的。一些值，比如，整数、原子和字符串，有一个引用表达式等于值的本身。其他值，像映射，需要被明确地转换。最后，像函数和引用这样的值完全不能被转换为引用表达式。</p>
<p>在 <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html" target="_blank" rel="external">Kernel.SpecialForms 模块</a>里，你可以阅读到跟多关于 quote 和 unquote 的内容。Macro.escape/1 和其他与引用表达式相关的函数的文档可以在 <a href="https://hexdocs.pm/elixir/Macro.html" target="_blank" rel="external">Macro 模块</a>里找到。</p>
<p>在这篇介绍文章里，我们已经为最终写我们的第一个宏奠定了基础，所以让我们开始下一章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/meta/quote-and-unquote.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Quoting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Unquoting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Escaping&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个Elixir程序可以由Elixir自己的数据结构表示。在本章里，我们将学习那些数据结构看起来是什么样的，以及如何组成它们。在本章中学习的概念是宏的构建块，我们将在下一章中更深入地研究它。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/"/>
    
      <category term="quote unquote" scheme="http://szpzs.oschina.io/categories/Elixir/meta-programming/quote-unquote/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="meta-programming" scheme="http://szpzs.oschina.io/tags/meta-programming/"/>
    
      <category term="quote" scheme="http://szpzs.oschina.io/tags/quote/"/>
    
      <category term="unquote" scheme="http://szpzs.oschina.io/tags/unquote/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－分布式任务和配置</title>
    <link href="http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/"/>
    <id>http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/</id>
    <published>2017-02-24T04:23:14.000Z</published>
    <updated>2017-02-24T04:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个分布式代码</a></li>
<li><a href="#part-two">异步/等待</a></li>
<li><a href="#part-three">分布式任务</a></li>
<li><a href="#part-four">路由层</a></li>
<li><a href="#part-five">测试过滤器和标签</a></li>
<li><a href="#part-six">应用环境和配置</a></li>
<li><a href="#part-seven">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<a id="more"></a>
<p>在这最后一章，我们将回到 :kv 应用并增加一个路由层，这个路由层将允许我们基于bucket名字在节点间分布请求。</p>
<p>路由层将接收如下格式的一张路由表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line"> &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>路由器将根据表检查bucket名字的第一个字节然后据此来派发到合适的节点。例如，以字母“a”开头的一个bucket（?a表示字母“a”的Unicode代码点）将被派发到节点 foo@computer-name 。</p>
<p>如果匹配的条目指向处理请求的节点，那么我们就已经完成了路由，并且这个节点将执行请求的操作。如果匹配的条目指向一个不同的节点，我们将传递请求给这个节点，它将查询自己的路由表（可能与第一个节点的不同）并且做响应的动作。如果没有条目匹配，则一个错误将抛出。</p>
<p>你可能想知道为什么我们不告诉我们在我们的路由表找到的节点直接执行被请求的操作，而是传递路由请求给那个节点处理。尽管路由表和上面的那样简单，但在所有节点之间都可以合理地共享，这样当我们的应用程序增长时用这种方式传递路由请求使路由表变得更小。也许在某个时候，foo@computer-name 只是负责路由bucket的请求，而bucket被派发给不同的节点。用这种方式，bar@computer-name 不需要知道任何这些改变。</p>
<blockquote>
<p>注意：我们将在本章在同一个机器上使用两个节点。你可以自由地使用两台（或更多）不同的机器在同一网络，但你需要做一些准备工作。首先，你需要确认所有机器有一个有完全相同值的 ~/.erlang.cookie 文件。其次，你需要保证 <a href="http://www.erlang.org/doc/man/epmd.html" target="_blank" rel="external">epmd</a> 正运行在一个没有阻塞的端口（你可以运行 epmd -d 来输出调试信息）。最后，如果你想大体上学习更多分布式的知识，我们建议看 <a href="http://learnyousomeerlang.com/distribunomicon" target="_blank" rel="external">Learn You Some Erlang 里很棒的分布式章节</a>。</p>
</blockquote>
<h1 id="我们第一个分布式代码"><a href="#我们第一个分布式代码" class="headerlink" title="我们第一个分布式代码"></a><span id="part-one">我们第一个分布式代码</span></h1><p>Elixir自带了工具来链接节点以及在它们之间交换信息。实际上，当在一个分布式环境工作的时候，我们用进程、消息传递和接收消息相同的概念，因为Elixir进程是<em>位置透明的</em>。这就是说当发送一个消息的时候，不用关心接收进程是在同一个节点还是在另一个节点，虚拟机将能够在这两种情况下传递消息。</p>
<p>要运行分布式代码，我们需要用一个名字来启动虚拟机。名字可以是短的（当在同一个网络里）或长的（需要完整的计算机地址）。让我们启动一个新的IEx会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo</div></pre></td></tr></table></figure>
<p>你现在可以看到提示符有一点不同，显示了节点名字和计算机名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex(foo<span class="variable">@jv</span>)<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>
<p>我的机器名是 jv ，所以在上面的例子里我看到 foo@jv ，不过你将得到一个不同的结果。在后续的例子里我们将使用 foo@computer-name，当使用这些代码的时候，你应该相应地修改它们。</p>
<p>让我们在shell里定义一个叫Hello的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Hello</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">world</span></span>, <span class="symbol">do:</span> IO.puts <span class="string">"hello world"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你在同一个网络里的其他机器上已经装好了Erlang和Elixir，你可以在它上面启动另外一个IEx会话。否则，你可以在另一个终端启动另一个IEx会话。在这两种情况，给它一个短名叫做bar：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar</div></pre></td></tr></table></figure>
<p>注意，在这个新的IEx会话里，我们无法访问 Hello.world/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Hello.world</div><div class="line">** (UndefinedFunctionError) undefined <span class="symbol">function:</span> Hello.world/<span class="number">0</span></div><div class="line">    Hello.world()</div></pre></td></tr></table></figure>
<p>但是我们可以从 bar@computer-name 在 foo@computer-name 上创建一个新进程！让我们来试一试（@computer-name 是依据你自己的机器名字来写的）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt; Hello.world <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>Elixir在其他节点上启动一个进程并返回它的pid。代码在 Hello.world/0 函数所在的节点上被执行。注意：结果“hello world”打印在节点bar上而不是节点foo上。也就是说，被打印的消息从foo节点传回给bar节点。这是因为创建在其他节点（foo）上的进程仍然是有节点bar的组领导。我们已经简单地在<a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html#processes-and-group-leaders" target="_blank" rel="external">IO那一章</a>介绍了组领导的概念。</p>
<p>我们和往常一样可以与Node.spawn_link/2返回的pid进行消息的发送和接收操作。让我们尝试一个快速ping-pong例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   receive <span class="keyword">do</span></div><div class="line">...&gt;     &#123;<span class="symbol">:ping</span>, client&#125; -&gt; send client, <span class="symbol">:pong</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:ping</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:ping</span>, <span class="comment">#PID&lt;0.73.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:pong</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>从我们的快速探索，我们可以得出这样的结论：每一次我们需要做一个分布式计算的时候，我们应该用node.spawn_link/2在远程节点上创建进程。但是，我们已经从本教程学到，应该尽可能避免在监督树外创建进程，所以我们需要寻找其他方式。</p>
<p>有三种比 Node.spawn_link/2 更好的方式，我们在我们的实现里可以使用它们：</p>
<ol>
<li>我们可以使用Erlang的 <a href="http://www.erlang.org/doc/man/rpc.html" target="_blank" rel="external">:rpc模块</a>在远程节点上执行函数。在上面例子的bar@computer-name shell里，你可以调用 :rpc.call(:”foo@computer-name”, Hello, :world, []) ，它将打印“hello world”。</li>
<li>我们可以有一个运行在其他节点的服务，然后通过 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> API发送请求到那个节点。例如，你可以用 GenServer.call({name, node}, arg) 调用远程节点上的一个服务，或者传递远程进程的PID作为此函数的第一个入参。</li>
<li>我们可以使用我们在<a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">前一章</a>学到的<a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a>，因为它们可以在本地和远程节点被启动。</li>
</ol>
<p>上述三种选项有不同的特点。:rpc 和使用 GenServer 都是在一个单独服务器里顺序执行你的请求，而 Task 在远程节点上高效地异步运行，它唯一的顺序点是被监督者创建的时候。</p>
<p>对于我们的路由层，我们将使用Task，但是其他方式也可以去尝试。</p>
<h1 id="异步-等待"><a href="#异步-等待" class="headerlink" title="异步/等待"></a><span id="part-two">异步/等待</span></h1><p>到目前为止，我们已经探索了独立启动和运行的任务而不考虑它们的返回值。但是，有时候运行一个任务，然后在稍后读取它的值是有用的使用方式。为此，Task也提供了 async/await 模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task = Task.async(<span class="keyword">fn</span> -&gt; compute_something_expensive <span class="keyword">end</span>)</div><div class="line">res  = compute_something_else()</div><div class="line">res + Task.await(task)</div></pre></td></tr></table></figure>
<p>async/await 提供了一个种非常简单的机制并发地计算某些值。不仅如此，async/await 也可以被用于我们前面章节学到的 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 。我们只需要用 Task.Supervisor.async/2 替换 Task.Supervisor.start_child/2 然后稍后用 Task.await/2 读取结果。</p>
<h1 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a><span id="part-three">分布式任务</span></h1><p>分布式任务和被监督任务是一样的。唯一的区别是，我们在监督者上创建任务的时候传递的是节点名。打开 :kv 应用的 lib/kv/supervisor.ex 。让我们加入一个任务监督者作为监督树的最后一个孩子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KV.RouterTasks]]),</div></pre></td></tr></table></figure>
<p>现在，我们在 :kv 应用里启动两个命名的节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo -S mix</div><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>在 bar@computer-name 里，我们现在可以通过监督者在其他节点直接创建一个任务：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, node()&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.88.0&gt;, ref: #Reference&lt;0.0.0.400&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;</div></pre></td></tr></table></figure>
<p>我们的第一个分布式任务获取任务运行节点的名字。注意，我们给了一个匿名函数给 Task.Supervisor.async/2 ，但是， 在分布式场景里，最好是明确地指定模块、函数和函数的入参：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, Kernel, <span class="symbol">:node</span>, []</div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.89.0&gt;, ref: #Reference&lt;0.0.0.404&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line"><span class="symbol">:<span class="string">"foo@computer-name"</span></span></div></pre></td></tr></table></figure>
<p>这两者的区别是：匿名函数需要目标节点和调用者有一样的代码版本。使用模块、函数和函数入参更健壮，因为你只需要在给定的模块里找到匹配函数参数个数的函数。</p>
<p>有了这方面的知识，最后让我们来写路由代码。</p>
<h1 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a><span id="part-four">路由层</span></h1><p>创建一个有如下内容的文件 lib/kv/router.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Router <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Dispatch the given `mod`, `fun`, `args` request</div><div class="line">  to the appropriate node based on the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">route</span></span>(bucket, mod, fun, args) <span class="keyword">do</span></div><div class="line">    <span class="comment"># Get the first byte of the binary</span></div><div class="line">    first = <span class="symbol">:binary</span>.first(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># Try to find an entry in the table() or raise</span></div><div class="line">    entry =</div><div class="line">      Enum.find(table(), <span class="keyword">fn</span> &#123;enum, _node&#125; -&gt;</div><div class="line">        first <span class="keyword">in</span> enum</div><div class="line">      <span class="keyword">end</span>) || no_entry_error(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># If the entry node is the current node</span></div><div class="line">    if elem(entry, <span class="number">1</span>) == node() <span class="keyword">do</span></div><div class="line">      apply(mod, fun, args)</div><div class="line">    else</div><div class="line">      &#123;KV.RouterTasks, elem(entry, <span class="number">1</span>)&#125;</div><div class="line">      |&gt; Task.Supervisor.async(KV.Router, <span class="symbol">:route</span>, [bucket, mod, fun, args])</div><div class="line">      |&gt; Task.await()</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">no_entry_error</span></span>(bucket) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"could not find entry for <span class="subst">#&#123;inspect bucket&#125;</span> in table <span class="subst">#&#123;inspect table()&#125;</span>"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  The routing table.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># Replace computer-name with your local machine name.</span></div><div class="line">    [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">     &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>让我们写一个测试来验证我们的路由器是否正常。创建一个名为 test/kv/router_test.exs 文件，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RouterTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div><div class="line">    assert KV.Router.route(<span class="string">"hello"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"foo@computer-name"</span></span></div><div class="line">    assert KV.Router.route(<span class="string">"world"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"bar@computer-name"</span></span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"raises on unknown entries"</span> <span class="keyword">do</span></div><div class="line">    assert_raise RuntimeError, ~r/could <span class="keyword">not</span> find entry/, <span class="keyword">fn</span> -&gt;</div><div class="line">      KV.Router.route(&lt;&lt;<span class="number">0</span>&gt;&gt;, Kernel, <span class="symbol">:node</span>, [])</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个测试用例调用 Kernel.node/0 ，它将返回基于bucket的名字是 “hello” 和 “world”的当前节点的名字。根据我们目前的路由表，我们应该分别获得 foo@computer-name 和 bar@computer-name 作为响应。</p>
<p>第二个测试检查未知条目引起的代码异常。</p>
<p>为了运行第一个测试，我们需要两个节点来运行。来到 apps/kv 目录，启动一个名叫 bar 节点，它将被用来运行测试用例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>然后运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>测试将通过。</p>
<h1 id="测试过滤器和标签"><a href="#测试过滤器和标签" class="headerlink" title="测试过滤器和标签"></a><span id="part-five">测试过滤器和标签</span></h1><p>虽然我们的测试通过了，但是我们的测试结构变得越来越复杂。特别是，在我们的测试套件里只用 mix test 运行测试引起失败，因为我们的测试需要链接另一个节点。</p>
<p>幸运地，ExUnit有一个工具用来标签测试，允许我们运行指定的回调函数或者甚至完全基于那些标签过滤测试。我们已经在前面的章节里使用了 :capture_log 标签，它有被ExUnit指定的自己的语义。</p>
<p>这次让我们增加一个标签到 test/kv/router_test.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@tag</span> <span class="symbol">:distributed</span></div><div class="line">test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div></pre></td></tr></table></figure>
<p>写 @tag :distributed 等价于写 @tag distributed: true 。</p>
<p>测试被正确地标签，我们现在可以检查节点是否活在在网络里，如果没有节点没有在网络里活着，我们可以不考虑所有分布式测试。在 :kv 应用里打开 test/test_helper.exs ，然后加入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exclude =</div><div class="line">  if Node.alive?, <span class="symbol">do:</span> [], <span class="symbol">else:</span> [<span class="symbol">distributed:</span> <span class="keyword">true</span>]</div><div class="line"></div><div class="line">ExUnit.start(<span class="symbol">exclude:</span> exclude)</div></pre></td></tr></table></figure>
<p>现在用 mix test 运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div><div class="line">Excluding tags: [distributed: <span class="literal">true</span>]</div><div class="line"></div><div class="line">.......</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.1 seconds (0.1s on load, 0.01s on tests)</div><div class="line">7 tests, 0 failures, 1 skipped</div></pre></td></tr></table></figure>
<p>这一次所有测试都通过了并且ExUnit警告我们，分布式测试被忽略了。如果你用 $ elixir --sname foo -S mix test 运行测试，只要 bar@computer-name 这个节点可用，则刚才被忽略的那个测试将被运行并成功通过。</p>
<p>mix test 命令也允许我们动态包括和排除标签。例如，我们可以运行 $ mix test --include distributed 来运行分布式测试，而不管 test/test_helper.exs 里设置的值。我们也可以传递 --exclude 从命令行排除特定的标签。最后，--only 可以被用来运行只有特别标签的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case 模块文档</a>里阅读到更多的过滤器、标签和默认标签的内容。</p>
<h1 id="应用环境和配置"><a href="#应用环境和配置" class="headerlink" title="应用环境和配置"></a><span id="part-six">应用环境和配置</span></h1><p>目前我们硬编码路由表在 KV.Router 模块里。但是，我们想使得路由表是动态的。这不仅让我们配置开发/测试/生产环境，也允许不同节点在路由表里有不同内容。有一个OTP特性正好做这个事情：应用环境。</p>
<p>每一个应用有一个环境通过键来存储应用的特定配置。例如，我们可以存储路由表在 :kv 应用环境里，给它一个默认值，并且让其他应用在需要的时候修改这个表。</p>
<p>打开 apps/kv/mix.exs ，修改 application/0 函数返回如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">env:</span> [<span class="symbol">routing_table:</span> []],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们增加了一个新的键 :env 到应用里。它返回应用的默认环境，默认环境里有一个键为 :routing_table 的条目，其值为一个空的列表。应用程序环境与空表一起工作是有意义的，因为特定的路由表依赖于测试/部署结构。</p>
<p>为了在我们的代码里使用应用环境，我们需要用下面的内容来替换 KV.Router.table/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">The routing table.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">  Application.fetch_env!(<span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用 Application.fetch_env!/2 来读取 :kv 的环境的 :routing_table 条目。你可以在 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application 模块文档</a>里找到更多操作应用环境的信息和其他函数。</p>
<p>因为我们的路由表现在是空的，我们的分布式测试将会失败。重启应用并且重新运行测试来看它的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>应用环境有趣的是，它不仅被配置为当前应用，而是可以被配置为所有应用。这样的设置可以用 config/config.exs 文件来做到。例如，我们可以配置来修改IEx的默认提示符为其他值。只要打开 apps/kv/config/config.exs ，增加如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">config <span class="symbol">:iex</span>, <span class="symbol">default_prompt:</span> <span class="string">"&gt;&gt;&gt;"</span></div></pre></td></tr></table></figure>
<p>用 iex -S mix 启动IEx，你可以看到IEx的提示符已经改变。</p>
<p>这意味着，我们也可以在 apps/kv/config/config.exs 文件里直接配置我们的 :routing_table ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用你的本地节点替换 computer-name 。</span></div><div class="line">config <span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>,</div><div class="line">       [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">        &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>重启节点并再次运行分布式测试。现在它们应该全部通过。</p>
<p>从 Elixir v1.2 开始，所有伞型应用共享它们的配置，由于在伞型应用的根目录的 config/config.exs 文件里的如下一行，装载所有子应用的配置：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import_config <span class="string">"../apps/*/config/config.exs"</span></div></pre></td></tr></table></figure>
<p>mix run 命令也接收 --config 标签，允许配置文件按需提供。这个方法可以用来启动不同的节点，每个节点有它自己特定的配置（例如，不同的路由表）。</p>
<p>总体而言，内置配置应用的能力以及我们已经建立了我们的软件作为一个伞应用的事实，给我们在部署软件的时候提供了很多选择。</p>
<p>我们可以：</p>
<ul>
<li>部署伞型应用在一个节点将使得它既作为TCP服务器也作为键值存储。</li>
<li>部署 :kv_server 应用只作为TCP服务器只要路由表指向其他节点。</li>
<li>当我们想一个节点只作为一个存储（没有TCP访问）的时候，则只不是 :kv 应用。</li>
</ul>
<p>当我们在将来添加更多的应用程序时，我们可以继续使用粒度相同的级别来控制我们的部署，也可以继续选择用哪个配置给将要在生产上运行的应用。</p>
<p>我们也可以考虑用一个像<a href="https://github.com/bitwalker/distillery" target="_blank" rel="external">Distillery</a>的工具构建多发布版本，Distillery将打包被选择的应用和配置，包括当前安装的Erlang和Elixir安装，所以我们可以部署应用即使运行时没有预先在目标系统里被安装。</p>
<p>最后，我们在本章也学到一些新的东西，并且它也可以被应用到 :kv_server 。我们将留下一步作为一个练习：</p>
<ul>
<li>修改 :kv_server 应用从它的应用环境读取端口号而不是用硬编码值 4040 。</li>
<li>修改和配置 :kv_server 应用使用路由功能而不是直接派发给本地 KV.Registry 。为了 :kv_server 的测试，你可以使得路由表指向它自己的当前节点。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-seven">总结</span></h1><p>在本章，我们构建了一个简单的路由器作为一个方法来探索Elixir和Erlang虚拟机的分布式特性，也学会了如果配置它的路由表。这是我们的Mix和OTP教程的最后一章。</p>
<p>通过这个教程，我们已经构建一个简单的分布式键值存储当做一个机会来探索许多结构，像通用服务器、监督者、任务、agent、应用以及其他事物。不仅如此，我们为整个应用写了测试，熟悉 ExUnit ，并学习如何用 Mix 这个构建工具来完成很多任务。</p>
<p>如果你正在找用于生产的一个分布式键值存储，那么应该你一定去看看<a href="http://basho.com/riak/" target="_blank" rel="external">Riak</a>，它也运行在Erlang虚拟机里。在Riak里，bucket被复制，避免数据丢失；不是用路由表，它们而是使用 <a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="external">一致性哈希</a> 映射一个bucket到一个节点。当存储bucket的新的节点被加入到你的基础设施的时候，一致性哈希有助于减少需要被迁移的数据量。</p>
<p>这里有更多的课程可以学，希望目前为止你玩得开心！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个分布式代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;异步/等待&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;分布式任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;路由层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;测试过滤器和标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;应用环境和配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="distributed-task configuration" scheme="http://szpzs.oschina.io/categories/Elixir/distributed-task-configuration/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="distributed-task" scheme="http://szpzs.oschina.io/tags/distributed-task/"/>
    
      <category term="configuration" scheme="http://szpzs.oschina.io/tags/configuration/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Docs、tests 和 with</title>
    <link href="http://szpzs.oschina.io/2017/02/23/elixir-getting-started-mix-otp-docs-tests-and-with/"/>
    <id>http://szpzs.oschina.io/2017/02/23/elixir-getting-started-mix-otp-docs-tests-and-with/</id>
    <published>2017-02-22T21:23:46.000Z</published>
    <updated>2017-02-22T21:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Doctests</a></li>
<li><a href="#part-two">with</a></li>
<li><a href="#part-three">运行命令</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将实现代码来分析我们在第一章描述的命令：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk <span class="number">1</span></div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs <span class="number">3</span></div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line"><span class="number">1</span></div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>分析做完后，我们将修改我们的服务器来派发被分析的命令给我们前面已经构建的 :kv 应用。</p>
<a id="more"></a>
<h1 id="Doctests"><a href="#Doctests" class="headerlink" title="Doctests"></a><span id="part-one">Doctests</span></h1><p>在Elixir语言首页，我们提到，Elixir使得文档在语言里作为第一类公民。我们已经在本指南探索这个概念多次，这些探索都是通过 mix help 或在IEx控制台上输入 h Enum 或 h 其他模块 来做到的。</p>
<p>在本节，我们将用 doctests 实现分析功能，它让我们直接在注释文档里写测试用例。这帮助我们提供有精确样例代码的注释文档。</p>
<p>让我们在 lib/kv_server/command.ex 创建我们的命令分析器，并用 doctest 启动：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Command <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">  Parses the given `line` into a command.</div><div class="line"></div><div class="line">  ## Examples</div><div class="line"></div><div class="line">      iex&gt; KVServer.Command.parse "CREATE shopping\r\n<span class="string">"</span></div><div class="line">      &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:not_implemented</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Doctest通过在注释文档字符串里的缩进四个空格在紧跟 iex&gt; 提示符来指定。如果一个命令跨多行，你可以使用 …&gt; 作为在IEx里。期望的结果在 iex&gt; 或 …&gt; 行的下一行，用一个新行或新的 iex&gt; 前缀作为结束。</p>
<p>也要注意：我们用 @doc ~S””” 开始注释文档字符串。~S 阻止 \r\n 被转换为回车和换行，直到它们在测试里被计算。</p>
<p>为了运行我们的doctest，我们创建一个文件：test/kv_server/command_test.exs ，并且在测试用例里调用 doctest KVServer.Command ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.CommandTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line">  doctest KVServer.Command</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>运行这个测试，doctest将失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> doc at KVServer.Command.parse/1 (1) (KVServer.CommandTest)</div><div class="line">   <span class="built_in">test</span>/kv_server/command_test.exs:3</div><div class="line">   Doctest failed</div><div class="line">   code: KVServer.Command.parse <span class="string">"CREATE shopping\r\n"</span> === &#123;:ok, &#123;:create, <span class="string">"shopping"</span>&#125;&#125;</div><div class="line">   lhs:  :not_implemented</div><div class="line">   stacktrace:</div><div class="line">     lib/kv_server/command.ex:11: KVServer.Command (module)</div></pre></td></tr></table></figure>
<p>不错！</p>
<p>现在让我们使得 doctest 通过。让我们来实现 parse/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> String.split(line) <span class="keyword">do</span></div><div class="line">    [<span class="string">"CREATE"</span>, bucket] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:create</span>, bucket&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的实现用空格分割一行字符串，然后把命令和一个列表匹配起来。使用 String.split/1 意味着我们的命令将是空格不敏感的。前导和尾随空格无关紧要了，词与词之间的连续的空格也无关紧要。让我们加入一些新的doctest，用其他命令来测试这个行为模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">Parses the given `line` into a command.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "CREATE shopping\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "CREATE  shopping  \r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:create, "shopping<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "PUT shopping milk <span class="number">1</span>\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:put, "shopping<span class="string">", "</span>milk<span class="string">", "</span><span class="number">1</span><span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "GET shopping milk\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:get, "shopping<span class="string">", "</span>milk<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "DELETE shopping eggs\r\n<span class="string">"</span></div><div class="line">    &#123;:ok, &#123;:delete, "shopping<span class="string">", "</span>eggs<span class="string">"&#125;&#125;</span></div><div class="line"></div><div class="line">Unknown commands or commands with the wrong number of</div><div class="line">arguments return an error:</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "UNKNOWN shopping eggs\r\n<span class="string">"</span></div><div class="line">    &#123;:error, :unknown_command&#125;</div><div class="line"></div><div class="line">    iex&gt; KVServer.Command.parse "GET shopping\r\n<span class="string">"</span></div><div class="line">    &#123;:error, :unknown_command&#125;</div><div class="line"></div><div class="line">"<span class="string">""</span></div></pre></td></tr></table></figure>
<p>有了doctest，轮到你来使得测试通过了！一旦你准备好了，你可以比较你的实现和我们下面的解决方案：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(line) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> String.split(line) <span class="keyword">do</span></div><div class="line">    [<span class="string">"CREATE"</span>, bucket] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:create</span>, bucket&#125;&#125;</div><div class="line">    [<span class="string">"GET"</span>, bucket, key] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:get</span>, bucket, key&#125;&#125;</div><div class="line">    [<span class="string">"PUT"</span>, bucket, key, value] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:put</span>, bucket, key, value&#125;&#125;</div><div class="line">    [<span class="string">"DELETE"</span>, bucket, key] -&gt; &#123;<span class="symbol">:ok</span>, &#123;<span class="symbol">:delete</span>, bucket, key&#125;&#125;</div><div class="line">    <span class="number">_</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：我们是如何能够优雅地分析命令，而不需要用大量的 if/else 分支来检查命令名字和参数个数！</p>
<p>最后，你可能已经观察到每一个doctest被认为是我们测试用例里的不同测试，因为我们的测试套件报告一共有7个测试。这是因为ExUnit认为如下所示是定义两个不同测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.Command.parse <span class="string">"UNKNOWN shopping eggs\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line"></div><div class="line">iex&gt; KVServer.Command.parse <span class="string">"GET shopping\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div></pre></td></tr></table></figure>
<p>而如下所示，中间没有新行，则ExUnit则编译它为一个单独的测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.Command.parse <span class="string">"UNKNOWN shopping eggs\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div><div class="line">iex&gt; KVServer.Command.parse <span class="string">"GET shopping\r\n"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.DocTest.html" target="_blank" rel="external">ExUnit.DocTest 文档</a>里阅读更多关于doctest的内容。</p>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a><span id="part-two">with</span></h1><p>因为我们现在能够分析命令，我们终于可以开始实现逻辑来运行命令。现在让我们为这个函数添加一个存根（stub）定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Command <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Runs the given command.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(command) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在我们实现这个函数之前，让我们修改我们的服务器开始使用我们新的 parse/1 和 run/1 函数。记住：当客户端关闭套接字的时候，我们的 read_line/1 函数也崩溃，所以我们也找个机会修复它。打开 lib/kv_server.ex ，其内容如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  socket</div><div class="line">  |&gt; read_line()</div><div class="line">  |&gt; write_line(socket)</div><div class="line"></div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">  data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用如下内容替换它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  msg =</div><div class="line">    <span class="keyword">case</span> read_line(socket) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, data&#125; -&gt;</div><div class="line">        <span class="keyword">case</span> KVServer.Command.parse(data) <span class="keyword">do</span></div><div class="line">          &#123;<span class="symbol">:ok</span>, command&#125; -&gt;</div><div class="line">            KVServer.Command.run(command)</div><div class="line">          &#123;<span class="symbol">:error</span>, <span class="number">_</span>&#125; = err -&gt;</div><div class="line">            err</div><div class="line">        <span class="keyword">end</span></div><div class="line">      &#123;<span class="symbol">:error</span>, <span class="number">_</span>&#125; = err -&gt;</div><div class="line">        err</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">  write_line(socket, msg)</div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:ok</span>, text&#125;) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, text)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:unknown_command</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 已知错误。写到客户端。</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"UNKNOWN COMMAND\r\n"</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(_socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:closed</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 链接关闭，友好地退出。</span></div><div class="line">  exit(<span class="symbol">:shutdown</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, error&#125;) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 未知错误。写到客户端并退出。</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"ERROR\r\n"</span>)</div><div class="line">  exit(error)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果我们启动我们的服务器，我们现在可以发送命令给它。现在我们将得到两种不同的响应：当命令是已知的，是“OK”；否则，是“UNKNOWN COMMAND”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line">HELLO</div><div class="line">UNKNOWN COMMAND</div></pre></td></tr></table></figure>
<p>这意味着我们的实现在正确的方向上进行，不过它看起来不是很优雅，是吗？</p>
<p>以前的实现使用管道，使逻辑直截了当地前进。然而，现在我们需要处理不同的错误代码在前进的道路上，我们的服务器逻辑嵌套在许多case调用里。</p>
<p>幸运地是，Elixir v1.2 引入 with 结构，它允许你简化像上面的代码，有一个匹配分支链来替换嵌套的call调用。让我们用with重写serve/1：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  msg =</div><div class="line">    with &#123;<span class="symbol">:ok</span>, data&#125; &lt;- read_line(socket),</div><div class="line">         &#123;<span class="symbol">:ok</span>, command&#125; &lt;- KVServer.Command.parse(data),</div><div class="line">         <span class="symbol">do:</span> KVServer.Command.run(command)</div><div class="line"></div><div class="line">  write_line(socket, msg)</div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>好多了！with将获取 &lt;- 右边返回的值与 &lt;- 左边的模式进行匹配。如果值匹配上模式，则with继续移动到下一个表达式。如果没有匹配，则返回非匹配值。</p>
<p>也就是说，我们转换每一个给予 case/2 的表达式作为 with 里的一步。只要任何一步的返回值不能匹配 {:ok, x} ，则with终止，并且返回非匹配值。</p>
<p>你可以在<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">我们的文档</a>里读到更多关于with的内容。</p>
<h1 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a><span id="part-three">运行命令</span></h1><p>最后一步是实现 KVServer.Command.run/1 ，来运行分析好的对应于 :kv 应用的命令。它的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Runs the given command.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(command)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:create</span>, bucket&#125;) <span class="keyword">do</span></div><div class="line">  KV.Registry.create(KV.Registry, bucket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:get</span>, bucket, key&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    value = KV.Bucket.get(pid, key)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"<span class="subst">#&#123;value&#125;</span>\r\nOK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:put</span>, bucket, key, value&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    KV.Bucket.put(pid, key, value)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:delete</span>, bucket, key&#125;) <span class="keyword">do</span></div><div class="line">  lookup bucket, <span class="keyword">fn</span> pid -&gt;</div><div class="line">    KV.Bucket.delete(pid, key)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">lookup</span></span>(bucket, callback) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> KV.Registry.lookup(KV.Registry, bucket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt; callback.(pid)</div><div class="line">    <span class="symbol">:error</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>每一个函数分支派发合适的命令到 KV.Registry 服务器，这个服务器我们在 :kv 应用启动的时候注册了。由于我们的 :kv_server 取决于 :kv 应用，它是完全可以依靠它提供的服务。</p>
<p>注意：我们也提供了一个名为 lookup/2 的私有函数，它帮助查找一个bucket，如果此bucket存在则返回其pid，否则，返回 {:error, :not_found} 。</p>
<p>顺便说一句，既然我们现在将返回 {:error, :not_found} ，我们就应该修改 KVServer里的 write_line/2 函数，让它也打印这样的错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(socket, &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125;) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, <span class="string">"NOT FOUND\r\n"</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的服务器功能几乎完成了。这剩下测试没完成。这次，我们最后剩下测试因为有一些重要考虑要做。</p>
<p>KVServer.Command.run/1的实现是直接发送命令给被 :kv 应用注册的名为 KV.Registry 的服务器。这意味着这个服务器是全局的，如果我们有两个测试用例同时发送消息给它，我们的测试用例将彼此冲突（并且可能失败）。我们需要在隔离和可以异步运行的单元测试之间做出决定，或者编写在全局状态之上工作的集成测试，但是在应用程序中执行我们的应用程序的完整堆栈，因为它意味着要在生产中进行操作。</p>
<p>到目前为止，我们只编写了单元测试，通常直接测试单个模块。然而，为了使kvserver.command.run/1作为一个可测试单元，我们需要改变它的实现，不能直接将命令发送到 KV.Registry 进程而是通过传递一个服务器作为参数。例如，我们将修改 run 函数的签名为 def run(command, pid) ，然后响应地修改所有分支：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(&#123;<span class="symbol">:create</span>, bucket&#125;, pid) <span class="keyword">do</span></div><div class="line">  KV.Registry.create(pid, bucket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="string">"OK\r\n"</span>&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># ... 其他 run 函数分支 ...</span></div></pre></td></tr></table></figure>
<p>去做上面的修改，写一些单元测试。目的是你的测试用例将启动一个 KV.Registry 实例并且把它作为参数传递给 run/2 而不是依赖全局 KV.Registry 。这有利于保持我们的测试异步，因为没有共享状态。</p>
<p>由于这是我们迄今为止在测试中所做的方法，我们将尝试一些不同的方法。让我们来写集成测试，它依赖全局服务器名来运用从TCP服务器到bucket的整个栈。我们的集成测试将依赖全局状态并且必须是同步的。通过集成测试，我们得到了覆盖在我们应用中组件如何一起工作的测试性能的成本。它们通常用于测试应用程序中的主要流程。例如，我们应该避免使用集成测试来测试在我们的命令解析实现的边缘情况。</p>
<p>我们的集成测试将用一个TCP客户端发送命令给我们的服务器，然后断言我们将得到想要的响应。</p>
<p>让我们在 test/kv_server_test.exs 里实现集成测试，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServerTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    Application.stop(<span class="symbol">:kv</span>)</div><div class="line">    <span class="symbol">:ok</span> = Application.start(<span class="symbol">:kv</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    opts = [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>]</div><div class="line">    &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.connect(<span class="string">'localhost'</span>, <span class="number">4040</span>, opts)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">socket:</span> socket&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"server interaction"</span>, %&#123;<span class="symbol">socket:</span> socket&#125; <span class="keyword">do</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"UNKNOWN shopping\r\n"</span>) ==</div><div class="line">           <span class="string">"UNKNOWN COMMAND\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) ==</div><div class="line">           <span class="string">"NOT FOUND\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"CREATE shopping\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"PUT shopping eggs 3\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    <span class="comment"># GET 返回两行</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) == <span class="string">"3\r\n"</span></div><div class="line">    assert send_and_recv(socket, <span class="string">""</span>) == <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    assert send_and_recv(socket, <span class="string">"DELETE shopping eggs\r\n"</span>) ==</div><div class="line">           <span class="string">"OK\r\n"</span></div><div class="line"></div><div class="line">    <span class="comment"># GET 返回两行</span></div><div class="line">    assert send_and_recv(socket, <span class="string">"GET shopping eggs\r\n"</span>) == <span class="string">"\r\n"</span></div><div class="line">    assert send_and_recv(socket, <span class="string">""</span>) == <span class="string">"OK\r\n"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">send_and_recv</span></span>(socket, command) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.send(socket, command)</div><div class="line">    &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>, <span class="number">1000</span>)</div><div class="line">    data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的集成测试检查所有服务器交互，包括未知命令和not found错误。值得注意的是，因为有ETS表和被链接进程，没有必要关闭套接字。一旦测试进程退出，套接字自动关闭。</p>
<p>这次因为我们的测试依赖全局数据，所有我们没有给 ExUnit.Case 设置 async: true 。另外，为了保证我们的测试总是在一个干净的状态中，在每一个测试用例前我们停止然后启动 :kv 应用。实际上，停止 :kv 应用甚至在终端打印一条警告信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">18:12:10.698 [info] Application kv exited: :stopped</div></pre></td></tr></table></figure>
<p>为了避免在测试期间打印日志消息，ExUnit提供了一个方便的特性，叫做 :capture_log 。通过在每一个测试用例前设置 @tag :capture_log 或为整个测试设置 @moduletag :capture_log ，ExUnit 将捕获在测试运行的时候记录的任何日志。如果我们的测试失败，被捕获的日志将和ExUnit报告一起被打印出来。</p>
<p>在 use ExUnit.Case 和 setup 之间增加如下调用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@moduletag</span> <span class="symbol">:capture_log</span></div></pre></td></tr></table></figure>
<p>如果测试崩溃，你将看到如下的报告：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>) test server interaction (KVServerTest)</div><div class="line">   test/kv_server_test.<span class="symbol">exs:</span><span class="number">17</span></div><div class="line">   ** (RuntimeError) oops</div><div class="line">   <span class="symbol">stacktrace:</span></div><div class="line">     test/kv_server_test.<span class="symbol">exs:</span><span class="number">29</span></div><div class="line"></div><div class="line">   The following output was <span class="symbol">logged:</span></div><div class="line"></div><div class="line">   <span class="number">13</span><span class="symbol">:</span><span class="number">44</span><span class="symbol">:</span><span class="number">10.035</span> [info]  Application kv <span class="symbol">exited:</span> <span class="symbol">:stopped</span></div></pre></td></tr></table></figure>
<p>通过这个简单的集成测试，我们开始明白为什么集成测试可能是缓慢的。 这个集成测试不仅不能异步运行，它还需要停止和启动 :kv 应用这样的耗时步骤。</p>
<p>最后，由你和你的团队为你们的应用制定出最好的测试策略。你需要平衡代码质量、信心和测试套件运行时。例如，我们可能一开始只有集成测试服务器的测试，但是如果服务器继续在将来的版本中成长，或它成为频繁的错误应用的一部分，重要的是要考虑分解集成测试，写更多的单元测试，无须集成测试这么重。</p>
<p>在下一章，我们通过增加一个bucket路由机制最终使得我们的系统成为分布式。我们也将学习应用配置。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Doctests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;with&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;运行命令&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将实现代码来分析我们在第一章描述的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;分析做完后，我们将修改我们的服务器来派发被分析的命令给我们前面已经构建的 :kv 应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Docstest with" scheme="http://szpzs.oschina.io/categories/Elixir/Docstest-with/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Docstest" scheme="http://szpzs.oschina.io/tags/Docstest/"/>
    
      <category term="with" scheme="http://szpzs.oschina.io/tags/with/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Task和gen_tcp</title>
    <link href="http://szpzs.oschina.io/2017/02/22/elixir-getting-started-mix-otp-task-and-gen-tcp/"/>
    <id>http://szpzs.oschina.io/2017/02/22/elixir-getting-started-mix-otp-task-and-gen-tcp/</id>
    <published>2017-02-21T23:02:22.000Z</published>
    <updated>2017-02-21T23:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Echo服务器</a></li>
<li><a href="#part-two">Tasks</a></li>
<li><a href="#part-three">Tasks监督者</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将学习如何使用<a href="http://www.erlang.org/doc/man/gen_tcp.html" target="_blank" rel="external">Erlang的 :gen_tcp 模块</a>来处理请求。这提供一个很好的机会来探索Elixir的Task模块。在将来的章节我们将扩展我们的服务器以便使得它可以真正地处理命令。</p>
<a id="more"></a>
<h1 id="Echo服务器"><a href="#Echo服务器" class="headerlink" title="Echo服务器"></a><span id="part-one">Echo服务器</span></h1><p>我们将首先实现一个echo服务器来开始我们的TCP服务器。它将发送一个响应，响应内容是它接收到的请求的文本。我们将慢慢地改善我们的服务器，一直到它被监督并且准备好处理多链接。</p>
<p>从广义的角度来看，在一个 TCP 服务器执行以下步骤︰</p>
<ol>
<li>侦听一个端口，直到端口可用，并获取套接字</li>
<li>在那个端口等待客户端链接并接受它</li>
<li>读取客户端的请求并写响应回去</li>
</ol>
<p>让我们来实现这些步骤。来到 apps/kv_server 应用，打开 lib/kv_server.ex ，然后增加如下的函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">require Logger</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(port) <span class="keyword">do</span></div><div class="line">  <span class="comment"># 下面的选项的意思：</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># 1. `:binary` - 以二进制数据方式接收数据（而不是列表）</span></div><div class="line">  <span class="comment"># 2. `packet: :line` - 一行行地接收数据</span></div><div class="line">  <span class="comment"># 3. `active: false` - 阻塞在 `:gen_tcp.recv/2` 一直到有数据可用</span></div><div class="line">  <span class="comment"># 4. `reuseaddr: true` - 如果侦听者崩溃，允许我们重用地址</span></div><div class="line">  <span class="comment">#</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.listen(port,</div><div class="line">                    [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>, <span class="symbol">reuseaddr:</span> <span class="keyword">true</span>])</div><div class="line">  Logger.info <span class="string">"Accepting connections on port <span class="subst">#&#123;port&#125;</span>"</span></div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  serve(client)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">  socket</div><div class="line">  |&gt; read_line()</div><div class="line">  |&gt; write_line(socket)</div><div class="line"></div><div class="line">  serve(socket)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">  data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">  <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将通过调用 KVServer.accept(4040) 来启动我们的服务器，4040是一个端口。accept/1 里的第一步是侦听一个端口一直到套接字可用，接着调用 loop_acceptor/1 。loop_acceptor/1 是一个接收客户端链接的循环。对于每一个接收到的链接，我们调用 serve/1 。</p>
<p>serve/1 是另一个循环，它从套接字读取一行数据然后把这些数据写回给套接字。注意：serve/1 函数用了 <a href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" target="_blank" rel="external">管道运算符 |&gt;</a> 来表达操作的数据流。管道运算符计算其左边的表达式并将其结果作为第一个入参传递给其右边的函数。上述例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket |&gt; read_line() |&gt; write_line(socket)</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">write_line(read_line(socket), socket)</div></pre></td></tr></table></figure>
<p>read_line/1 用 :gen_tcp.recv/2 实现从套接字接收数据，而write_line/2 用 :gen_tcp.send/2 写数据到套接字。</p>
<p>注意：serve/1 在 loop_acceptor/1 里被顺序地无限循环地调用，所以对 loop_acceptor/1 的尾调用永远不会到达，因此应该被避免。但是，正如我们将看到的，我们将需要在一个隔离的进程里执行 serve/1 ，所以我们很快就需要这样的尾调用。</p>
<p>这几乎是实现我们echo服务器所有需要的内容。让我们来试一下！</p>
<p>在 kv_server 应用里用 iex -S mix 启动一个IEx会话。在IEx里运行：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; KVServer.accept(<span class="number">4040</span>)</div></pre></td></tr></table></figure>
<p>服务器现在正在运行，你甚至会注意到控制台被阻塞。让我们用<a href="https://en.wikipedia.org/wiki/Telnet" target="_blank" rel="external">一个telnet客户端</a>来访问我们的服务器。大多数操作系统上都有客户端，它们的命令行大致相同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">hello</div><div class="line">hello</div><div class="line">is it me</div><div class="line">is it me</div><div class="line">you are looking <span class="keyword">for</span>?</div><div class="line">you are looking <span class="keyword">for</span>?</div></pre></td></tr></table></figure>
<p>输入“hello”，按下回车键，你将得到回复的“hello”。完美！</p>
<p>我的特别的telnet客户端可以通过输入 ctrl + ] ，接着输入 quit ，再按下回车键 来退出，但是你的客户端可能需要不同的步骤。</p>
<p>一旦你退出了telnet客户端，你将可能在IEx会话里看到一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> &#123;<span class="symbol">:error</span>, <span class="symbol">:closed</span>&#125;</div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">45</span>: KVServer.read_line/<span class="number">1</span></div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">37</span>: KVServer.serve/<span class="number">1</span></div><div class="line">    (kv_server) lib/kv_server.<span class="symbol">ex:</span><span class="number">30</span>: KVServer.loop_acceptor/<span class="number">1</span></div></pre></td></tr></table></figure>
<p>这是因为我们期望从 :gen_tcp.recv/2 获得数据，但是客户端关闭了链接。在我们服务器将来的修订版里我们需要更好地处理这样的情况。</p>
<p>现在我们有一个更重要的bug需要去修复：如果我们的TCP接收者崩溃会发生什么？因为没有监督，服务器死掉而我们将不能服务更多请求，因为服务器不能被重启。这就是为什么我们必须把我们的服务器移到一颗监督树里的原因。</p>
<h1 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a><span id="part-two">Tasks</span></h1><p>我们已经学习了agent，通用服务器和监督者。它们都可以处理多消息或者管理状态。当我们只是需要执行一些任务的时候我们用哪个而它又是什么？</p>
<p><a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task模块</a>提供了这个功能。例如，它有一个 start_link/3 函数，此函数接收一个模块、函数和函数的参数作为入参，让我们运行一个给定的函数作为一个监督树的一部分。</p>
<p>让我们试试它。打开 lib/kv_server/application.ex ，让我们修改 start/2 函数里的监督者，修改如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">  import Supervisor.Spec</div><div class="line"></div><div class="line">  children = [</div><div class="line">    worker(Task, [KVServer, <span class="symbol">:accept</span>, [<span class="number">4040</span>]])</div><div class="line">  ]</div><div class="line"></div><div class="line">  opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">  Supervisor.start_link(children, opts)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>经过这个修改，我们说我们想运行 KVServer.accept(4040) 作为一个工作者。现在我们硬编码端口号，不过稍后我们将讨论修改这种方式。</p>
<p>现在服务器是监督树的一部分，当我们启动应用的时候它将自动启动。在终端里输入 mix run –no-halt ，然后再次使用 telnet 客户端来确认所有事情都依然运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">say you</div><div class="line">say you</div><div class="line">say me</div><div class="line">say me</div></pre></td></tr></table></figure>
<p>对的，它运行着！如果你杀掉客户端，整个服务器也崩溃。但是你将看到另一个服务器马上起来。但是，它的扩展性如何？</p>
<p>尝试同时链接两个telnet客户端。当你这么做的时候，你将注意到第二个客户端没有回声消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ telnet 127.0.0.1 4040</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.</div><div class="line">hello</div><div class="line">hello?</div><div class="line">HELLOOOOOO?</div></pre></td></tr></table></figure>
<p>它好像没有完全正确运行。这是因为我们在接收链接的进程里处理请求。当一个客户端被链接了，我们就不能再接收另一个客户端。</p>
<h1 id="Tasks监督者"><a href="#Tasks监督者" class="headerlink" title="Tasks监督者"></a><span id="part-three">Tasks监督者</span></h1><p>为了使得我们的服务器处理同时发生的链接，我们需要有一个作为接收者的进程创建其他进程来处理请求。一个解决方案是将如下所示内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  serve(client)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>改为用 Task.start_link/1 ，它和 Task.start_link/3  相似，不过它接收一个匿名函数而不是模块、函数和函数的参数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  Task.start_link(<span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们从接收者进程直接启动一个被链接的任务。但是我们已经犯了一次错。你还记得吗？</p>
<p>这个错与当我们从registry直接调用 KV.Bucket.start_link/0 造成的错误相似。这意味着在任何一个bucket的错误将把整个registry搞垮。</p>
<p>上面的代码有同样的瑕疵：如果我们链接 serve(client) 这个任务到接收者，当它处理请求的时候崩溃，则会导致接收者乃至其他所有链接崩溃。</p>
<p>我们通过用 :simple_one_for_one 这种监督者来为registry修复这个问题。我们将使用相同的策略，除了这个模式是如此常见，Task已经有一个解决方案：一个 :simple_one_for_one 监督者启动临时任务作为我们的监督树的一部分。</p>
<p>让我们再次修改 start/2 ，增加一个监督者到我们的监督树：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">  import Supervisor.Spec</div><div class="line"></div><div class="line">  children = [</div><div class="line">    supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KVServer.TaskSupervisor]]),</div><div class="line">    worker(Task, [KVServer, <span class="symbol">:accept</span>, [<span class="number">4040</span>]])</div><div class="line">  ]</div><div class="line"></div><div class="line">  opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">  Supervisor.start_link(children, opts)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们现在将用 KVServer.TaskSupervisor 这个名字启动一个 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 进程。记住：因为接收者任务依赖这个监督者，因此这个监督者必须先启动。</p>
<p>现在我们需要修改 loop_acceptor/1 使用 Task.Supervisor 来处理每一个请求：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">  &#123;<span class="symbol">:ok</span>, pid&#125; = Task.Supervisor.start_child(KVServer.TaskSupervisor, <span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">  <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.controlling_process(client, pid)</div><div class="line">  loop_acceptor(socket)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你可能注意到我们增加了一行，:ok = :gen_tcp.controlling_process(client, pid) 。这使得子进程成为 client 这个套接字进程的“控制进程”。如果我们不这么做，如果接收者崩溃，它将把所有客户端都搞崩溃，因为套接字被绑定到接收它们的进程（这是默认的行为）。</p>
<p>用 mix run –no-halt 启动一个新的服务器，然后我们现在可以打开许多并发的telnet客户端。你也将注意到，退出一个客户端，不会把接收者搞崩溃。非常好！</p>
<p>下面是整个echo服务器的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span> <span class="keyword">do</span></div><div class="line">  require Logger</div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts accepting connections on the given `port`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(port) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, socket&#125; = <span class="symbol">:gen_tcp</span>.listen(port,</div><div class="line">                      [<span class="symbol">:binary</span>, <span class="symbol">packet:</span> <span class="symbol">:line</span>, <span class="symbol">active:</span> <span class="keyword">false</span>, <span class="symbol">reuseaddr:</span> <span class="keyword">true</span>])</div><div class="line">    Logger.info <span class="string">"Accepting connections on port <span class="subst">#&#123;port&#125;</span>"</span></div><div class="line">    loop_acceptor(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">loop_acceptor</span></span>(socket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, client&#125; = <span class="symbol">:gen_tcp</span>.accept(socket)</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = Task.Supervisor.start_child(KVServer.TaskSupervisor, <span class="keyword">fn</span> -&gt; serve(client) <span class="keyword">end</span>)</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:gen_tcp</span>.controlling_process(client, pid)</div><div class="line">    loop_acceptor(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">serve</span></span>(socket) <span class="keyword">do</span></div><div class="line">    socket</div><div class="line">    |&gt; read_line()</div><div class="line">    |&gt; write_line(socket)</div><div class="line"></div><div class="line">    serve(socket)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">read_line</span></span>(socket) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, data&#125; = <span class="symbol">:gen_tcp</span>.recv(socket, <span class="number">0</span>)</div><div class="line">    data</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">write_line</span></span>(line, socket) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:gen_tcp</span>.send(socket, line)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们已经修改了监督者规格说明，我们要问：我们的监督策略还正确吗？</p>
<p>在现在的情况下，答案是：正确。如果接收者崩溃，无需崩溃已经存在的链接。在另一方面，如果任务监督者崩溃，也不需要崩溃接收者。</p>
<p>在下一章，我们将开始分析客户端请求和发送响应，并结束我们的服务器。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Echo服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Tasks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Tasks监督者&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将学习如何使用&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang的 :gen_tcp 模块&lt;/a&gt;来处理请求。这提供一个很好的机会来探索Elixir的Task模块。在将来的章节我们将扩展我们的服务器以便使得它可以真正地处理命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Task gen_tcp" scheme="http://szpzs.oschina.io/categories/Elixir/Task-gen-tcp/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="gen_tcp" scheme="http://szpzs.oschina.io/tags/gen-tcp/"/>
    
      <category term="Task" scheme="http://szpzs.oschina.io/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－依赖和伞型项目</title>
    <link href="http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/"/>
    <id>http://szpzs.oschina.io/2017/02/21/elixir-getting-started-mix-otp-dependencies-and-umbrella-apps/</id>
    <published>2017-02-20T22:25:27.000Z</published>
    <updated>2017-02-20T22:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">外部依赖</a></li>
<li><a href="#part-two">内部依赖</a></li>
<li><a href="#part-three">伞型项目</a></li>
<li><a href="#part-four">伞型项目里的依赖</a></li>
<li><a href="#part-five">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将讨论用Mix如何管理依赖。</p>
<p>我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。</p>
<p>构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。</p>
<a id="more"></a>
<h1 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a><span id="part-one">外部依赖</span></h1><p>外包依赖是没有绑定到你的业务领域的。例如，如果你需要为你的分布式 kv 应用提供HTTP API，你可以用 <a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a> 项目作为一个外包依赖。</p>
<p>安装外部依赖是简单的。最常见的，我们通过在我们的mix.exs文件里的deps函数内列出依赖来使用 <a href="https://hex.pm/" target="_blank" rel="external">Hex包管理器</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="string">"~&gt; 1.0"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个依赖指向已经发布到Hex的Plug的1.x.x版本系列的最新版本。这由版本号数字前的 ~&gt; 符号表示。有关指定版本要求的更多信息，请参见<a href="https://hexdocs.pm/elixir/Version.html" target="_blank" rel="external">版本模块的文档</a>。</p>
<p>通常，稳定版本被发布到Hex。如果你想依赖一个还处于开发中的外部依赖，Mix也能够管理git依赖：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:plug</span>, <span class="symbol">git:</span> <span class="string">"git://github.com/elixir-lang/plug.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你将注意到，当你增加一个依赖到你的项目，Mix生成一个mix.lock文件来保证<em>可重复构建</em>。这个lock文件必需被提交到你的版本控制系统，以便保证所有使用这个项目的人将使用和你一样的依赖版本。</p>
<p>Mix提供很多任务来处理依赖，这些任务可以用 mix help 来列出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">help</span></div><div class="line">mix deps              <span class="comment"># 列出依赖和它们的状态</span></div><div class="line">mix deps.clean        <span class="comment"># 删除给定的依赖文件</span></div><div class="line">mix deps.compile      <span class="comment"># 编译依赖</span></div><div class="line">mix deps.get          <span class="comment"># 获取所有过时的依赖</span></div><div class="line">mix deps.tree         <span class="comment"># 打印依赖树</span></div><div class="line">mix deps.unlock       <span class="comment"># 解锁给定的依赖</span></div><div class="line">mix deps.update       <span class="comment"># 更新给定的依赖</span></div></pre></td></tr></table></figure>
<p>最常用的任务是 mix deps.get 和 mix deps.update 。一旦被获取到，依赖被自动编译。你可以通过输入 mix help deps 和在 <a href="https://hexdocs.pm/mix/Mix.Tasks.Deps.html" target="_blank" rel="external">Mix.Tasks.Deps 模块文档</a>里读到更多关于依赖的内容。</p>
<h1 id="内部依赖"><a href="#内部依赖" class="headerlink" title="内部依赖"></a><span id="part-two">内部依赖</span></h1><p>内部依赖项是特定于你的项目的依赖。它们通常在你的项目/公司/组织范围之外是没有意义的。大多数时候，你想让他们私有化，无论是由于技术，经济或商业原因。</p>
<p>如果你有一个内部依赖，Mix支持两种方法与它一起工作：git仓库和伞型项目。</p>
<p>例如，如果你推送 kv 应用到一个git仓库，你将需要在你的依赖代码里列出它以便使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">git:</span> <span class="string">"https://github.com/YOUR_ACCOUNT/kv.git"</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果仓库是私有的，您可能需要指定私有URL git@github.com:YOUR_ACCOUNT/kv.git 。在任何情况下，Mix将能够把它拿来给你，只要你有适当的凭据。</p>
<p>在Elixir里不鼓励使用git依赖作为内部依赖。记住：运行时和Elixir生态已经提供了应用这个概念。因此，我们希望你经常将你的代码分解成可以被逻辑地组织的应用，即使在单个项目中也是如此。</p>
<p>然而，如果你把每个应用作为一个独立的项目放入一个git仓库，那么你的项目可能非常难以维护，因为你将花费大量时间来管理那些git仓库而不是写你代码。</p>
<p>因为这个原因，Mix支持“伞型项目”。伞型项目允许你创建一个项目，它拥有许多项目，而且保持它们在一个单独源码仓库里。这正是下一节我们将要探索的风格。</p>
<p>让我们创建一个新的Mix项目。我们将创造性地命名它为 kv_umbrella ，这个新项目里面将拥有已经存在的 kv 应用和新的 kv_server 应用。目录结构将如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>关于这个方法令人感兴趣的事情是，Mix有许多遍历措施来处理这样的项目，诸如用一个命令将apps里的所有应用都编译和测试的能力。但是，尽管它们都在apps目录里，它们依然是彼此解耦的，所以，如果你想的话，你就可以独立地构建、测试和部署每一个应用。</p>
<p>所以让我们开始吧！</p>
<h1 id="伞型项目"><a href="#伞型项目" class="headerlink" title="伞型项目"></a><span id="part-three">伞型项目</span></h1><p>让我们用 mix new 开始一个新项目。这个新项目将被命名为 kv_umbrella ，并且在创建它的时候，我们需要传递 --umbrella 参数。不要在已经存在的 kv 项目里创建这个新项目！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix new kv_umbrella --umbrella</div><div class="line">* creating .gitignore</div><div class="line">* creating README.md</div><div class="line">* creating mix.exs</div><div class="line">* creating apps</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div></pre></td></tr></table></figure>
<p>从打印出来的信息我们可以看到生成的文件少了很多。生成的mix.exs文件也不同。让我们看一看这个文件（注释已经被删除）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KvUmbrella</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">apps_path:</span> <span class="string">"apps"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>使得这个项目与前面的项目不同的是在项目定义里有一个 apps_path: “apps” 条目。它的意思是这个项目将表现得像一把伞。这样的项目既没有源码文件也没有测试用例，但是它们可以有它们自己的依赖。每一个子应用必须定义在apps目录里。</p>
<p>让我们进入apps目录里开始构建 kv_server 。这一次，我们将传递 --sup 标志，它将告诉Mix自动为我们生成一颗监督树，替代在前面章节里如我们所做的手工构建监督树：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv_umbrella/apps</div><div class="line">$ mix new kv_server --module KVServer --sup</div></pre></td></tr></table></figure>
<p>生成的文件与我们第一次为 kv 所生成的相似，有一些不同。让我们打开 mix.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv_server</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line">     <span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line">     <span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line">     <span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.4"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">     <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>首先，因为我们在kv_umbrella/apps里创建这个项目，Mix自动监测到伞型结构并且增加四行到项目定义里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>这些选项的意思是，所有选项将被放置到 kv_umbrella/deps ，并且它们将共享同样的构建、配置和锁文件。这确保为整个伞型结构，依赖将被获取并被编译一次，而不是每一个伞型应用一次。</p>
<p>第二个改变是在 mix.exs 里的 application 函数中：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KVServer.Application, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们传递了 --sup 标志，Mix自动增加了 mod: {KVServer.Application, []} ，指明 KVServer.Application 是我们的应用回调模块。KVServer.Application 将启动我们的应用监督树。</p>
<p>事实上，让我们打开 lib/kv_server/application.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVServer</span></span>.Application <span class="keyword">do</span></div><div class="line">  <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Application.html</span></div><div class="line">  <span class="comment"># for more information on OTP Applications</span></div><div class="line">  <span class="variable">@moduledoc</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    import Supervisor.Spec, <span class="symbol">warn:</span> <span class="keyword">false</span></div><div class="line"></div><div class="line">    <span class="comment"># Define workers and child supervisors to be supervised</span></div><div class="line">    children = [</div><div class="line">      <span class="comment"># Starts a worker by calling: KVServer.Worker.start_link(arg1, arg2, arg3)</span></div><div class="line">      <span class="comment"># worker(KVServer.Worker, [arg1, arg2, arg3]),</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># See http://elixir-lang.org/docs/stable/elixir/Supervisor.html</span></div><div class="line">    <span class="comment"># for other strategies and supported options</span></div><div class="line">    opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">name:</span> KVServer.Supervisor]</div><div class="line">    Supervisor.start_link(children, opts)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：它定义了应用回调函数，start/2，而不是使用 Supervisor 模块定义一个名为 KVServer.Supervisor 的监督者，它便捷地在行内定义了监督者！你可以通过阅读<a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor模块文档</a>获得更多这样的监督者的内容。</p>
<p>我们已经可以试试我们第一个伞型子应用。我们可以在 apps/kv_server 里运行测试，但是那样不好玩。相反，到伞型项目的根目录，运行 mix test ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>它正常运行！</p>
<p>因为我们想让 kv_server 最终使用我们在 kv 里定义的功能，因此我们需要将 kv 作为一个依赖加入我们的应用。</p>
<h1 id="伞型项目里的依赖"><a href="#伞型项目里的依赖" class="headerlink" title="伞型项目里的依赖"></a><span id="part-four">伞型项目里的依赖</span></h1><p>Mix支持一种简单的机制使得一个伞型子应用依赖于另一个伞型子应用。打开 apps/kv_server/mix.exs 并且按如下所示修改 deps/0 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">  [&#123;<span class="symbol">:kv</span>, <span class="symbol">in_umbrella:</span> <span class="keyword">true</span>&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述代码使得 :kv作为 :kv_server 里的一个可用依赖并且在启动 :kv_server 前自动启动 :kv 应用。</p>
<p>最后，拷贝我们已经构建好的 kv 应用到我们新的伞型项目的 apps 目录里。最终的目录结构和我们前面提到的结构匹配上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ kv_umbrella</div><div class="line">  + apps</div><div class="line">    + kv</div><div class="line">    + kv_server</div></pre></td></tr></table></figure>
<p>我们现在需要修改 apps/kv/mix.exs 让其包含我们已经在 apps/kv_server/mix.exs 所见到的伞型相关条目。打开 apps/kv/mix.exs 并将如下内容加入 project 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">build_path:</span> <span class="string">"../../_build"</span>,</div><div class="line"><span class="symbol">config_path:</span> <span class="string">"../../config/config.exs"</span>,</div><div class="line"><span class="symbol">deps_path:</span> <span class="string">"../../deps"</span>,</div><div class="line"><span class="symbol">lockfile:</span> <span class="string">"../../mix.lock"</span>,</div></pre></td></tr></table></figure>
<p>现在你可以从伞型项目根目录用 mix test 运行两个应用的测试。太棒了！</p>
<p>请记住，伞型项目是一个方便工具用来帮助你组织和管理你的应用。apps 目录里的应用仍然是彼此解耦的。它们之间的依赖必须明确地列出来。这允许它们被一起开发，但是如果需要的话，独立地编译、测试和部署。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-five">总结</span></h1><p>在这一章，我们学到了更多关于Mix依赖和伞型项目的内容。我们决定构建一个伞型项目，因为我们认为 kv 和 kv_server 是内部依赖的，其重要性只存在于这个项目的上下文里。</p>
<p>在将来，你将写应用并且你将注意到它们可以被提取到一个简洁的单元，这个单元能被不同的项目使用。在这种情况下，使用Git或Hex依赖是要走的路。</p>
<p>这里有几个问题，当你使用依赖的时候你可以问自己。问题是：这个应用在这个项目之外有意义吗？</p>
<ul>
<li>如果没有，则使用一个有伞型子应用的伞型项目。</li>
<li>如果有，则这个项目在你的公司或组织外部可以被共享吗？<ul>
<li>不可以， 则使用一个私有git仓库。</li>
<li>如果可以，则推送你的代码到一个git仓库并且用Hex做频繁的发布。</li>
</ul>
</li>
</ul>
<p>我们的伞型项目构建好并运行了，是时候开始写我们的服务器了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;外部依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;内部依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;伞型项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;伞型项目里的依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将讨论用Mix如何管理依赖。&lt;/p&gt;
&lt;p&gt;我们的 kv 应用已经完成，所以是时候实现一个服务器，它将处理在第一章我们定义的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs 3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，我们不是增加更多代码到 kv 应用里，而是将构建一个TCP服务器作为另一个应用，它是 kv 应用的一个客户端。因为整个运行时和Elixir生态是面向应用的，因此把我们的项目分成一起运作的更小的应用比构建一个巨大单一的应用有意义。&lt;/p&gt;
&lt;p&gt;构建我们新应用前，我们必须讨论Mix如何处理依赖。在实践中，我们通常运用两种依赖：内部依赖和外部依赖。Mix支持运用这两种依赖。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Dependency Umbrella-Apps" scheme="http://szpzs.oschina.io/categories/Elixir/Dependency-Umbrella-Apps/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Dependency" scheme="http://szpzs.oschina.io/tags/Dependency/"/>
    
      <category term="Umbrella-Apps" scheme="http://szpzs.oschina.io/tags/Umbrella-Apps/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－ETS</title>
    <link href="http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/"/>
    <id>http://szpzs.oschina.io/2017/02/20/elixir-getting-started-mix-otp-ets/</id>
    <published>2017-02-20T05:41:49.000Z</published>
    <updated>2017-02-20T06:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">ETS作为缓存</a></li>
<li><a href="#part-two">竞争条件</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！</p>
<p>在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。</p>
<blockquote>
<p>警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。</p>
</blockquote>
<a id="more"></a>
<h1 id="ETS作为缓存"><a href="#ETS作为缓存" class="headerlink" title="ETS作为缓存"></a><span id="part-one">ETS作为缓存</span></h1><p>ETS允许我们存储任何Elixir数据到一个内存表里。与ETS表交互是通过Erlang :ets 模块做到的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:set</span>, <span class="symbol">:protected</span>])</div><div class="line"><span class="number">8207</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(table, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>当创建一个ETS表的时候，需要两个入参：一个表名字和一个选项集合。从可用选项中，我们选择传递表类型和它的访问规则。我们选择了 :set 类型，这意味着键不能是重复的。我们也设置表的访问规则为 :protected ，这意味着只有创建表的进程能写这个表，不过其他进程可以从表里读取数据。这两个选项实际上是默认值，所以从现在开始我们将忽略它们。</p>
<p>ETS表可以被命名，允许我们通过给定的名字访问它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:ets</span>.new(<span class="symbol">:buckets_registry</span>, [<span class="symbol">:named_table</span>])</div><div class="line"><span class="symbol">:buckets_registry</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(<span class="symbol">:buckets_registry</span>, &#123;<span class="string">"foo"</span>, <span class="keyword">self</span>()&#125;)</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.lookup(<span class="symbol">:buckets_registry</span>, <span class="string">"foo"</span>)</div><div class="line">[&#123;<span class="string">"foo"</span>, <span class="comment">#PID&lt;0.41.0&gt;&#125;]</span></div></pre></td></tr></table></figure>
<p>让我们修改 KV.Registry 来使用ETS表。因为我们的registry需要一个名字作为入参，我们计划用与registry相同的名字来命名ETS表。ETS的名字和进程的名字存储在不同的地方，因此没有冲突的可能。</p>
<p>打开 lib/kv/registry.ex ，让我们修改它的实现。我们增加注释到源码中来强调我们所做的修改：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry with the given `name`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 1. 传递名字给GenServer的init回调函数</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, name, <span class="symbol">name:</span> name)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">when</span> is_atom(server) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 2. 查询现在直接在ETS里做，没有访问服务器</span></div><div class="line">    <span class="keyword">case</span> <span class="symbol">:ets</span>.lookup(server, name) <span class="keyword">do</span></div><div class="line">      [&#123;^name, pid&#125;] -&gt; &#123;<span class="symbol">:ok</span>, pid&#125;</div><div class="line">      [] -&gt; <span class="symbol">:error</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Stops the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">    GenServer.stop(server)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(table) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 3. 我们已经用ETS表替换名字映射</span></div><div class="line">    names = <span class="symbol">:ets</span>.new(table, [<span class="symbol">:named_table</span>, <span class="symbol">read_concurrency:</span> <span class="keyword">true</span>])</div><div class="line">    refs  = %&#123;&#125;</div><div class="line">    &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 4. 原来为查询服务的handle_call回调函数被删除</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 5. 读写ETS表而不是映射</span></div><div class="line">    <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:ok</span>, _pid&#125; -&gt;</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">      <span class="symbol">:error</span> -&gt;</div><div class="line">        &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">        ref = Process.monitor(pid)</div><div class="line">        refs = Map.put(refs, ref, name)</div><div class="line">        <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">        &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 6. 从ETS表而不是从映射删除</span></div><div class="line">    &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">    <span class="symbol">:ets</span>.delete(names, name)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意：在我们修改前， KV.Registry.lookup/2 发送请求给服务器，但是现在它直接从ETS表里读取，ETS表被所有进程共享。这是我们实现的缓存机制背后的主要思想。</p>
<p>为了让缓存机制工作，被创建的ETS表需要有 :protected 访问规则（访问规则的默认值），因此所有客户端可以从它读取数据，而只有 KV.Registry 进程可以写数据到这个表里。当表启动的时候，我们已经设置 read_concurrency: true ，这样就优化了表的并发读取操作的通用场景。</p>
<p>我们上面的修改已经使得我们的测试失败，因为我们原来是用registry进程的pid来做所有操作，而现在registry查询需要ETS表的名字。但是，ETS表的名字和registry进程的名字相同，这个问题就很容易修复。如下所示修改 test/kv/registry_test.exs 的setup函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> context.test&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们修改 setup ，一些测试用例将继续失败。你可能甚至注意到，在不同的运行之间，测试的通过和失败也不是一致的。例如：“spawns buckets”测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">  assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>可能在这一行失败：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div></pre></td></tr></table></figure>
<p>如果我们刚刚在上一行创建了bucket，这一行为何会失败？</p>
<p>那些发生的失败的原因是因为为了教学目的，我们已经犯两个错误：</p>
<ol>
<li>我们过早地优化（通过增加这个缓存层）</li>
<li>我们使用 cast/2 （但是我们应该使用 call/2 ）</li>
</ol>
<h1 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a><span id="part-two">竞争条件</span></h1><p>在Elixir里做开发不会使得你的代码免于竞争条件。然而，Elixir的简单抽象，默认情况下不共享数据，更容易发现竞争条件的根本原因。</p>
<p>在我们测试里所发生的是，在一个操作和我们可以观察到在ETS表里这个改变的时间之间有一个延迟。下面是我们所期望的事件发生步骤：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>registry创建bucket并修改缓存表</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 {:ok, bucket}</li>
</ol>
<p>但是，因为 KV.Registry.create/2 是一个 cast 操作，这个命令在我们实际写表前返回。换句话说，实际发生的步骤如下：</p>
<ol>
<li>我们调用 KV.Registry.create(registry, “shopping”)</li>
<li>我们用 KV.Registry.lookup(registry, “shopping”) 从表访问信息</li>
<li>上面的命令返回 :error</li>
<li>registry创建bucket并修改缓存表</li>
</ol>
<p>要修复这个错误，我们需要通过用 call/2 替代 cast/2 来使得 KV.Registry.create/2 成为同步操作。这将保证在修改被写入表后客户端才继续执行。让我们如下所示修改这个函数和它的回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">  GenServer.call(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, _from, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> lookup(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; -&gt;</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">    <span class="symbol">:error</span> -&gt;</div><div class="line">      &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">      ref = Process.monitor(pid)</div><div class="line">      refs = Map.put(refs, ref, name)</div><div class="line">      <span class="symbol">:ets</span>.insert(names, &#123;name, pid&#125;)</div><div class="line">      &#123;<span class="symbol">:reply</span>, pid, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将回调函数从 handle_cast/2 改为 handle_call/3，并且修改它用被创建的bucket的pid作为返回结果。总的来说，Elixir开发者喜欢用 call/2 而不是 cast/2 ，因为 call/2 也提供反压（你被阻塞一直到你获得响应）。在不必要的时候使用 cast/2 也可以被认为是一种过早优化。</p>
<p>让我们再次运行测试，这次，我们将传递 --trace 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> --trace</div></pre></td></tr></table></figure>
<p>当你的测试有死锁或有竞争条件的时候 --trace 选项有用，因为它同步地运行所有测试（async: true 无效了）并且显示每一个测试详细信息。这次我们将减少到一到两个不连续的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes buckets on <span class="built_in">exit</span> (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:19</div><div class="line">   Assertion with == failed</div><div class="line">   code: KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == :error</div><div class="line">   lhs:  &#123;:ok, <span class="comment">#PID&lt;0.109.0&gt;&#125;</span></div><div class="line">   rhs:  :error</div><div class="line">   stacktrace:</div><div class="line">     <span class="built_in">test</span>/kv/registry_test.exs:23</div></pre></td></tr></table></figure>
<p>根据失败消息，我们期望bucket不再存在表里，但是它依然还在！这个问题和我们刚才解决的问题相反：已经解决的问题是在创建bucket的命令和修改表之间有延迟，现在的这个问题是bucket进程死亡和它的信息从表里删除之间存在延迟。</p>
<p>不幸的是，这次我们不能简单地修改负责清理ETS表的 handle_info/2 函数 为同步操作。相反，我们要找到一个方法保证registry已经处理了当bucket崩溃的时候发送给它的 :DOWN 通知。</p>
<p>一个简单的方法来做到这点，就是通过发送一个同步请求给registry：因为消息按顺序被处理，如果registry响应了一个在Agent.stop调用后发送的请求，这就说明 :DOWN 消息已经被处理了。让我们通过创建一个“假的”bucket来做到这点，它是一个在Agent.stop后的同步请求，在两个测试用例里。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Kill the bucket and wait for the notification</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># Wait until the bucket is dead</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  <span class="comment"># Do a call to ensure the registry processed the DOWN message</span></div><div class="line">  <span class="number">_</span> = KV.Registry.create(registry, <span class="string">"bogus"</span>)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试用例现在应该（一直）通过！</p>
<p>到此我们的优化章节结束。我们用ETS作为一个缓存机制，读取可以从任何进程发起，但是写入依然只能通过一个单独的进程顺序执行。更重要的是，我们也学到，一旦数据可以被异步读取，我们需要明白它可能引入竞争条件。</p>
<p>下一章我们将讨论外部和内部的依赖以及Mix如何帮助我们管理大型代码库。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/ets.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/ets.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;ETS作为缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;竞争条件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;每次我们需要查询一个bucket，我们需要发送一个消息给registry。这样的话，我们的registry被多个进程并发地访问，registry可能成为瓶颈！&lt;/p&gt;
&lt;p&gt;在本章，我们将学习ETS（Erlang数据存储）并且学习如何使用它来作为缓存机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;警告：不要贸然使用ETS作为缓存！记录并分析你应用的性能并识别哪部分是瓶颈，这样你就知道你应该在哪里缓存，你应该缓存什么。本章只是在你一旦需要的情况下，ETS如何被使用的一个例子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Elixir/ETS/"/>
    
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－监督者和应用</title>
    <link href="http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/"/>
    <id>http://szpzs.oschina.io/2017/02/19/elixir-getting-started-mix-otp-supervisor-and-application/</id>
    <published>2017-02-19T11:02:53.000Z</published>
    <updated>2017-02-20T05:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个监督者</a></li>
<li><a href="#part-two">理解应用</a><br> 2.1. <a href="#part-two-one">启动应用</a><br> 2.2. <a href="#part-two-two">应用的回调函数</a><br> 2.3. <a href="#part-two-three">项目或者应用？</a></li>
<li><a href="#part-three">简单的一对一监督者</a></li>
<li><a href="#part-four">监督树</a></li>
<li><a href="#part-five">Observer</a></li>
<li><a href="#part-six">测试里的共享状态</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。</p>
<p>当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。</p>
<p>在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。</p>
<a id="more"></a>
<h1 id="我们第一个监督者"><a href="#我们第一个监督者" class="headerlink" title="我们第一个监督者"></a><span id="part-one">我们第一个监督者</span></h1><p>创建一个监督者和创建一个GenServer没有太大的不同。我们将在文件 lib/kv/supervisor.ex 里定义一个名为 KV.Supervisor 的模块，它将使用 Supervisor 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Registry, [KV.Registry])</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的监督者目前只有一个孩子：registry。如下格式的一个工作者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker(KV.Registry, [KV.Registry])</div></pre></td></tr></table></figure>
<p>将用下面的调用启动一个进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KV.Registry.start_link(KV.Registry)</div></pre></td></tr></table></figure>
<p>我们传递给start_link的入参是这个进程的名字。给在监督树下的进程命名是通用的做法，这样使得其他进程不需要知道它们的pid就可以通过名字来访问它们。这是有用的，因为一个被监督的进程可能崩溃，这样的话，当监督者重启它时，它的pid将改变。通过使用一个名字，我们可以保证新的被重启的进程将注册到同样的名字下，而不用一定获取最新的pid。注意，用定义它的相同的模块的名字来注册进程也是通用的做法，这使得在调试或监测一个运行的系统时更方便直接。</p>
<p>最后，我们用孩子列表和策略 :one_for_one 作为入参调用 supervise/2 。</p>
<p>监督策略规定，当一个孩子进程发生崩溃的时候会发生什么。:one_for_one 的意思是，如果一个孩子进程死了，只有它一个将被重启。因为我们只有一个孩子进程，所有这些就是我们所需的。Supervisor行为支持许多不同的策略，我们将在本章中讨论它们。</p>
<p>因为现在KV.Registry.start_link/1期望有一个入参，我们需要改变我们的实现来接收这样的入参。打开 lib/kv/registry.ex 并替换 start_link/0 的实现如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Starts the registry with the given `name`.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(name) <span class="keyword">do</span></div><div class="line">  GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> name)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们也需要修改我们的测试用例，当启动一个registry的时候给它一个名字。用下面的内容替换 test/kv/registry_test.exs 里的setup回调函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>setup/2也可以接收测试上下文，和test/3相似。除了我们在设置块中添加的任何值外，上下文还包含一些默认键，例如：:case， :test，:file 和 :line。我们用当前运行的测试的相同名字作为快捷方式来启动一个registry。</p>
<p>现在我们的测试通过，我们可以带我们的监督者兜兜风。如果我们在我们的项目目录里用 iex -S mix 启动一个控制台，我们可以手工启动一个监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Registry.create(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, <span class="string">"shopping"</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div></pre></td></tr></table></figure>
<p>当我们启动监督者，registry工作者自动被启动，允许我们创建bucket而不需要手工去启动它。</p>
<p>在实践中，我们很少手动启动应用的监督者。相反，它被作为应用的回调的一部分启动。</p>
<h1 id="理解应用"><a href="#理解应用" class="headerlink" title="理解应用"></a><span id="part-two">理解应用</span></h1><p>在这整个时间里我们一直在一个应用里工作。每次我们修改完一个文件并运行 mix compile ，我们会看到在编译输出里有一个 Generated kv app 的消息。</p>
<p>我们可以找到这个被创建的 .app 文件，它在 _build/dev/lib/kv/ebin/kv.app 。让我们看看它的内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;application,kv,</div><div class="line">             [&#123;registered,[]&#125;,</div><div class="line">              &#123;description,<span class="string">"kv"</span>&#125;,</div><div class="line">              &#123;applications,[kernel,stdlib,elixir,logger]&#125;,</div><div class="line">              &#123;vsn,<span class="string">"0.0.1"</span>&#125;,</div><div class="line">              &#123;modules,[<span class="string">'Elixir.KV'</span>,<span class="string">'Elixir.KV.Bucket'</span>,</div><div class="line">                        <span class="string">'Elixir.KV.Registry'</span>,<span class="string">'Elixir.KV.Supervisor'</span>]&#125;]&#125;.</div></pre></td></tr></table></figure>
<p>这个文件包含Erlang数据（用Erlang语法写的）。即使我们不熟悉Erlang，也很容易猜出这个文件有我们应用的定义。它包含我们应用的版本，由它定义的所有模块，以及我们依赖的应用的列表，比如：Erlang的kernel、elixir它自己和在mix.exs文件里的应用列表里指定的logger。</p>
<p>每次我们增加一个新的模块到我们的应用都要手工修改这个文件将会是非常麻烦的。这就是为什么Mix帮我们生成并维护它的原因。</p>
<p>我们也可以通过在我们mix.exs项目文件里自定义 application/0 的返回值来配置被创建的 .app 文件。我们马上将做我们第一个自定义的应用。</p>
<h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a><span id="part-two-one">启动应用</span></h2><p>当我们定义了一个应用规格说明文件：.app 文件，我们就能把应用当做一个整体来启动和停止。目前我们不需要关注这个文件是因为有两个原因：</p>
<ol>
<li>Mix自动为我们启动我们当前的应用。</li>
<li>即使Mix没有启动我们的应用程序，我们的应用程序还没有做任何事情当它启动的时候。</li>
</ol>
<p>不管怎样，让我们看看Mix如何为我们启动应用。让我们用 iex -S mix 启动一个项目的控制台并且进行如下操作：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:already_started</span>, <span class="symbol">:kv</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>哇！它已经启动了。Mix通常启动在我们项目的 mix.exs 文件所定义的整个应用层级的应用；如果这些应用依赖其他应用，它也会同样地为这些所依赖的应用做相同的事情。</p>
<p>我们可以传递一个选项给Mix要求它不要启动我们的应用。让我们运行 iex -S mix run --no-start 来试试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们可以停止我们的 :kv 应用和 :logger应用，:logger应用是由Elixir默认启动的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.stop(<span class="symbol">:kv</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Application.stop(<span class="symbol">:logger</span>)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>然后让我们再次启动我们的应用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.start(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:error</span>, &#123;<span class="symbol">:not_started</span>, <span class="symbol">:logger</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们得到了一个错误因为 :kv 应用依赖的 :logger 应用没有启动。我们需要按正确顺序手工启动每一个应用或如下所示调用 Application.ensure_all_started ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Application.ensure_all_started(<span class="symbol">:kv</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, [<span class="symbol">:logger</span>, <span class="symbol">:kv</span>]&#125;</div></pre></td></tr></table></figure>
<p>没有什么真正值得兴奋的，不过它展现了我们如何能控制我们的应用。</p>
<blockquote>
<p>当你运行 iex -S mix 的时候，它相当于运行 iex -S mix run 。所以当你启动IEx无论何时你需要传递更多选项给Mix，一定运行 iex -S mix run ，然后传递任何选项给run命令接收。你可以在你的shell里运行mix help run找到更多关于run的信息。</p>
</blockquote>
<h2 id="应用的回调函数"><a href="#应用的回调函数" class="headerlink" title="应用的回调函数"></a><span id="part-two-two">应用的回调函数</span></h2><p>既然我们花了所有时间来谈论应用如何启动和停止，则必定有方法在应用启动的时候做一些有用的事情。而事实上，有！</p>
<p>我们可以指定一个应用的回调函数。这个函数将在应用启动的时候被调用。这个函数必须返回格式为 {:ok, pid} 的结果，pid是监督者进程的进程标识符。</p>
<p>我们可以用两个步骤来设置应用的回调函数。首先，打开 mix.exs 文件，然后，按如下所示改变 def application ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:mod 选项指定了“应用回调模块”，它后面的参数将在应用启动的时候被传递。应用回调模块可以是任何实现了 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application</a> 行为的模块。</p>
<p>现在我们已经指定了 KV 作为模块回调，我们需要修改定义在 lib/kv.ex 的 KV 模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    KV.Supervisor.start_link</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们 use Application 时，我们需要定义一些函数，和当我们使用 Supervisor 或 GenServer 时相似。这次我们只是需要定义一个 start/2 函数。如果我们想在应用结束时指定自定义的行为，我们可以定义一个 stop/1 函数。</p>
<p>让我们再次用 iex -S mix 来启动我们项目的控制台。我们将看到一个名为 KV.Registry 的进程已经在运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create(KV.Registry, &quot;shopping&quot;)</div><div class="line">:ok</div><div class="line">iex&gt; KV.Registry.lookup(KV.Registry, &quot;shopping&quot;)</div><div class="line">&#123;:ok, #PID&lt;0.88.0&gt;&#125;</div></pre></td></tr></table></figure>
<p>我们如何知道它是正常运行的？毕竟，我们创建了一个bucket然后查询它；当然，它应该正常运行，对吗？好的，记得 KV.Registry.create/2 使用 GenServer.cast/2 ，因此将返回 :ok ，而不管消息是否找到它的目标。在这个时候，我们不知道监督者和服务器是否起来了，以及bucket是否被创建了。但是， KV.Registry.lookup/2 使用 GenServer.call/3 ，而且将阻塞并等待从服务器返回的结果。我的确得到了正确的响应，所以我们知道所有事情都起来并运行着。</p>
<p>做一个实验，尝试用 GenServer.call/3 替代来重新实现 KV.Registry.create/2 ，并且短暂地使得应用回调不可用。在控制台再次运行上面的代码，你会立即看到创建步骤失败。</p>
<p>记得在继续教程前恢复代码。</p>
<h2 id="项目或者应用？"><a href="#项目或者应用？" class="headerlink" title="项目或者应用？"></a><span id="part-two-three">项目或者应用？</span></h2><p>Mix区分项目和应用。基于我们的mix.exs文件内容，我们可以说我们有一个Mix项目，它定义了一个 :kv 应用。正如我们将在后面章节所看到的，有的项目没有定义任何应用。</p>
<p>当我们说“项目”的时候，你应该考虑Mix。Mix是一种工具，它管理你的项目。它知道如何编译你的项目，测试你的项目等等。它也知道如何编译和启动与你的项目相关的应用程序。</p>
<p>当我们谈论应用的时候，我们谈论的是OTP。应用程序是由运行时作为一个整体来启动和停止的实体。你可以从<a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application的官方文档</a>里学到更多关于应用的内容，也可以通过运行 mix help compile.app 来学到更多在 def application 里被支持的选项。</p>
<h1 id="简单的一对一监督者"><a href="#简单的一对一监督者" class="headerlink" title="简单的一对一监督者"></a><span id="part-three">简单的一对一监督者</span></h1><p>我们现在已经成功地定义了我们的监督者，它作为我们应用生命周期的一部分被自动地启动（和结束）。</p>
<p>然而我们记得在 handle_cast/2 回调函数里，我们的 KV.Registry 同时链接和监测着bucket进程：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>链接是双向的，这暗示着bucket的崩溃会导致registry的崩溃。虽然我们现在有监督者，它保证registry将被恢复并运行，但是崩溃registry意味着我们丢失所有bucket名字与它们相应进程的关联数据。</p>
<p>换句话说，我们希望registy继续运行，即使一个bucket溃。让我们写一个新的registry测试：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes bucket on crash"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 用非正常原因停止bucket</span></div><div class="line">  Process.exit(bucket, <span class="symbol">:shutdown</span>)</div><div class="line"></div><div class="line">  <span class="comment"># 等待一直到bucket死亡</span></div><div class="line">  ref = Process.monitor(bucket)</div><div class="line">  assert_receive &#123;<span class="symbol">:DOWN</span>, ^ref, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>&#125;</div><div class="line"></div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个测试用例和“removes bucket on exit”测试用例相似，不同点是我们有点苛刻地发送 :shutdown 作为退出原因替代 :normal 。和 Agent.stop/1 相反，Process.exit/2 是一个异步操作，因此我们不能简单地在发送退出信号后立即调用 KV.Registry.lookup/2 来查询，因为那时还无法保证bucket已死。为解决这个问题，我们在测试期间也监测bucket，一旦我们确认它死掉了，我们才查询registry，这样就避免了条件竞争。</p>
<p>因为bucket被链接到registry，而registry被链接到测试进程，那么杀掉bucket导致registry崩溃，从而导致测试进程也崩溃：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) <span class="built_in">test</span> removes bucket on crash (KV.RegistryTest)</div><div class="line">   <span class="built_in">test</span>/kv/registry_test.exs:52</div><div class="line">   ** (EXIT from <span class="comment">#PID&lt;0.94.0&gt;) shutdown</span></div></pre></td></tr></table></figure>
<p>这个问题有一个解决办法，提供一个调用 Agent.start/1 的 KV.Bucket.start/0  ，然后在registry里使用它，删除bucket和registry之间的链接。但是，这是一个坏主意，因为这么修改了后，bucket将不会和任何一个进程链接。这就意味着，如果有人停止 :kv 应用，所有的bucket因为无法被访问而继续存活。不仅如此，如果一个进程是不可被访问的，它们就更难被监测。</p>
<p>我们将通过定义一个新的创建和监督所有bucket的监督者来解决这个问题。有一个监督者策略，叫做 :simple_one_for_one ，它特别适合这样的场景：它允许我们指定一个工作者模板并监督许多基于这个模板的子进程。使用这个策略，没有一个工作者在监督者初始化的时候被启动，而每次通过调用 start_child/2 启动一个新的工作者。</p>
<p>让我们在 lib/kv/bucket/supervisor.ex 文件里定义我们的 KV.Bucket.Supervisor ，内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="comment"># 一个存储监督者名字的简单模块属性</span></div><div class="line">  <span class="variable">@name</span> KV.Bucket.Supervisor</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, <span class="symbol">name:</span> <span class="variable">@name</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_bucket</span></span> <span class="keyword">do</span></div><div class="line">    Supervisor.start_child(<span class="variable">@name</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    children = [</div><div class="line">      worker(KV.Bucket, [], <span class="symbol">restart:</span> <span class="symbol">:temporary</span>)</div><div class="line">    ]</div><div class="line"></div><div class="line">    supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:simple_one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>和第一个监督者相比这个监督者有三处改变。</p>
<p>首先，我们决定给这个监督者一个本地名字 KV.Bucket.Supervisor 。我们也定义了一个 start_bucket/0 函数，它将启动一个bucket作为叫做 KV.Bucket.Supervisor 监督者的子进程。我们将在registry里直接调用 start_bucket/0 来替换对 KV.Bucket.start_link 的调用。</p>
<p>最后，在 init/1 回调函数里，我们标注工作者是 :temporary 。这意味着，如果一个bucket死了，它不会被重启。这是因为我们只是想用监督者作为一种聚集bucket的机制。</p>
<p>运行 iex -S mix  ，我们来试试我们新的监督者：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, <span class="number">_</span>&#125; = KV.Bucket.Supervisor.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.70.0&gt;&#125;</span></div><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.72.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(bucket, <span class="string">"eggs"</span>, <span class="number">3</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(bucket, <span class="string">"eggs"</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>让我们修改registry，用KV.Bucket.Supervisor 来重写bucket如何被重启：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.Supervisor.start_bucket</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>一旦我们按上述所示进行了修改，我们的测试用例将失败，因为没有bucket监督者。让我们来自动启动bucket监督者作为我们主监督树的一部分来替代每次测试都直接地启动bucket监督者。</p>
<h1 id="监督树"><a href="#监督树" class="headerlink" title="监督树"></a><span id="part-four">监督树</span></h1><p>为了在我们的应用里使用bucket监督者，我们需要把它加进 KV.Supervisor 的子进程了。注意：我们开始有监督其他监督者的监督者，形成所谓的“监督树”。</p>
<p>打开 lib/kv/supervisor.ex ，按如下所示修改 init/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这次我们增加一个监督者作为一个子进程，没有用参数来启动它。重新运行测试套件，现在所有测试用例都将通过。</p>
<p>因为我们增加了更多的子进程给监督者，所以评估 :one_for_one 监督策略是否依然正确也很重要。有一个瑕疵马上显现出来，就是 KV.Registry 工作者进程和 KV.Bucket.Supervisor 监督者进程之间的关系。如果 KV.Registry 死了，所有链接 KV.Bucket 名字到 KV.Bucket 进程的信息丢失，而且因此 KV.Bucket.Supervisor 也必须死，否则，它管理的 KV.Bucket 进程将成为孤儿。</p>
<p>根据这一观察，我们应该考虑转移到另一个监督策略。另外两个候选者是：:one_for_all 和 :rest_for_one 。一个监督者使用 :one_for_all 策略，则无论何时它任何一个子进程死亡，它将杀掉和重启它所有的子进程。乍一看，这似乎适合我们的使用情况，但它似乎也有点霸道，因为如果 KV.Bucket.Supervisor 死了，KV.Registry 是完全能够清理它自己的。在这种情况下，:rest_for_one 策略就派上用场了：当一个进程崩溃了，监督者将只是杀掉和重启在崩溃子进程后启动的子进程。让我们重写我们的监督树，用这个策略来替代原来的策略：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  children = [</div><div class="line">    worker(KV.Registry, [KV.Registry]),</div><div class="line">    supervisor(KV.Bucket.Supervisor, [])</div><div class="line">  ]</div><div class="line"></div><div class="line">  supervise(children, <span class="symbol">strategy:</span> <span class="symbol">:rest_for_one</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，如果 KV.Registry 工作者崩溃，则 KV.Registry 和 KV.Supervisor 的“剩余”子进程（即 KV.Bucket.Supervisor ）将被重启。但是，如果 KV.Bucket.Supervisor 崩溃了，KV.Registry 将不会被重启，因为它先于 KV.Bucket.Supervisor 启动。</p>
<p>还有其他的策略和其他的选项可以给 worker/2，supervisor/2 和 supervise/2 函数，所以不要忘了仔细阅读 <a href="https://hexdocs.pm/elixir/Supervisor.html" target="_blank" rel="external">Supervisor</a> 和 <a href="https://hexdocs.pm/elixir/Supervisor.Spec.html" target="_blank" rel="external">Supervisor.Spec</a> 模块的文档。</p>
<p>为了帮助开发者记住如何使用 Supervisor 和它方便的函数，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a> 已经创建了 <a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/Supervisor_CheatSheet.pdf" target="_blank" rel="external">Supervisor备忘录</a> 。</p>
<p>在我们转到下一章前还剩下两个话题。</p>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><span id="part-five">Observer</span></h1><p>现在我们已经定义了我们的监督树，这是一个很好的机会介绍Erlang自带的Observer工具。用 iex -S mix 启动你的应用，然后在里面输入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:observer</span>.start</div></pre></td></tr></table></figure>
<p>一个包含我们系统的所有各类信息的图形界面弹出来，信息包括从总的统计到负载图，也有所有运行的进程和应用的列表。</p>
<p>在应用标签卡里，你将看到你的系统里的所有当前运行的应用以及它们的监督树。你可以选择 kv 应用来进一步浏览它：</p>
<p><img src="/images/getting-started-mix-otp-supervisor-and-application-kv-observer.png" style="border:0;"></p>
<p>不仅如此，当你在终端创建一个新的bucket的时候，你将在Observer里看到被新创建的进程在监督树里展示出来。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; KV.Registry.create KV.Registry, <span class="string">"shopping"</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们将留给你进一步探索Observer提供了什么。记住，你可以双击监督树里的任何进程来获取这个进程的更多信息，也可以右击一个进程来发送“一个杀死信号”，这是一个完美的方式来模拟失败并看看你的监督者是否如预期地响应。</p>
<p>在一天结束之际，像Observer这样的工具是你想要总是在监督树内启动进程，即使他们是暂时的，以确保它们总是可以到达和监测的主要原因之一。</p>
<h1 id="测试里的共享状态"><a href="#测试里的共享状态" class="headerlink" title="测试里的共享状态"></a><span id="part-six">测试里的共享状态</span></h1><p>到目前为止，我们已经为每一个测试用例启动一个registry来确保它们是被隔离的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setup context <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link(context.test)</div><div class="line">  &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>既然我们现在已经改变了我们的registry来使用 KV.Bucket.Supervisor ，它被全局注册，我们的测试现在依靠这个共享、全局的监督者，尽管每个测试用例都有自己的registry。问题是：我们应该这样做吗？</p>
<p>这取决于只要我们只依赖于这个状态的非共享部分，就可以依赖共享的全局状态。例如，每次我们用给定的名字注册一个进程，我们就是正在对应于一个共享了名字的registry来注册一个进程。然而，只要我们通过使用像 context.test 这样的结构来保证这个名字对于每一个测试用例都是特定的，我们就不会在测试用例之间有并发或者数据依赖的问题。</p>
<p>类似的推理应适用于我们的bucket监督者。虽然在共享的bucket监督者上多个registry可能启动bucket，但是那些bucket和registry是彼此隔离的。如果我们使用像 Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数，我们只会遇到并发问题；Supervisor.count_children(KV.Bucket.Supervisor) 这样的函数从所有registry统计所有的bucket数量，当测试用例并发地运行的时候，潜在获得不同结果的问题。</p>
<p>因为我们目前只依赖bucket监督者的非共享部分，因此在我们的测试套件里我们不需要担心并发问题。万一它成为一个问题，我们可以每一个测试用例启动一个监督者并且把它作为入参传递给registry的start_link函数。</p>
<p>现在，我们的应用得到适当的监督和测试，让我们看看如何可以加快速度。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个监督者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;理解应用&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;启动应用&lt;/a&gt;&lt;br&gt; 2.2. &lt;a href=&quot;#part-two-two&quot;&gt;应用的回调函数&lt;/a&gt;&lt;br&gt; 2.3. &lt;a href=&quot;#part-two-three&quot;&gt;项目或者应用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;简单的一对一监督者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;监督树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Observer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;测试里的共享状态&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;到目前为止，我们的应用有一个registry，它可以监测数十个而不是数百个bucket。虽然我们认为我们的当前的实现是非常棒的，但是没有软件是没有bug的，失败一定会发生。&lt;/p&gt;
&lt;p&gt;当失败发生时，你的第一反应可能是：“让我们补救这些失败”。但是在Elixir中，我们避免挽救异常的防御型编程习惯，这在其他语言中常常见到。相反，我们说“让它崩溃”。如果有bug导致我们的registry崩溃，我们没有什么可担心的，因为我们将设置一个监督者，它会重启一个新的registry。&lt;/p&gt;
&lt;p&gt;在本章，我们将学习监督者和应用。我们不止创建一个监督者，而是创建两个监督者，并使用它们来监督我们的进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Supervisor Application" scheme="http://szpzs.oschina.io/categories/Elixir/Supervisor-Application/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Supervisor" scheme="http://szpzs.oschina.io/tags/Supervisor/"/>
    
      <category term="Application" scheme="http://szpzs.oschina.io/tags/Application/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－GenServer</title>
    <link href="http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/"/>
    <id>http://szpzs.oschina.io/2017/02/18/elixir-getting-started-mix-otp-genserver/</id>
    <published>2017-02-18T04:05:34.000Z</published>
    <updated>2017-02-20T05:50:29.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个GenServer</a></li>
<li><a href="#part-two">测试一个GenServer</a></li>
<li><a href="#part-three">监测的必要性</a></li>
<li><a href="#part-four">call、cast还是info？</a></li>
<li><a href="#part-five">监测还是链接？</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在<a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">上一章</a>我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>, <span class="symbol">name:</span> <span class="symbol">:shopping</span>)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.43.0&gt;&#125;</span></div><div class="line">iex&gt; KV.Bucket.put(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; KV.Bucket.get(<span class="symbol">:shopping</span>, <span class="string">"milk"</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而<strong>我们不应该将用户输入转换为原子</strong>。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！</p>
<p>在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。</p>
<p>我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。</p>
<p>注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。</p>
<p>我们将使用一个 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。</p>
<a id="more"></a>
<h1 id="我们第一个GenServer"><a href="#我们第一个GenServer" class="headerlink" title="我们第一个GenServer"></a><span id="part-one">我们第一个GenServer</span></h1><p>一个GenServer被实现为两部分：客户端API和服务端回调函数。你既可以把这两部分合并到一个单独的模块里，也可以把它们分拆到一个客户端模块和一个服务端模块。客户端和服务端分别运行在隔离的进程里，客户端和服务端来回传递消息，而服务器在内部基于收到的消息而调用相关的函数。本文我们将用一个单独的模块来容纳客户端API和服务端回调函数。</p>
<p>创建一个文件 lib/kv/registry.ex ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Registry <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="comment">## Client API</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts the registry.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, <span class="symbol">:ok</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Looks up the bucket pid for `name` stored in `server`.</div><div class="line"></div><div class="line">  Returns `&#123;:ok, pid&#125;` if the bucket exists, `:error` otherwise.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.call(server, &#123;<span class="symbol">:lookup</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Ensures there is a bucket associated to the given `name` in `server`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(server, name) <span class="keyword">do</span></div><div class="line">    GenServer.cast(server, &#123;<span class="symbol">:create</span>, name&#125;)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">## Server Callbacks</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, %&#123;&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, names) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), names&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, names) <span class="keyword">do</span></div><div class="line">    if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:noreply</span>, names&#125;</div><div class="line">    else</div><div class="line">      &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">      &#123;<span class="symbol">:noreply</span>, Map.put(names, name, bucket)&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个函数是 start_link/3 ，它接收三个入参来启动一个新的GenServer：</p>
<ol>
<li>服务端回调函数被实现所在模块，本例子里是 __MODULE__ ，意思就是当前模块。</li>
<li>初始化参数，本例子里是原子 :ok 。</li>
<li>一个选项列表，它可以被用来指定一些事项，比如服务器名字。本例子里我们传递了一个空列表。</li>
</ol>
<p>有两种类型请求你可以发送给一个GenServer：call 和 cast。call是同步的，服务端<strong>必须</strong>发送一个响应给这一个的请求。cast是异步的，服务端不需要返回响应。</p>
<p>接下来的两个函数，lookup/2 和 create/2 负责发送这些请求给服务端。在本例子中，我们分别用 {:lookup, name} 和 {:create, name} 作为请求消息。请求消息常常被指定为元组，就像本例一样，是为了在第一个参数位置提供多于一个“参数”。通常指定请求的动作作为元组的第一个元素，而剩下的元素作为该动作的参数。注意：请求必需匹配 handle_call/3 或 handle_cast/2 的第一个入参。</p>
<p>上面讲的就是客户端API。在服务器这边，我们可以实现各种各样的回调函数来保证服务器的初始化、终止和处理请求。那些回调函数是可选的，目前我们只实现我们所关心的。</p>
<p>第一个是 init/1 回调函数，它接收传给 GenServer.start_link/3 的参数并且返回 {:ok, state} ，此处的状态是一个新的映射。我们可能已经注意到GenServer的API是如何使得客户端和服务端隔离的更明显的。start_link/3 在客户端，而它所对应的回调函数 init/1 运行在服务端。</p>
<p>对应于 call/2 的请求，我们实现一个 handle_call/3 回调函数来接收它的请求、请求的来源进程（_from），以及当前服务器状态（state）。handle_call/3 回调函数返回一个格式为 {:reply, reply, new_state} 的元组。这个元组的第一个元素，:reply ，表明服务器将发送一个应答给客户端。第二个元素，reply，就是发送给客户端的应答。而第三个元素，new_state，是一个新的服务器状态。</p>
<p>对应于 cast/2 的请求，我们实现了一个 handle_cast/2 回调函数来接收它的请求和当前服务器状态（state）。handle_cast/2  回调函数返回一个格式为 {:noreply, new_state} 的元组。注意：在一个真实的应用里，可能应该用同步调用的方式为 :create 实现回调函数来替换异步的cast函数。我们在本例里这么做是为了说明如何实现一个cast函数的回调。</p>
<p>handle_call/3 和 handle_cast/2 函数还有其他格式的返回元组。也有其他的回调函数我们可以实现，比如：terminate/2 和 code_change/3 。欢迎你探索<a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">整个GenServer文档</a>以了解关于这方面的更多内容。</p>
<p>现在，让我们写一些测试来保证我们的GenServer如我们所期望地工作。</p>
<h1 id="测试一个GenServer"><a href="#测试一个GenServer" class="headerlink" title="测试一个GenServer"></a><span id="part-two">测试一个GenServer</span></h1><p>测试一个GenServer和测试一个Agent没有太大的不同。我们将在测试的setup回调函数里创建一个服务器，并在我们整个测试中使用它。创建一个文件：test/kv/registry_test.exs ，它的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RegistryTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, registry&#125; = KV.Registry.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">registry:</span> registry&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"spawns buckets"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"></div><div class="line">    KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">    assert &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">1</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的测试应该毫无阻碍地通过！</p>
<p>你不需要明确地停掉registry，因为当我们的测试结束的时候，它将收到一个 :shutdown 信号。虽然这么处理相应的测试来说没问题。但是如果需要将停止一个GenServer作为一个应用里逻辑的一部分，那么你可以使用 GenServer.stop/1 函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 客户端 API</span></div><div class="line"></div><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Stops the registry.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(server) <span class="keyword">do</span></div><div class="line">  GenServer.stop(server)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="监测的必要性"><a href="#监测的必要性" class="headerlink" title="监测的必要性"></a><span id="part-three">监测的必要性</span></h1><p>我们的registry几乎完成了。仅剩的问题是，如果一个bucket停止或崩溃了，registry的数据可能会变得过时。让我们增加一个测试用例到 KV.RegistryTest 来揭示这个bug：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"removes buckets on exit"</span>, %&#123;<span class="symbol">registry:</span> registry&#125; <span class="keyword">do</span></div><div class="line">  KV.Registry.create(registry, <span class="string">"shopping"</span>)</div><div class="line">  &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Registry.lookup(registry, <span class="string">"shopping"</span>)</div><div class="line">  Agent.stop(bucket)</div><div class="line">  assert KV.Registry.lookup(registry, <span class="string">"shopping"</span>) == <span class="symbol">:error</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的测试用例将在最后的断言处失败，因为bucket的名字还保留在registry里，即使在我们停止了bucket进程后。</p>
<p>为了修复这个bug，我们需要registry监测每一个由它创建的bucket。一旦我们设置了监测，每次bucket退出的时候，registry将收到一个通知，允许我们来清理字典。</p>
<p>让我们用 iex -S mix 启动一个新的控制台，先来玩一下监测：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.66.0&gt;&#125;</span></div><div class="line">iex&gt; Process.monitor(pid)</div><div class="line"><span class="comment">#Reference&lt;0.0.0.551&gt;</span></div><div class="line">iex&gt; Agent.stop(pid)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; flush()</div><div class="line">&#123;<span class="symbol">:DOWN</span>, <span class="comment">#Reference&lt;0.0.0.551&gt;, :process, #PID&lt;0.66.0&gt;, :normal&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Process.monitor(pid) 返回一个唯一的引用，这允许我们匹配将要到来的消息，从而监测引用。我们停止Agent后，我们可以 flush/0 所有消息，注意到：一个 :DOWN 消息到达，带着与monitor返回的一样的引用，告诉我们，bucket进程因为 :normal 原因退出。</p>
<p>让我们重新实现服务端回调函数来修复这个bug并使得测试通过。首先，我们将修改GenServer的状态为两个字典：一个包含 name -&gt; pid ，另一个包含 ref -&gt; name。然后我们需要在 handle_cast/2 里监测bucket，也实现一个 handle_info/2 回调函数来处理监测消息。所有服务端回调函数的实现如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 服务端回调函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(<span class="symbol">:ok</span>) <span class="keyword">do</span></div><div class="line">  names = %&#123;&#125;</div><div class="line">  refs  = %&#123;&#125;</div><div class="line">  &#123;<span class="symbol">:ok</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_call</span></span>(&#123;<span class="symbol">:lookup</span>, name&#125;, _from, &#123;names, <span class="number">_</span>&#125; = state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:reply</span>, Map.fetch(names, name), state&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cast</span></span>(&#123;<span class="symbol">:create</span>, name&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  if Map.has_key?(names, name) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">    ref = Process.monitor(pid)</div><div class="line">    refs = Map.put(refs, ref, name)</div><div class="line">    names = Map.put(names, name, pid)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;<span class="symbol">:DOWN</span>, ref, <span class="symbol">:process</span>, _pid, _reason&#125;, &#123;names, refs&#125;) <span class="keyword">do</span></div><div class="line">  &#123;name, refs&#125; = Map.pop(refs, ref)</div><div class="line">  names = Map.delete(names, name)</div><div class="line">  &#123;<span class="symbol">:noreply</span>, &#123;names, refs&#125;&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(_msg, state) <span class="keyword">do</span></div><div class="line">  &#123;<span class="symbol">:noreply</span>, state&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>注意，我们能够在不改变任何客户端API的情况下，大幅度地改变服务器实现。这就是明确地隔离服务器和客户端的好处之一。</p>
<p>最后，不同于其他回调函数，我们为 handle_info/2 回调函数定义了一个“catch-all”分支，它丢弃任何未知的消息。想知道为什么，请移步下一节。</p>
<h1 id="call、cast还是info？"><a href="#call、cast还是info？" class="headerlink" title="call、cast还是info？"></a><span id="part-four">call、cast还是info？</span></h1><p>我们已经用了三个回调函数：handle_call/3，handle_cast/2 和 handle_info/2。现在我们要考虑什么时候决定和什么时候使用它们：</p>
<ol>
<li>handle_call/3 必须用于同步请求。这应该是等待服务器的回复是一个有用的反压机制的默认选择。</li>
<li>handle_cast/2 必须用于异步请求，而且当你不关心响应的时候。cast甚至不保证服务端收到了消息，因此，它应该尽量少用。例如，本章我们已经定义的 create/2 函数应该使用 call/2 。我们使用 cast/2 是为了教学目的。</li>
<li>handle_info/2 必须用于服务端接收到的不是GenServer.call/2 或 GenServer.cast/2发送的其他所有消息，包括了用send/2发送的普通消息。监测消息 :DOWN 就是其中的例子。</li>
</ol>
<p>因为任何消息，包括send/2方式的消息都由handle_info/2处理，则有机会不期望的消息到达服务器。因此，如果我们没有定义catch-all分支，那些消息将导致我们的registry崩溃，因为没有分支可以匹配它们。但是我们却不用担心这样的情况发生在handle_call/3 和 handle_cast/2。call和cast只能通过GenServer的API来做，所以一个未知消息就十分可能是由开发者的错误造成。</p>
<p>为了帮助开发者记住call，cast 和 info之间的区别，它们支持的返回值以及其他知识，<a href="http://benjamintan.io/" target="_blank" rel="external">Benjamin Tan Wei Hao</a>已经创建了非常棒的<a href="https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf" target="_blank" rel="external">GenServer备忘录</a>.</p>
<h1 id="监测还是链接？"><a href="#监测还是链接？" class="headerlink" title="监测还是链接？"></a><span id="part-five">监测还是链接？</span></h1><p>我们已经在Process这章学习了链接。现在，我们完成了registry模块，我们可能想知道：什么时候我们应该用监测而什么时候我们应该用链接？</p>
<p>链接是双向的。如果你链接了两个进程，其中一个进程崩溃，则另一个进程也将崩溃（除非它捕获了退出信号）。监测是单向的：只有监测的进程才收到关于被监测进程的通知。也就是说：当你想链接崩溃的时候使用链接，而当你只是想获得崩溃、退出等的信息的时候就使用检测。</p>
<p>回到我们的 handle_cast/2 实现，你可以看到registry既链接也监测bucket：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">:ok</span>, pid&#125; = KV.Bucket.start_link</div><div class="line">ref = Process.monitor(pid)</div></pre></td></tr></table></figure>
<p>这是一个坏注意，因为我们不想我们的registry在bucket崩溃的时候也崩溃！我们通常避免直接创建进程，而是把这个责任委托给监督者。正如我们将在下一章所见，监督者依赖于链接，这就解释了为什么基于链接的API（spawn_link，start_link，等）在Elixir和OTP里很普遍。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/genserver.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个GenServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;测试一个GenServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;监测的必要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;call、cast还是info？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;监测还是链接？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/agent.html&quot;&gt;上一章&lt;/a&gt;我们用agent来表示我们的bucket（容器）。在第一章中，我们指出了我们要命名每个bucket，这样我们就可以做到以下几点：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然agent是进程，那么每个bucket有一个进程标识符（pid），但是它没有名字。我们已经在进程那一章中了解了的名字注册，你可能会倾向于使用此注册来解决这个问题。例如，我们可以像下面这样来创建一个bucket：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; Agent.start_link(&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; -&amp;gt; %&amp;#123;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;:ok&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;#PID&amp;lt;0.43.0&amp;gt;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; KV.Bucket.put(&lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;milk&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;:ok&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; KV.Bucket.get(&lt;span class=&quot;symbol&quot;&gt;:shopping&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;milk&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，这是一个可怕的想法！在Elixir中进程的名字必须是原子，这意味着我们需要将bucket的名字（通常是从外部客户端接收过来的）转换为原子，而&lt;strong&gt;我们不应该将用户输入转换为原子&lt;/strong&gt;。这是因为原子没有垃圾回收。一个原子一旦被创建，它就再也不会被回收。从用户的输入来生成原子将意味着用户可以注入足够多的不同名字来耗尽我们系统的内存！&lt;/p&gt;
&lt;p&gt;在实践中，更可能的是你会耗尽内存也就是使得你的系统崩溃之前达到Erlang虚拟机的原子的最大数量的限制。&lt;/p&gt;
&lt;p&gt;我们不滥用名字注册的功能，反而是创建我们自己的注册进程，它持有一个映射来关联bucket的名字和bucket的进程。&lt;/p&gt;
&lt;p&gt;注册需要保证字典内容总是最新的。例如，一个bucket进程因为bug而崩溃了，注册必须清理字典来避免数据被污染。在Elixir中，我们描述这一点，说注册表需要监视每个bucket。&lt;/p&gt;
&lt;p&gt;我们将使用一个 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; 来创建一个注册进程，它可以监测bucket进程。GenServer提供工业级强度的功能来构建Elixir和OTP里的服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="GenServer" scheme="http://szpzs.oschina.io/categories/Elixir/GenServer/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="GenServer" scheme="http://szpzs.oschina.io/tags/GenServer/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Agent</title>
    <link href="http://szpzs.oschina.io/2017/02/17/elixir-getting-started-mix-otp-agent/"/>
    <id>http://szpzs.oschina.io/2017/02/17/elixir-getting-started-mix-otp-agent/</id>
    <published>2017-02-17T12:54:47.000Z</published>
    <updated>2017-02-20T05:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">状态的麻烦</a></li>
<li><a href="#part-two">Agents</a></li>
<li><a href="#part-three">用ExUnit回调函数设置测试</a></li>
<li><a href="#part-four">其他Agent动作</a></li>
<li><a href="#part-five">Agent的Client/Server</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<p>在本章，我们将创建一个名为 KV.Bucket 的模块。这个模块将以某种方式存储我们的键值对实体，并允许其他进程读取和修改它们。</p>
<p>如果你跳过了入门教程或已经读过了很长时间，你应该重新读一下<a href="http://elixir-lang.org/getting-started/processes.html" target="_blank" rel="external">进程</a>这一章。我们将用它作为起始点。</p>
<a id="more"></a>
<h1 id="状态的麻烦"><a href="#状态的麻烦" class="headerlink" title="状态的麻烦"></a><span id="part-one">状态的麻烦</span></h1><p>Elixir是一门不可修改的语言，也就是说默认情况下是没有任何东西是共享的。如果我们想要提供状态，在状态里我们创建“桶”，从其他地方可以放置和读取“桶”里的数据，我们在Elixir有两种主要的选择：</p>
<ul>
<li>进程</li>
<li><a href="http://www.erlang.org/doc/man/ets.html" target="_blank" rel="external">ETS（Erlang Term Storage）</a></li>
</ul>
<p>我们已经谈论过进程，而ETS是个新事物，我们将在本教程的后面讨论它。当需要使用进程的时候，我们几乎没有自己亲自处理它的，反而是使用Elixir和OTP里可用的进程抽象：</p>
<ul>
<li><a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent</a> - 对状态的简单封装</li>
<li><a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> - “通用服务器”（进程），它封装状态，提供同步和异步调用，支持代码重载等等。</li>
<li><a href="https://hexdocs.pm/elixir/GenEvent.html" target="_blank" rel="external">GenEvent</a> - “通用事件”管理器，它允许发布事件给多个处理者。</li>
<li><a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a> - 计算的异步单元，它允许创建一个进程并且在稍后获取它的结果。</li>
</ul>
<p>我们将在本教程里探讨这些抽象中的大多数。我们要记住：它们都是基于进程之上的实现，使用了Erlang虚拟机提供的基本特性，比如：send、receive、spawn和link。</p>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a><span id="part-two">Agents</span></h1><p><a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent</a>是状态的简单封装。如果你想要从一个进程的所有所得是保持状态，那么agent非常合适。让我们在项目里启动一个iex会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex -S mix</div></pre></td></tr></table></figure>
<p>并且玩一下agent：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, agent&#125; = Agent.start_link <span class="keyword">fn</span> -&gt; [] <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="comment">#PID&lt;0.57.0&gt;&#125;</span></div><div class="line">iex&gt; Agent.update(agent, <span class="keyword">fn</span> list -&gt; [<span class="string">"eggs"</span> | list] <span class="keyword">end</span>)</div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; Agent.get(agent, <span class="keyword">fn</span> list -&gt; list <span class="keyword">end</span>)</div><div class="line">[<span class="string">"eggs"</span>]</div><div class="line">iex&gt; Agent.stop(agent)</div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>我们用一个空列表作为初识状态来启动一个agent。我们修改agent的状态，增加我们新的元素到列表头部。<a href="https://hexdocs.pm/elixir/Agent.html#update/3" target="_blank" rel="external">Agent.update/3</a> 的第二个入参是一个函数，这个函数将agent的当前状态作为输入并返回它期望的新状态。最后，我们获取整个列表。<a href="https://hexdocs.pm/elixir/Agent.html#get/3" target="_blank" rel="external">Agent.get/3</a> 的第二个入参是一个函数，这个函数把状态当做输入，然后返回 <a href="https://hexdocs.pm/elixir/Agent.html#get/3" target="_blank" rel="external">Agent.get/3</a> 将返回的值。一旦我们用完agent，我们可以调用 <a href="Agent.stop/3">Agent.stop/3</a> 来终止agent进程。</p>
<p>让我们用agent来实现我们的 KV.Bucket 。不过在开始实现之前，让我们首先写一些测试用例。创建一个文件 test/kv/bucket_test.exs （记住后缀是 .exs），内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.BucketTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"stores values by key"</span> <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="keyword">nil</span></div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">3</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们第一个测试用例启动一个新的 KV.Bucket 并且在其上执行一些 get/2 和 put/3 操作，断言结果。我们不需要明确地停止agent因为它被链接到测试进程，一旦测试结束agent自动地结束。这将一直有效除非这个进程被命名。</p>
<p>也请注意：async: true 选项被传给 ExUnit.Case 。这个选项通过使用我们机器的多核使得这个测试用例和其他 :async 测试用例平行地运行。这对加速我们的测试套件非常有用。但是， :async 必需在不依赖或修改任何全局值的情况下才能被设置。例如，如果测试需要写文件系统、注册进程或访问数据库，那么就保持它为同步的（删除 :async 选项）以避免测试之间的竞争条件。</p>
<p>不管异步与否，我们新的测试将明显会失败，因为被测试的模块里任何一个功能都没有实现。</p>
<p>为了修复失败的测试，让我们创建一个文件： lib/kv/bucket.ex ，它的内容如下所示。在看下面内容前，你自己尝试一下用agent实现 KV.Bucket 模块。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Bucket <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Starts a new bucket.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    Agent.start_link(<span class="keyword">fn</span> -&gt; %&#123;&#125; <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Gets a value from the `bucket` by `key`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">    Agent.get(bucket, &amp;Map.get(&amp;<span class="number">1</span>, key))</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Puts the `value` for the given `key` in the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(bucket, key, value) <span class="keyword">do</span></div><div class="line">    Agent.update(bucket, &amp;Map.put(&amp;<span class="number">1</span>, key, value))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用一个映射来保存我们的键和值。捕获运算符，&amp; ，在<a href="http://elixir-lang.org/getting-started/modules-and-functions.html#function-capturing" target="_blank" rel="external">入门教程</a>里有介绍。</p>
<p>现在 KV.Bucket 模块已经被定义，我们的测试应该pass！你可以运行 mix test 来尝试一下。</p>
<h1 id="用ExUnit回调函数设置测试"><a href="#用ExUnit回调函数设置测试" class="headerlink" title="用ExUnit回调函数设置测试"></a><span id="part-three">用ExUnit回调函数设置测试</span></h1><p>在继续往 KV.Bucket 添加更多功能之前，我们来讨论一下 ExUnit 的回调函数。正如你所期望的，所有KV.Bucket的测试用例在设置和测试后停止期间将需要一个启动的bucket。幸运的是，ExUnit支持回调函数来允许我们来跳过这样的重复任务。</p>
<p>让我们用回调函数来重新写测试用例：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.BucketTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  setup <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, bucket&#125; = KV.Bucket.start_link</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="symbol">bucket:</span> bucket&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"stores values by key"</span>, %&#123;<span class="symbol">bucket:</span> bucket&#125; <span class="keyword">do</span></div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="keyword">nil</span></div><div class="line"></div><div class="line">    KV.Bucket.put(bucket, <span class="string">"milk"</span>, <span class="number">3</span>)</div><div class="line">    assert KV.Bucket.get(bucket, <span class="string">"milk"</span>) == <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们首先在 setup/1 宏的帮助下定义了一个设置回调。在每次测试之前，在与测试本身相同的过程中运行setup/1 回调。</p>
<p>注意我们需要一种机制从回调传递 bucket 的pid给测试用例。我们使用测试上下文来做这种机制。当我们从回调返回 {:ok, bucket: bucket} ，ExUnit将元组的第二个元素（一个字典）合并到测试上下文。测试上下文是一个映射，我们可以在测试定义匹配它，在代码块里访问这些值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test <span class="string">"stores values by key"</span>, %&#123;<span class="symbol">bucket:</span> bucket&#125; <span class="keyword">do</span></div><div class="line">  <span class="comment"># `bucket` 正是从setup传递过来的bucket</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你可以在<a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case模块文档</a>里读到更多关于ExUnit用例的内容，在<a href="https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html" target="_blank" rel="external">ExUnit.Callbacks文档</a>里读到更多回调的内容。</p>
<h1 id="其他Agent动作"><a href="#其他Agent动作" class="headerlink" title="其他Agent动作"></a><span id="part-four">其他Agent动作</span></h1><p>除了获取一个值和修改agent状态，agent允许我们通过 Agent.get_and_update/2 在一个函数调用里获取一个值并且修改agent状态。让我们实现KV.Bucket.delete/2函数，它从bucket删除一个键并返回它的当前值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Deletes `key` from `bucket`.</div><div class="line"></div><div class="line">Returns the current value of `key`, if `key` exists.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Agent.get_and_update(bucket, &amp;Map.pop(&amp;<span class="number">1</span>, key))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在轮到你写一个上面代码的测试用例！另外，要阅读一下<a href="https://hexdocs.pm/elixir/Agent.html" target="_blank" rel="external">Agent模块的文档</a>学习更多内容。</p>
<h1 id="Agent的Client-Server"><a href="#Agent的Client-Server" class="headerlink" title="Agent的Client/Server"></a><span id="part-five">Agent的Client/Server</span></h1><p>在我们转到下一章内容前，让我们讨论一下agent里的客户端/服务端的概念。让我们展开我们刚刚实现的delete/2函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Agent.get_and_update(bucket, <span class="keyword">fn</span> dict-&gt;</div><div class="line">    Map.pop(dict, key)</div><div class="line">  <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在函数内我们传递给agent的所有内容都发生在agent进程中。在这个场景里，因为agent进程是接收和相应我们消息的，那么我们说agent进程是服务器。函数外不的所有事情发生在客户端。</p>
<p>这个区分很重要。如果有耗时的动作要做，你必须要考虑是在服务端还是在客户端执行这些操作更好。例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(bucket, key) <span class="keyword">do</span></div><div class="line">  Process.sleep(<span class="number">1000</span>) <span class="comment"># puts client to sleep</span></div><div class="line">  Agent.get_and_update(bucket, <span class="keyword">fn</span> dict -&gt;</div><div class="line">    Process.sleep(<span class="number">1000</span>) <span class="comment"># puts server to sleep</span></div><div class="line">    Map.pop(dict, key)</div><div class="line">  <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当一个长时间的动作在服务器上执行，则所有对这个特定服务器的其他请求将一直等待到这个动作完成才能得到处理，这可能导致一些客户端超时。</p>
<p>在下一章，我们将探讨GenServers，它的客户机和服务器之间的隔离变得更加明显。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/agent.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;状态的麻烦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Agents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;用ExUnit回调函数设置测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;其他Agent动作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Agent的Client/Server&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章是&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix和OTP教程&lt;/a&gt;的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的&lt;a href=&quot;http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;第一章&lt;/a&gt;，或者查看本教程的章节索引。&lt;/p&gt;
&lt;p&gt;在本章，我们将创建一个名为 KV.Bucket 的模块。这个模块将以某种方式存储我们的键值对实体，并允许其他进程读取和修改它们。&lt;/p&gt;
&lt;p&gt;如果你跳过了入门教程或已经读过了很长时间，你应该重新读一下&lt;a href=&quot;http://elixir-lang.org/getting-started/processes.html&quot;&gt;进程&lt;/a&gt;这一章。我们将用它作为起始点。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Agent" scheme="http://szpzs.oschina.io/categories/Elixir/Agent/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Agent" scheme="http://szpzs.oschina.io/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>Mix 和 OTP－Mix简介</title>
    <link href="http://szpzs.oschina.io/2017/02/16/elixir-getting-started-mix-otp-introduction-to-mix/"/>
    <id>http://szpzs.oschina.io/2017/02/16/elixir-getting-started-mix-otp-introduction-to-mix/</id>
    <published>2017-02-16T07:54:20.000Z</published>
    <updated>2017-02-16T08:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">我们第一个项目</a></li>
<li><a href="#part-two">项目编译</a></li>
<li><a href="#part-three">运行测试</a></li>
<li><a href="#part-four">环境</a></li>
<li><a href="#part-five">探索</a></li>
</ol>
<p>在本教程里，我们将学习如何构建一个完整的Elixir应用，该应用有自己的监督树、配置、测试等等。</p>
<p>这个应用是一个分布式键值对存储。我们将组织键值对到容器中，然后跨多节点分布这些容器。我们也将构建一个简单的客户端来让我们连接到那些节点中的任何一个，并且像如下所示发送请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE shopping</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping milk 1</div><div class="line">OK</div><div class="line"></div><div class="line">PUT shopping eggs 3</div><div class="line">OK</div><div class="line"></div><div class="line">GET shopping milk</div><div class="line">1</div><div class="line">OK</div><div class="line"></div><div class="line">DELETE shopping eggs</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>为了构建我们的键值对应用，我们将使用三个主要工具：</p>
<ul>
<li>OTP（开放电信平台）是一个Erlang自带的库的集合。Erlang开发者用OTP来构建健壮、容错的应用。在本章中我们将探讨OTP和Elixir整合有多少方面，包括监督树、事件管理器等等；</li>
<li>Mix是一个Elixir自带的构建工具，它为创建、编译、测试你的应用、管理应用的依赖等等提供任务；</li>
<li>ExUnit是一个Elixir自带的基于单元测试的框架。</li>
</ul>
<p>在本章里，我们将用Mix创建我们的第一个项目，然后逐步探索OTP、Mix和ExUnit里的不同特性。</p>
<blockquote>
<p>注意：本教程需要Elixir v1.2.0 或者更高版本。你可以用 elixir –version 来检查你的Elixir版本并且如果需要的话，你可以按 <a href="http://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="external">Elixir入门教程第一章里</a> 描述的步骤安装一个最新的版本。</p>
<p>如果你对本教程有任何疑问或改进建议请到诸如 <a href="https://elixirforum.com/" target="_blank" rel="external">Elixir论坛</a> 或 <a href="https://github.com/elixir-lang/elixir-lang.github.com/issues" target="_blank" rel="external">问题跟踪</a> 告诉我们。你的建议对我们的教程真的很重要。</p>
<p>最后，本教程的代码在这个<a href="https://github.com/josevalim/kv_umbrella" target="_blank" rel="external">仓库</a>里，你可以把它当做参考。</p>
</blockquote>
<a id="more"></a>
<h1 id="我们第一个项目"><a href="#我们第一个项目" class="headerlink" title="我们第一个项目"></a><span id="part-one">我们第一个项目</span></h1><p>当你安装Elixir的时候，除了得到 elixir、elixirc 和 iex 这些可执行文件，你也得到一个叫做Mix的可执行Elixir脚本。</p>
<p>让我们从命令行通过调用 mix new 创建我们的第一个项目。我们将传递项目名字作为这个命令的参数（在这个例子里项目名字是kv），并且告诉Mix我们的主模块应该是全部大写的KV，而不是默认的Kv：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix new kv --module KV</div></pre></td></tr></table></figure>
<p>Mix将创建一个名为kv的目录，并在这个目录里创建一些文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* creating README.md</div><div class="line">* creating .gitignore</div><div class="line">* creating mix.exs</div><div class="line">* creating config</div><div class="line">* creating config/config.exs</div><div class="line">* creating lib</div><div class="line">* creating lib/kv.ex</div><div class="line">* creating <span class="built_in">test</span></div><div class="line">* creating <span class="built_in">test</span>/test_helper.exs</div><div class="line">* creating <span class="built_in">test</span>/kv_test.exs</div></pre></td></tr></table></figure>
<p>让我们简单地看一下那些被创建的文件：</p>
<blockquote>
<p>注意：Mix是一个Elixir可执行文件。这就是说要运行mix，你需要在你的路径里有Elixir可执行文件。如果没有，你可以通过传递这个脚本作为Elixir的参数来运行它：</p>
<pre><code>$ bin/elixir bin/mix new kv --module KV
</code></pre><p>注意：你也可以通过 -S 选项用Elixir执行你路径里的任何脚本：</p>
<pre><code>$ bin/elixir -S mix new kv --module KV
</code></pre><p>当使用 -S 的时候，Elixir在你的路径里找到脚本并执行它。</p>
</blockquote>
<h1 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a><span id="part-two">项目编译</span></h1><p>在我们新项目的目录（kv）里一个名为mix.exs被创建出来，它的主要职责是配置我们的项目。让我们来看看它（注释被删除）:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:kv</span>,</div><div class="line">     <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">     <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.3"</span>,</div><div class="line">     <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">     <span class="symbol">deps:</span> deps()]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>]]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    []</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们的mix.exs定义了两个公共函数：project和application。project返回项目的配置，比如，项目名字和版本；application被用来生成一个应用文件。</p>
<p>还有一个名字为 deps 的私有函数，它被project函数调用，它定义我们项目的依赖。定义 deps 作为一个独立函数不是必需的，但是它有助于我们项目配置的整洁。</p>
<p>Mix也用一个简单模块定义来创建了文件 lib/kv.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span> <span class="keyword">do</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样的结构已经足够编译我们的项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> kv</div><div class="line">$ mix compile</div></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Compiling 1 file (.ex)</div><div class="line">Generated kv app</div></pre></td></tr></table></figure>
<p>lib/kv.ex文件被编译，一个名为 kv.app 的应用清单被创建，并且<a href="http://elixir-lang.org/getting-started/protocols.html#protocol-consolidation" target="_blank" rel="external">如入门教程里所描述的一样，所有协议被整合</a>。所有编译产出物用 mix.exs文件里的选项被置于 _build 目录里，。</p>
<p>一旦项目被编译，你就可以如下所示在项目里启动一个iex会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex -S mix</div></pre></td></tr></table></figure>
<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a><span id="part-three">运行测试</span></h1><p>Mix也创建合适的结构来运行我们的项目测试。Mix项目通常遵循这样的习惯，就是lib目录里的每一个文件，在test目录里都有对应的一个文件，文件名格式为：&lt;filename&gt;_test.exs 。正因为这个缘故，我们已经可以找到一个 test/kv_test.exs 文件对应于我们的 lib/kv.ex 文件。它当前还没有做太多功能：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KVTest</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case</div><div class="line">  doctest KV</div><div class="line"></div><div class="line">  test <span class="string">"the truth"</span> <span class="keyword">do</span></div><div class="line">    assert <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>重要的是要注意两点：</p>
<ol>
<li>测试文件是Elixir脚本文件（.exs）。这样很方便，因为我们不需要在运行它们前编译它们。</li>
<li>我们定义一个名为 KVTest 的测试模块，用 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case</a> 来注入测试API，并且用 test/2 宏定义一个简单的测试用例。</li>
</ol>
<p>Mix也创建了一个名为 test/test_helper.exs 的文件，它负责设置测试框架：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExUnit.start()</div></pre></td></tr></table></figure>
<p>每一次我们运行我们的测试前，这个文件将被Mix自动 require 。我们可以用 mix test 来运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Compiled lib/kv.ex</div><div class="line">Generated kv app</div><div class="line">[...]</div><div class="line">.</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.04 seconds (0.04s on load, 0.00s on tests)</div><div class="line">1 <span class="built_in">test</span>, 0 failures</div><div class="line"></div><div class="line">Randomized with seed 540224</div></pre></td></tr></table></figure>
<p>注意：通过运行 mix test ，Mix再一次编译源文件并且创建应用文件。这是因为Mix支持多环境，这个我们将在下一节讨论。</p>
<p>而且，你可以看到ExUnit为一个成功的测试用例打印一个点号，而且也自动地随机化测试。让我们故意让测试失败，看看会发生什么。</p>
<p>如下一样修改 test/kv_test.exs 里的断言：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></div></pre></td></tr></table></figure>
<p>现在我们再次运行 mix test （注意，这次没有编译）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  1) <span class="built_in">test</span> the truth (KVTest)</div><div class="line">     <span class="built_in">test</span>/kv_test.exs:5</div><div class="line">     Assertion with == failed</div><div class="line">     code: 1 + 1 == 3</div><div class="line">     lhs:  2</div><div class="line">     rhs:  3</div><div class="line">     stacktrace:</div><div class="line">       <span class="built_in">test</span>/kv_test.exs:6</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.05 seconds (0.05s on load, 0.00s on tests)</div><div class="line">1 <span class="built_in">test</span>, 1 failure</div></pre></td></tr></table></figure>
<p>对于每个失败，Mix打印详细的报告，包含测试用例的名字，失败的代码，以及 == 运算符左边的值（lhs）和右边的值（rhs）。</p>
<p>失败的第二行，正好在测试用例名字下面，这是测试被定义的位置。如果你拷贝测试位置这行（包括文件和行数）然后加在Mix test 后面，Mix将装载和运行这个指定的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span> <span class="built_in">test</span>/kv_test.exs:5</div></pre></td></tr></table></figure>
<p>该快捷方式当我们建立我们的项目时将是非常有用的，让我们仅仅运行一个特定的测试来快速迭代。</p>
<p>最后，堆栈跟踪涉及失败本身，它给出有关测试和失败在源文件生成的位置信息。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><span id="part-four">环境</span></h1><p>Mix支持“环境”这个概念。它们允许开发者为特定的场景定制编译和其他选项。默认情况下，Mix理解三种环境：</p>
<ul>
<li>:dev - 这是Mix任务（像 compile）默认运行的</li>
<li>:test - 被 mix test 使用</li>
<li>:prod - 你将在生成环境运行你的项目时使用它</li>
</ul>
<p>环境仅运用到当前的项目。正如稍后我们将看到的，任何你添加到你的项目的依赖将默认运行在 :prod 环境。</p>
<p>定制化每一个环境可以通过在你的mix.exs文件里访问<a href="https://hexdocs.pm/mix/Mix.html#env/1" target="_blank" rel="external">Mix.env函数</a>来做到，这个函数以一个原子方式返回当前环境。我们已经在 :build_embedded 和 :start_permanent 选项里这么使用了：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">  [...,</div><div class="line">   <span class="symbol">build_embedded:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">   <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">   ...]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当你编译你的源码的时候，Elixir把编译的生成物放置到 _build 目录里。然而，在许多场合为了避免不必要的拷贝，Elixir将创建文件系统链接，从 _build 到实际源文件。当 :build_embedded 选项为 true 时，它将禁止这个行为，因为它的目的是在 _build 目录里提供运行你的应用的所需要的一切。</p>
<p>相似地，当 :start_permanent 选项为 true 时，它以 permanent  模式启动你的应用，意思是，当你的应用的监督树结束了，Erlang虚拟机也崩溃。注意：我们不想在开发和测试的时候用这种方式，因为为了解决问题而保持Erlang虚拟机实例运行在那样的环境是有用的。</p>
<p>Mix默认使用 :dev 环境，除了 test 任务默认使用 :test 环境。环境可以通过环境变量 MIX_ENV 修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ MIX_ENV=prod mix compile</div></pre></td></tr></table></figure>
<p>或在Windows下这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> <span class="string">"MIX_ENV=prod"</span> &amp;&amp; mix compile</div></pre></td></tr></table></figure>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a><span id="part-five">探索</span></h1><p>Mix的知识还有很多，我们将在构建我们的项目中继续探索它。<a href="https://hexdocs.pm/mix/" target="_blank" rel="external">Mix官方文档里有它的总览</a>。</p>
<p>记住，你可以一直调用 help 任务列出所有可用的任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mix <span class="built_in">help</span></div></pre></td></tr></table></figure>
<p>调用 mix help TASK 你可以得到指定任务的更多信息。</p>
<p>接下来让我们写一些代码！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;我们第一个项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;项目编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;运行测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;探索&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本教程里，我们将学习如何构建一个完整的Elixir应用，该应用有自己的监督树、配置、测试等等。&lt;/p&gt;
&lt;p&gt;这个应用是一个分布式键值对存储。我们将组织键值对到容器中，然后跨多节点分布这些容器。我们也将构建一个简单的客户端来让我们连接到那些节点中的任何一个，并且像如下所示发送请求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CREATE shopping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping milk 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PUT shopping eggs 3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GET shopping milk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DELETE shopping eggs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了构建我们的键值对应用，我们将使用三个主要工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OTP（开放电信平台）是一个Erlang自带的库的集合。Erlang开发者用OTP来构建健壮、容错的应用。在本章中我们将探讨OTP和Elixir整合有多少方面，包括监督树、事件管理器等等；&lt;/li&gt;
&lt;li&gt;Mix是一个Elixir自带的构建工具，它为创建、编译、测试你的应用、管理应用的依赖等等提供任务；&lt;/li&gt;
&lt;li&gt;ExUnit是一个Elixir自带的基于单元测试的框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本章里，我们将用Mix创建我们的第一个项目，然后逐步探索OTP、Mix和ExUnit里的不同特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：本教程需要Elixir v1.2.0 或者更高版本。你可以用 elixir –version 来检查你的Elixir版本并且如果需要的话，你可以按 &lt;a href=&quot;http://elixir-lang.org/getting-started/introduction.html&quot;&gt;Elixir入门教程第一章里&lt;/a&gt; 描述的步骤安装一个最新的版本。&lt;/p&gt;
&lt;p&gt;如果你对本教程有任何疑问或改进建议请到诸如 &lt;a href=&quot;https://elixirforum.com/&quot;&gt;Elixir论坛&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;问题跟踪&lt;/a&gt; 告诉我们。你的建议对我们的教程真的很重要。&lt;/p&gt;
&lt;p&gt;最后，本教程的代码在这个&lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;仓库&lt;/a&gt;里，你可以把它当做参考。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Mix" scheme="http://szpzs.oschina.io/categories/Elixir/Mix/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Mix" scheme="http://szpzs.oschina.io/tags/Mix/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－下一步</title>
    <link href="http://szpzs.oschina.io/2017/02/15/elixir-getting-started-where-to-go-next/"/>
    <id>http://szpzs.oschina.io/2017/02/15/elixir-getting-started-where-to-go-next/</id>
    <published>2017-02-15T06:01:27.000Z</published>
    <updated>2017-02-15T06:13:04.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">构建你的第一个Elixir项目</a></li>
<li><a href="#part-two">元编程</a></li>
<li><a href="#part-three">社区和其他资源</a></li>
<li><a href="#part-four">关于Erlang</a></li>
</ol>
<p>渴望学更多吗？请继续阅读！</p>
<a id="more"></a>
<h1 id="构建你的第一个Elixir项目"><a href="#构建你的第一个Elixir项目" class="headerlink" title="构建你的第一个Elixir项目"></a><span id="part-one">构建你的第一个Elixir项目</span></h1><p>为了开始你的第一个项目，Elixir提供了一个构建工具，叫做Mix。你可以按如下所示开始你的新项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mix new path/to/new/project</div></pre></td></tr></table></figure>
<p>我们已经写了一个教程，涵盖了如何构建一个Elixir应用，包括它自己的监督树、配置、测试等等。这个应用是一个分布式键值存储，我们把键值对放入容器中，并且把这些容器跨多节点分布：</p>
<ul>
<li><a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix and OTP</a></li>
</ul>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a><span id="part-two">元编程</span></h1><p>Elixir是一种可扩展和非常定制化的编程语言，这归功于它的元编程支持。Elixir中绝大多数元编程是通过宏来做的，宏在一些场景下非常有用，特别是写领域特定语言。我们已经写了一个简短教程来解释宏背后的基本机制，展示如何写宏，以及如何用宏来创建领域特定语言。</p>
<ul>
<li><a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html" target="_blank" rel="external">Elixir中的元编程</a></li>
</ul>
<h1 id="社区和其他资源"><a href="#社区和其他资源" class="headerlink" title="社区和其他资源"></a><span id="part-three">社区和其他资源</span></h1><p>我们有一个<a href="http://elixir-lang.org/learning.html" target="_blank" rel="external">学习区</a>，在里面我们推荐一些书籍、视频和其他资源，都是关于学习Elixir和浏览它的生态系统的。除此之外，社区也提供了大量Elixir资源，比如，会议的演讲、开源项目以及其他学习Elixir的资源。</p>
<p>别忘了你也可以从Github上获取<a href="https://github.com/elixir-lang/elixir" target="_blank" rel="external">Elixir它自己的源代码</a>，Elixir绝大多数代码是用Elixir写的（主要在lib目录里），或者<a href="http://elixir-lang.org/docs.html" target="_blank" rel="external">浏览Elixir的官方文档</a>。</p>
<h1 id="关于Erlang"><a href="#关于Erlang" class="headerlink" title="关于Erlang"></a><span id="part-four">关于Erlang</span></h1><p>Elixir运行在Erlang虚拟机之上，而作为一个名Elixir开发者，他迟早会想要与已存在的Erlang库进行交互。在线上有大量的资源，包括Erlang的基础知识和Erlang的更高级特性：</p>
<ul>
<li><a href="http://elixir-lang.org/crash-course.html" target="_blank" rel="external">Erlang语法：速成课程</a>提供了一个Erlang语法的简洁介绍。每一段代码都伴随着等效的Elixir代码。这是一个好机会，对于你来说不仅可以熟悉Erlang语法，也可以复习你在本教程学到的一些知识。</li>
<li>Erlang的官方网站有一个简短的<a href="http://www.erlang.org/course/concurrent_programming.html" target="_blank" rel="external">教程</a>，它用图来简单地描述了Erlang并发编程的基础知识。</li>
<li><a href="http://learnyousomeerlang.com/" target="_blank" rel="external">《Learn You Some Erlang for Great Good!》</a>是一本非常棒的介绍Erlang的设计原则、标准库、最佳实践以及其他知识的书籍。一旦你已经阅读了上面提及的速成课程，你就可以安全地略过这本书介绍语法的前面几章。当你读到 <a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency" target="_blank" rel="external">并发指南</a> 这一章的时候，才是真正有趣的开始。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/where-to-go-next.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/where-to-go-next.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;构建你的第一个Elixir项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;元编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;社区和其他资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;关于Erlang&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;渴望学更多吗？请继续阅读！&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－Erlang的库</title>
    <link href="http://szpzs.oschina.io/2017/02/14/elixir-getting-started-erlang-libraries/"/>
    <id>http://szpzs.oschina.io/2017/02/14/elixir-getting-started-erlang-libraries/</id>
    <published>2017-02-13T22:18:33.000Z</published>
    <updated>2017-02-13T22:22:34.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">binary模块</a></li>
<li><a href="#part-two">格式化文本输出</a></li>
<li><a href="#part-three">crypto模块</a></li>
<li><a href="#part-four">digraph模块</a></li>
<li><a href="#part-five">ETS</a></li>
<li><a href="#part-six">math模块</a></li>
<li><a href="#part-seven">queue模块</a></li>
<li><a href="#part-eight">rand模块</a></li>
<li><a href="#part-nine">zip和zlib模块</a></li>
</ol>
<p>Elixir提供了非常棒的与Erlang的库交互的能力。实际上，Elixir不鼓励简单地封装Erlang的库，而是提倡直接与Erlang代码交互。本文我们将介绍一些最常见和有用的而在Elixir里找不到的Erlang功能。</p>
<p>当你逐渐熟悉了Elixir，你可能想要探索Erlang的<a href="http://erlang.org/doc/apps/stdlib/index.html" target="_blank" rel="external">STDLIB指引手册</a>来获得更多细节。</p>
<a id="more"></a>
<h1 id="binary模块"><a href="#binary模块" class="headerlink" title="binary模块"></a><span id="part-one">binary模块</span></h1><p>Elixir内建的String模块处理用UTF-8编码的二进制数据。当你要处理不一定要用UTF-8编码的二进制数据的时候，<a href="http://erlang.org/doc/man/binary.html" target="_blank" rel="external">binary模块</a>就有用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.to_charlist <span class="string">"Ø"</span></div><div class="line">[<span class="number">216</span>]</div><div class="line">iex&gt; <span class="symbol">:binary</span>.bin_to_list <span class="string">"Ø"</span></div><div class="line">[<span class="number">195</span>, <span class="number">152</span>]</div></pre></td></tr></table></figure>
<p>上面的例子展示了区别；String模块返回Unicode代码点，而 :binary 处理原始数据的字节。</p>
<h1 id="格式化文本输出"><a href="#格式化文本输出" class="headerlink" title="格式化文本输出"></a><span id="part-two">格式化文本输出</span></h1><p>Elixir没有包含与C语言和其他语言里的printf函数相似的函数。幸运地是，Erlang标准库函数 :io.format/2 和 :io_lib.format/2 可以被用作这样的功能。第一个函数格式化数据输出到终端，而第二个函数格式化数据为一个iolist。格式化说明符不同于printf，<a href="http://erlang.org/doc/man/io.html#format-1" target="_blank" rel="external">细节请参阅Erlang官方文档</a>。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:io</span>.format(<span class="string">"Pi is approximately given by:~10.3f~n"</span>, [<span class="symbol">:math</span>.pi])</div><div class="line">Pi is approximately given <span class="symbol">by:</span>     <span class="number">3.142</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; to_string <span class="symbol">:io_lib</span>.format(<span class="string">"Pi is approximately given by:~10.3f~n"</span>, [<span class="symbol">:math</span>.pi])</div><div class="line"><span class="string">"Pi is approximately given by:     3.142\n"</span></div></pre></td></tr></table></figure>
<p>另外要注意Erlang的格式化函数需要特别注意Unicode的处理。</p>
<h1 id="crypto模块"><a href="#crypto模块" class="headerlink" title="crypto模块"></a><span id="part-three">crypto模块</span></h1><p>crypto模块包含哈希函数、数字签名、加解密等等函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Base.encode16(<span class="symbol">:crypto</span>.hash(<span class="symbol">:sha256</span>, <span class="string">"Elixir"</span>))</div><div class="line"><span class="string">"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"</span></div></pre></td></tr></table></figure>
<p>:crypto模块不是Erlang标准库的一部分，但是它包含在Erlang发行版里。这意味着，任何时候你要使用 :crypto 的时候，就要把它加入你的项目应用列表里。要这么做的话，编辑你的 mix.exs 文件包含它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:crypto</span>]]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="digraph模块"><a href="#digraph模块" class="headerlink" title="digraph模块"></a><span id="part-four">digraph模块</span></h1><p><a href="http://erlang.org/doc/man/digraph.html" target="_blank" rel="external">digraph模块</a>（还有<a href="http://erlang.org/doc/man/digraph_utils.html" target="_blank" rel="external">digraph工具</a>）包含了处理用点和边构建的有向图的函数。在构建了图后，模块里的算法将帮助找到图里的两个节点间的最短路径或回环路径。</p>
<p>给定三个节点，找到从第一个到最后一个节点的最短路径。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; digraph = <span class="symbol">:digraph</span>.new()</div><div class="line">iex&gt; coords = [&#123;<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;]</div><div class="line">iex&gt; [v<span class="number">0</span>, v1, v2] = (<span class="keyword">for</span> c &lt;- coords, <span class="symbol">do:</span> <span class="symbol">:digraph</span>.add_vertex(digraph, c))</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.add_edge(digraph, v<span class="number">0</span>, v1)</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.add_edge(digraph, v1, v2)</div><div class="line">iex&gt; <span class="symbol">:digraph</span>.get_short_path(digraph, v<span class="number">0</span>, v2)</div><div class="line">[&#123;<span class="number">0</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">0</span>.<span class="number">0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;]</div></pre></td></tr></table></figure>
<p>注意：:digraph里的函数在内部修改了图的结构，这是可能的，因为它们被实现为ETS表。下面我们来看看ETS。</p>
<h1 id="ETS"><a href="#ETS" class="headerlink" title="ETS"></a><span id="part-five">ETS</span></h1><p><a href="http://erlang.org/doc/man/ets.html" target="_blank" rel="external">ets</a> 和 <a href="http://erlang.org/doc/man/dets.html" target="_blank" rel="external">dets</a> 模块分别处理内存或硬盘的大数据结构存储。</p>
<p>ETS让你创建一个包含元组的表。默认情况下，ETS表是被保护的，就是说只有拥有者进程可以写这个表，而其他任何进程可以读这个表。ETS有一些功能被用来当做简单数据库、KV存储或者缓存机制。</p>
<p>ets模块的函数将修改表的状态作为副作用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; table = <span class="symbol">:ets</span>.new(<span class="symbol">:ets_test</span>, [])</div><div class="line"><span class="comment"># Store as tuples with &#123;name, population&#125;</span></div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"China"</span>, <span class="number">1_374_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"India"</span>, <span class="number">1_284_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.insert(table, &#123;<span class="string">"USA"</span>, <span class="number">322_000_000</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:ets</span>.i(table)</div><div class="line">&lt;<span class="number">1</span>   &gt; &#123;&lt;&lt;<span class="string">"India"</span>&gt;&gt;,<span class="number">1284000000</span>&#125;</div><div class="line">&lt;<span class="number">2</span>   &gt; &#123;&lt;&lt;<span class="string">"USA"</span>&gt;&gt;,<span class="number">322000000</span>&#125;</div><div class="line">&lt;<span class="number">3</span>   &gt; &#123;&lt;&lt;<span class="string">"China"</span>&gt;&gt;,<span class="number">1374000000</span>&#125;</div></pre></td></tr></table></figure>
<h1 id="math模块"><a href="#math模块" class="headerlink" title="math模块"></a><span id="part-six">math模块</span></h1><p><a href="http://erlang.org/doc/man/math.html" target="_blank" rel="external">math模块</a>包含常用的数学运算，覆盖三角函数、指数函数、对数函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; angle_45_deg = <span class="symbol">:math</span>.pi() * <span class="number">45.0</span> / <span class="number">180.0</span></div><div class="line">iex&gt; <span class="symbol">:math</span>.sin(angle_45_deg)</div><div class="line"><span class="number">0</span>.<span class="number">7071067811865475</span></div><div class="line">iex&gt; <span class="symbol">:math</span>.exp(<span class="number">55.0</span>)</div><div class="line"><span class="number">7.694785265142018</span>e23</div><div class="line">iex&gt; <span class="symbol">:math</span>.log(<span class="number">7.694785265142018</span>e23)</div><div class="line"><span class="number">55.0</span></div></pre></td></tr></table></figure>
<h1 id="queue模块"><a href="#queue模块" class="headerlink" title="queue模块"></a><span id="part-seven">queue模块</span></h1><p><a href="http://erlang.org/doc/man/queue.html" target="_blank" rel="external">queue是一个数据结构</a>，它高效地实现了（双端）FIFO（先进先出）队列。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; q = <span class="symbol">:queue</span>.new</div><div class="line">iex&gt; q = <span class="symbol">:queue</span>.<span class="keyword">in</span>(<span class="string">"A"</span>, q)</div><div class="line">iex&gt; q = <span class="symbol">:queue</span>.<span class="keyword">in</span>(<span class="string">"B"</span>, q)</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line">&#123;<span class="symbol">:value</span>, <span class="string">"A"</span>&#125;</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line">&#123;<span class="symbol">:value</span>, <span class="string">"B"</span>&#125;</div><div class="line">iex&gt; &#123;value, q&#125; = <span class="symbol">:queue</span>.out(q)</div><div class="line">iex&gt; value</div><div class="line"><span class="symbol">:empty</span></div></pre></td></tr></table></figure>
<h1 id="rand模块"><a href="#rand模块" class="headerlink" title="rand模块"></a><span id="part-eight">rand模块</span></h1><p><a href="http://erlang.org/doc/man/rand.html" target="_blank" rel="external">rand</a>有返回随机数和设置随机种子的函数。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform()</div><div class="line"><span class="number">0</span>.<span class="number">8175669086010815</span></div><div class="line">iex&gt; <span class="number">_</span> = <span class="symbol">:rand</span>.seed(<span class="symbol">:exs1024</span>, &#123;<span class="number">123</span>, <span class="number">123534</span>, <span class="number">345345</span>&#125;)</div><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform()</div><div class="line"><span class="number">0</span>.<span class="number">5820506340260994</span></div><div class="line">iex&gt; <span class="symbol">:rand</span>.uniform(<span class="number">6</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<h1 id="zip和zlib模块"><a href="#zip和zlib模块" class="headerlink" title="zip和zlib模块"></a><span id="part-nine">zip和zlib模块</span></h1><p>zip模块让你从硬盘或内存读写ZIP文件，也提取文件的信息。</p>
<p>下面的代码统计ZIP文件里的文件个数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:zip</span>.foldl(<span class="keyword">fn</span> <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>, acc -&gt; acc + <span class="number">1</span> <span class="keyword">end</span>, <span class="number">0</span>, <span class="symbol">:binary</span>.bin_to_list(<span class="string">"file.zip"</span>))</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="number">633</span>&#125;</div></pre></td></tr></table></figure>
<p>zlib模块用zlib格式，就如gzip命令里找到的格式，来处理压缩数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">iex&gt; song = <span class="string">"</span></div><div class="line">...&gt; Mary had a little lamb,</div><div class="line">...&gt; His fleece was white as snow,</div><div class="line">...&gt; And everywhere that Mary went,</div><div class="line">...&gt; The lamb was sure to go."</div><div class="line">iex&gt; compressed = <span class="symbol">:zlib</span>.compress(song)</div><div class="line">iex&gt; byte_size song</div><div class="line"><span class="number">110</span></div><div class="line">iex&gt; byte_size compressed</div><div class="line"><span class="number">99</span></div><div class="line">iex&gt; <span class="symbol">:zlib</span>.uncompress(compressed)</div><div class="line"><span class="string">"\nMary had a little lamb,\nHis fleece was white as snow,\nAnd everywhere that Mary went,\nThe lamb was sure to go."</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/erlang-libraries.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/erlang-libraries.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;binary模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;格式化文本输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;crypto模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;digraph模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;ETS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;math模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;queue模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-eight&quot;&gt;rand模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-nine&quot;&gt;zip和zlib模块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Elixir提供了非常棒的与Erlang的库交互的能力。实际上，Elixir不鼓励简单地封装Erlang的库，而是提倡直接与Erlang代码交互。本文我们将介绍一些最常见和有用的而在Elixir里找不到的Erlang功能。&lt;/p&gt;
&lt;p&gt;当你逐渐熟悉了Elixir，你可能想要探索Erlang的&lt;a href=&quot;http://erlang.org/doc/apps/stdlib/index.html&quot;&gt;STDLIB指引手册&lt;/a&gt;来获得更多细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Erlang&#39;s libraries" scheme="http://szpzs.oschina.io/categories/Elixir/Erlang-s-libraries/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Erlang&#39;s libraries" scheme="http://szpzs.oschina.io/tags/Erlang-s-libraries/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－Typespecs 和 behaviours</title>
    <link href="http://szpzs.oschina.io/2017/02/13/elixir-getting-started-typespecs-and-behaviours/"/>
    <id>http://szpzs.oschina.io/2017/02/13/elixir-getting-started-typespecs-and-behaviours/</id>
    <published>2017-02-13T03:13:48.000Z</published>
    <updated>2017-02-13T03:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">类型和规格说明</a><br> 1.1 <a href="#part-one-one">函数规格说明</a><br> 1.2 <a href="#part-one-two">定义自定义类型</a><br> 1.3 <a href="#part-one-three">静态代码分析</a></li>
<li><a href="#part-two">行为</a><br> 2.1 <a href="#part-two-one">定义行为</a><br> 2.2 <a href="#part-two-two">采用行为</a></li>
</ol>
<a id="more"></a>
<h1 id="类型和规格说明"><a href="#类型和规格说明" class="headerlink" title="类型和规格说明"></a><span id="part-one">类型和规格说明</span></h1><p>Elixir是一门动态类型语言，所以Elixir里的所有类型是由运行时推断出来的。尽管如此，Elixir还是有一个标记叫做 <strong>typespecs</strong> ，它被用来：</p>
<ol>
<li>声明类型函数签名（规格说明）</li>
<li>声明自定义数据类型</li>
</ol>
<h2 id="函数规格说明"><a href="#函数规格说明" class="headerlink" title="函数规格说明"></a><span id="part-one-one">函数规格说明</span></h2><p>Elixir默认提供一些基本类型，比如：整形 或 pid，以及更复杂的类型：例如，round/1 函数，它返回一个浮点数最接近的整数，它的入参是一个数字（整数或浮点数）而返回的是一个整数。在<a href="https://hexdocs.pm/elixir/Kernel.html#round/1" target="_blank" rel="external">它的文档里</a>你可以看到，round/1 的类型签名写为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(number) <span class="symbol">:</span>: integer</div></pre></td></tr></table></figure>
<p>:: 的意思是，其左边的函数返回一个值，它的类型就是其左边的类型。</p>
<p>函数规格说明用指令 @spec 来写，刚好置于函数定义的前面。round/1 函数如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@spec</span> round(number) <span class="symbol">:</span>: integer</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span></span>(number), <span class="symbol">do:</span> <span class="comment"># implementation...</span></div></pre></td></tr></table></figure>
<p>Elixir也支持组合类型。例如，整数列表的类型为：[integer] 。<a href="https://hexdocs.pm/elixir/typespecs.html" target="_blank" rel="external">在 typespec 的文档里</a>，你可以看到Elixir提供的所有内建类型。</p>
<h2 id="定义自定义类型"><a href="#定义自定义类型" class="headerlink" title="定义自定义类型"></a><span id="part-one-two">定义自定义类型</span></h2><p>Elixir提供了很多有用的内建类型，这便于在适当的时候定义自定义类型。这可以在定义模块的时候通过 @type 指令来做到。</p>
<p>假设我们有一个 LousyCalculator 模块，它执行一些通常的算术运算（和、乘积，等等），但是，它不返回计算结果，而是返回一个元组，这个元组用运算结果作为第一个元素，用一个随机的评论作为第二个元素。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">LousyCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> &#123;x + y, <span class="string">"You need a calculator to do that?!"</span>&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> multiply(number, number) <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x, y), <span class="symbol">do:</span> &#123;x * y, <span class="string">"Jeez, come on!"</span>&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如你在例子看到的，元组是一个组合类型，并且每一个元组在其内部通过类型来定义。要理解为什么String.t不写作String，请看<a href="https://hexdocs.pm/elixir/typespecs.html#notes" target="_blank" rel="external">在typespec文档里的说明</a>。</p>
<p>定义函数规格说明以上述例子的方式是可行的，不过很快就变得令人烦恼了，因为我们正一遍又一遍地重复输入 {number, String.t} 。我们可以用 @type 指令来声明我们自己的自定义类型。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">LousyCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@typedoc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Just a number followed by a string.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="variable">@type</span> number_with_remark <span class="symbol">:</span>: &#123;number, String.t&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: number_with_remark</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> &#123;x + y, <span class="string">"You need a calculator to do that?"</span>&#125;</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> multiply(number, number) <span class="symbol">:</span>: number_with_remark</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x, y), <span class="symbol">do:</span> &#123;x * y, <span class="string">"It is like addition on steroids."</span>&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>@typedoc 指令相似于 @doc 和 @moduledoc 指令，它被用来注释自定义类型。</p>
<p>通过 @type 定义的自定义类型被导出而且在它们被定义的模块外部也可用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">QuietCalculator</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@spec</span> add(number, number) <span class="symbol">:</span>: number</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x, y), <span class="symbol">do:</span> make_quiet(LousyCalculator.add(x, y))</div><div class="line"></div><div class="line">  <span class="variable">@spec</span> make_quiet(LousyCalculator.number_with_remark) <span class="symbol">:</span>: number</div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">make_quiet</span></span>(&#123;num, _remark&#125;), <span class="symbol">do:</span> num</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你想保留自定义类型为私有的，你可以用 @typep 指令替代 @type 指令。</p>
<h2 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a><span id="part-one-three">静态代码分析</span></h2><p>类型规格说明不仅是对开发人员有用的附加文档。例如，Erlang工具 <a href="http://www.erlang.org/doc/man/dialyzer.html" target="_blank" rel="external">Dialyzer</a> 使用类型规格说明来进行代码的静态分析。这就是为什么在 QuietCalculator  例子里，我们为 make_quiet/1 函数写规格说明，即使它被定义为私有函数。</p>
<h1 id="行为"><a href="#行为" class="headerlink" title="行为"></a><span id="part-two">行为</span></h1><p>许多模块共享相同的公共API。我们看看<a href="https://github.com/elixir-lang/plug" target="_blank" rel="external">Plug</a>，正如它自己的描述所声明，它是web应用里可组合的模块的<strong>规格说明</strong>。每一个plug是一个模块，它必须实现最少两个公共函数：init/1 和 call/2 。</p>
<p>行为提供一种方式：</p>
<ul>
<li>定义必须被一个模块实现的一个函数集合；</li>
<li>确定一个模块实现这个集合里的所有函数。</li>
</ul>
<p>如果你愿意，你可以认为行为就像Java这种面向对象语言里的接口：一个模块必须实现的函数签名的集合。</p>
<h2 id="定义行为"><a href="#定义行为" class="headerlink" title="定义行为"></a><span id="part-two-one">定义行为</span></h2><p>假如我们想实现一些分析器，它们每一个都分析结构化的数据：例如，一个JSON分析器和一个YAML分析器。这两个解析器将有相同的行为方式：两者都提供一个parse/1 函数和一个 extensions/0 函数。parse/1 函数将返回一个Elixir的结构化数据描述，而 extensions/0 函数将返回可被用于每种数据类型（例如，.json对应于JSON文件）的文件扩展名的列表。</p>
<p>我们可以创建一个 Parser 行为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Parser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@callback</span> parse(String.t) <span class="symbol">:</span>: any</div><div class="line">  <span class="variable">@callback</span> extensions() <span class="symbol">:</span>: [String.t]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>采用 Parser 行为的模块将必须实现所有用 @callback 指令定义的函数。如你所见，@callback 指令期望有一个函数名以及如我们前面所看到的 @spec 指令用到的函数规格说明。</p>
<h2 id="采用行为"><a href="#采用行为" class="headerlink" title="采用行为"></a><span id="part-two-two">采用行为</span></h2><p>采用一个行为很简单：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">JSONParser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> Parser</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str), <span class="symbol">do:</span> <span class="comment"># ... parse JSON</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extensions</span></span>, <span class="symbol">do:</span> [<span class="string">"json"</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">YAMLParser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> Parser</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(str), <span class="symbol">do:</span> <span class="comment"># ... parse YAML</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extensions</span></span>, <span class="symbol">do:</span> [<span class="string">"yml"</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果一个模块采用一个给定的行为却没有实现行为需要的所有回调函数中的一个，则一个编译期警告将被生成。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/typespecs-and-behaviours.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;类型和规格说明&lt;/a&gt;&lt;br&gt; 1.1 &lt;a href=&quot;#part-one-one&quot;&gt;函数规格说明&lt;/a&gt;&lt;br&gt; 1.2 &lt;a href=&quot;#part-one-two&quot;&gt;定义自定义类型&lt;/a&gt;&lt;br&gt; 1.3 &lt;a href=&quot;#part-one-three&quot;&gt;静态代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;行为&lt;/a&gt;&lt;br&gt; 2.1 &lt;a href=&quot;#part-two-one&quot;&gt;定义行为&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#part-two-two&quot;&gt;采用行为&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="typespec behaviour" scheme="http://szpzs.oschina.io/categories/Elixir/typespec-behaviour/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="typespec" scheme="http://szpzs.oschina.io/tags/typespec/"/>
    
      <category term="behaviour" scheme="http://szpzs.oschina.io/tags/behaviour/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－尝试、捕获和挽救</title>
    <link href="http://szpzs.oschina.io/2017/02/12/elixir-getting-started-try-catch-and-rescue/"/>
    <id>http://szpzs.oschina.io/2017/02/12/elixir-getting-started-try-catch-and-rescue/</id>
    <published>2017-02-12T11:41:15.000Z</published>
    <updated>2017-02-12T11:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">Errors</a></li>
<li><a href="#part-two">Throws</a></li>
<li><a href="#part-three">Exits</a></li>
<li><a href="#part-four">After</a></li>
<li><a href="#part-five">Else</a></li>
<li><a href="#part-six">变量作用域</a></li>
</ol>
<p>Elixir有三种错误机制：errors，throws，和 exits 。本章我们将探索它们每一个，并且包括应该何时使用哪一个的评论。</p>
<a id="more"></a>
<h1 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a><span id="part-one">Errors</span></h1><p>错误（或者叫异常）是在代码里有异常的事情发生的时候被使用的。例如，通过尝试将一个数字和原子相加就可以获得一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="symbol">:foo</span> + <span class="number">1</span></div><div class="line">** (ArithmeticError) bad argument <span class="keyword">in</span> arithmetic expression</div><div class="line">     <span class="symbol">:erlang</span>.+(<span class="symbol">:foo</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>任何时候用 raise/1 一个运行时错误可以被抛出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; raise <span class="string">"oops"</span></div><div class="line">** (RuntimeError) oops</div></pre></td></tr></table></figure>
<p>其他种类的错误可以通过传入错误名字和一个关键字列表作为入参给函数 raise/2 来抛出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; raise ArgumentError, <span class="symbol">message:</span> <span class="string">"invalid argument foo"</span></div><div class="line">** (ArgumentError) invalid argument foo</div></pre></td></tr></table></figure>
<p>通过创建一个模块并在它里面使用 defexception 结构，你也可以定义自己的错误；用这种方式，你将创建一个和这个错误定义所在的模块的名字相同的错误。最常见的场景是定义一个自定义的异常，并且有一个消息字段：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MyError</span></span> <span class="keyword">do</span></div><div class="line">iex&gt;   defexception <span class="symbol">message:</span> <span class="string">"default message"</span></div><div class="line">iex&gt; <span class="keyword">end</span></div><div class="line">iex&gt; raise MyError</div><div class="line">** (MyError) default message</div><div class="line">iex&gt; raise MyError, <span class="symbol">message:</span> <span class="string">"custom message"</span></div><div class="line">** (MyError) custom message</div></pre></td></tr></table></figure>
<p>错误可以用 try/rescue  结构来<strong>挽救</strong>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"oops"</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   e <span class="keyword">in</span> RuntimeError -&gt; e</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%RuntimeError&#123;<span class="symbol">message:</span> <span class="string">"oops"</span>&#125;</div></pre></td></tr></table></figure>
<p>上面的例子挽救了运行时错误并且返回这个错误，然后这个错误被打印在iex会话里。</p>
<p>如果错误对你无用，你就不需要返回它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"oops"</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   RuntimeError -&gt; <span class="string">"Error!"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Error!"</span></div></pre></td></tr></table></figure>
<p>但是在实践中，Elixir开发者很少使用 try/rescue 结构。例如，当一个文件不能被成功打开的时候，许多语言会强制要求你去挽救这个错误。Elixir反而是提供了一个函数 File.read/1 ，它返回一个元组，包含了关于这个文件是否被成功打开的相关消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:enoent</span>&#125;</div><div class="line">iex&gt; File.write <span class="string">"hello"</span>, <span class="string">"world"</span></div><div class="line"><span class="symbol">:ok</span></div><div class="line">iex&gt; File.read <span class="string">"hello"</span></div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>这里就没有 try/rescue 。如果你想要处理打开一个文件的不同输出，你可以在case语句里使用模式匹配：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> File.read <span class="string">"hello"</span> <span class="keyword">do</span></div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, body&#125;      -&gt; IO.puts <span class="string">"Success: <span class="subst">#&#123;body&#125;</span>"</span></div><div class="line">...&gt;   &#123;<span class="symbol">:error</span>, reason&#125; -&gt; IO.puts <span class="string">"Error: <span class="subst">#&#123;reason&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最终由你的程序来决定打开一个文件出现的出错是否是一个异常。这就是为什么Elixir在File.read/1和许多函数上没有强制输出异常。相反，它留给开发者选择最好的方法进行处理。</p>
<p>对于你确实期望一个文件存在（而这个文件不存在就一定是一个错误）的场景，你可以使用 File.read!/1 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read! <span class="string">"unknown"</span></div><div class="line">** (File.Error) could <span class="keyword">not</span> read file <span class="symbol">unknown:</span> no such file <span class="keyword">or</span> directory</div><div class="line">    (elixir) lib/file.<span class="symbol">ex:</span><span class="number">305</span>: File.read!<span class="regexp">/1</span></div></pre></td></tr></table></figure>
<p>标准库里的许多函数遵循这样的模式：它有一个副本函数，它抛出异常而不是返回用来匹配的元组。这个约定习惯是，创建一个返回 {:ok, result} 或 {:error, reason} 元组的函数（foo）而另一个函数（foo!，相同的名字不过尾部有一个！字符）接收和foo函数一样的入参，但是如果有错误的时候，它抛出一个异常。如果一切正常，foo!将返回结果（而不是用元组包裹起来）。<a href="https://hexdocs.pm/elixir/File.html" target="_blank" rel="external">File模块</a>是这个约定习惯的很好的例子。</p>
<p>在Elixir里，我们避免使用 try/rescue ，因为我们不使用错误来进行流程控制。我们真正对待错误的看法是：他们是为意外和/或例外情况预留的。如果你确实需要流程控制结构，可以使用 throws 。它就是我们接下来看到的。</p>
<h1 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a><span id="part-two">Throws</span></h1><p>在Elixir里，一个值可以被抛出然后被捕获。throw 和 catch 是为这样的情况保留的，就是：除了用throw 和 catch，不可能来获取到一个值。</p>
<p>实际上这些场景是非常罕见的，除非当你和没有提供合适API的库交互的时候。例如，让我们假设Enum模块没有提供任何API来找到一个值，而这个值就是我们需要在一个数字列表里找到第一个13的倍数的数字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   Enum.each -<span class="number">50</span>..<span class="number">50</span>, <span class="keyword">fn</span>(x) -&gt;</div><div class="line">...&gt;     if rem(x, <span class="number">13</span>) == <span class="number">0</span>, <span class="symbol">do:</span> throw(x)</div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt;   <span class="string">"Got nothing"</span></div><div class="line">...&gt; catch</div><div class="line">...&gt;   x -&gt; <span class="string">"Got <span class="subst">#&#123;x&#125;</span>"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got -39"</span></div></pre></td></tr></table></figure>
<p>因为Enum的确是提供了合适的API，所以实际上Enum.find/2是最好的人选：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.find -<span class="number">50</span>..<span class="number">50</span>, &amp;(rem(&amp;<span class="number">1</span>, <span class="number">13</span>) == <span class="number">0</span>)</div><div class="line">-<span class="number">39</span></div></pre></td></tr></table></figure>
<h1 id="Exits"><a href="#Exits" class="headerlink" title="Exits"></a><span id="part-three">Exits</span></h1><p>所有Elixir代码运行在彼此交互的进程里。当一个进程死于“自然原因”（比如，没有处理异常），它会发送一个退出信号。一个进程也可以通过明确地发送一个退出信号而死亡：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; spawn_link <span class="keyword">fn</span> -&gt; exit(<span class="number">1</span>) <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;0.56.0&gt;</span></div><div class="line">** (EXIT from <span class="comment">#PID&lt;0.56.0&gt;) 1</span></div></pre></td></tr></table></figure>
<p>上面的例子，通过发送值为1的退出信号，被链接的进程死亡。Elixir shell自动处理那些消息并打印在终端上。</p>
<p>退出可以用try/catch来“捕获”：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   exit <span class="string">"I am exiting"</span></div><div class="line">...&gt; catch</div><div class="line">...&gt;   <span class="symbol">:exit</span>, <span class="number">_</span> -&gt; <span class="string">"not really"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"not really"</span></div></pre></td></tr></table></figure>
<p>使用 try/catch 已经很少见了，用它来捕获退出更加罕见。</p>
<p>退出信号是由Erlang虚拟机提供的容错系统的一个重要部分。进程常常运行在监督树下，监督树也是进程；这些进程监听从被监督进程来的退出信号。一旦接收到一个退出信号，监督策略被触发，被监督进程被重启。</p>
<p>正是这种监督体系，使得像 try/catch 和 try/rescue 这样的结构在Elixir里那么罕见。我们宁愿“速错”而不是挽救一个错误，因为我们的监督树将保证我们的应用在错误后将回到一个可知的初始状态。</p>
<h1 id="After"><a href="#After" class="headerlink" title="After"></a><span id="part-four">After</span></h1><p>有时候，在一些可能潜在地引起错误的动作后确保资源被清理干净是必须的。try/after 结构允许你这么做。例如，我们可以打开一个文件并使用after分支关闭它，即使有一些事情出错：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="symbol">:ok</span>, file&#125; = File.open <span class="string">"sample"</span>, [<span class="symbol">:utf8</span>, <span class="symbol">:write</span>]</div><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   IO.write file, <span class="string">"olá"</span></div><div class="line">...&gt;   raise <span class="string">"oops, something went wrong"</span></div><div class="line">...&gt; after</div><div class="line">...&gt;   File.close(file)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (RuntimeError) oops, something went wrong</div></pre></td></tr></table></figure>
<p>after分支将被执行而不管try语句块时候成功。然而需要注意，如果一个被链接的进程退出，这个进程将退出并且after分支将不会被执行。因此，after仅提供一个软保证。幸运地是，Elixir里的文件也被链接到当前进程，因此如果当前进程崩溃了，它们将总是被关闭，而与after分支无关。你将发现其他资源比如ETS表、socket、port等等也是这样。</p>
<p>有时你可能想在一个try结构中封装一个函数的整个身体部分，这样通常是为了保证一些代码在后面被执行。这样的场景，Elixir允许你省略 try 这一行：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">RunAfter</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">without_even_trying</span></span> <span class="keyword">do</span></div><div class="line">...&gt;     raise <span class="string">"oops"</span></div><div class="line">...&gt;   after</div><div class="line">...&gt;     IO.puts <span class="string">"cleaning up!"</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; RunAfter.without_even_trying</div><div class="line">cleaning up!</div><div class="line">** (RuntimeError) oops</div></pre></td></tr></table></figure>
<p>任何时候，after、rescue 或 catch 其中任何一个被用到了，Elixir将自动地封装函数的身体部分到try结构里。</p>
<h1 id="Else"><a href="#Else" class="headerlink" title="Else"></a><span id="part-five">Else</span></h1><p>提供一个 else 块来允许在表达式执行结果上进行模式匹配。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">2</span></div><div class="line">try <span class="keyword">do</span></div><div class="line">  <span class="number">1</span> / x</div><div class="line">rescue</div><div class="line">  ArithmeticError -&gt;</div><div class="line">    <span class="symbol">:infinity</span></div><div class="line">else</div><div class="line">  y <span class="keyword">when</span> y &lt; <span class="number">1</span> <span class="keyword">and</span> y &gt; -<span class="number">1</span> -&gt;</div><div class="line">    <span class="symbol">:small</span></div><div class="line">  <span class="number">_</span> -&gt;</div><div class="line">    <span class="symbol">:large</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>结果被传递给else，并且在那里陪匹配。请注意，如果一个异常被捕获，else也被执行，catch/rescue 块的结果将传递给else。</p>
<p>else块的异常不被捕获。如果else块里的模式没有被匹配上，一个异常将被抛出，这个异常不被当前的 try/catch/rescue/after 块捕获。</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><span id="part-six">变量作用域</span></h1><p>重要的是要记住，定义在try/catch/rescue/after块内的变量不泄漏到外部环境。这是因为try块可能失败，并且变量可能在第一个地方没有被绑定。换句话说，下面的代码是无效的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; try <span class="keyword">do</span></div><div class="line">...&gt;   raise <span class="string">"fail"</span></div><div class="line">...&gt;   what_happened = <span class="symbol">:did_not_raise</span></div><div class="line">...&gt; rescue</div><div class="line">...&gt;   <span class="number">_</span> -&gt; what_happened = <span class="symbol">:rescued</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; what_happened</div><div class="line">** (RuntimeError) undefined <span class="symbol">function:</span> what_happened/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>相反，你可以存储try表达式的值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; what_happened =</div><div class="line">...&gt;   try <span class="keyword">do</span></div><div class="line">...&gt;     raise <span class="string">"fail"</span></div><div class="line">...&gt;     <span class="symbol">:did_not_raise</span></div><div class="line">...&gt;   rescue</div><div class="line">...&gt;     <span class="number">_</span> -&gt; <span class="symbol">:rescued</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">iex&gt; what_happened</div><div class="line"><span class="symbol">:rescued</span></div></pre></td></tr></table></figure>
<p>到此我们结束了try、catch 和 rescue的介绍。你将发现它们在Elixir里用得频率比在其他语言里少很多，虽然在一些库或某些特定的代码不“按规则”玩的情况下，它们用起来可能很方便。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/try-catch-and-rescue.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/try-catch-and-rescue.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;Throws&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;Exits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;After&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;Else&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;变量作用域&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Elixir有三种错误机制：errors，throws，和 exits 。本章我们将探索它们每一个，并且包括应该何时使用哪一个的评论。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="try catch rescue" scheme="http://szpzs.oschina.io/categories/Elixir/try-catch-rescue/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="try" scheme="http://szpzs.oschina.io/tags/try/"/>
    
      <category term="catch" scheme="http://szpzs.oschina.io/tags/catch/"/>
    
      <category term="rescue" scheme="http://szpzs.oschina.io/tags/rescue/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－印记</title>
    <link href="http://szpzs.oschina.io/2017/02/12/elixir-getting-started-sigils/"/>
    <id>http://szpzs.oschina.io/2017/02/12/elixir-getting-started-sigils/</id>
    <published>2017-02-12T01:44:02.000Z</published>
    <updated>2017-02-12T02:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">正则表达式</a></li>
<li><a href="#part-two">字符串、字符列表和词列表印记</a><br> 2.1 <a href="#part-two-one">字符串</a><br> 2.2 <a href="#part-two-two">字符列表</a><br> 2.3 <a href="#part-two-three">词列表</a></li>
<li><a href="#part-three">在印记中插入文本和转义字符</a></li>
<li><a href="#part-four">自定义印记</a></li>
</ol>
<p>我们已经学了Elixir提供双引号字符串和单引号字符列表。然而，这只是涵盖了该语言有文本表示的数据类型结构的表面。例如，原子主要就是通过 :atom 表示来创建的。</p>
<p>Elixir其中一个目标是可扩展性：开发者可以扩展该语言来解决任何特定的领域问题。计算机科学已经成为如此广阔的领域，一门语言解决许多领域的问题来作为它的核心部分是不太可能的。相反，我们最好的方法是使语言具有可扩展性，因此开发人员、公司和社区可以将语言扩展到相关领域。</p>
<p>本章，我们将探索印记，它是由Elixir这门语言提供的处理文本描述数据类型的其中一种机制。印记由波浪字符（~）开始，紧接着是一个字符（这个字符定义本印记），然后是一个分隔符，可选性的修饰符可以增加在最后的分隔符后。</p>
<a id="more"></a>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><span id="part-one">正则表达式</span></h1><p>Elixir里最常用的印记是~r，它被用来创建<a href="https://en.wikipedia.org/wiki/Regular_Expressions" target="_blank" rel="external">正则表达式</a>：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A regular expression that matches strings which contain "foo" or "bar":</span></div><div class="line">iex&gt; regex = ~r/foo|bar/</div><div class="line">~r/foo|bar/</div><div class="line">iex&gt; <span class="string">"foo"</span> =~ regex</div><div class="line"><span class="keyword">true</span></div><div class="line">iex&gt; <span class="string">"bat"</span> =~ regex</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<p>Elixir提供Perl兼容正则表达式（regexes），它由<a href="http://www.pcre.org/" target="_blank" rel="external">PCRE</a>库实现。regexes也支持修饰符。例如，i修饰符使得正则表达式不大小写敏感：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"HELLO"</span> =~ ~r/hello/</div><div class="line"><span class="keyword">false</span></div><div class="line">iex&gt; <span class="string">"HELLO"</span> =~ ~r/hello/i</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>请查阅<a href="https://hexdocs.pm/elixir/Regex.html" target="_blank" rel="external">Regex模块</a>获取正则表达式的其他修饰符和被支持的操作的信息。</p>
<p>到目前为止，所有例子都是用 / 来界定一个正则表达式。然后印记支持8种不同的分隔符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">~r/hello/</div><div class="line">~r|hello|</div><div class="line">~r<span class="string">"hello"</span></div><div class="line">~r<span class="string">'hello'</span></div><div class="line">~r(hello)</div><div class="line">~r[hello]</div><div class="line">~r&#123;hello&#125;</div><div class="line">~r&lt;hello&gt;</div></pre></td></tr></table></figure>
<p>支持不同分隔符背后的原因是提供一种不需要转义分隔符来写字面量。例如，一个有斜杠的正则表达式，这样写：~r(^https?://) 肯定比这么写 ~r/^https?:\/\/ 更容易读。相似地，如果正则表达式含有斜杠和捕获组（即使用()），那么你可以使用双引号来替代圆括号。</p>
<h1 id="字符串、字符列表和词列表印记"><a href="#字符串、字符列表和词列表印记" class="headerlink" title="字符串、字符列表和词列表印记"></a><span id="part-two">字符串、字符列表和词列表印记</span></h1><p>除了正则表达式，Elixir还有三种其他印记。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span id="part-two-one">字符串</span></h2><p>~s印记被用来创建字符串，像双引号一样。当一个字符串包含有双引号的时候，~s印记很有用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s(this is a string with <span class="string">"double"</span> quotes, <span class="keyword">not</span> <span class="string">'single'</span> ones)</div><div class="line"><span class="string">"this is a string with \"double\" quotes, not 'single' ones"</span></div></pre></td></tr></table></figure>
<h2 id="字符列表"><a href="#字符列表" class="headerlink" title="字符列表"></a><span id="part-two-two">字符列表</span></h2><p>~c印记被用来创建含有单引号的字符列表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~c(this is a char list containing <span class="string">'single quotes'</span>)</div><div class="line"><span class="string">'this is a char list containing \'single quotes\''</span></div></pre></td></tr></table></figure>
<h2 id="词列表"><a href="#词列表" class="headerlink" title="词列表"></a><span id="part-two-three">词列表</span></h2><p>~w印记被用来创建词列表（词就是普通字符串）。在~w印记里，词被空白分隔。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~w(foo bar bat)</div><div class="line">[<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"bat"</span>]</div></pre></td></tr></table></figure>
<p>~w印记也接收c， s 和 a 修饰符（分别对应，字符列表、字符串和原子），它们指定结果列表的元素的数据类型：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~w(foo bar bat)a</div><div class="line">[<span class="symbol">:foo</span>, <span class="symbol">:bar</span>, <span class="symbol">:bat</span>]</div></pre></td></tr></table></figure>
<h1 id="在印记中插入文本和转义字符"><a href="#在印记中插入文本和转义字符" class="headerlink" title="在印记中插入文本和转义字符"></a><span id="part-three">在印记中插入文本和转义字符</span></h1><p>除了小写印记，Elixir也支持大写印记来处理转义字符和插入文本。虽然 ~s 和 ~S 都返回字符串，但是前者允许转义码和插入文本，而后者则不允许：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s(String with escape codes \x26 <span class="comment">#&#123;"inter" &lt;&gt; "polation"&#125;)</span></div><div class="line"><span class="string">"String with escape codes &amp; interpolation"</span></div><div class="line">iex&gt; ~S(String without escape codes \x26 without <span class="comment">#&#123;interpolation&#125;)</span></div><div class="line"><span class="string">"String without escape codes \\x26 without \#&#123;interpolation&#125;"</span></div></pre></td></tr></table></figure>
<p>下面的转义码可以被用在字符串和字符列表里：</p>
<ul>
<li>\ - 单个反斜杠</li>
<li>\a - 铃声/警报</li>
<li>\b - 退格键</li>
<li>\d - 删除键</li>
<li>\e - 退出键</li>
<li>\f - 换页符</li>
<li>\n - 新行符</li>
<li>\r - 回车符</li>
<li>\s - 空格付</li>
<li>\t - Tab键</li>
<li>\v - 垂直Tab键</li>
<li>\0 - 空字节</li>
<li>\xDD - 用十六进制表示的单字节（比如：\x13）</li>
<li>\uDDDD 和 \u{D…} - 用十六进制表示的Unicode代码点（比如：\u{1F600}）</li>
</ul>
<p>另外，在双引号字符串里的双引号需要用\”来转义，类似的，单引号字符列表里的单引号需要用\’来转义。然而，向上述的例子那样改变分隔符而不是转义它们是一种更好的方式。</p>
<p>印记也支持 heredocs ，即 三个双或单引号作为分隔符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ~s<span class="string">""</span><span class="string">"</span></div><div class="line">...&gt; this is</div><div class="line">...&gt; a heredoc string</div><div class="line">...&gt; "<span class="string">""</span></div></pre></td></tr></table></figure>
<p>heredocs印记最常用的地方是在写文档的时候。例如，在文档里写转义字符很容易出错，因为需要两次转义一些字符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">Converts double-quotes to single-quotes.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; convert("\\\<span class="string">"foo\\\""</span>)</div><div class="line">    <span class="string">"'foo'"</span></div><div class="line"></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line">def convert(...)</div></pre></td></tr></table></figure>
<p>但是用~S，这个问题可以完全避免：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> ~S<span class="string">""</span><span class="string">"</span></div><div class="line">Converts double-quotes to single-quotes.</div><div class="line"></div><div class="line">## Examples</div><div class="line"></div><div class="line">    iex&gt; convert("\<span class="string">"foo\""</span>)</div><div class="line">    <span class="string">"'foo'"</span></div><div class="line"></div><div class="line"><span class="string">""</span><span class="string">"</span></div><div class="line">def convert(...)</div></pre></td></tr></table></figure>
<h1 id="自定义印记"><a href="#自定义印记" class="headerlink" title="自定义印记"></a><span id="part-four">自定义印记</span></h1><p>如本文开始的时候所提示，Elixir中的印记是一种扩展。实际上，用印记 ~r/foo/i 和以一个二进制数据和一个字符列表作为入参调用 sigil_r 是等效的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; sigil_r(&lt;&lt;<span class="string">"foo"</span>&gt;&gt;, <span class="string">'i'</span>)</div><div class="line">~r<span class="string">"foo"</span>i</div></pre></td></tr></table></figure>
<p>我们可以通过访问sigil_r文档来看看~r：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; h sigil_r</div><div class="line">...</div></pre></td></tr></table></figure>
<p>我们也可以通过遵循 sigil_{identifier} 模式来实现函数以提供我们自己的印记。例如，让我们来实现 ~i 印记，它返回一个整数（使用可选择的 n 修饰符来返回它的负数）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">MySigils</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sigil_i</span></span>(string, []), <span class="symbol">do:</span> String.to_integer(string)</div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">sigil_i</span></span>(string, [?n]), <span class="symbol">do:</span> -String.to_integer(string)</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">iex&gt; import MySigils</div><div class="line">iex&gt; ~i(<span class="number">13</span>)</div><div class="line"><span class="number">13</span></div><div class="line">iex&gt; ~i(<span class="number">42</span>)n</div><div class="line">-<span class="number">42</span></div></pre></td></tr></table></figure>
<p>印记也可以在宏的帮助下被用来做编译期工作。例如，Elixir里的正则表达式可以在源代码编译期间被编译为一个高效的描述，因此在运行期跳过这一步。如果你对这个主题有兴趣，我们建议你学习更多关于宏的知识，并查阅印记在Kernel模块（即形如sigil_*相关被定义的函数）里是如何实现的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/sigils.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/sigils.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;字符串、字符列表和词列表印记&lt;/a&gt;&lt;br&gt; 2.1 &lt;a href=&quot;#part-two-one&quot;&gt;字符串&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#part-two-two&quot;&gt;字符列表&lt;/a&gt;&lt;br&gt; 2.3 &lt;a href=&quot;#part-two-three&quot;&gt;词列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;在印记中插入文本和转义字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;自定义印记&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们已经学了Elixir提供双引号字符串和单引号字符列表。然而，这只是涵盖了该语言有文本表示的数据类型结构的表面。例如，原子主要就是通过 :atom 表示来创建的。&lt;/p&gt;
&lt;p&gt;Elixir其中一个目标是可扩展性：开发者可以扩展该语言来解决任何特定的领域问题。计算机科学已经成为如此广阔的领域，一门语言解决许多领域的问题来作为它的核心部分是不太可能的。相反，我们最好的方法是使语言具有可扩展性，因此开发人员、公司和社区可以将语言扩展到相关领域。&lt;/p&gt;
&lt;p&gt;本章，我们将探索印记，它是由Elixir这门语言提供的处理文本描述数据类型的其中一种机制。印记由波浪字符（~）开始，紧接着是一个字符（这个字符定义本印记），然后是一个分隔符，可选性的修饰符可以增加在最后的分隔符后。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="sigil" scheme="http://szpzs.oschina.io/categories/Elixir/sigil/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="sigil" scheme="http://szpzs.oschina.io/tags/sigil/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－速构</title>
    <link href="http://szpzs.oschina.io/2017/02/11/elixir-getting-started-comprehensions/"/>
    <id>http://szpzs.oschina.io/2017/02/11/elixir-getting-started-comprehensions/</id>
    <published>2017-02-11T12:59:06.000Z</published>
    <updated>2017-02-11T13:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">生成器和过滤器</a></li>
<li><a href="#part-two">位串生成器</a></li>
<li><a href="#part-three">:into选项</a></li>
</ol>
<p>在Elixir中，遍历一个枚举类型数据，过滤其中一些值并且将值映射到另一个列表里这种做法是很平常的。速构是对于这种数据结构的语法糖：Elixir里将这种语法组织成 for 的格式。</p>
<p>例如，我们可以将一个整数列表的每个值都求平方：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>一个速构有三部分组成：生成器、过滤器和收集动作。</p>
<a id="more"></a>
<h1 id="生成器和过滤器"><a href="#生成器和过滤器" class="headerlink" title="生成器和过滤器"></a><span id="part-one">生成器和过滤器</span></h1><p>上面的表达式中，n &lt;- [1, 2, 3, 4] 是<strong>生成器</strong>。它逐个生成在速构中被使用的值。任何枚举类型数据都可以置于生成器表达式的右边：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- <span class="number">1</span>..<span class="number">4</span>, <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>生成器表达式的左边也支持模式匹配；所有没有匹配到的数据被忽略。想象一下，我们用一个关键字列表而不是一个范围类型数据，键有 :good 和 :bad ，而我们只是想计算 :good 的值的平方：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; values = [<span class="symbol">good:</span> <span class="number">1</span>, <span class="symbol">good:</span> <span class="number">2</span>, <span class="symbol">bad:</span> <span class="number">3</span>, <span class="symbol">good:</span> <span class="number">4</span>]</div><div class="line">iex&gt; <span class="keyword">for</span> &#123;<span class="symbol">:good</span>, n&#125; &lt;- values, <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>除了生成器使用模式匹配，过滤器可以被用来选择一些特定的元素。例如，我们可以选择是3的倍数的值而丢弃其他的值：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; multiple_of_3? = <span class="keyword">fn</span>(n) -&gt; rem(n, <span class="number">3</span>) == <span class="number">0</span> <span class="keyword">end</span></div><div class="line">iex&gt; <span class="keyword">for</span> n &lt;- <span class="number">0</span>..<span class="number">5</span>, multiple_of_3?.(n), <span class="symbol">do:</span> n * n</div><div class="line">[<span class="number">0</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>速构丢弃所有过滤器返回false或者nil的元素，而选择其他元素。</p>
<p>速构通常提供比使用Enum 和 Stream模块里的函数更加简洁的描述。而且，速构也运行有多个生成器和过滤器。这里有一个例子，接收一个目录组成的列表，然后获得这些目录里每一个文件的大小：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dirs = [<span class="string">'/home/mikey'</span>, <span class="string">'/home/james'</span>]</div><div class="line"><span class="keyword">for</span> dir  &lt;- dirs,</div><div class="line">    file &lt;- File.ls!(dir),</div><div class="line">    path = Path.join(dir, file),</div><div class="line">    File.regular?(path) <span class="keyword">do</span></div><div class="line">  File.stat!(path).size</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>多生成器也可以被用来计算两个列表的笛卡儿积：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> i &lt;- [<span class="symbol">:a</span>, <span class="symbol">:b</span>, <span class="symbol">:c</span>], j &lt;- [<span class="number">1</span>, <span class="number">2</span>], <span class="symbol">do:</span>  &#123;i, j&#125;</div><div class="line">[<span class="symbol">a:</span> <span class="number">1</span>, <span class="symbol">a:</span> <span class="number">2</span>, <span class="symbol">b:</span> <span class="number">1</span>, <span class="symbol">b:</span> <span class="number">2</span>, <span class="symbol">c:</span> <span class="number">1</span>, <span class="symbol">c:</span> <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>一个更高级的多生成器和多过滤器的例子是毕达哥拉斯三元数组。一个毕达哥拉斯三元数组是满足形如 a<em>a + b</em>b = c*c 这样等式的一个正整数集合，让我们来写一个速构到名为triple.exs的文件里：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Triple</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pythagorean</span></span>(n) <span class="keyword">when</span> n &gt; <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> a &lt;- <span class="number">1</span>..n,</div><div class="line">        b &lt;- <span class="number">1</span>..n,</div><div class="line">        c &lt;- <span class="number">1</span>..n,</div><div class="line">        a + b + c &lt;= n,</div><div class="line">        a*a + b*b == c*c,</div><div class="line">        <span class="symbol">do:</span> &#123;a, b, c&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>接着在终端里运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex triple.exs</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; Triple.pythagorean(<span class="number">5</span>)</div><div class="line">[]</div><div class="line">iex&gt; Triple.pythagorean(<span class="number">12</span>)</div><div class="line">[&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;]</div><div class="line">iex&gt; Triple.pythagorean(<span class="number">48</span>)</div><div class="line">[&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">8</span>, <span class="number">6</span>, <span class="number">10</span>&#125;, &#123;<span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span>&#125;,</div><div class="line"> &#123;<span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>&#125;, &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">13</span>&#125;, &#123;<span class="number">12</span>, <span class="number">9</span>, <span class="number">15</span>&#125;, &#123;<span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>&#125;, &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">17</span>&#125;, &#123;<span class="number">16</span>, <span class="number">12</span>, <span class="number">20</span>&#125;]</div></pre></td></tr></table></figure>
<p>当输入值很大的时候，上面例子的代码是非常耗时的。另外，因为元组 {b, a, c} 和元组{a, b, c}表示的是相同的毕达哥拉斯三元数组，我们的函数产生了重复的结果。我们可以通过在后续的生成器里从前面的生成器引用变量来优化速构并排除重复的结果，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Triple</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pythagorean</span></span>(n) <span class="keyword">when</span> n &gt; <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> a &lt;- <span class="number">1</span>..n-<span class="number">2</span>,</div><div class="line">        b &lt;- a+<span class="number">1</span>..n-<span class="number">1</span>,</div><div class="line">        c &lt;- b+<span class="number">1</span>..n,</div><div class="line">        a + b + c &lt;= n,</div><div class="line">        a*a + b*b == c*c,</div><div class="line">        <span class="symbol">do:</span> &#123;a, b, c&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最后，要记住，速构里的，在生成器、过滤器或者内部代码块里赋值的变量，不会反映到速构外面去。</p>
<h1 id="位串生成器"><a href="#位串生成器" class="headerlink" title="位串生成器"></a><span id="part-two">位串生成器</span></h1><p>位串生成器也是被支持的，并且当你需要解析位串流的时候是非常有用的。下面的例子里，从一个二进制数据里接收一个由像素组成的列表，数据分别代表红、绿和蓝的值，然后将每个像素转换为三个元素的元组：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; pixels = &lt;&lt;<span class="number">213</span>, <span class="number">45</span>, <span class="number">132</span>, <span class="number">64</span>, <span class="number">76</span>, <span class="number">32</span>, <span class="number">76</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">234</span>, <span class="number">32</span>, <span class="number">15</span>&gt;&gt;</div><div class="line">iex&gt; <span class="keyword">for</span> &lt;&lt;<span class="symbol">r:</span><span class="symbol">:</span><span class="number">8</span>, <span class="symbol">g:</span><span class="symbol">:</span><span class="number">8</span>, <span class="symbol">b:</span><span class="symbol">:</span><span class="number">8</span> &lt;- pixels&gt;&gt;, <span class="symbol">do:</span> &#123;r, g, b&#125;</div><div class="line">[&#123;<span class="number">213</span>, <span class="number">45</span>, <span class="number">132</span>&#125;, &#123;<span class="number">64</span>, <span class="number">76</span>, <span class="number">32</span>&#125;, &#123;<span class="number">76</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">234</span>, <span class="number">32</span>, <span class="number">15</span>&#125;]</div></pre></td></tr></table></figure>
<p>位串生成器也可以和“常规的”枚举类型数据生成器混合使用，同时也支持过滤器。</p>
<h1 id="into选项"><a href="#into选项" class="headerlink" title=":into选项"></a><span id="part-three">:into选项</span></h1><p>上面所有的例子，所有的速构都是返回列表作为它们的结果。但是，通过传递 :into 选项给速构，则速构的结果可以被插入到不同的数据结构里。</p>
<p>例如，一个位串生成器可以使用 :into 选项来很容易地删除一个字符串里的所有空格：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> &lt;&lt;c &lt;- <span class="string">" hello world "</span>&gt;&gt;, c != ?\s, <span class="symbol">into:</span> <span class="string">""</span>, <span class="symbol">do:</span> &lt;&lt;c&gt;&gt;</div><div class="line"><span class="string">"helloworld"</span></div></pre></td></tr></table></figure>
<p>集合、映射和其他字典类型数据也可以赋给 :into 选项。总而言之，:into 接收任何实现了 Collectable 协议的数据结构。</p>
<p>:into常见用例是转换映射里的值，而不需要理会它的键：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">for</span> &#123;key, val&#125; &lt;- %&#123;<span class="string">"a"</span> =&gt; <span class="number">1</span>, <span class="string">"b"</span> =&gt; <span class="number">2</span>&#125;, <span class="symbol">into:</span> %&#123;&#125;, <span class="symbol">do:</span> &#123;key, val * val&#125;</div><div class="line">%&#123;<span class="string">"a"</span> =&gt; <span class="number">1</span>, <span class="string">"b"</span> =&gt; <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<p>让我们用流来做另一个例子。因为IO模块提供流（就是实现了Enumerable 和 Collectable 协议），那么一个回响终端，即无论输入的是什么都将其大写后返回的终端，可以使用速构来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; stream = IO.stream(<span class="symbol">:stdio</span>, <span class="symbol">:line</span>)</div><div class="line">iex&gt; <span class="keyword">for</span> line &lt;- stream, <span class="symbol">into:</span> stream <span class="keyword">do</span></div><div class="line">...&gt;   String.upcase(line) &lt;&gt; <span class="string">"\n"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，输入任何字符串到终端里，你将看到大写化后的相同字符串打印在终端里。不幸的是，这个例子也使得你的IEx停在速构里，所以你要按两次 Ctl+C来退出。：）</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/comprehensions.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/comprehensions.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;生成器和过滤器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;位串生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;:into选项&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Elixir中，遍历一个枚举类型数据，过滤其中一些值并且将值映射到另一个列表里这种做法是很平常的。速构是对于这种数据结构的语法糖：Elixir里将这种语法组织成 for 的格式。&lt;/p&gt;
&lt;p&gt;例如，我们可以将一个整数列表的每个值都求平方：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; n &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], &lt;span class=&quot;symbol&quot;&gt;do:&lt;/span&gt; n * n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个速构有三部分组成：生成器、过滤器和收集动作。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="comprehension" scheme="http://szpzs.oschina.io/categories/Elixir/comprehension/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="comprehension" scheme="http://szpzs.oschina.io/tags/comprehension/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－协议</title>
    <link href="http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/"/>
    <id>http://szpzs.oschina.io/2017/02/10/elixir-getting-started-protocols/</id>
    <published>2017-02-10T13:36:51.000Z</published>
    <updated>2017-02-10T13:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">协议和结构体</a></li>
<li><a href="#part-two">实现Any</a><br> 2.1. <a href="#part-two-one">派生</a><br> 2.3. <a href="#part-two-two">回退到Any</a></li>
<li><a href="#part-three">内建协议</a></li>
<li><a href="#part-four">协议整合</a></li>
</ol>
<p>协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。</p>
<p>在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。</p>
<p>虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。</p>
<a id="more"></a>
<p>协议的定义看起来像下面这样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">"Calculates the size (and not the length!) of a data structure"</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Size协议期望有一个接受一个入参（我们想要知道大小的数据结构）叫做size的函数被实现。我们现在可以为一些数据结构实现这个协议，这些数据结构应该有一个合适的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> BitString <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(string), <span class="symbol">do:</span> byte_size(string)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Map <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(map), <span class="symbol">do:</span> map_size(map)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Tuple <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(tuple), <span class="symbol">do:</span> tuple_size(tuple)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们没有为列表实现Size协议，因为列表没有预先计算好的“大小”信息，并且列表的长度必须要被计算出来（用 length/1）。</p>
<p>现在我们有了协议定义和实现，我们可以开始使用它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(<span class="string">"foo"</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; Size.size(&#123;<span class="symbol">:ok</span>, <span class="string">"hello"</span>&#125;)</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; Size.size(%&#123;<span class="symbol">label:</span> <span class="string">"some label"</span>&#125;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>传入一个没有实现协议的数据类型将会引起一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>为所有Elixir数据类型实现协议是可能的：</p>
<ul>
<li>Atom</li>
<li>BitString</li>
<li>Float</li>
<li>Function</li>
<li>Integer</li>
<li>List</li>
<li>Map</li>
<li>PID</li>
<li>Port</li>
<li>Reference</li>
<li>Tuple</li>
</ul>
<h1 id="协议和结构体"><a href="#协议和结构体" class="headerlink" title="协议和结构体"></a><span id="part-one">协议和结构体</span></h1><p>Elixir的可扩展性的能力来自当协议和结构一起使用时。</p>
<p>在上一章，我们已经学到，虽然结构体底层是映射，但是它没有和映射共享协议实现。例如，<a href="https://hexdocs.pm/elixir/MapSet.html" target="_blank" rel="external">MapSet</a> （基于映射的集合）被实现为结构体。让我们尝试应用Size协议于MapSet上：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; Size.size(%&#123;&#125;)</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; set = %MapSet&#123;&#125; = MapSet.new</div><div class="line"><span class="comment">#MapSet&lt;[]&gt;</span></div><div class="line">iex&gt; Size.size(set)</div><div class="line">** (Protocol.UndefinedError) protocol Size <span class="keyword">not</span> implemented <span class="keyword">for</span> <span class="comment">#MapSet&lt;[]&gt;</span></div></pre></td></tr></table></figure>
<p>结构体没有和映射共享协议实现，而是需要它自己的协议实现。因为MapSet有它自己的预先计算大小并且可以通过MapSet.size/1访问，我们可以为它定义一个Size协议的实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> MapSet <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(set), <span class="symbol">do:</span> MapSet.size(set)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果需要，你可以拿出你自己结构大小的语义。你不仅可以用结构体来构建更健壮的数据类型，比如像队列，而且可以为这个数据类型实现所有相关的协议，比如 Enumerable 和 可能的 Size。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">User</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> User <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(_user), <span class="symbol">do:</span> <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="实现Any"><a href="#实现Any" class="headerlink" title="实现Any"></a><span id="part-two">实现Any</span></h1><p>手工为所有类型实现协议可能很快就变得重复和单调乏味。在这种情况下，Elixir提供了两种选择：我们可以明确地为我们的类型派生协议的实现或自动为所有类型实现协议。在这两种情况下，我们需要为Any实现协议。</p>
<h2 id="派生"><a href="#派生" class="headerlink" title="派生"></a><span id="part-two-one">派生</span></h2><p>Elixir允许我们基于Any的实现派生一个协议实现。让我们先实现Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上述的实现可以说是不合理的。例如，说一个PID或一个整数的大小为零。</p>
<p>然而，我们应该很好地处理这个Any的实现。为了使用这个实现，我们应该需要告诉我们的结构体明确地派生于这个Size协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">OtherUser</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@derive</span> [Size]</div><div class="line">  defstruct [<span class="symbol">:name</span>, <span class="symbol">:age</span>]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当派生的时候，Elixir将基于为Any提供的实现为OtherUser实现Size协议。</p>
<h2 id="回退到Any"><a href="#回退到Any" class="headerlink" title="回退到Any"></a><span id="part-two-two">回退到Any</span></h2><p>当找不到实现的时候，对于 @derive 的另外一个选择就是明确地告诉协议退回到Any。这可以在协议定义里通过设置@fallback_to_any为true来实现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defprotocol</span> <span class="title">Size</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@fallback_to_any</span> <span class="keyword">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(data)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>正如我们在前一节所说，为Any所做的Size实现不能应用到所有数据类型。这就是为什么@fallback_to_any是一个可选项的原因之一。对于大多数协议来说，当没有实现的时候抛出一个错误是正确的行为。也就是说，假设像上一节一样我们已经实现了Any：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defimpl</span> <span class="title">Size</span></span>, <span class="symbol">for:</span> Any <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(<span class="number">_</span>), <span class="symbol">do:</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>那么现在所有数据类型（包括结构体），如果它没有实现Size协议，则被认为大小为0。</p>
<p>派生和回退到Any哪一个技术最好，这要依赖于使用场景。但是，Elixir开发者喜欢明确的而不是推断的。你可以看到许多库倾向于 @derive 方法。</p>
<h1 id="内建协议"><a href="#内建协议" class="headerlink" title="内建协议"></a><span id="part-three">内建协议</span></h1><p>Elixir内建了一些协议。前面的章节里，我们讨论过的Enum模块，它提供了许多函数处理任意数据结构，这个模块就实现了 Enumerable 协议：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; Enum.map [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">fn</span>(x) -&gt; x * <span class="number">2</span> <span class="keyword">end</span></div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div><div class="line">iex&gt; Enum.reduce <span class="number">1</span>..<span class="number">3</span>, <span class="number">0</span>, <span class="keyword">fn</span>(x, acc) -&gt; x + acc <span class="keyword">end</span></div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>另一个有用的例子是String.Chars协议，它指明如何用字符转换一个数据结构为一个字符串。它通过to_string函数暴露出来：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_string <span class="symbol">:hello</span></div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>注意到Elixir字符串插入是调用to_string函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"age: <span class="subst">#&#123;<span class="number">25</span>&#125;</span>"</span></div><div class="line"><span class="string">"age: 25"</span></div></pre></td></tr></table></figure>
<p>上面的例子可以正常运行是因为数字数据类型实现了String.Chars协议。如果传递一个元组，则会导致一个错误：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;tuple&#125;</span>"</span></div><div class="line">** (Protocol.UndefinedError) protocol String.Chars <span class="keyword">not</span> implemented <span class="keyword">for</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p>当需要“打印”一个更复杂的数据结构的时候，我们可以用基于Inspect协议的inspect函数：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"tuple: <span class="subst">#&#123;inspect tuple&#125;</span>"</span></div><div class="line"><span class="string">"tuple: &#123;1, 2, 3&#125;"</span></div></pre></td></tr></table></figure>
<p>Inspect协议被用来转换任何数据结构为一个易于阅读的文本。像IEx这样的工具就是用它来打印的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">iex&gt; %User&#123;&#125;</div><div class="line">%User&#123;<span class="symbol">name:</span> <span class="string">"john"</span>, <span class="symbol">age:</span> <span class="number">27</span>&#125;</div></pre></td></tr></table></figure>
<p>记住，按照惯例，每当被检查的价值以#开头，它是代表这是非有Elixir的语法的数据结构。这意味着inspect协议是不可逆的，因为以这种方式信息可能会丢失：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; inspect &amp;(&amp;<span class="number">1</span>+<span class="number">2</span>)</div><div class="line"><span class="string">"#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;"</span></div></pre></td></tr></table></figure>
<p>Elixir还有其他协议，不过本文讲最常用的这几个。</p>
<h1 id="协议整合"><a href="#协议整合" class="headerlink" title="协议整合"></a><span id="part-four">协议整合</span></h1><p>当处理Elixir项目的时候，使用Mix构建工具，你可以看到如下的输出：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Consolidated String.Chars</div><div class="line">Consolidated Collectable</div><div class="line">Consolidated List.Chars</div><div class="line">Consolidated IEx.Info</div><div class="line">Consolidated Enumerable</div><div class="line">Consolidated Inspect</div></pre></td></tr></table></figure>
<p>这些是Elixir自带的所有协议并且它们被整合。因为一个协议可以派发消息到任何数据类型，如果对于给定的类型的实现存在，则协议一定检查每一个调用。这可能非常消耗资源。</p>
<p>但是，在我们的项目使用像Mix这样的工具被编译后，我们知道所有被定义的模块，包括协议和他们的实现。用这个方法，协议可以被合并到一个非常简单快速的派发模块。</p>
<p>从Elixir v1.2开始，对于所有项目，协议合并都自动发生。我们将在<strong>Mix和OTP指引</strong>里构建我们的项目。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/protocols.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/protocols.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;协议和结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;实现Any&lt;/a&gt;&lt;br&gt; 2.1. &lt;a href=&quot;#part-two-one&quot;&gt;派生&lt;/a&gt;&lt;br&gt; 2.3. &lt;a href=&quot;#part-two-two&quot;&gt;回退到Any&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;内建协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;协议整合&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协议是Elixir里实现多态的一种机制。在一个协议上派发消息给任意数据类型是可行的，只要这个数据类型实现了这个协议。让我们看一个例子。&lt;/p&gt;
&lt;p&gt;在Elixir里，我们有两个动作来检查在一个数据结构里有多少个元素：length 和 size。length 意味着信息必需是被计算的。例如：length(list)需要遍历整个列表来计算它的长度。而另一方面，tuple_size(tuple) 和 byte_size(binary) 不依赖于元组和二进制数据的大小，因为在数据结构里大小的信息已经被预先计算了。&lt;/p&gt;
&lt;p&gt;虽然我们已经有Elixir内建的获取大小的指定类型函数（比如tuple_size/1），我们还是想实现一个通用的 Size 协议，然后所有数据结构只要它的大小是预先计算的，都可以实现这个协议。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/categories/Elixir/protocol/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="protocol" scheme="http://szpzs.oschina.io/tags/protocol/"/>
    
  </entry>
  
</feed>
