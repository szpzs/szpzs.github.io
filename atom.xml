<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2016-12-19T09:13:32.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Erlang里用进程保存状态</title>
    <link href="http://szpzs.oschina.io/2016/12/19/storing-state-in-erlang-with-processes/"/>
    <id>http://szpzs.oschina.io/2016/12/19/storing-state-in-erlang-with-processes/</id>
    <published>2016-12-19T08:57:00.000Z</published>
    <updated>2016-12-19T09:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>状态是我们如何使程序做不平凡的事情。如果我们正在写一个电子游戏，它的一个状态可能是一个被打败的坏人的数字。在大多数编程语言中，我们将通过将计数分配给变量，然后在每次新的坏人被击败时更新这个值来实现这一点。然而，一旦变量已经被赋值（单次赋值），Erlang不允许我们修改这个变量的值。那么如果我们不能够改变一个变量的值，我们如何在Erlang里跟踪状态？答案是：用进程。</p>
<a id="more"></a>
<h1 id="单次赋值"><a href="#单次赋值" class="headerlink" title="单次赋值"></a>单次赋值</h1><p>Erlang从单次赋值中获得很多的能力。单次赋值意味着，一旦一个值被赋予一个变量，则没有其他值可以被赋予这同一个变量。在许多Erlang的教程里你可以看到像如下一样的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; X = <span class="number">1</span>.</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; X = <span class="number">2</span>.</div><div class="line">** exception error: no match <span class="keyword">of</span> right hand side value <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在第一步，Erlang尝试用值1<a href="http://learnyousomeerlang.com/syntax-in-functions" target="_blank" rel="external">模式匹配</a>X。因为X没有被绑定，所以它被绑定到值1。从现在开始，当X在模式匹配操作符的左手边的时候，普通的模式匹配就会发生。这就是为什么我们在第二步得到一个错误 - Erlang尝试用值2去和已经有值为1的X匹配，因此引起一个无法匹配的错误。我们依然可以匹配X只要右手边相应的值是1，如下例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; X = <span class="number">1</span>.</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; &#123;X, <span class="number">2</span>&#125; = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;.</div><div class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>单次赋值是Erlang的一个非常棒的的优点，因为它减少了有<a href="http://en.wikipedia.org/wiki/Side_effect_computer_science" target="_blank" rel="external">副作用</a>的函数调用的可能。副作用使得写高并发的代码非常困难。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>在本文剩下的部分我们将使用一个计数器的例子。我的意思是通过一个计数器也就是一段简单的代码，它能够保持计数值，并提供一个API增值和（或）访问计数的值。这是一个关于状态的非常简单的例子；计数器的状态就是计数的值。</p>
<p>面向对象语言做这个例子非常简单，它很自然地存储状态到类实例的变量里。例如，用Ruby来实现一个简单的计数器，我们可能会像下面这样做：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ruby里一个简单面向对象计数器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @count = <span class="number">0</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">click</span></span></div><div class="line">    @count += <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">c = Counter.new</div><div class="line">c.click <span class="comment"># =&gt; <span class="doctag">@count</span> is now 1</span></div><div class="line">c.click <span class="comment"># =&gt; <span class="doctag">@count</span> is now 2</span></div></pre></td></tr></table></figure>
<p>@count是Counter类的一个实例变量。当我们通过调用Counter.new来创建Counter类的一个新实例的时候，在构造器（函数initialize）里@count被初始化为0。每次我们调用click方法，@count的值被增加一。@count持有计数器的状态。我们可以很容易地创建多个计数器，它们都有自己私有的状态。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c1 = Counter.new</div><div class="line">c2 = Counter.new</div><div class="line">c1.click <span class="comment"># =&gt; 1</span></div><div class="line">c1.click <span class="comment"># =&gt; 2</span></div><div class="line">c2.click <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<h1 id="递归和状态"><a href="#递归和状态" class="headerlink" title="递归和状态"></a>递归和状态</h1><p>那么我们如何在Erlang里保持状态呢？我们可以用递归来做到，通过从初始函数调用到下一个函数调用和后续的函数调用之间传递状态。如下有一个Erlang的计数器例子，每次递归函数调用的时候打印出递增的计数器值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% loop_counter.erl</span></div><div class="line"><span class="comment">% 一个递归循环计数器</span></div><div class="line"><span class="comment">% 基于当前进程，并且没有访问计数器的值</span></div><div class="line"><span class="keyword">-module</span><span class="params">(loop_counter)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([go/<span class="number">0</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">go</span><span class="params">()</span> -&gt;</span></div><div class="line">  go(<span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">go</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"N is ~p~n"</span>, [N]),</div><div class="line">  <span class="comment">% 只是为了不让我们的终端忙疯了。</span></div><div class="line">  timer:sleep(<span class="number">1000</span>),</div><div class="line">  go(N + <span class="number">1</span>).</div><div class="line"></div><div class="line"><span class="comment">%%% Erlang shell</span></div><div class="line"><span class="number">1</span>&gt; c(loop_counter).</div><div class="line">&#123;ok,loop_counter&#125;</div><div class="line"><span class="number">2</span>&gt; loop_counter:go().</div><div class="line">N is <span class="number">0</span></div><div class="line">N is <span class="number">1</span></div><div class="line">N is <span class="number">2</span></div><div class="line">N is <span class="number">3</span></div><div class="line"></div><div class="line">(hit Ctrl-c)</div><div class="line">BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded</div><div class="line">       (v)ersion (k)ill (D)b-tables (d)istribution</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用go/1函数的输入参数N来跟踪我们的状态，我们用N+1作为下一个调用的参数递归地调用相同函数来增加计数器值。事实上，我们能够增加这个值意味着我们正在跟踪计数器的状态。但是这个例子没有太多用处，因为递归调用循环完全占据当前的Erlang进程。</p>
<p>我们可以用 <a href="http://www.erlang.org/doc/man/erlang.html#spawn-1" target="_blank" rel="external">erlang:spawn/1</a> 将我们的计数器循环从主进程（我们的Erlang shell）分开。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(loop_counter).</div><div class="line">&#123;ok,loop_counter&#125;</div><div class="line"><span class="number">2</span>&gt; Pid = spawn(<span class="keyword">fun</span> loop_counter:go/<span class="number">0</span>).</div><div class="line">N is <span class="number">0</span></div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line">N is <span class="number">1</span></div><div class="line">N is <span class="number">2</span></div><div class="line">N is <span class="number">3</span></div><div class="line">N is <span class="number">4</span></div><div class="line"><span class="number">3</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>这样我们重新获取我们Erlang shell的控制权，但是现在我们无法控制计数器或者以编程方式获取它当前的值。</p>
<h1 id="用消息控制和查询状态"><a href="#用消息控制和查询状态" class="headerlink" title="用消息控制和查询状态"></a>用消息控制和查询状态</h1><p>在前面一节，我们创建了一个计数器，通过递归地调用自己来增加自己的值，但是我们无法控制计数器或者从外部代码访问它的状态。我们可以用消息来做到这点。如下的例子，增加一个click消息给我们的计数器。我们可以用click消息增加计数器的值，并且将修改后的值作为消息返回给调用的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% counter.erl</span></div><div class="line"><span class="comment">% 创建一个计数器循环来侦听click消息。</span></div><div class="line"><span class="keyword">-module</span><span class="params">(counter)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, click/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">% 创建一个计数器，返回pid</span></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></div><div class="line">  spawn(<span class="keyword">fun</span>() -&gt; loop(<span class="number">0</span>) <span class="keyword">end</span>).</div><div class="line"></div><div class="line"><span class="comment">% 递归循环，函数中用receive块接收消息。</span></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  <span class="keyword">receive</span></div><div class="line">    &#123;click, From&#125; -&gt;</div><div class="line">      From ! N + <span class="number">1</span>,</div><div class="line">      loop(N + <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% API函数。增值计数器，计数器的pid是入参给定的。</span></div><div class="line"><span class="function"><span class="title">click</span><span class="params">(Pid)</span> -&gt;</span></div><div class="line">  Pid ! &#123;click, self()&#125;,</div><div class="line">  <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">%%% in Erlang shell</span></div><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; counter:click(C).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; counter:click(C).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">5</span>&gt; counter:click(C).</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>当我们调用counter:new/0，这个函数创建一个新的递归循环，并用0初始化计数器的值，然后返回被创建进程的pid。循环函数立即进入receive块，在这里它无限期等待从任何其他进程发来的消息。我们设置它只监听一个消息：{click, From}，并要求From是调用进程的pid。</p>
<p>如下例子是从终端创建一个计数器进程并直接发送一个消息给它然后等待接收一个消息返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; C ! &#123;click, self()&#125;.</div><div class="line">&#123;click,&lt;<span class="number">0.32</span>.<span class="number">0</span>&gt;&#125;</div><div class="line"><span class="number">4</span>&gt; <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>上述这个例子显得有点笨拙。我们不想每次要增值计数器的时候都必须写消息调用和receive块；而且这样也不安全，因为这样做留下了很多犯错的空间。因此我们引入API函数counter:click/1（参阅上面的代码例子），它的入参是一个计数器的pid，它知道以正确的方式发送和接收一个click消息。</p>
<p>注意：我们在counter:click/1里用self/0来自动获取调用进程的pid。这种用法可以正常工作，因为counter:click/1是被调用进程调用的。如果我们在counter:loop/1函数里调用self/0，它将返回被创建进程的pid，而这个被创建的进程正在执行循环。</p>
<p>使用这个范例，通过创建多个进程来创建和控制多个计数器是很容易的。此外，API隐藏了大部分的底层实现细节，我们可以与计数器实例一起工作，而不必知道它们的值实际上是一个进程标识符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C1 = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; C2 = counter:new().</div><div class="line">&lt;<span class="number">0.41</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">4</span>&gt; counter:click(C1).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">5</span>&gt; counter:click(C1).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">6</span>&gt; counter:click(C2).</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们也可以修改循环函数来侦听一个set消息来允许我们手工设置计数器的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 增加一个消息处理器来设置计数器的值。</span></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  <span class="keyword">receive</span></div><div class="line">    &#123;click, From&#125; -&gt;</div><div class="line">      From ! N + <span class="number">1</span>,</div><div class="line">      loop(N + <span class="number">1</span>);</div><div class="line">    &#123;set, Value, From&#125; -&gt;</div><div class="line">      From ! ok,</div><div class="line">      loop(Value)</div><div class="line">  <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% API函数。依据给定的pid来设置计数器的值。</span></div><div class="line"><span class="function"><span class="title">set</span><span class="params">(Pid, Value)</span> -&gt;</span></div><div class="line">  Pid ! &#123;set, self(), Value&#125;,</div><div class="line">  <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="用于生产环境的gen-server"><a href="#用于生产环境的gen-server" class="headerlink" title="用于生产环境的gen_server"></a>用于生产环境的gen_server</h1><p>我们上述例子的计数器有许多潜在问题。当一个计数器进程收到一个意料之外的消息会发生什么？当系统很忙并且无法以及时的方式响应一个click消息的时候会发生什么？我们如何停止计数器并释放它正在使用的任何系统资源？当我们增加越来越多的消息的时候，代码也很快变得不可管理。</p>
<p>Erlang有一套<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id60128" target="_blank" rel="external">行为</a>接口用来解决当试图使用Erlang解决问题时普遍遇到的各种问题。这套模块被称为<a href="http://www.erlang.org/doc/design_principles/des_princ.html" target="_blank" rel="external">OTP</a>（正式称谓是“开放电信平台”，现在只是简单地叫做“OTP”）。</p>
<p>OTP的 <a href="http://www.erlang.org/doc/design_principles/gen_server_concepts.html" target="_blank" rel="external">gen_server</a> 行为被设计和实现出来就是为了用来实现一种设计模式，这种设计模式解决我们在本文已经遇到的问题。它以一种健壮和完整的方式实现一个有状态的被创建的进程行为，并且解决很多我们还没有考虑到的问题。</p>
<p>我不打算在这里深入研究OTP行为，因为本文的目的不是教你各种OTP行为或者正确的OTP设计。如果你想学习更多的细节，请看Erlang官方的 <a href="http://www.erlang.org/doc/man/gen_server.html" target="_blank" rel="external">gen_server 文档</a>以及《Learn You Some Erlang》的 <a href="http://learnyousomeerlang.com/clients-and-servers" target="_blank" rel="external">客户端和服务端</a> 章节。然而下面的例子将给你一个不错的主意，就是gen_server如何解决在Erlang里保持状态的问题。</p>
<p>如下就是一个用gen_server实现一个简单的计数器的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% counter_server.erl</span></div><div class="line"><span class="comment">% 简单计数器实现为一个gen_server</span></div><div class="line"><span class="keyword">-module</span><span class="params">(counter_server)</span>.</div><div class="line"><span class="keyword">-behavior</span><span class="params">(gen_server)</span>.</div><div class="line"></div><div class="line"><span class="comment">% API</span></div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, click/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">% gen_server需要的</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_call/<span class="number">3</span>, handle_cast/<span class="number">2</span>, handle_info/<span class="number">2</span>, terminate/<span class="number">2</span>, code_change/<span class="number">3</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%%% API 方法</span></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></div><div class="line">  gen_server:start(?MODULE, [], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">click</span><span class="params">(Pid)</span> -&gt;</span></div><div class="line">  gen_server:call(Pid, click).</div><div class="line"></div><div class="line"><span class="comment">%%% gen_server 回调</span></div><div class="line"><span class="comment">%%%   这些是实现gen_server行为所需要的</span></div><div class="line"><span class="comment">%%%   我们只是使用了 init 和 handle_call</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  <span class="comment">% 第二个值是初始化计数器的状态</span></div><div class="line">  &#123;ok, <span class="number">0</span>&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(click, _From, N)</span> -&gt;</span></div><div class="line">  <span class="comment">% 第二个值是消息回复的调用者</span></div><div class="line">  <span class="comment">% 第三个值是新状态</span></div><div class="line">  &#123;reply, N + <span class="number">1</span>, N + <span class="number">1</span>&#125;.</div><div class="line"></div><div class="line"><span class="comment">% 基本上，我们忽略这些函数，不过我们保持同样的计数器状态</span></div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, N)</span> -&gt;</span></div><div class="line">  &#123;noreply, N&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Msg, N)</span> -&gt;</span></div><div class="line">  &#123;noreply, N&#125;.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, N, _Other)</span> -&gt;</span></div><div class="line">  &#123;ok, N&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _N)</span> -&gt;</span></div><div class="line">  ok.</div><div class="line"></div><div class="line"><span class="comment">%%% Erlang console</span></div><div class="line"><span class="number">1</span>&gt; c(counter_server).</div><div class="line">&#123;ok,counter_server&#125;</div><div class="line"><span class="number">2</span>&gt; &#123;ok, C&#125; = counter_server:new().</div><div class="line">&#123;ok,&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;&#125;</div><div class="line"><span class="number">3</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">5</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>这个例子可能看起来像是解决一个简单问题用了很多代码，但是我们只是在这个框架里实现功能让我们获得非常大的灵活性。另外也有大量可用模版为你创建代码框架（在Emacs里，你可以从Erlang包里用 M-x tempo-template-erlang-generic-server 创建代码框架）。</p>
<p>作为一个例子，和上述例子一样增加一个set/2功能只是增加一个API函数和一个handle_call回调函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% API</span></div><div class="line"><span class="function"><span class="title">set</span><span class="params">(Value, Pid)</span> -&gt;</span></div><div class="line">  gen_server:call(Pid, &#123;set, Value&#125;).</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(&#123;set, Value&#125;, _From, _N)</span> -&gt;</span></div><div class="line">  &#123;reply, ok, Value&#125;;</div><div class="line"></div><div class="line"><span class="comment">% 来自上面的现有回调，供参考</span></div><div class="line"><span class="comment">%  (这两个函数分支在一起是为了模式匹配)</span></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(click, _From, N)</span> -&gt;</span></div><div class="line">  &#123;reply, N + <span class="number">1</span>, N + <span class="number">1</span>&#125;.</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这就是你从本文学到的。我们在Erlang里用进程保持状态跟踪，并且我们用消息访问和控制状态。在很多方面，Erlang的进程类似于其他语言中的类的实例。在许多其他方面，它们是非常不同的。在Erlang里解决问题要用不同的思考方式：用进程的概念来思考。一开始这可能很难理解，但是一旦你理解它了，许多问题以这种方式更容易解决。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://dantswain.herokuapp.com/blog/2014/09/27/storing-state-in-erlang-with-processes/" target="_blank" rel="external">http://dantswain.herokuapp.com/blog/2014/09/27/storing-state-in-erlang-with-processes/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态是我们如何使程序做不平凡的事情。如果我们正在写一个电子游戏，它的一个状态可能是一个被打败的坏人的数字。在大多数编程语言中，我们将通过将计数分配给变量，然后在每次新的坏人被击败时更新这个值来实现这一点。然而，一旦变量已经被赋值（单次赋值），Erlang不允许我们修改这个变量的值。那么如果我们不能够改变一个变量的值，我们如何在Erlang里跟踪状态？答案是：用进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Erlang/process/"/>
    
      <category term="state" scheme="http://szpzs.oschina.io/categories/Erlang/process/state/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
      <category term="state" scheme="http://szpzs.oschina.io/tags/state/"/>
    
      <category term="gen_server" scheme="http://szpzs.oschina.io/tags/gen-server/"/>
    
      <category term="behavior" scheme="http://szpzs.oschina.io/tags/behavior/"/>
    
  </entry>
  
  <entry>
    <title>BIF和NIF函数之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/18/eli5-bif-nif/"/>
    <id>http://szpzs.oschina.io/2016/12/18/eli5-bif-nif/</id>
    <published>2016-12-18T10:46:43.000Z</published>
    <updated>2016-12-18T10:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIF函数"><a href="#BIF函数" class="headerlink" title="BIF函数"></a>BIF函数</h1><p>除非你在Erlang/OTP的C源码上工作，你永远不需要创建自己的BIF函数。如果你想为你的项目实现自己的原生函数，请看下一节关于NIF的内容。</p>
<a id="more"></a>
<p>在Erlang的标准库里大多数的函数是用Erlang实现的。不过许多虚拟机的特性以及内部函数是不可能用纯Erlang语言来做到的。所以它们被用C语言来写并被导出为BIF，即内部构建函数。BIF被用作标准Erlang库，并且在编译的时候被静态地构建进Erlang虚拟机模拟器。</p>
<p>当阅读Erlang标准库的时候，你经常会看到一些函数会有一个调用是：erlang:nif_error(…)。这些是BIF的桩。BEAM装载器找到原生库并且使用对C语言的原生实现的引用来替换这些桩。你也可以用其他语言比如C++或Rust来创建BIF或NIF函数。你也可以在一个叫做bif.tab的特殊文件里注册一个新的BIF，当你构建Erlang虚拟机的模拟器的时候，这个文件串联起module:function名字和BIF的对应关系。</p>
<p>如果你好奇，你可以在Erlang/OTP的C源码中搜索一些函数，比如：erl_bif_lists.c里的lists_reverse_2。一个BIF函数接受进程指针和一个指向寄存器的指针，它可以访问它所需的许多<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">Term</a>（Eterm C 类型）寄存器。一个BIF必须返回一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">Term</a>值或者一个THE_NON_VALUE来针对特殊的执行控制功能，如trap，yield和异常。</p>
<h1 id="NIF函数"><a href="#NIF函数" class="headerlink" title="NIF函数"></a>NIF函数</h1><p>NIF是一种制作原生函数的不同方式，它更适合于分开编译和被用户模块装载。NIF接口和类型系统也是简化的，他们抽象并隐藏了Erlang虚拟机模拟器的许多内部类型、位和字段。</p>
<p>在官方标准文档里有很好的<a href="http://erlang.org/doc/tutorial/nif.html" target="_blank" rel="external">NIF教程</a>，并且大约有一百万个有用户写的以及在许多GitHub项目里可用的NIF函数。</p>
<p>就算它简化了，我们还是一定要小心 ！写得很糟糕的 NIF 是能够搞垮整个虚拟机或抢占资源和减慢执行速度。</p>
<blockquote>
<p>参见：<br>BEAM智慧：<a href="http://beam-wisdoms.clau.se/en/latest/interfacing.html" target="_blank" rel="external">Erlang与外部世界的接口</a>，针对一些NIF、交互库以及为不同语言提供的端口驱动器。</p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-bif-nif.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-bif-nif.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BIF函数&quot;&gt;&lt;a href=&quot;#BIF函数&quot; class=&quot;headerlink&quot; title=&quot;BIF函数&quot;&gt;&lt;/a&gt;BIF函数&lt;/h1&gt;&lt;p&gt;除非你在Erlang/OTP的C源码上工作，你永远不需要创建自己的BIF函数。如果你想为你的项目实现自己的原生函数，请看下一节关于NIF的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="BIF" scheme="http://szpzs.oschina.io/categories/Erlang/BIF/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/categories/Erlang/BIF/NIF/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="BIF" scheme="http://szpzs.oschina.io/tags/BIF/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/tags/NIF/"/>
    
  </entry>
  
  <entry>
    <title>跟踪之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/18/eli5-tracing/"/>
    <id>http://szpzs.oschina.io/2016/12/18/eli5-tracing/</id>
    <published>2016-12-18T01:12:29.000Z</published>
    <updated>2016-12-18T01:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang VM 如何跟踪函数调用、消息传递、进程的创建和结束？</p>
<a id="more"></a>
<p>跟踪是一种Erlang虚拟机模式，可以被打开和关闭。打开该模式会开始产生一个事件流。调用dbg:tracer()启动一个将接收这个事件流的进程。你可以创建你自己的跟踪器，它有自己的状态，然后给它输送事件。</p>
<p>跟踪能够产生大量不相关的数据。要限制这些不相关的数据，可以调用dbg:tp/4 （这一类函数）来产生一个跟踪过滤器。</p>
<p>当所有事情准备好了：一个跟踪器和一个过滤器，就可以开始打开开关接收事件了。一个对dbg:p/2（这一类函数）的调用设置跟踪目标（一个进程、一个端口、创建和退出事件、所有相关事件，诸如此类）。它将开始发送所有匹配跟踪目标和你给跟踪器进程设置的过滤器的事件。</p>
<h1 id="跟踪的内部运作"><a href="#跟踪的内部运作" class="headerlink" title="跟踪的内部运作"></a>跟踪的内部运作</h1><p>像进程生命周期事件或消息这样简单的事情在虚拟机的C代码中到处都有跟踪器检查。如果跟踪被开启，那么一条消息会发送给当前的跟踪器。</p>
<p>对BIF函数的调用和返回进行跟踪会更复杂。因为BIF不是真正的Erlang代码，它们必须以某种方式被包裹在跟踪代码里。这是通过用BIF的入口函数地址与另一个表替换BIF表来做到的。这个新表中的每个条目是一个简单的使用函数名称和参数来对erts_bif_trace函数的调用。这个函数执行真正的调用并且发送跟踪消息。</p>
<p>在某些时刻使用另一个技巧。在BIF结束前，特定的BEAM操作码被推送到栈上，它将发送跟踪事件。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-tracing.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-tracing.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang VM 如何跟踪函数调用、消息传递、进程的创建和结束？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="tracer" scheme="http://szpzs.oschina.io/categories/Erlang/tracer/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="tracer" scheme="http://szpzs.oschina.io/tags/tracer/"/>
    
  </entry>
  
  <entry>
    <title>输入/输出和端口之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/17/eli5-io/"/>
    <id>http://szpzs.oschina.io/2016/12/17/eli5-io/</id>
    <published>2016-12-17T14:38:54.000Z</published>
    <updated>2016-12-17T14:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>人们运行电脑程序的主要原因是因为有副作用。一个没有副作用的纯粹程序将消耗电力，温暖你的房间，除此之外别无他用。为了将程序连接到外部世界，每一种语言都有输入和输出的功能。例如：读写文件、访问硬件端口、或者与操作系统驱动器交互、在屏幕上描绘等等。</p>
<a id="more"></a>
<p>Erlang用端口来做到上述事情，端口是被叫做端口驱动器的小的C语言模块驱动。一些驱动是Erlang自带的，另一些则需要你自己创建或者请别人帮你创建。许多端口问题在GitHub上都有了解决方案（比如Unix管道）。</p>
<p>当你连接到一个资源开始使用它的时候，你收到的值是一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-port" target="_blank" rel="external">端口</a>。它的行为和进程相似：它消耗CPU时间来处理你的数据，你可以发消息给它，它也可以发消息给你。你可以连接或者监测一个端口（监测功能是从Erlang/OTP 19开始增加的）。</p>
<h1 id="端口任务"><a href="#端口任务" class="headerlink" title="端口任务"></a>端口任务</h1><p>每个端口和进程一样都是赋给一个调度器。每个CPU核上的调度器将会定期地检查赋予它的端口并且执行轮询和维护（这叫做运行端口任务）。这样就给端口驱动器分配CPU时间来执行实际的IO并且传递结果给正在等待的进程。</p>
<p>为了提高这个过程的效率并且为了从调度器分离出来端口任务，以便使得它们不影响主程序，异步线程被发明出来。虚拟机创建额外的线程，它们只有一个主要目标，就是服务IO任务。</p>
<p>异步线程的个数可以通过命令行标志 +A 正整数 来控制。默认是10个异步线程。</p>
<h1 id="端口驱动器"><a href="#端口驱动器" class="headerlink" title="端口驱动器"></a>端口驱动器</h1><p>一个C模块可以用名字的方式被注册成一个端口驱动器。你可以指定，当打开一个端口的时候，哪一个驱动器被调用。端口驱动器执行几个基本命令来打开端口、关闭端口、发送数据给端口或者从端口读取数据。例如，套接字接口、操作系统进程的创建，它们都是作为端口驱动器来实现的。</p>
<blockquote>
<p>参见：<br>技术细节：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-io.html" target="_blank" rel="external">Erlang的IO</a></p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-io.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-io.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人们运行电脑程序的主要原因是因为有副作用。一个没有副作用的纯粹程序将消耗电力，温暖你的房间，除此之外别无他用。为了将程序连接到外部世界，每一种语言都有输入和输出的功能。例如：读写文件、访问硬件端口、或者与操作系统驱动器交互、在屏幕上描绘等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="port" scheme="http://szpzs.oschina.io/categories/Erlang/port/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="input" scheme="http://szpzs.oschina.io/tags/input/"/>
    
      <category term="output" scheme="http://szpzs.oschina.io/tags/output/"/>
    
      <category term="port" scheme="http://szpzs.oschina.io/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>进程堆之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/16/eli5-process-heap/"/>
    <id>http://szpzs.oschina.io/2016/12/16/eli5-process-heap/</id>
    <published>2016-12-16T09:02:13.000Z</published>
    <updated>2016-12-16T13:13:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang里的每一个事物都是一个term。一个term是Erlang里的任何值。在Erlang内部，一个term是一个保留一些最少有效位（根据值的不同有效位从2到6不等）的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-word" target="_blank" rel="external">字</a>，这些有效位定义了它的类型。剩下的位包含它自己的值（比如<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>的值）或包含一个指向堆上数据（<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box" target="_blank" rel="external">box</a> 值）的指针。</p>
<a id="more"></a>
<p>一个进程的堆是一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。而进程的栈则是另一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。栈被分配在堆的里面。<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-registers" target="_blank" rel="external">寄存器</a>也是一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。堆上的数据大多数都是由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组，除了用<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-header" target="_blank" rel="external">头部标签</a>（详情参阅 <a href="http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html" target="_blank" rel="external">数据类型内存布局</a>）标记的数据。</p>
<h1 id="堆载体"><a href="#堆载体" class="headerlink" title="堆载体"></a>堆载体</h1><p>Erlang内的内存分配发生在所谓的“载体”内。它们看起来像游戏里使用的“区域内存”–事先分配的一大块系统堆。在载体内部，真正的内存分配在这里发生。至于它们是如何运作的，为简单起见你可以想象成简单的malloc/realloc。</p>
<p>克服内存碎片的复杂事情都被封装好了，并且不是我们要理解的重点。你可以看源码 erts/emulator/beam/erl_*alloc.c （有许多文件，每一个分配策略一个文件）。模拟器有命令行标志来控制分配策略（参阅 <a href="http://erlang.org/doc/man/erts_alloc.html" target="_blank" rel="external">http://erlang.org/doc/man/erts_alloc.html</a> 标志部分）。</p>
<h1 id="堆内的内存分配"><a href="#堆内的内存分配" class="headerlink" title="堆内的内存分配"></a>堆内的内存分配</h1><p>当一个进程需要一些内存，它的 heap_top 增大，堆顶下面的内存就准备好被使用。一些活动想在其他进程的堆上分配内存，例如发送一个消息将把一个消息的拷贝给接收进程。</p>
<p>在进程堆内部是没有记账本的。就是没有跟踪那一个字属于哪里，但是我们可能通过查看标签位是可以知道每一个内存单元存储了什么。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>垃圾回收跟踪从寄存器和栈知道的活数据并保存它们，然后将其他的数据都卸掉。</p>
<p>当一个堆达到它的容量阀值（比如75%），进程就触发垃圾回收。一个新的更大的堆可能被分配出来。扫描分代的垃圾回收算法运行在堆上。这个算法获取“<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-roots" target="_blank" rel="external">roots</a>”（垃圾回收期间，根是所有已知的活数据）并把它们移到新堆。然后扫描源堆的剩余部分，提取更多的值，由根引用。扫描后，源堆只剩下死数据接着算法把它们卸掉。</p>
<p>“扫描”的意思是，垃圾回收器将数据从头到尾过一遍，分析所有它遇到的数据。“分代的”的意思是，算法将数据分为新生代和老生代，并假设新数据经常是死掉的，老数据是不太可能被释放的。另外算法记住老的位置（成熟的），也就是上一次扫描结束的地方。这个位置下面的任何数据被保证自上次扫描以来有没有更新。这一招会减少扫描的量，并加速算法。</p>
<p>在现实中比较复杂一点。可能有一个或两个堆有不同的逻辑应用于它们。每一个进程都有自己的垃圾回收器这样就使得Erlang的垃圾回收延时低。另外它不会暂停或影响其他调度器上的其他进程。这不是一个简单的话题，不过原理都在这：<a href="http://gchandbook.org/" target="_blank" rel="external">http://gchandbook.org/</a></p>
<blockquote>
<p>另外请参阅<br>BEAM 智慧: 深层次知识: <a href="http://beam-wisdoms.clau.se/en/latest/indepth-heap-layout.html" target="_blank" rel="external">进程堆布局</a>。<br>BEAM Wisdoms: 深层次知识: <a href="http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html" target="_blank" rel="external">数据类型内存布局</a>。<br><a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html" target="_blank" rel="external">Erlang里的垃圾回收器</a></p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-process-heap.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-process-heap.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang里的每一个事物都是一个term。一个term是Erlang里的任何值。在Erlang内部，一个term是一个保留一些最少有效位（根据值的不同有效位从2到6不等）的&lt;a href=&quot;http://beam-wisdoms.clau.se/en/latest/definitions.html#def-word&quot;&gt;字&lt;/a&gt;，这些有效位定义了它的类型。剩下的位包含它自己的值（比如&lt;a href=&quot;http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed&quot;&gt;立即数&lt;/a&gt;的值）或包含一个指向堆上数据（&lt;a href=&quot;http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box&quot;&gt;box&lt;/a&gt; 值）的指针。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Erlang/process/"/>
    
      <category term="heap" scheme="http://szpzs.oschina.io/categories/Erlang/process/heap/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
      <category term="heap" scheme="http://szpzs.oschina.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>进程之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/15/eli5-processes/"/>
    <id>http://szpzs.oschina.io/2016/12/15/eli5-processes/</id>
    <published>2016-12-15T15:07:17.000Z</published>
    <updated>2016-12-15T15:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是进程如何组成的以及如何工作的高层次概述。</p>
<a id="more"></a>
<h1 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h1><p>一个进程就是一个简单的C语言结构，这个结构包含了一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-heap" target="_blank" rel="external">堆</a>，一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack" target="_blank" rel="external">栈</a>，一些<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-registers" target="_blank" rel="external">寄存器</a>，还有一个指令指针。也有一些异常处理、跟踪等额外字段。一个新的进程是以这个C语言结构创建的，创建的时候有一个最小尺寸的堆。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img src="/images/eli5-process-stack.png" style="border:0;"></p>
<p><a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack" target="_blank" rel="external">栈</a>是在新生代堆上一个内存数组，它被用来当作返回栈和变量的临时存储。栈从堆的尾部开始，向堆的首部增长。栈上的数据按<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack-frame" target="_blank" rel="external">栈帧</a>来组织。</p>
<p>当一个函数需要一些临时的内存，它在栈上分配几个字的空间，并在第0个字上设置一个特定的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cp" target="_blank" rel="external">CP</a>值。后续这个内存地址可以被当作返回地址，并且从这个内存内找到下一个栈帧从哪里开始。这个临时内存也可以被用来在递归调用的时候保存寄存器（这样会造成栈的增长）。</p>
<p>尾递归避免保存这些临时数据或者在递归前释放这些临时数据。它用更聪明的办法传递参数，这样就不需要在栈上保存参数从而不会使得栈增长。</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>每一个新进程都被赋予一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-scheduler" target="_blank" rel="external">调度器</a>。调度器从队列里取出一个进程并拿到该进程的指令指针。然后调度器执行一个指令接着进入重复执行指令的循环。在完成一定数量的工作（<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-reduction" target="_blank" rel="external">规约数</a>）后，调度器将把当前的进程放回队列然后从队列里选择另一个进程。这种机制使得一些类型的公平调度成为可能：每一个进程都可以得到CPU时间而不管队列中其他进程如何繁忙。</p>
<h1 id="杀死和退出"><a href="#杀死和退出" class="headerlink" title="杀死和退出"></a>杀死和退出</h1><p>杀死一个进程就像给它发送一个退出异常。进程从睡眠中醒来，获得CPU时间，然后发现一个异常。那么它将终止自己或者捕获这个异常并且像一个正常的消息一样进行处理。无条件杀死信号和异常很像，这是Erlang代码无法捕获它。</p>
<h1 id="调度和负载均衡"><a href="#调度和负载均衡" class="headerlink" title="调度和负载均衡"></a>调度和负载均衡</h1><p><img src="/images/eli5-process-sched.png" style="border:0;"></p>
<p>默认情况下BEAM虚拟机每个CPU核启动一个调度器。进程以某种方式（简单来说你可以认为是随机地）赋给调度器。你可以用标志 +S 和 +SP 来配置调度器。调度器可以用不同的方式（+sbt 标志）被绑定到CPU核。</p>
<p>有3种进程优先级：low、normal、high和max。处在max优先级的进程总是首先运行而其他进程一直等待。high优先级进程比normal优先级进程大约多8倍时间运行（这个倍数依赖于实现）。当没有其他工作可做的时候low优先级进程才运行。</p>
<p>在运行时，调度器和其他调度器（即在调度器数组中比它前一位的调度器）比较它们之间的进程队列。如果其他调度器的队列比它的长，调度器将从其他调度器的队列里偷一个或多个进程给自己的队列。这种默认行为是可以被改变的。负载均衡策略可以用虚拟机标志 +S 和 +scl 来配置。你可能想使用尽可能少的CPU核来让其他CPU核睡眠和节能。或者你更喜欢将进程平摊给各个CPU核从而减少时延。</p>
<p>偷进程就如将指针从一个数组移到另一个数组一样容易。当一个活动进程在CPU核间跳动的话，可能影响<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cache-locality" target="_blank" rel="external">缓存区</a>。</p>
<h1 id="进程注册"><a href="#进程注册" class="headerlink" title="进程注册"></a>进程注册</h1><p>一个全局进程表映射进程标识符（pid）到进程结构。要了解一个进程的pid，可以参阅它的Process.common.id字段。进程通过它本地的pid唯一标识。远程pid包含更多信息：一个节点名和内部节点id。远程pid必须在拥有它的节点上解析。</p>
<p>另一个全局表（进程注册）映射名字到pid。你可以用erlang:register、erlang:unregister和erlang:whereis 这些BIF来使用它。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><img src="/images/eli5-process-mqueue.png" style="border:0;"></p>
<p>消息被存储在堆上或者在堆段里，并且被用单链表串起来。消息队列是一个属于进程结构的C结构并且它包含了发给进程的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">数据项</a>。对于更大的或嵌套的数据则使用<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box" target="_blank" rel="external">Boxed data</a>，它被分配在堆上。存在一个队列位置的指针，它是先进的BEAM操作码，它用来扫描邮箱。当扫描指针到达邮箱的底部，进程将被置为接收消息状态。仅当一个消息被匹配了，指针才被复位到队列的首部。这就是为什么在一个大的邮箱队列中进行选择接收是缓慢的。</p>
<h1 id="发送一个消息"><a href="#发送一个消息" class="headerlink" title="发送一个消息"></a>发送一个消息</h1><p>发送一个消息给一个进程很简单。下面就是虚拟机的做法：</p>
<ol>
<li>锁上一个进程邮箱（如果运行在一个单核上就不需要）。</li>
<li>拷贝消息到目的进程的堆。</li>
<li>添加结果数据到进程邮箱。</li>
<li>解锁进程邮箱。</li>
<li>如果进程处在接收消息状态，它将回到调度队列并随时醒来处理消息。</li>
</ol>
<p>一个进程等待一个消息（用接收操作），直到消息到达它都不会被放入调度器运行队列等待执行。这就是为什么百万个空闲进程可以毫不费劲地同时存在于一个单机上。</p>
<h1 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h1><p>Traps是虚拟机循环的一个特性，它允许临时暂停长时间运行的BIF。状态被保存在临时内存区并且控制权回到调度器。进程设置它的指令指针到特定的trap指令并且BIF返回。</p>
<p>在trap期间，当前进程被放回进程队列，这就允许其他进程运行。当时机到来，虚拟机循环遇到trap指令，并且跳回到长时间运行BIF。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-processes.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-processes.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是进程如何组成的以及如何工作的高层次概述。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Erlang/process/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>Erlang垃圾回收细节以及它为何重要</title>
    <link href="http://szpzs.oschina.io/2016/12/13/erlang-garbage-collection-details-and-why-it-matters/"/>
    <id>http://szpzs.oschina.io/2016/12/13/erlang-garbage-collection-details-and-why-it-matters/</id>
    <published>2016-12-13T13:27:00.000Z</published>
    <updated>2016-12-13T13:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang尝试解决的一个主要问题就是为实现高水平响应的<a href="https://en.wikipedia.org/wiki/Real-time_computing" target="_blank" rel="external">软实时系统</a>创建一个平台。这样的系统需要快速的<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="external">垃圾回</a>收策略，这样就不会阻止系统以及时的方式进行响应。另外当我们认为Erlang是一门无破坏性修改特性的<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="external">不可改变</a>语言的时候，垃圾回收变得更重要，因为这样的语言有更高产生垃圾的几率。</p>
<a id="more"></a>
<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>在我们深入垃圾回收之前，了解Erlang进程的内存布局是很有必要的。Erlang进程的内存布局可以分为三个主要部分：进程控制块，栈和堆。这和Unix的进程布局非常像。</p>
<p><img src="/images/erlang-memory-layout.png" style="border:0;"></p>
<ul>
<li><strong>进程控制块</strong>：进程控制块持有进程的一些信息，诸如：它在进程表里的标识符（PID），当前状态（运行、等待），它的注册名字，初始化调用和当前调用；另外进程控制块还持有指向到达消息的指针，这些消息是<em>链接列表</em>的成员，它们存储在进程私有堆里。</li>
<li><strong>栈</strong>：它是一个向下增长的内存区域，它持有函数的进出参数，返回地址，本地变量以及计算表达式的临时空间。</li>
<li><strong>堆</strong>：它是一个向上增长的内存区域，它持有进程邮箱的实际消息，像<a href="http://www.erlang.org/doc/man/lists.html" target="_blank" rel="external">列表</a>和<a href="http://www.erlang.org/documentation/doc-5.8/doc/reference_manual/data_types.html" target="_blank" rel="external">元组</a>这样的复合数据，<a href="http://www.erlang.org/doc/man/binary.html" target="_blank" rel="external">二进制数据</a>，大于一个机器字的诸如浮点数对象。大于64字节的二进制数据不保存在进程私有堆里，这样的二进制数据叫做<em>Refc Binary</em>（引用计数二进制），它们存储在一个大<em>共享堆</em>，被那些有指向引用计数二进制数据指针的进程访问。那些指针叫做<em>ProcBin</em>并且存储在进程的私有堆里。</li>
</ul>
<h1 id="垃圾回收细节"><a href="#垃圾回收细节" class="headerlink" title="垃圾回收细节"></a>垃圾回收细节</h1><p>为了解释当前默认的Erlang垃圾回收机制，我们可以简单地说，一种是独立运行在每个Erlang进程私有堆内的分代复制垃圾回收，另一种是发生在全局共享堆的引用计数垃圾回收。</p>
<h2 id="私有堆垃圾回收"><a href="#私有堆垃圾回收" class="headerlink" title="私有堆垃圾回收"></a>私有堆垃圾回收</h2><p>私有堆的垃圾回收是分代的。分代垃圾回收将堆分成两个段：年轻代和老生代。分代的原理是：如果一个对象在一个垃圾回收周期存活下来，那么它短时间成为垃圾的机会就降低了。所以年轻代给新分配的数据使用，老生代给那些已经执行了指定次数的垃圾回收后还依然幸存下来的数据使用。这种分割为两个段的方式有助于垃圾回收减少在还没有变成垃圾的数据上进行不必要的垃圾回收过程。Erlang的垃圾回有两种策略：<em>分代的</em>（轻量级的）和<em>全扫描</em>（重量级的）。分代的垃圾回收只是回收年轻代堆，而全扫描垃圾回收则回收年轻代和老生的堆。现在让我们仔细看看一个新启动的Erlang进程在私有堆里的垃圾回收步骤：</p>
<p><strong>场景1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; No GC &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个短时存活的进程没有垃圾回收发生，它用的堆没有超过<em>min_heap_size</em>设置的值然后就终止了。在这个场景下，被进程使用的所有内存都被回收。</p>
<p><strong>场景2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个新创建的进程，它的数据增长超过<em>min_heap_size</em>设置的值，所以发生了一次全扫描垃圾回收，很明显因为在此之前从来没有发生过垃圾回收，所以就不存在年轻代和老生代两个段。在第一次全扫描垃圾回收后，堆被分割成年轻代和老生代，并且此后垃圾回收策略切换到分代的垃圾回收并且一直维持这种策略直到进程终止。</p>
<p><strong>场景3:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Generational &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在进程的生命周期里当垃圾回收策略从分代的垃圾回收再次切换到全扫描的垃圾回收的时候，这会有几种不同的情况。第一种情况是在一定数量的分代的垃圾回收发生后。这个一定的数量可以全局设置或者每个进程用<em>fullsweep_after</em>标志设置。每个进程的分代的垃圾回收次数统计和它切换到全扫描到垃圾回收前的分代的垃圾回收次数上限分别是进程的<em>minor_gcs</em>和<em>fullsweep_after</em>属性，同时这两个值可用<em>process_info(PID, garbage_collection)</em>的返回值来获得。第二种情况是分代的垃圾回收不能回收足够的内存的时候。最后一种情况是当<em>garbage_collection(PID)</em>函数被手工调用的时候。在这几种情况后，垃圾回收策略再次从全扫描的垃圾回收切换回分代的垃圾回收并且保持直到上述的情况发生。</p>
<p><strong>场景4:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Increase Heap &gt; Fullsweep &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在场景3里，如果第二次全扫描垃圾回收不能回收足够的内存，那么堆被增大，而垃圾回收策略再切换回全扫描垃圾回收，像一个新创建的进程一样。所有这四种场景可以反复发生。</p>
<p>那么现在的问题是，像Erlang这样的自动垃圾回收语言，上述这些知识为什么重要？首先这些知识能帮助你通过调优全局的或某个进程的垃圾回收的发生和策略来使得你的系统更快。其次从它的垃圾回收角度来开，我们可以理解使得Erlang成为一个软实时平台的主要原因之一。这是因为每一个进程都有它自己的私有堆和它自己的垃圾回收，因此每次在一个进程里垃圾回收发生只是让这个正在进行垃圾回收的进程停顿而不会停顿其他任何进程，这是一个软实时系统所需要的。</p>
<h2 id="共享堆垃圾回收"><a href="#共享堆垃圾回收" class="headerlink" title="共享堆垃圾回收"></a>共享堆垃圾回收</h2><p>共享堆垃圾回收是引用计数垃圾回收。每一个共享堆里的对象（Refc）都有一个引用它的计数器，这个计数器被其他对象（ProcBin）持有，而这个ProcBin对象存储在Erlang进程的私有堆里。如果一个对象的引用计数器的值变为0，这个对象变成不可访问，并且将被销毁。引用计数器方式的垃圾回收是如此的廉价而且帮助系统避免出现意外的长时间暂停同时促进了系统的响应。但是由于在设计你的参与者模式系统时不太熟悉的一些知名反模式可能会造成内存泄漏的麻烦。</p>
<ul>
<li>首先是当一个引用计数二进制数据被分割为子二进制数据。为了节省资源，子二进制数据并不是原二进制数据分割部分的新拷贝，而只是对这个分割部分的引用。然而除了原始二进制数据，这个子二进制数据的引用计数是一个新的引用，正如你能理解的，这将导致一个问题，原始二进制数据必须等它的子二进制数据被回收后才能回收。</li>
<li>另一个众所周知的问题是当有一类长期生存的中间件进程，它作为一个请求控制器或消息路由器来控制和传输大的引用计数二进制消息。因为这个进程和所有这些引用计数二进制数据关联，所以它们的计数器值就增加了。所以回收这些引用计数二进制数据依赖于回收所有的ProcBin对象，甚至包括这个中间件进程里的ProcBin对象。非常不幸的是，因为ProcBin只是一个指针，它非常廉价，以至于在这个中间件进程里要花很长时间才能遇到一次回收这个ProcBin对象。造成的结果就是，即使除了中间件进程外其他所有进程里的ProcBin对象都被回收了，引用计数二进制数据还是继续留存在共享堆里。</li>
</ul>
<p>共享堆很重要，因为它减少了进程间传递大二进制消息的IO开销。另外子二进制数据只是某个二进制数据的指针，所以它的创建是如此快速。但是按一般规律来说，为了更快而使用快捷方式是有代价的，代价就是要以某种方式好好设计你的系统不至于让你陷入到麻烦当中。另外针对引用计数二进制数据泄漏问题有一些著名的架构模式，这些在<a href="http://ferd.ca/" target="_blank" rel="external">Fred Hebert</a>的免费电子书 <a href="http://www.erlang-in-anger.com/" target="_blank" rel="external">Erlang in Anger</a> 里有详细的解释，我想我是没办法解释的比他更好。所以我强烈建议你读一下这本书。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>即使我们现在正在使用的语言，它像Erlang这样自己管理内存，但是也不能阻止我们去理解它是如何分配和回收内存的。不像<a href="https://golang.org/ref/mem" target="_blank" rel="external">Go语言内存模型文档</a>所建议的：“如果你必须读本文档剩下部分来理解你自己程序的行为，你就是太聪明了。不过别自作聪明。”，我相信我们必须足够聪明才能够使我们的系统更快更安全，有时候它不会发生除非我们更深地钻研挖进去理解它的本质。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/faq/academic.html" target="_blank" rel="external">Erlang的学时和历史疑问</a></li>
<li><a href="http://lampwww.epfl.ch/resources/lamp/teaching/advancedCompiler/2004/slides/ImplementationOfConcurrency_slides.pdf" target="_blank" rel="external">FPL和并发执行</a></li>
<li><a href="http://user.it.uu.se/~jesperw/publications/Wilhelmsson_lic.pdf" target="_blank" rel="external">消息传递并发的有效内存管理</a></li>
<li><a href="http://labouseur.com/courses/erlang/programming-parallel-with-erlang.pdf" target="_blank" rel="external">用Erlang编程并行世界</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang尝试解决的一个主要问题就是为实现高水平响应的&lt;a href=&quot;https://en.wikipedia.org/wiki/Real-time_computing&quot;&gt;软实时系统&lt;/a&gt;创建一个平台。这样的系统需要快速的&lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;垃圾回&lt;/a&gt;收策略，这样就不会阻止系统以及时的方式进行响应。另外当我们认为Erlang是一门无破坏性修改特性的&lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;不可改变&lt;/a&gt;语言的时候，垃圾回收变得更重要，因为这样的语言有更高产生垃圾的几率。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/categories/Erlang/GC/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Erlang调度器的细节以及它为何重要</title>
    <link href="http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/"/>
    <id>http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/</id>
    <published>2016-12-10T16:50:08.000Z</published>
    <updated>2016-12-10T16:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">Erlang垃圾回收细节以及它为何重要</a>》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。</p>
<a id="more"></a>
<h1 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度"></a>什么是调度</h1><p>通常来说，调度就是一种分派工作给工作者的机制。所谓的工作可能是一个算数运算、字符串处理或者数据抽取，而工作者是一些资源，比如像<a href="https://en.wikipedia.org/wiki/Green_threads" target="_blank" rel="external">Green Thread</a>这样虚拟的资源或者像<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Native Thread</a>这样的物理资源。调度器以一种方式执行调度活度，最大限度地提高吞吐量和公平性，最大限度地降低响应时间和延时。调度是像操作系统和虚拟机这样的多任务系统的重要组成部分，它被分为两种类型：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29" target="_blank" rel="external">抢占式</a>：一个抢占式调度器在执行的任务间进行上下文切换，它有权力抢占（中断）任务并且在不需要被抢占任务的配合下的稍后恢复执行它们。实现这样的功能是基于如下几个因素，比如：任务的优先级，时间切片或者规约数。</li>
<li><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="external">协作式</a>：一个协作式调度器需要任务协作来进行上下文切换。在这种方式下，调度器简单地让任务周期性地或者空闲地时候自愿地释放控制权，然后启动一个新的任务并且再一次等待它自愿地归还控制权。</li>
</ul>
<p>现在的问题是，哪一种调度机制适合软实时系统，也就是这个系统必须在指定的时间内响应。协作式调度系统不能满足软实时系统的要求，因为其运行的任务可能永远也不会返还控制权或者在规定时限后返还控制权。所以软实时系统通常采用抢占式调度。</p>
<h1 id="Erlang的调度"><a href="#Erlang的调度" class="headerlink" title="Erlang的调度"></a>Erlang的调度</h1><p>Erlang作为一个多任务软实时平台采用的就是抢占式调度。Erlang调度器的职责就是选择一个进程并执行它的代码。它也处理垃圾回收和内存管理。如何选择一个进程来执行是基于每个进程可配置的优先级，并且同一优先级的进程是轮询地被调度的。另外，执行中的进程被抢占的因素是基于自上次该进程被选中执行后一定数量的<strong>规约数</strong>而不管它的优先级如何。规约数是每个进程的一个计数器，一般每调用一次函数，它就加一。当一个进程的计数器达到最大规约数时，就会抢占进程和进行上下文切换。例如，在Erlang/OTP R12B 计数器的最大值是2000规约数。</p>
<p>Erlang的任务调度有很长的发展历史。它随着时间而改变。这些改变受Erlang的SMP（对称多处理器）特性的改变而被影响。</p>
<h2 id="R11B之前的调度"><a href="#R11B之前的调度" class="headerlink" title="R11B之前的调度"></a>R11B之前的调度</h2><p>在R11B之前，Eralng还不支持SMP，因此它只有一个调度器运行在操作系统主进程的线程里，并且相应的只有一个<strong>运行队列</strong>。调度器从运行队列选择可运行的Erlang进程和IO任务来执行。</p>
<p><img src="/images/scheduling-before-r11b.png" style="border:0;"></p>
<p>这种方式不需要锁数据结构，但是这么写的应用无法利用并行的好处。</p>
<h2 id="R11B和R12B的调度"><a href="#R11B和R12B的调度" class="headerlink" title="R11B和R12B的调度"></a>R11B和R12B的调度</h2><p>SMP支持被加入Erlang虚拟机里，所以它可以有1到1024个运行在操作系统进程的线程里的调度器。然而，这个版本的调度器只能从一个共用运行队列里选取可执行任务。</p>
<p><img src="/images/scheduling-in-r11b-and-r12b.png" style="border:0;"></p>
<p>由于这种方式造成并行，使得所有共享数据结构都要用锁保护起来。例如运行队列本身就是一个必须被保护起来的共享数据结构。虽热锁会造成一些性能损失，但是新的调度器在多核处理器上带来的性能提升还是很可观的。</p>
<p>在这个版本里的一些瓶颈如下：</p>
<ul>
<li>当调度器增加后，共用运行队列成为瓶颈。</li>
<li>增加ETS表相关的锁，同时也影响到Mnesia。</li>
<li>当许多进程同时给一个进程发送消息的时候增加锁的冲突。</li>
<li>一个进程等待获取一个锁的时候会阻塞它的调度器。</li>
</ul>
<p>然而，每一个调度器分配一个运行队列的方案在下一个版本被选择来解决这些瓶颈。</p>
<h2 id="R13B后的调度"><a href="#R13B后的调度" class="headerlink" title="R13B后的调度"></a>R13B后的调度</h2><p>在这个版本，每个调度器有它自己的运行队列。在多核多调度器的系统里，这将减少锁冲突数量并且提升系统整体性能。</p>
<p><img src="/images/scheduling-after-r13b.png" style="border:0;"></p>
<p>这种方式在访问运行队列时锁冲突解决了，不过却引入了一些新问题：</p>
<ul>
<li>如何在运行队列中分配任务做到公平？</li>
<li>如果一个调度器被分配了过多的任务而另外的调度器却很清闲，这个问题如何解决？</li>
<li>基于什么样的命令一个调度器可以从一个过载的调度器偷任务？</li>
<li>要是我们启动了很多调度器，但是却很少任务，如何处理？</li>
</ul>
<p>这些问题使得Erlang开发团队引入一个概念使得调度公平和高效，这个概念就是<strong>迁移逻辑</strong>。它尝试在基于从系统收集来的统计数据上控制和平衡运行队列。</p>
<p>然而我们不应该让我们的调度一直维持现状，因为它很可能在将来的版本变得更好。</p>
<h1 id="控制和监督API"><a href="#控制和监督API" class="headerlink" title="控制和监督API"></a>控制和监督API</h1><p>有一些Erlang模拟器启动标志和一些内部控制和监督函数与调度器行为有关。</p>
<h2 id="调度线程"><a href="#调度线程" class="headerlink" title="调度线程"></a>调度线程</h2><p>当用erl启动脚本启动Erlang模拟器的时候，可以通过给+S标志传递两个用冒号分割的数字来指定最大可用调度线程数和在线调度线程数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S MaxAvailableSchedulers:OnlineSchedulers</div></pre></td></tr></table></figure>
<p>最大可用调度线程数只能在启动的时候指定而且在运行时是固定不变的，但是在线调度线程数可以在启动和运行时被指定和修改。例如我们可以在启动一个模拟器的时候指定16个最大调度线程和8个在线调度线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S 16:8</div></pre></td></tr></table></figure>
<p>然后在shell里在线调度线程可以被修改，如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; erlang:system_info(schedulers). <span class="comment">%% =&gt; returns 16</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_flag(schedulers_online, <span class="number">16</span>). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 16</span></div></pre></td></tr></table></figure>
<p>另外，使用+SP标志可以用百分比的方式设置这两个值。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>如前所述调度器基于进程的优先级来选择它们来执行。优先级可以在进程内通过调用erlang:process_flag/2函数来设置。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PID = spawn(<span class="keyword">fun</span>() -&gt;</div><div class="line">   <span class="comment">%% ...</span></div><div class="line">   <span class="keyword">end</span>).</div></pre></td></tr></table></figure>
<p>优先级可以是 low、normal、high、max 这些原子中的任何一个。默认优先级是normal，max优先级是保留给Erlang运行时内部使用不应被一般进程使用。</p>
<h2 id="运行队列统计"><a href="#运行队列统计" class="headerlink" title="运行队列统计"></a>运行队列统计</h2><p>如前所述运行队列持有准备好执行但未被调度器选中执行的进程。可以通过调用erlang:statistics(run_queue)获取在所有可用运行队列已经准备好可运行的进程数。作为一个真实例子，让我启动Erlang模拟器，给它4个在线调度器，并且给它们10个非常消耗CPU的并发进程。这些进程<a href="https://gist.github.com/hamidreza-s/9e3ed289f65759048875" target="_blank" rel="external">计算一个很大数字的素数</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%% 就绪</span></div><div class="line">&gt; erlang:statistics(online_schedulers). <span class="comment">%% =&gt; 4</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div><div class="line"></div><div class="line"><span class="comment">%% 并发创建10个重型进程</span></div><div class="line">&gt; [spawn(<span class="keyword">fun</span>() -&gt; calc:prime_numbers(<span class="number">10000000</span>) <span class="keyword">end</span>) || _ &lt;- lists:seq(<span class="number">1</span>, <span class="number">10</span>)].</div><div class="line"></div><div class="line"><span class="comment">%% 运行队列中还有任务要做</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 8</span></div><div class="line"></div><div class="line"><span class="comment">%% Erlang shell依然可以响应，非常棒！</span></div><div class="line">&gt; calc:prime_numbers(<span class="number">10</span>). <span class="comment">%% =&gt; [2, 3, 5, 7]</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 4</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div></pre></td></tr></table></figure>
<p>因为并发进程数大于在线调度器，这将花些时间让调度器执行运行队列里的进程并最终清空运行队列。有趣的是，创建了这些重型进程后，Erlang模拟器任然因为它的抢占式调度可以响应其他请求。Erlang的抢占式调度不会让这些重型进程消耗掉所有运行时，其他轻量并且重要的进程也可以被执行，这个特性在实现一个软实时系统的时候是非常棒的。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>虽然实现一个抢占式调度系统可能很复杂，但是在Erlang里这些不是开发者的责任，因为抢占式调度特性已经在Erlang虚拟机里。另一方面，当在一个软实时系统里系统以高水平的公平性和即时的响应需要扩展到所有处理资源的时候，跟踪、平衡、执行、迁移和抢占进程这些额外的处理成本是完全可负担的。顺便值得一提的是，完全抢占式调度是几乎所有操作系统都支持的特性，但在高层次的平台，语言或库里，Erlang虚拟机几乎是唯一完全抢占式调度的，因为JVM依赖于操作系统的调度器，CAF这个C++ actor库用协作式调度，Go也不是完全抢占式调度，还有诸如Python的Twisted，Ruby的Event Machine和Nodejs也不是完全抢占式调度的。这并不意味着对于所有的挑战这都是最好的选择，而是说我们如果要实现一个低延时的软实时系统，Erlang是一个好的选择。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/doc/man/erl.html" target="_blank" rel="external">erl脚本官方文档</a></li>
<li><a href="http://erlang.org/doc/man/erlang.html" target="_blank" rel="external">erlang模块官方文档</a></li>
<li><a href="http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html" target="_blank" rel="external">Erlang如何调度</a></li>
<li><a href="http://www.erlang.org/euc/08/euc_smp.pdf" target="_blank" rel="external">深入Erlang虚拟机</a></li>
<li><a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html" target="_blank" rel="external">Erlang调度器：它是如何工作的</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《&lt;a href=&quot;https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html&quot;&gt;Erlang垃圾回收细节以及它为何重要&lt;/a&gt;》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Scheduler" scheme="http://szpzs.oschina.io/categories/Erlang/Scheduler/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Scheduler" scheme="http://szpzs.oschina.io/tags/Scheduler/"/>
    
  </entry>
  
  <entry>
    <title>用Rebar3热更新Erlang代码</title>
    <link href="http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/"/>
    <id>http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/</id>
    <published>2016-12-09T13:16:16.000Z</published>
    <updated>2016-12-09T13:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：</p>
<blockquote>
<p>代码热更新就是一门给正在飞奔的汽车换引擎的艺术。</p>
</blockquote>
<p>简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。</p>
<a id="more"></a>
<p>我们将创建一个样例项目，然后学习如何来做代码热更新。这个项目的代码我已经放在<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">这里</a>。让我们用rebar3来创建一个模版项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new release nine9s</div></pre></td></tr></table></figure>
<p>现在我们在我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config" target="_blank" rel="external">rebar.config</a>文件里增加cowboy和lager为依赖。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [</div><div class="line">	&#123;lager, &#123;git, <span class="string">"git://github.com/basho/lager.git"</span>, &#123;tag, <span class="string">"2.1.1"</span>&#125;&#125;&#125;,</div><div class="line">	&#123;cowboy, &#123;git, <span class="string">"https://github.com/ninenines/cowboy.git"</span>, &#123;tag, <span class="string">"2.0.0-pre.1"</span>&#125;&#125;&#125;</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>为了更加真实的体验，请按如下修改我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config#L14-L15" target="_blank" rel="external">rebar.config</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;relx, [</div><div class="line">		&#123;release, &#123;'nine9s', <span class="string">"0.1.0"</span>&#125;, ['nine9s', sasl]&#125;,</div><div class="line">		&#123;sys_config, <span class="string">"./config/sys.config"</span>&#125;,</div><div class="line">		&#123;vm_args, <span class="string">"./config/vm.args"</span>&#125;,</div><div class="line">		&#123;dev_mode, false&#125;,</div><div class="line">		&#123;include_erts, true&#125;,</div><div class="line">		&#123;extended_start_script, true&#125;</div><div class="line">	]</div><div class="line">&#125;.</div></pre></td></tr></table></figure>
<p>你可能想知道这个“nine9s”应用将会做些什么？我的想法是先让这个应用做成一个hello world的web服务，然后再热更新它的代码。修改你的nine9s_app.erl文件以便让start/2看起来像下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line"> Dispatch = cowboy_router:compile(</div><div class="line">                                  [&#123;‘_’, [</div><div class="line">                                          &#123;“/”, default_handler, []&#125;</div><div class="line">                                         ]&#125;</div><div class="line">                                  ]),</div><div class="line"> &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line"> [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line"> ‘nine9s_sup’:start_link().</div></pre></td></tr></table></figure>
<p>现在我们创建一个模块，它叫做default_handler.erl。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-module(default_handler).</div><div class="line">-export([init/2]).</div><div class="line">init(Req, Opts) -&gt;</div><div class="line">    Req2 = cowboy_req:reply(200, [ &#123;&lt;&lt;”content-type"&gt;&gt;,</div><div class="line">                                    &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                            &lt;&lt;”Hello world!”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>接下来，我们编译并运行这个应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile &amp;&amp; rebar3 release</div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 console</div></pre></td></tr></table></figure>
<p>现在你已经运行了你的应用，你可以浏览<a href="http://localhost:9090" target="_blank" rel="external">http://localhost:9090</a>来验证一下。请保持这个应用一直运行，因为我们将创建这个应用的一个新版本并且尝试在线进行代码热更新。</p>
<p>上述代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0分支</a>里。</p>
<p>我们开始添加一些新的特性到我们的项目里，这样将形成我们项目的0.2.0版本，然后我们将尝试在运行着的0.1.0版本上在线进行代码热更新。版本0.2.0的代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0分支</a>。</p>
<p>我们想统计我们的default_handler已经响应的请求数。这个很好解决，我们创建一个模块<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/state_handler.erl" target="_blank" rel="external">state_handler.erl</a>，它是一个gen_server，它将存储default_handler.erl被调用的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(state_handler)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"><span class="comment">%% API functions</span></div><div class="line"><span class="keyword">-export</span><span class="params">([hello_world/<span class="number">0</span>,</span></div><div class="line">         get_hello_world_count/<span class="number">0</span>,</div><div class="line">         start_link/<span class="number">0</span>]).</div><div class="line"><span class="comment">%% gen_server callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>,</span></div><div class="line">         handle_call/<span class="number">3</span>,</div><div class="line">         handle_cast/<span class="number">2</span>,</div><div class="line">         handle_info/<span class="number">2</span>,</div><div class="line">         terminate/<span class="number">2</span>,</div><div class="line">         code_change/<span class="number">3</span>]).</div><div class="line"><span class="keyword">-record</span><span class="params">(state, &#123;count = <span class="number">0</span>&#125;)</span>.</div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="comment">%%% API functions</span></div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="function"><span class="title">hello_world</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:cast(?MODULE, hello_world).</div><div class="line"><span class="function"><span class="title">get_hello_world_count</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:call(?MODULE, hello_world_count).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:start_link(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="comment">%%% callback functions</span></div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    &#123;ok, #state&#123;&#125;&#125;.</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(hello_world_count, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, State#state.count, State&#125;;</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    Reply = ok,</div><div class="line">    &#123;reply, Reply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(hello_world, State)</span> -&gt;</span></div><div class="line">    Count = State#state.count,</div><div class="line">    &#123;noreply, State#state&#123;count = Count + <span class="number">1</span>&#125;&#125;;</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>我们修改我们的<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/default_handler.erl" target="_blank" rel="external">default_handler.erl</a>，以便每次它接收到请求的时候就通知state_handler。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(default_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    state_handler:hello_world(),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         &lt;&lt;”Hello world <span class="number">2</span> !”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>我们的state_handler将是<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_sup.erl" target="_blank" rel="external">nine9s_sup</a>监督者下的一个工作进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_sup’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(CHILD(Id, Mod, Args, Restart, Type)</span>, &#123;Id, &#123;Mod, start_link, Args&#125;, Restart, 60000, Type, [Mod]&#125;).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?SERVER&#125;, ?MODULE, []).</div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    State_Handler = ?CHILD(state_handler, state_handler, [], transient, worker),</div><div class="line">    &#123;ok, &#123; &#123;one_for_all, <span class="number">0</span>, <span class="number">1</span>&#125;, [State_Handler]&#125; &#125;.</div></pre></td></tr></table></figure>
<p>既然我们已经记录了default_handler的访问次数，我们就想有一个cowboy的路由来给出当前的访问次数，所以我们修改<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_app.erl" target="_blank" rel="external">nine9s_sup.erl</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_app’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(application)</span>.</div><div class="line"><span class="comment">%% Application callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">2</span></span></div><div class="line">         ,stop/<span class="number">1</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([set_routes_new/<span class="number">0</span></span></div><div class="line">        ,set_routes_old/<span class="number">0</span> ]).</div><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line">    Dispatch = cowboy_router:compile([&#123;‘_’, get_new_routes()&#125;]),</div><div class="line">    &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line">    [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line">    ‘nine9s_sup’:start_link().</div><div class="line"><span class="function"><span class="title">stop</span><span class="params">(_State)</span> -&gt;</span> ok.</div><div class="line"><span class="function"><span class="title">get_new_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/count”, count_handler, []&#125;] ++ get_old_routes().</div><div class="line"><span class="function"><span class="title">get_old_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/”, default_handler, []&#125;].</div><div class="line"><span class="function"><span class="title">set_routes_new</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_new_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div><div class="line"><span class="function"><span class="title">set_routes_old</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_old_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div></pre></td></tr></table></figure>
<p>请注意，我们把路由分成两部分，一部分是版本0.1.0里就有的，也就是老路由，还有一部分就是新路由。函数set_routes_new/0和set_routes_old/0我们将在后面解释。</p>
<p>下述代码是count_handler模块，就是处理路由 “/count”的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(count_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    Count = state_handler:get_hello_world_count(),</div><div class="line">    BCount = integer_to_binary(Count),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         BCount, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>最后，我们将修改在<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s.app.src#L3" target="_blank" rel="external">nine9s.app.src</a>和<a href="https://github.com/kansi/nine9s/blob/0.2.0/rebar.config#L7" target="_blank" rel="external">rebar.config</a>里的版本数字。版本0.2.0的特性就完成了。现在我们将尝试将正在运行的0.1.0版本升级到版本0.2.0。</p>
<p>为了升级到新的版本，我们需要创建一个appup文件，也就是nine9s.app.src文件，它描述了如何从版本0.1.0升级到0.2.0。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"vsn in app.src"</span>,</div><div class="line">    [ &#123;<span class="string">"upgrade from vsn"</span>, Instructions1&#125;],</div><div class="line">    [ &#123;<span class="string">"downgrade to vsn"</span>, Instructions2&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>appup文件是一个三元素组成的元组文件。第一个元素是和.app.src文件里一样的版本号（也就是当前版本）。第二个元素是一个元组列表，它的第一个元素是将要被升级的版本号，它的第二个元素是一些指令组成的列表，这些指令指示该如何从这个版本升级到新的版本。第三个元素也是一个元组列表，它的第一个元素是将要降级到的版本号，它的第二个元素是也是一些指令组成的列表，这些指令指示该如何降级到这个版本。</p>
<p>下面是应用nine9s的appup文件内容：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;“<span class="number">0.2</span>.<span class="number">0</span>”,</div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;add_module, state_handler&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, restart_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;add_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_new, [] &#125;&#125; ] &#125;],</div><div class="line"></div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, terminate_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, delete_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;delete_module, state_handler&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_old, [] &#125;&#125;</div><div class="line">             ,&#123;delete_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ]</div><div class="line">&#125;]&#125;.</div></pre></td></tr></table></figure></p>
<p>现在我们先来解释一下升级指令。注意：这些指令是按它们在文件中的先后顺序来执行的。</p>
<ul>
<li>{add_module, state_handler} : 指示增加state_handler模块到运行环境里。</li>
<li>{update, nine9s, supervisor} : 这条指令将修改监督者的内部状态，也就是改变重启策略和最大重启频率，同时也改变子进程规格说明。最终将增加state_handler这个模块到监督者的子进程规格说明里。</li>
<li>{apply, {supervisor, restart_child, [nine9s, state_handler]}} : “apply”指令接收{M,F,A}做为参数，然后执行 M:F(A1, … An)。所以我们实际上是执行supervisor:restart_child(nine9s, state_handler)，这将在nine9s_sup监督者下启动state_handler做为工作进程。请注意：上述三条指令的顺序。首先我们增加state_handler模块，然后改变监督者的状态，最后创建state_handler进程。</li>
<li>{load_module, default_handler} : 这条指令将重新装载default_handler模块，替换它的老版本代码。</li>
<li>{add_module, count_handler} : 增加count_handler模块。</li>
<li>{load_module, nine9s_app} : 我们重新装载nine9s_app，从而我们新增加的函数被装载进虚拟机。</li>
<li>{apply, {nine9s_app, set_routes_new, [ ] }} ] } ] : 既然我们装载了新的函数，我就执行 nine9s_app:set_routes_new() 增加新的路由到我们的服务器。</li>
</ul>
<p>接下来的元素是如何降级的指令，它的工作模式和前一个元素相似，但是是用老模块替换新模块。</p>
<ul>
<li>{load_module, default_handler} : 这个指令将装载老的default_handler模块。</li>
<li>{apply, {supervisor, terminate_child, [nine9s_sup, state_handler]}} : 终止state_handler进程。</li>
<li>{apply, {supervisor, delete_child, [nine9s_sup, state_handler]}} : 从nine9s_sup里删除state_handler这个子进程规格。</li>
<li>{update, nine9s_sup, supervisor} : 修改监督者nine9s_sup的内部状态。</li>
<li>{delete_module, state_handler} : 删除state_handler模块。</li>
<li>{apply, {nine9s_app, set_routes_old, [ ] }} : 设置路由为老版本路由。</li>
<li>{delete_module, count_handler} : 删除count_handler模块。</li>
<li>{load_module, nine9s_app} : 装载老的nine9s_app模块。</li>
</ul>
<p>既然我们的appup文件准备好了，我们就开始升级到最新的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先我们拷贝appup文件到lib目录下nine9s/ebin下</span></div><div class="line">$ cp apps/nine9s/src/nine9s.appup.src _build/default/lib/nine9s/ebin/nine9s.appup</div><div class="line"><span class="comment"># 接着我们编译和发布应用</span></div><div class="line">$ rebar3 compile</div><div class="line">$ rebar3 release</div><div class="line"><span class="comment"># 生成relup到前一个版本</span></div><div class="line">$ rebar3 relup -n nine9s -v <span class="string">"0.2.0"</span> -u <span class="string">"0.1.0"</span></div><div class="line"><span class="comment"># 生成新版本的tar文件</span></div><div class="line">$ rebar3 tar -n nine9s -v <span class="string">"0.2.0"</span></div><div class="line">$ mv _build/default/rel/nine9s/nine9s-0.2.0.tar.gz _build/default/rel/nine9s/releases/0.2.0/nine9s.tar.gz</div><div class="line"><span class="comment"># 升级到新的版本</span></div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 upgrade <span class="string">"0.2.0"</span></div></pre></td></tr></table></figure>
<p>搞定！如果所有执行都成功，那么我们就升级到0.2.0版本了。你可以浏览 <a href="http://localhost:9090和http://localhost:9090/count来验证一下。" target="_blank" rel="external">http://localhost:9090和http://localhost:9090/count来验证一下。</a></p>
<p>项目有两个分支<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0</a>和<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0</a>。你可以先编译和运行分支0.1.0，然后切换到0.2.0分支，使用python脚本<a href="https://github.com/kansi/nine9s/blob/0.2.0/upgrade.py" target="_blank" rel="external">upgrade.py</a>来升级到0.2.0版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4" target="_blank" rel="external">https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码热更新就是一门给正在飞奔的汽车换引擎的艺术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/tags/Rebar3/"/>
    
      <category term="热更新" scheme="http://szpzs.oschina.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>rebar3 shell</title>
    <link href="http://szpzs.oschina.io/2016/12/07/rebar3-shell/"/>
    <id>http://szpzs.oschina.io/2016/12/07/rebar3-shell/</id>
    <published>2016-12-07T13:39:29.000Z</published>
    <updated>2016-12-08T01:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。</p>
<a id="more"></a>
<p>它有很多好的特性，不过在我的观点来看，这些是一个Erlang shell工具最少要支持的。因此，尝试展示这些特性听起来好像是吹嘘你该做的本分事情一样；多说无益，下面就进入正题。</p>
<p>不过，一些Erlang的东西的可用性一直很糟糕，我们（贡献者）已经在rebar3上做了很多工作来尝试解决这些糟糕的体验。我不得不说，很多社区已经有大量的非常好的工具，但是它们都是独立的，如何用好它们必须要读者自己去逐个尝试。这个时候，rebar3横空出世了。</p>
<p>当使用rebar3 shell命令的时候首先吸引人的是，它会自动编译项目（如果项目还没有被编译）并且将编译后的项目加入你的代码搜索路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; vegur:module_info().</div><div class="line">[&#123;module,vegur&#125;,</div><div class="line">&#123;exports,[&#123;start_http,3&#125;,</div><div class="line">&#123;start_proxy,3&#125;,</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个功能作用于所有项目。这至少摆脱很多需要你自己手写默认设置的许多烦恼。现在这些都由rebar3 shell来做。</p>
<p>对于一个编程语言来说，一个好的shell环境就是关于它的互动性。期望能够快速地重编译代码或者运行测试，并且重新装载代码而不需要任何中断或丢失状态。rebar3 shell有一个代理，隐藏在r3模块背后，它准备着所有需要重新编译代码或者运行任务的状态的管理。所以，例如任何存在的项目，我可以要求重新编译或者任何其他任务运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; r3:do(compile).</div><div class="line">===&gt; This feature is experimental <span class="keyword">and</span> may be modified or removed at any time.</div><div class="line">Verifying dependencies...</div><div class="line">Compiling vegur</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(ct).</div><div class="line">Verifying dependencies...</div><div class="line">Fetching websocket_client (&#123;git,<span class="string">"git@github.com:jeremyong/websocket_client.git"</span>,</div><div class="line">&#123;tag,<span class="string">"v0.7"</span>&#125;&#125;)</div><div class="line">Linking _build/default/lib/cowboyku to _build/test/lib/cowboyku</div><div class="line">Linking _build/default/lib/cowlib to _build/test/lib/cowlib</div><div class="line">Linking _build/default/lib/erequest_id to _build/test/lib/erequest_id</div><div class="line">...</div><div class="line">Running Common Test suites...</div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_callback: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_timeout: OK</span></div><div class="line">...</div><div class="line">All <span class="number">140</span> tests passed.</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(dialyzer).</div><div class="line">Verifying dependencies...</div><div class="line">...</div><div class="line">Analyzing <span class="number">19</span> files with <span class="string">"/home/ferd/code/self/vegur/_build/default/rebar3_18.1.5_plt"</span>...</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>如上述例子等等。所有这些任务都会用你的最新版本的rebar.config文件来运行它的任务和切换路径重装载模块等等。</p>
<p>rebar3的代理还有一个名字使得可以在外部调用它。你可以用一个名字来启动一个shell（rebar3 shell –name my_shell 或 rebar3 shell –sname my_shell）然后远程向它发送消息或者直接RPC调用当作指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --sname=my_shell</div><div class="line">erl -sname remote -eval <span class="string">'rpc:call(my_shell@localhost, r3, do, [ct]), halt(0).'</span> -noshell</div></pre></td></tr></table></figure>
<p>当作人们的工具的目的应该是可以被用来从你的IDE或编辑器里增加钩子到Erlang shell里。</p>
<p>被写出来的和rebar3代理一起工作的插件也是一种选择。例如，通过监控硬盘，<a href="https://www.rebar3.org/docs/using-available-plugins#auto-compile-and-load" target="_blank" rel="external">rebar3_atuo 能够被用来自动重新编译修改过的文件</a>，这样也省了这个的功能要和IDE或编辑器合成的需求。</p>
<p>这提供了一个非常好的改进，例如，在运行调试周期，在测试，代码分析和交互式调试都可以在同一个环境进行。</p>
<p>为了使得开发周期更加与你的项目成长无缝对接，rebar3 shell将在构建工具里自动侦测<a href="https://www.rebar3.org/docs/releases" target="_blank" rel="external">release配置</a>，并且以你的release遵循的的<a href="https://www.rebar3.org/docs/releases#section-application-configuration" target="_blank" rel="external">应用配置</a>【1】启动你的系统。</p>
<p>这意味着只要你的代码库配置成装配为一个可执行版本，你可以在它里面访问shell的代码重装载特性，使用的是同样的工具，而这些工具你可能以别的方式使用。</p>
<p>如果你不使用release呢？应用可以在你的rebar.config文件里被指定为{shell, [{apps, [myapp]}]}  或者在命令行里的参数里指定（–apps app1,app2）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --apps vegur</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">...</div><div class="line">===&gt; Booted midjan</div><div class="line">===&gt; Booted quickrand</div><div class="line">===&gt; Booted uuid</div><div class="line">===&gt; Booted erequest_id</div><div class="line">===&gt; Booted vegur</div></pre></td></tr></table></figure>
<p>万一你的开发环境和生产环境不匹配，任意的代码可以被运行来设置shell并且通过escript来设置它。这些设置指定的动态环境变量或启动外部依赖的模拟模块是特别有用的。为了进一步解释，下面的例子将展示我们如何不让shell启动，除非所有需要设置的环境变量都设置好了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env escript</div><div class="line"></div><div class="line"><span class="function"><span class="title">main</span><span class="params">(_)</span> -&gt;</span></div><div class="line">	OSVars = [<span class="string">"USER"</span>, <span class="string">"PASS"</span>],</div><div class="line">	[check_is_set(Var) || Var &lt;- OSVars].</div><div class="line"></div><div class="line"><span class="function"><span class="title">check_is_set</span><span class="params">(Var)</span> -&gt;</span></div><div class="line">	<span class="keyword">case</span> os:getenv(Var) <span class="keyword">of</span></div><div class="line">		<span class="literal">false</span> -&gt;</div><div class="line">			rebar_api:error(<span class="string">"Missing var ~s"</span>, [Var]),</div><div class="line">			halt(<span class="number">1</span>);</div><div class="line">		_ -&gt;</div><div class="line">			ok</div><div class="line">	<span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个escript文件可以通过增加{shell, [{script_file, “path/to/file”}]}到你的rebar.config文件配置成总是执行，或者通过在命令行被直接调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --script_file <span class="built_in">test</span>/check_env.escript</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; ===&gt; Missing var PASS</div></pre></td></tr></table></figure>
<p>希望这些工具比那些开箱即用的更可以让Erlang开发者的生活轻松些。</p>
<p>【1】这里有些警告：因为rebar3 shell是一个开发工具，诸如Erlang虚拟机配置的选项（例如，调度器的数量）已经在运行时里有了而且不能被修改。它不能复制所有release的配置，因此，你应该在生产环境保持使用release。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">http://ferd.ca/rebar3-shell.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3 Shell" scheme="http://szpzs.oschina.io/tags/Rebar3-Shell/"/>
    
  </entry>
  
  <entry>
    <title>用Rebar3构建你的第一个Erlang应用</title>
    <link href="http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/"/>
    <id>http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/</id>
    <published>2016-12-05T03:17:42.000Z</published>
    <updated>2016-12-05T11:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rebar3是Erlang的构建工具和包管理工具。归功于<a href="http://www.rebar3.org/" target="_blank" rel="external">Rebar3</a>以及它的插件<a href="https://hex.pm/" target="_blank" rel="external">Hex</a>，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。</p>
<a id="more"></a>
<h1 id="下载Rebar3"><a href="#下载Rebar3" class="headerlink" title="下载Rebar3"></a>下载Rebar3</h1><p>从Rebar3官方网站下载最新版本的Rebar3，网址：<a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -O https://s3.amazonaws.com/rebar3/rebar3</div></pre></td></tr></table></figure>
<p>用chmod赋予其可执行权限，并将它加入你的环境变量PATH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x rebar3</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:rebar3所在目录</div></pre></td></tr></table></figure>
<h1 id="你的第一个Erlang应用"><a href="#你的第一个Erlang应用" class="headerlink" title="你的第一个Erlang应用"></a>你的第一个Erlang应用</h1><p>使用rebar3 new命令采用内建模块app可以创建一个新的项目。在本例子里我们创建一个叫做myapp的项目。其他可用内建模版是：release、lib、plugin、escript、cmake。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new app myapp</div><div class="line">===&gt; Writing myapp/src/myapp_app.erl</div><div class="line">===&gt; Writing myapp/src/myapp_sup.erl</div><div class="line">===&gt; Writing myapp/src/myapp.app.src</div><div class="line">===&gt; Writing myapp/rebar.config</div><div class="line">===&gt; Writing myapp/.gitignore</div><div class="line">===&gt; Writing myapp/LICENSE</div><div class="line">===&gt; Writing myapp/README.md</div></pre></td></tr></table></figure>
<p>代码在src目录里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> myapp</div><div class="line">$ tree</div><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── rebar.config</div><div class="line">└── src</div><div class="line">    ├── myapp.app.src</div><div class="line">    ├── myapp_app.erl</div><div class="line">    └── myapp_sup.erl</div></pre></td></tr></table></figure>
<p>因为Rebar3只处理 <a href="http://www.erlang.org/doc/design_principles/applications.html" target="_blank" rel="external">OTP结构的项目</a> ，所以约定成俗用一个 .app.src 文件定义你的应用是一个OTP应用。看起来是不是很熟悉？这个文件也是Erlang文件。你可以阅读 <a href="http://www.erlang.org/doc/design_principles/applications.html#id73836" target="_blank" rel="external">详细的指引</a> 来看看它都能包括些什么元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp.app.src</div><div class="line">&#123;application, <span class="string">'myapp'</span>,</div><div class="line"> [&#123;description, <span class="string">"An OTP application"</span>&#125;,</div><div class="line">  &#123;vsn, <span class="string">"0.1.0"</span>&#125;,</div><div class="line">  &#123;registered, []&#125;,</div><div class="line">  &#123;mod, &#123;<span class="string">'myapp_app'</span>, []&#125;&#125;,</div><div class="line">  &#123;applications,</div><div class="line">   [kernel,</div><div class="line">    stdlib</div><div class="line">   ]&#125;,</div><div class="line">  &#123;env,[]&#125;,</div><div class="line">  &#123;modules, []&#125;</div><div class="line"> ]&#125;.</div></pre></td></tr></table></figure>
<p>src/myapp_app.erl是一个非常简单的代码框架。它只是让你可以启动和停止你的Erlang应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp_app.erl</div><div class="line">-module(<span class="string">'myapp_app'</span>).</div><div class="line">-behaviour(application).</div><div class="line">-export([start/2, stop/1]).</div><div class="line">start(_StartType, _StartArgs) -&gt;</div><div class="line">    <span class="string">'myapp_sup'</span>:start_link().</div><div class="line">stop(_State) -&gt;</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>Rebar3用rebar.config来指定一些额外的元数据，比如<a href="https://github.com/rebar/rebar/wiki/Dependency-management" target="_blank" rel="external">依赖</a>。rebar.config还可以包含很多配置项。你可以参考 <a href="https://github.com/rebar/rebar/blob/master/rebar.config.sample" target="_blank" rel="external">详细例子</a> 来学习各种配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat rebar.config</div><div class="line">&#123;erl_opts, [debug_info]&#125;.</div><div class="line">&#123;deps, []&#125;.</div></pre></td></tr></table></figure>
<p>现在我们用Rebar3启动一个Erlang shell，它包含了你的应用及依赖的路径。然后运行 application:start(myapp). 来确认你的应用被正确地装载了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling myapp</div><div class="line">Erlang R16B03-1 (erts-5.10.4) [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line">Eshell V5.10.4  (abort with ^G)</div><div class="line">1&gt; application:start(myapp).</div><div class="line">ok</div><div class="line">2&gt; application:stop(myapp).</div><div class="line">ok</div><div class="line">3&gt;</div><div class="line">=INFO REPORT==== 29-Jun-2015::16:14:10 ===</div><div class="line">    application: myapp</div><div class="line">    exited: stopped</div><div class="line">    <span class="built_in">type</span>: temporary</div></pre></td></tr></table></figure>
<p><a href="https://github.com/ferd" target="_blank" rel="external">Fred Hebert</a> （<a href="http://learnyousomeerlang.com/" target="_blank" rel="external">Learn You Some Erlang</a> 的作者）写了一篇很好的<a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">文章</a>介绍rebar3 shell的命令。</p>
<h1 id="Erlang的包"><a href="#Erlang的包" class="headerlink" title="Erlang的包"></a>Erlang的包</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要安装一个叫做<a href="https://github.com/hexpm/rebar3_hex" target="_blank" rel="external">rebar3_hex</a>的插件来从<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>（Erlang和Elixir的包管理者）获取和安装Erlang包。简单地把如下一行加入到rebar.config文件中（你需要Erlang/OTP17.4或以上版本）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;plugins, [rebar3_hex]&#125;.</div></pre></td></tr></table></figure>
<p>然后运行命令：rebar3 update 来启用这个插件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rebar3 update</div><div class="line">===&gt; Fetching jsx (&#123;pkg,&lt;&lt;<span class="string">"jsx"</span>&gt;&gt;,&lt;&lt;<span class="string">"2.6.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching ssl_verify_hostname (&#123;pkg,&lt;&lt;<span class="string">"ssl_verify_hostname"</span>&gt;&gt;,</div><div class="line">                                           &lt;&lt;<span class="string">"1.0.5"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching rebar3_hex (&#123;pkg,&lt;&lt;<span class="string">"rebar3_hex"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.6.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling ssl_verify_hostname</div><div class="line">===&gt; Compiling jsx</div><div class="line">===&gt; Compiling rebar3_hex</div><div class="line">===&gt; Updating package index…</div></pre></td></tr></table></figure>
<p>如果你想避免每次创建一个新Erlang应用都要做这个步骤，则将上述配置添加到全局的配置文件rebar.config中，并把这个配置文件放置在如下目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.config/rebar3/rebar.config</div></pre></td></tr></table></figure>
<h2 id="查找Erlang包"><a href="#查找Erlang包" class="headerlink" title="查找Erlang包"></a>查找Erlang包</h2><p>搜索命令让你远程查找在<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>上发布的Erlang包。你可以在查询语句里用正则表达式字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 hex search cowboy</div><div class="line">cloudi_service_http_cowboy</div><div class="line">cowboy</div></pre></td></tr></table></figure>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>Rebar3能下载和安装Erlang包以及任何必要的依赖。在你的rebar.config文件里增加应用名字到deps配置项，然后运行命令：rebar3 compile。下面的例子，我们尝试使用两个Erlang包，cowboy和meck。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [cowboy, meck]&#125;.</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Fetching ranch (&#123;pkg,&lt;&lt;<span class="string">"ranch"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching meck (&#123;pkg,&lt;&lt;<span class="string">"meck"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.8.2"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowlib (&#123;pkg,&lt;&lt;<span class="string">"cowlib"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowboy (&#123;pkg,&lt;&lt;<span class="string">"cowboy"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling cowlib</div><div class="line">===&gt; Compiling ranch</div><div class="line">===&gt; Compiling meck</div><div class="line">===&gt; Compiling cowboy</div><div class="line">===&gt; Compiling myapp</div></pre></td></tr></table></figure>
<p>想要安装一个Erlang包的指定版本？在配置中把应用名字和版本写在一个元组中。你可以在<a href="https://hex.pm/" target="_blank" rel="external">Hex主页</a>上查询Erlang包的可用版本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [&#123;cowboy, “<span class="number">1.0</span>.<span class="number">2</span>”&#125;, &#123;meck, <span class="string">"0.8.3"</span>&#125;]&#125;.</div></pre></td></tr></table></figure>
<h2 id="列出已安装的包"><a href="#列出已安装的包" class="headerlink" title="列出已安装的包"></a>列出已安装的包</h2><p>rebar3 deps 命令列出你本地已经安装的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div><div class="line">meck (locked package 0.8.2)</div></pre></td></tr></table></figure>
<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>要卸载一个包，你首先要在rebar.config文件中将它删除，然后使用命令：rebar unlock。现在我们卸载meck包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 unlock</div><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div></pre></td></tr></table></figure>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz" target="_blank" rel="external">https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rebar3是Erlang的构建工具和包管理工具。归功于&lt;a href=&quot;http://www.rebar3.org/&quot;&gt;Rebar3&lt;/a&gt;以及它的插件&lt;a href=&quot;https://hex.pm/&quot;&gt;Hex&lt;/a&gt;，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/tags/Rebar3/"/>
    
  </entry>
  
  <entry>
    <title>红回调和绿回调</title>
    <link href="http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/"/>
    <id>http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/</id>
    <published>2016-12-01T07:11:46.000Z</published>
    <updated>2016-12-01T07:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。</p>
<p>为了解释这个问题，我必须先回过头来讲讲I/O。</p>
<a id="more"></a>
<h1 id="Erlang的并发I-O"><a href="#Erlang的并发I-O" class="headerlink" title="Erlang的并发I/O"></a>Erlang的并发I/O</h1><p>Erlang是如何处理并发I/O的？相当简单！假设我们有三个进程A、B和C，它们在并行执行。我用如下的方式描述这个场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A || B || C</div></pre></td></tr></table></figure>
<p>上述描述假设三个进程A、B、C正在进行I/O操作。</p>
<p>进程A如下所描述做一些事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A: --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>进程B则如下描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B: ---- write --- write --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>C进程也大致如此。虚线表示一些顺序的计算。进程A的Erlang代码框架如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">a</span><span class="params">()</span> -&gt;</span></div><div class="line">    ...</div><div class="line">    X = read(),</div><div class="line">    ...</div><div class="line">    Y = read(),</div><div class="line">    ...</div><div class="line">    write(...),</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>进程B和进程C的代码也和这个差不多。</p>
<p>Erlang里实际上是没有read()这个函数的。Erlang有  <a href="http://www.erlang.org/course/concurrent_programming.html#select" target="_blank" rel="external">select receive</a>  模式来处理消息，所以我们实际上定义的read()函数像如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        Pattern1 -&gt;</div><div class="line">           ...</div><div class="line">        Pattern2 -&gt;</div><div class="line">           ...</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>select receive 模式如何工作的细节不是本次讨论的重点，因此本文我将忽略这些细节。</p>
<p>重点是我在进程A的代码里如下所写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">X = read()</div><div class="line">...</div></pre></td></tr></table></figure>
<p>那么，我们的进程将在read函数处被挂起（或者叫做阻塞）直到read函数执行完毕。因此我们的代码“看起来像”是正在做一个同步阻塞的读动作。</p>
<p>看起来像是用双引号括起来的，因为它不是一个真正的阻塞读，而是一个真正的异步读，这个读操作不阻塞其他任何Erlang进程。</p>
<p>这真是棒极了，因为从一开始，程序就等待读请求完成，然后获得读取到的数据，程序继续运行。</p>
<h1 id="理解并发"><a href="#理解并发" class="headerlink" title="理解并发"></a>理解并发</h1><p>Erlang的I/O非常特别。当我们有两个并行的进程A和B，A进程里的一个读请求将明显地阻塞A进程，但是不会对其他任何并行的进程（这里指B）有影响。</p>
<p>所以A和B可以都同时执行写入操作就好像它们是连续的进程。</p>
<p>现在假设我们没有一个合适的基础并发模型。假设所有我们要做的事情都放入一个单独线程来执行。假设我们做一个读操作（它是阻塞的）而其他事情都在等待。啊！亲！我们的编程模型是更加清晰简单了，但是我们却浪费了CPU的宝贵资源。</p>
<p>现在在一些语言（正是我在研究的Javascript）没有多进程和多线程。不确切地说，它有一个线程，所有的事情都揉进这个线程里。在Javascript里要写与读相关操作的代码，你不得不用红回调，并且发明你自己的并发概念。</p>
<h1 id="红回调"><a href="#红回调" class="headerlink" title="红回调"></a>红回调</h1><p>在Javascript里你肯定不想在主线程里做一个阻塞同步读操作（记住它只有一个线程），那么你必需设置一个回调，当读操作完成的时候触发这个回调。我叫这样的回调为红回调。你写的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; ... do something <span class="keyword">with</span> x ..&#125;;</div><div class="line"><span class="keyword">var</span> error = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; .... x …&#125;</div><div class="line">read(Something, &#123;onSuccess:done, onError:error&#125;);</div><div class="line">... ... more code ...</div></pre></td></tr></table></figure>
<p>这样的代码搞得我脑袋一团浆糊。</p>
<p>当程序正在上述代码 more code 的某个地方执行的时候，读操作完成了，则必需立即回到done这个函数来执行，然后再回到前面 more code 中断的地方。我发现这个方式非常难以理解。</p>
<p>这的确很糟糕，每一个要解决并发问题的Javascript程序员必需要发明他自己的并发模型。问题就在于他们不知道他们正在做的是什么。每次一个Javascript程序员写下一行代码，说是“此处就该这么做”的时候，他实际上是在发明一个新的并发模型，并且在这些代码执行的时候他是没有任何线索知道这些代码是怎样交织在一起的。</p>
<p>（其实我对Javascript又爱又恨，它的大部分我都喜欢，但是就是恨它的并发模型。不过好笑的是，Javascript是没有并发模型的，所以对它也无从可恨了。:-）</p>
<p>更加难以理解的是错误。在共享内存的多线程回调代码里的错误更加是令我极度头痛！</p>
<h1 id="绿回调"><a href="#绿回调" class="headerlink" title="绿回调"></a>绿回调</h1><p>只是为了使得生活更加困惑，在Erlang里我们大量使用了回调。我把这些回调称为“绿回调”。因此回调并不一定是不好的。在Erlang里，我们可以在一个进程的上下文里更清晰地看到回调的执行，所以我们没有如何查看回调执行过程的问题。</p>
<p>如下是Erlang里一个绿回调的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">loop</span><span class="params">(F)</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;new_callback, F1&#125; -&gt;</div><div class="line">            loop(F1);</div><div class="line">        Msg -&gt;</div><div class="line">            F(Msg),</div><div class="line">            loop(F)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>当一个进程运行这段代码的时候收到一个消息Msg，它就执行函数F(Msg)。这里没有任何不确定的，当回调被触发的时候我们确切地知道。在收到消息Msg后，这个回调被立即触发。</p>
<p>这一小段代码却非常漂亮。如果你给进程发送一个消息{new_callbak, F1}，那么它将改变它的行为，在下一次调用的时候，它将执行新的回调。</p>
<p>我不知道你在Javascript里如何写出这样的代码。我写过大量的JQurey代码并且明白如何设置和删除回调。但是在删除一个事件处理并新增一个事件处理这期间里，这个事件被触发了，这会发生什么？我不知道。生命如此短暂如何花的起那么多时间来找这个答案。</p>
<h1 id="Erlang的I-O是如何工作的"><a href="#Erlang的I-O是如何工作的" class="headerlink" title="Erlang的I/O是如何工作的"></a>Erlang的I/O是如何工作的</h1><p>我们实际上并没有给进程发送消息。我们给进程的邮箱发送消息。每一个进程有一个邮箱，当我们给一个进程发送消息，这个消息被放入这个进程的邮箱（如果快递小子能找到这个进程的话）。</p>
<p>想像一下，Erlang的进程是有邮箱的房子。发送消息就好比你把你的消息给快递小子。快递小子的工作就是做两件事：把邮件放入目的邮箱并敲门说：“有新信到了”。</p>
<p>进程可能在忙着也可能在睡觉，就如一个房东一个样，他可能在干这活或者在睡觉。如果他在睡觉，那么当邮递员来了并敲响了房门，房东就会走到邮箱那里检查是否有令人感兴趣的邮件。</p>
<p>如果房东此时把手头的活干完后，正在做其他事情的时候，房东可能会走到邮箱那里检查是否有新的邮件到了，</p>
<p>这就是Erlang的消息工作机制。每一个房子（进程）有它自己的生命周期。邮递员投递邮件，房东根据自己的意愿决定什么时候去检查邮箱。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html" target="_blank" rel="external">http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。&lt;/p&gt;
&lt;p&gt;为了解释这个问题，我必须先回过头来讲讲I/O。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="callback" scheme="http://szpzs.oschina.io/categories/Erlang/callback/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="callback" scheme="http://szpzs.oschina.io/tags/callback/"/>
    
  </entry>
  
  <entry>
    <title>Erlang(和Elixir)无epmd之分布式</title>
    <link href="http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/"/>
    <id>http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/</id>
    <published>2016-11-22T02:50:54.000Z</published>
    <updated>2016-11-22T03:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：</p>
<ul>
<li>epmd（Erlang端口映射守护进程）端口4369，</li>
<li>Erlang节点自己的端口，一个不可预知的大数字端口。</li>
</ul>
<p>这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的<a href="http://erlang.org/doc/man/kernel_app.html" target="_blank" rel="external">kernel文档</a>里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。</p>
<a id="more"></a>
<p>但是如果我们限制了Erlang节点在一个单独的端口，那么我们还真的需要一个端口映射吗？运行epmd有以下几个潜在的缺点：</p>
<ul>
<li>我们可能想要以运行Erlang节点的用户来运行epmd，但是正如我们将见到的，这个很难得到保证。</li>
<li>我们可能想要配置epmd监听一个特定的端口，但是这依赖于在本机上我们如何第一次运行epmd。</li>
<li>任何人无需身份验证可以连接epmd并且可以列出本地的所有Erlang节点。</li>
<li>与epmd的连接都没有加密，即使你按 <a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">Erlang distribution over TLS</a> 这篇文章的方法去做，与epmd的连接也是不受保护的，并且有被中间人攻击的潜在风险。</li>
<li>虽然epmd很稳定，它也有发生崩溃的可能。一旦它崩溃了，任何已经存在的分布式Erlang节点将继续运行，即使epmd恢复了，这些节点也不会重新连接empd。这意味着存在的分布式连接继续工作着，但是与这些节点的新的连接将不起作用。阅读俄文博客 <a href="https://habrahabr.ru/post/49535/" target="_blank" rel="external">Экстренная реанимация epmd</a> 可能可以在不重启epmd的情况下解决这个问题。</li>
</ul>
<p>那么我们来研究一下epmd是如何工作的，然后我们如何做就可以在不用epmd的情况下运行一个Erlang集群。</p>
<h1 id="epmd是如何第一次启动的？"><a href="#epmd是如何第一次启动的？" class="headerlink" title="epmd是如何第一次启动的？"></a>epmd是如何第一次启动的？</h1><p>让我们来读读源码！epmd是在<a href="https://github.com/erlang/otp/blob/OTP-19.1.1/erts/etc/common/erlexec.c#L1234-L1279" target="_blank" rel="external">erlexec.c文件的start_epmd函数</a>里被启动的。实际上，每一次一个Erlang分布式节点启动epmd都无条件地被启动。如果一个epmd实例已经在运行，新的epmd在侦听端口4369的时候将失败，它将因此悄无声息地结束运行。</p>
<p>事实上，这就是即使由另一个用户启动的epmd实例存在系统将发生的事情。任何epmd实例都非常乐意为由任何用户启动的Erlang节点服务，因此这个通常不会引起任何问题。</p>
<h1 id="那么谁可以连接epmd？"><a href="#那么谁可以连接epmd？" class="headerlink" title="那么谁可以连接epmd？"></a>那么谁可以连接epmd？</h1><p>任何人都可以！默认情况下，epmd侦听在所有有效的接口上，并且响应关于当前有哪些节点以及这些节点所侦听的端口的查询。一听到这个场景，系统管理员应该有点紧张。</p>
<p>你可以在epmd启动前通过手工指定 -address 选项或设定ERL_EPMD_ADDRESS 环境变量启动epmd来改变上述情况。这个方法在<a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="external">官方文档</a>里有描述。这个方法需要在你第一次启动epmd的时候来做，否则，已经存在的epmd实例将不受影响地继续运行。</p>
<h1 id="为什么我们需要一个端口映射守护进程？"><a href="#为什么我们需要一个端口映射守护进程？" class="headerlink" title="为什么我们需要一个端口映射守护进程？"></a>为什么我们需要一个端口映射守护进程？</h1><p>很明显，epmd就是一个中间人。我们可以绕过这个中间人吗？</p>
<p>我们可以让每个Erlang节点侦听在一个大家熟知的端口–如果我们打算去除掉epmd的话，我们可以用empd默认保留的端口，4369。但是这就意味着我们只能够在每个主机上运行一个Erlang节点（当然，在某些场景下这就足够了）。</p>
<p>那么让我们指定一些其他端口。前面我们提到变量 inet_dist_listen_min 和 inet_dist_listen_max 。这两个变量定义一个端口范围，不过如果我们设置它们为相同的值，我们就把范围缩小到一个端口：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">erl -sname foo \</div><div class="line">    -kernel inet_dist_listen_min <span class="number">4370</span> \</div><div class="line">            inet_dist_listen_max <span class="number">4370</span></div></pre></td></tr></table></figure>
<p>这个方法不错，不过我们也需要告诉其他节点不要再去询问epmd来获取端口号，而是只用这个端口号来代替。如果我们在同一个主机上有几个节点，我们需要为这些节点配置不同的端口号。</p>
<h1 id="用别的方法"><a href="#用别的方法" class="headerlink" title="用别的方法"></a>用别的方法</h1><p>在Erlang/OTP 19.0里，有两个新的命令行选项：</p>
<ul>
<li>当我们指定 -start_epmd false，Erlang将不会在启动一个分布式节点的时候尝试去启动epmd；</li>
<li>选项 -epmd_module foo 让你指定一个不同的模块替代默认的模块erl_epmd，用来节点名字注册和查询。</li>
</ul>
<p>接下来我们来构建一些代码！</p>
<p>我想用一个无状态的方式来实现这个方法：既然发起连接的节点知道了它要连接的节点的名字，那么我就用这个名字作为资源来得到相应的端口号。我选择4370这个端口作为基准端口，它比epmd的端口大一。接着我从节点名称的“节点”部分抽取出数字，比如节点名称为 myapp3@foo.example.com 抽取的数字是3。最后我把这个数字和基准端口相加。由此得知，节点 myapp3@foo.example.com 侦听在端口4373。如果节点名字最后不是数字，我这种情况将处理为0。这意味着节点 myapp3 和 myotherapp3 不能运行在同一个主机上，但是我准备好了处理对这种场景。（感谢 Luca Favatella 的完美建议）</p>
<p>为此我们来写一个小模块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([dist_port/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% 返回被一个指定节点使用的端口号。</span></div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_atom</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    dist_port(atom_to_list(Name));</div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_list</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 获取基端口号。如果没有在 kernel 的环境变量</span></div><div class="line">    <span class="comment">%% inet_dist_base_port 里指定, 则默认为</span></div><div class="line">    <span class="comment">%% 4370, 比epmd端口大1。</span></div><div class="line">    BasePort = application:get_env(kernel, inet_dist_base_port, <span class="number">4370</span>),</div><div class="line"></div><div class="line">    <span class="comment">%% 现在，算出我们相对于基端口号的偏移值。</span></div><div class="line">    <span class="comment">%% 这个偏移值就是我们节点名的@符号左边的数字。</span></div><div class="line">    <span class="comment">%% 如果这个数字不存在，则偏移量设置为0。</span></div><div class="line">    <span class="comment">%%</span></div><div class="line">    <span class="comment">%% 同时我们也处理主机名没有指定的情况。</span></div><div class="line">    NodeName = re:replace(Name, <span class="string">"@.*$"</span>, <span class="string">""</span>),</div><div class="line">    Offset =</div><div class="line">        <span class="keyword">case</span> re:run(NodeName, <span class="string">"[0-9]+$"</span>, [&#123;capture, first, list&#125;]) <span class="keyword">of</span></div><div class="line">            nomatch -&gt;</div><div class="line">                <span class="number">0</span>;</div><div class="line">            &#123;match, [OffsetAsString]&#125; -&gt;</div><div class="line">                list_to_integer(OffsetAsString)</div><div class="line">        <span class="keyword">end</span>,</div><div class="line"></div><div class="line">    BasePort + Offset.</div></pre></td></tr></table></figure>
<p>同时我们还要写一个模块用作 -epmd_module。有一点小复杂就是因为OTP19.0期望这个模块导出 register_node/2 函数，而从OTP19.1开始则是期望导出 register_node/3 函数。我们把这两个函数都包含进去。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_epmd_client)</span>.</div><div class="line"></div><div class="line"><span class="comment">%% epmd_module 回调函数</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>,</span></div><div class="line">         register_node/<span class="number">2</span>,</div><div class="line">         register_node/<span class="number">3</span>,</div><div class="line">         port_please/<span class="number">2</span>,</div><div class="line">         names/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="comment">%% 监督者模块 erl_distribution 尝试着把我们当做一个被监督的子进程。</span></div><div class="line"><span class="comment">%% 我们不需要子进程，所以返回 ignore 。</span></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    ignore.</div><div class="line"></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(_Name, _Port)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 本函数是我们连接epmd并告诉它我们监听哪个端口，</span></div><div class="line">    <span class="comment">%% 不过因为我们是无epmd的，所以我们不需要做这些。</span></div><div class="line"></div><div class="line">    <span class="comment">%% 需要返回一个1到3的 ”creation” 数字。</span></div><div class="line">    Creation = rand:uniform(<span class="number">3</span>),</div><div class="line">    &#123;ok, Creation&#125;.</div><div class="line"></div><div class="line"><span class="comment">%% 从Erlang/OTP19.1开始，register_node/3函数替代register_node/2函数，</span></div><div class="line"><span class="comment">%% 该函数多了一个地址族的入参，取值为 ‘inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line"><span class="comment">%% 这一点对我们来说没有多大的改动。</span></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(Name, Port, _Family)</span> -&gt;</span></div><div class="line">    register_node(Name, Port).</div><div class="line"></div><div class="line"><span class="function"><span class="title">port_please</span><span class="params">(Name, _IP)</span> -&gt;</span></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line">    <span class="comment">%% 分布式协议版本从Erlang/OTP16开始就是5。</span></div><div class="line">    Version = <span class="number">5</span>,</div><div class="line">    &#123;port, Port, Version&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">names</span><span class="params">(_Hostname)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 因为我们没有epmd，所以我们真的不知道此处是否有其他节点。</span></div><div class="line">    &#123;error, address&#125;.</div></pre></td></tr></table></figure>
<p>正如你所见，大多数事情基本完成了。</p>
<p>当这个模块被加为 erl_distribution 监督者的子进程的时候，start_link/0 将被调用。我们并不需要在这个启动一个进程，因此我们只是返回 ignore。</p>
<p>register_node函数通常会连接epmd并告诉它我们使用哪一个端口。epmd将返回一个“creation”数字。“creation”数字上一个介于1和3的整数。epmd跟踪每一个节点名字的“creation”数字并且当一个确定名字的节点重连的时候增加这个数字。这意味着它可以区分先前某一个节点“存活期间”的进程id。</p>
<p>既然我们没有epmd，那么我们就没有获得它跟踪节点生命周期的好处。在这里我们返回一个随机数，它有三分之二的机会不同于前面的“creation”数字。</p>
<p>port_please/2 获取远程主机的IP地址以便连接它的epmd，但是我们不关心这些；我们用我们自己的算法来算出我们的端口号。</p>
<p>我们也需要返回一个分布式协议版本号。从Erlang/OTP 6开始它就是5（参阅 <a href="http://erlang.org/doc/apps/erts/erl_dist_protocol.html" target="_blank" rel="external">分布式协议官方文档</a> ），就这么简单。</p>
<p>最后，names/1 函数被调用来返回某个主机上的Erlang节点列表。我们没有办法知道这些信息，所以让我们假装我们连接不上这个主机。</p>
<p>目前为止，一起都顺利。但是我们需要一个方法来确认我们正侦听在合适的端口上。我认为最好的方法是写一个新的分布式协议模块，该模块仅是设置端口号而让真正的协议模块做它自己的事情：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_dist)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([listen/<span class="number">1</span>,</span></div><div class="line">         select/<span class="number">1</span>,</div><div class="line">         accept/<span class="number">1</span>,</div><div class="line">         accept_connection/<span class="number">5</span>,</div><div class="line">         setup/<span class="number">5</span>,</div><div class="line">         close/<span class="number">1</span>,</div><div class="line">         childspecs/<span class="number">0</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">listen</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 在此处我们算出我们想要侦听在什么端口。</span></div><div class="line"></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line"></div><div class="line">    <span class="comment">%% 设置 “最小” 和 “最大” 两个变量，强制侦听端口为一个值。</span></div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_min, Port),</div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_max, Port),</div><div class="line"></div><div class="line">    <span class="comment">%% 最后运行真正的函数！</span></div><div class="line">    inet_tcp_dist:listen(Name).</div><div class="line"></div><div class="line"><span class="function"><span class="title">select</span><span class="params">(Node)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:select(Node).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept_connection</span><span class="params">(AcceptPid, Socket, MyNode, Allowed, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">setup</span><span class="params">(Node, Type, MyNode, LongOrShortNames, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:setup(Node, Type, MyNode, LongOrShortNames, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">close</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:close(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">childspecs</span><span class="params">()</span> -&gt;</span></div><div class="line">    inet_tcp_dist:childspecs().</div></pre></td></tr></table></figure>
<p>几乎所有的代码都在这。listen/1函数在将控制权交给真正的处理模块inet_tcp_dist前，根据我们的节点名来设置inet_dist_listen_min和inet_dist_listen_max两个变量。</p>
<p>（请注意：虽然inet_tcp_dist是默认的处理模块，但是它仅提供基于IPv4上的未加密连接。如果你想用IPv6，你应该用inet6_tcp_dist，而如果你想用<a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">基于TLS上的Erlang分布式功能</a>，那就应该选择inet_tsl_dist或inet6_tsl_dist。增加这些弹性的尝试留给读者自己练习。）</p>
<p>我们准备好了！现在我们启动两个节点，foo1和foo2，并且使它们彼此互连：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo1</div><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo2</div></pre></td></tr></table></figure>
<p>系统能正常运行吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(foo2@poki-sona-sin)<span class="number">1</span>&gt; net_adm:ping('foo1@poki-sona-sin').</div><div class="line">pong</div></pre></td></tr></table></figure>
<p>看起来没问题！</p>
<h1 id="接着在Elixir下尝试"><a href="#接着在Elixir下尝试" class="headerlink" title="接着在Elixir下尝试"></a>接着在Elixir下尝试</h1><p>当然，因为Erlang和Elixir都运行在同样的虚拟机上，那么就没有什么可以阻止我们在Elixir里实现上述功能了。</p>
<p>在Elixir里，我们可以将所有代码放在一个单独文件里，编译器会将它编译成我们需要的不同的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个包含根据一个节点名来决定端口号的函数的模块。</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_atom(name) <span class="keyword">do</span></div><div class="line">    dist_port Atom.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_list(name) <span class="keyword">do</span></div><div class="line">    dist_port List.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_binary(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 算出基端口。如果没有指定则用</span></div><div class="line">    <span class="comment"># inet_dist_base_port 这个kernel的环境变量,</span></div><div class="line">    <span class="comment"># 默认值是4370, 比epmd的端口大1。</span></div><div class="line">    base_port = <span class="symbol">:application</span>.get_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_base_port</span>, <span class="number">4370</span></div><div class="line"></div><div class="line">    <span class="comment"># 现在，基于基端口算出我们的“偏移量”。</span></div><div class="line">    <span class="comment"># 偏移量就是一个我们节点名@符号左边的整数。</span></div><div class="line">    <span class="comment"># 如果这个整数不存在，则偏移量是0。</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># 也处理主机名没有指定的情况。</span></div><div class="line">    node_name = Regex.replace ~r/@.*<span class="variable">$/</span>, name, <span class="string">""</span></div><div class="line">    offset =</div><div class="line">      <span class="keyword">case</span> Regex.run ~r/[<span class="number">0</span>-<span class="number">9</span>]+<span class="variable">$/</span>, node_name <span class="keyword">do</span></div><div class="line">    <span class="keyword">nil</span> -&gt;</div><div class="line">      <span class="number">0</span></div><div class="line">    [offset_as_string] -&gt;</div><div class="line">      String.to_integer offset_as_string</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    base_port + offset</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_dist</span></span> <span class="keyword">do</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 此处我们算出我们想要侦听的端口。</span></div><div class="line"></div><div class="line">    port = Epmdless.dist_port name</div><div class="line"></div><div class="line">    <span class="comment"># 设置“min”和“max”变量，强制两个端口为一个值。</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_min</span>, port</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_max</span>, port</div><div class="line"></div><div class="line">    <span class="comment"># 最后运行真正的函数！</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.listen name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(node) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.select node</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept_connection</span></span>(accept_pid, socket, my_node, allowed, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept_connection accept_pid, socket, my_node, allowed, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>(node, type, my_node, long_or_short_names, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.setup node, type, my_node, long_or_short_names, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.close listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">childspecs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.childspecs</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_epmd_client</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># erl_distribution想要我们启动一个工作进程，然而我们并不需要。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ignore</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 因为Erlang/OTP 19.1用register_node/3来替换register_node/2，</span></div><div class="line">  <span class="comment"># 只是多传了一个参数：地址族，’inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line">  <span class="comment"># 这对于我们来说没什么问题。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(name, port, _family) <span class="keyword">do</span></div><div class="line">    register_node(name, port)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(_name, _port) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 在此处我们应该连接epmd并告诉它哪个是我们侦听的端口，</span></div><div class="line">    <span class="comment"># 但是因为我们是无epmd的，所以我们不需要这么做。</span></div><div class="line"></div><div class="line">    <span class="comment"># 需要返回一个介于1和3的"creation”数字。</span></div><div class="line">    creation = <span class="symbol">:rand</span>.uniform <span class="number">3</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, creation&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">port_please</span></span>(name, _ip) <span class="keyword">do</span></div><div class="line">    port = Epmdless.dist_port name</div><div class="line">    <span class="comment"># 分布式协议版本数字从Erlang/OTP R6开始就是5。</span></div><div class="line">    version = <span class="number">5</span></div><div class="line">    &#123;<span class="symbol">:port</span>, port, version&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">names</span></span>(_hostname) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 既然我们没有epmd，那么我们就不真正需要知道其他节点。</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:address</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们启动Elixir，我们需要用 - -erl 来传递一些参数来使得功能启用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --erl <span class="string">"-proto_dist Elixir.Epmdless -start_epmd false -epmd_module Elixir.Epmdless_epmd_client"</span> --sname foo3</div></pre></td></tr></table></figure>
<p>让我们ping我们前面已经启动的两个节点：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">1</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo1@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">2</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo2@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div></pre></td></tr></table></figure>
<p>它们都连通了并且没有epmd参与！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文描述的只是其中一种不需要epmd的Erlang分布式方式；我相信你可以用别的办法来更好地符合你的需求。我希望上述的示例代码是有用的指南！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epmd（Erlang端口映射守护进程）端口4369，&lt;/li&gt;
&lt;li&gt;Erlang节点自己的端口，一个不可预知的大数字端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的&lt;a href=&quot;http://erlang.org/doc/man/kernel_app.html&quot;&gt;kernel文档&lt;/a&gt;里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="distribution" scheme="http://szpzs.oschina.io/categories/Erlang/distribution/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="epmd" scheme="http://szpzs.oschina.io/tags/epmd/"/>
    
  </entry>
  
  <entry>
    <title>Erlang快速安装</title>
    <link href="http://szpzs.oschina.io/2016/09/28/erlang-quick-install/"/>
    <id>http://szpzs.oschina.io/2016/09/28/erlang-quick-install/</id>
    <published>2016-09-28T14:01:48.000Z</published>
    <updated>2016-10-13T12:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/erlang-logo.png" style="border:0;"><br>在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的<a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank" rel="external">完全安装指引</a>。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。</p>
<ul>
<li><a href="#part1">在Mac OS X上安装Erlang</a></li>
<li><a href="#part2">在Linux上安装Erlang</a></li>
<li><a href="#part3">在Windows上安装Erlang</a></li>
<li><a href="#part4">用最新版本预编译包安装Erlang</a></li>
<li><a href="#part5">从源码编译安装Erlang</a></li>
</ul>
<a id="more"></a>
<h2 id="在Mac-OS-X上安装Erlang"><a href="#在Mac-OS-X上安装Erlang" class="headerlink" title="在Mac OS X上安装Erlang"></a><span id="part1">在Mac OS X上安装Erlang</span></h2><p><strong>使用HomeBrew来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install erlang</div></pre></td></tr></table></figure>
<p><strong>用MacPorts来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install erlang</div></pre></td></tr></table></figure>
<h2 id="在Linux上安装Erlang"><a href="#在Linux上安装Erlang" class="headerlink" title="在Linux上安装Erlang"></a><span id="part2">在Linux上安装Erlang</span></h2><p>大多数操作系统在它们的包管理系统里有预构建的Erlang发行版本。</p>
<p><strong>在Ubuntu和Debian下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install erlang</div></pre></td></tr></table></figure>
<p><strong>在Fedora下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<p><strong>在FreeBSD下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pkg update</div><div class="line">sudo pkg install erlang</div></pre></td></tr></table></figure>
<h2 id="在Windows上安装Erlang"><a href="#在Windows上安装Erlang" class="headerlink" title="在Windows上安装Erlang"></a><span id="part3">在Windows上安装Erlang</span></h2><p><a href="http://www.erlang.org/download.html" target="_blank" rel="external">直接下载安装程序来安装</a></p>
<h2 id="用最新版本预编译包安装Erlang"><a href="#用最新版本预编译包安装Erlang" class="headerlink" title="用最新版本预编译包安装Erlang"></a><span id="part4">用最新版本预编译包安装Erlang</span></h2><p>你在寻找最新的稳定Erlang版本或者前一个Erlang版本吗？<a href="https://www.erlang-solutions.com/" target="_blank" rel="external">Erlang Solutions</a> 给OS X，Windows，Ubuntu，Debian，Fedora，CentOS，Raspbian 以及其他平台都提供了一个<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp" target="_blank" rel="external">预编译安装包</a>。它们也提供了一个企业级Erlang发行版。</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="external">从Erlang Solutions下载</a></p>
<h2 id="从源码编译安装Erlang"><a href="#从源码编译安装Erlang" class="headerlink" title="从源码编译安装Erlang"></a><span id="part5">从源码编译安装Erlang</span></h2><p>你可以用Kerl脚本在你自己的机器上从源码来构建Erlang。Kerl是一个脚本，它使得你用几个命令就轻松地构建不同版本的Erlang。</p>
<p><strong>下载Kerl指令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O https://raw.githubusercontent.com/spawngrid/kerl/master/kerl</div><div class="line">chmod +x kerl</div></pre></td></tr></table></figure>
<p>选择一个可用的Erlang源码发行版本并且像如下指令一样来构建它（在这个例子里，我们选择18.0版本并且命名它为mybuild-18.0）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list releases</div><div class="line">./kerl build 18.0 mybuild-18.0</div></pre></td></tr></table></figure>
<p>选择一个目录来安装，例如 ~/erlang-r16b03</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list builds</div><div class="line">./kerl install mybuild-18.0 ~/erlang-18.0</div></pre></td></tr></table></figure>
<p>最后，把目录 ~/erlang-18.0/bin 加到你的环境变量 $PATH 里。</p>
<p><strong>搞定！</strong></p>
<p>在你的终端运行erl来启动一个Erlang shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 18 [erts-7.0] [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.0  (abort with ^G)</div><div class="line">1&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634" target="_blank" rel="external">https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/erlang-logo.png&quot; style=&quot;border:0;&quot;/&gt;&lt;br&gt;在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的&lt;a href=&quot;http://www.erlang.org/doc/installation_guide/INSTALL.html&quot;&gt;完全安装指引&lt;/a&gt;。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#part1&quot;&gt;在Mac OS X上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part2&quot;&gt;在Linux上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part3&quot;&gt;在Windows上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part4&quot;&gt;用最新版本预编译包安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part5&quot;&gt;从源码编译安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/categories/Erlang/install/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/tags/install/"/>
    
      <category term="HomeBrew" scheme="http://szpzs.oschina.io/tags/HomeBrew/"/>
    
      <category term="MacPorts" scheme="http://szpzs.oschina.io/tags/MacPorts/"/>
    
      <category term="Kerl" scheme="http://szpzs.oschina.io/tags/Kerl/"/>
    
  </entry>
  
  <entry>
    <title>往Elixir里的Map塞东西</title>
    <link href="http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/"/>
    <id>http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/</id>
    <published>2016-09-27T10:57:03.000Z</published>
    <updated>2016-09-27T11:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Elixir的<a href="http://elixir-lang.org/docs/stable/elixir/Map.html" target="_blank" rel="external">Map</a>模块提供了一些不同的函数来操作map数据结构。其中一个函数就是<a href="http://elixir-lang.org/docs/stable/elixir/Map.html#put/3" target="_blank" rel="external">Map.put/3</a> 。这个函数允许你将一个健值对放入一个map中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">9</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">10</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果这个键对于此map来说是新的话，这个键值对就简单地加入map。如果这个键对于此map来说是已存在的，那么对应的老的值则被新的值替换。</p>
<p>同样的效果可以用Map.merge/2来实现。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">10</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">11</span>, <span class="symbol">bulbasaur:</span> <span class="number">14</span>&#125;)</div><div class="line">%&#123;<span class="symbol">bulbasaur:</span> <span class="number">14</span>, <span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">11</span>&#125;</div></pre></td></tr></table></figure>
<p>Map.merge/2的优势是它的灵活性。它能够更容易地在不同情况下使用。它甚至允许一次增加并且替换多个健值对。因为两个入参都是map，它让我们感觉到更容易阅读。</p>
<p>也有一个语法糖的方法，就是用map字面符号和一个管道来替换已经存在的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = %&#123;pokemon | <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>这个是最简洁的方法，但是，它仅仅是用来替换一个健值对。如果这个键不存在map中，则一个错误将发生。</p>
<p>除此之外当然还有其他函数来设置值到map中，包括 <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/3" target="_blank" rel="external">Kernel.put_in/3</a> 和 <a href="http://elixir-lang.org/docs/stable/elixir/Map.html#get_and_update/3" target="_blank" rel="external">Map.get_and_update/3</a> 。然而上述几个方法是我自己最经常接触到的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/" target="_blank" rel="external">http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elixir的&lt;a href=&quot;http://elixir-lang.org/docs/stable/elixir/Map.html&quot;&gt;Map&lt;/a&gt;模块提供了一些不同的函数来操作map数据结构。其中一个函数就是&lt;a href=&quot;http://elixir-lang.org/docs/stable/elixir/Map.html#put/3&quot;&gt;Map.put/3&lt;/a&gt; 。这个函数允许你将一个健值对放入一个map中。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = %&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = Map.put(pokemon, &lt;span class=&quot;symbol&quot;&gt;:squirtle&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;squirtle:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = Map.put(pokemon, &lt;span class=&quot;symbol&quot;&gt;:squirtle&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;squirtle:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Map" scheme="http://szpzs.oschina.io/categories/Elixir/Map/"/>
    
    
      <category term="merge" scheme="http://szpzs.oschina.io/tags/merge/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Map" scheme="http://szpzs.oschina.io/tags/Map/"/>
    
      <category term="put" scheme="http://szpzs.oschina.io/tags/put/"/>
    
  </entry>
  
  <entry>
    <title>原子之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/09/20/eli5-atoms/"/>
    <id>http://szpzs.oschina.io/2016/09/20/eli5-atoms/</id>
    <published>2016-09-20T15:36:59.000Z</published>
    <updated>2016-09-21T00:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img alt="Atom Table" src="/images/eli5-atom-tab.png" style="border: 0;"><br><a id="more"></a><br>原子表是一个全局表，它将原子内部值（一个整数值）映射到一个字符串。同时也有一个反向的查询表，它将一个字符串映射到一个原子内部值。原子表有一个固定的记录条数上限：1048576。如果它一旦到达了这个上限，当前节点将崩溃 －－ 这就是为什么在运行时动态创建原子是很危险的做法。原子表的记录条数上限可以通过给erl命令指定 +t 标签来设置。</p>
<p>原子是在运行时不能改变它的值的一个符号。当一个新的原子被创建，它得到一个唯一的值来给当前节点来使用。原子在系统内部仅仅是指向原子表对应记录索引的整数值。这就是为什么原子的操作如此廉价的原因。</p>
<p>BEAM装载器例程读取原子值并且在原子表里查询它们。它将它们的整数值标记为原子<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>来替代原子名称。然后代码只是操作这些立即数而不是它们的名称。</p>
<p>这些内部值不能当做整数（通过网络或磁盘）离开节点。这是因为其他节点对于相通的原子有不同的内部值。因此当原子离开当前节点的时候都被转换为字符串。这会影响到BEAM文件，外部pid，外部port，Mnesia或DETS里的原子等等。这就是为什么一些开发者更喜欢给数据库字段名使用短原子名称的原因 －－ 它们将以字符串的形式出现在数据库数据中。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img alt=&quot;Atom Table&quot; src=&quot;/images/eli5-atom-tab.png&quot; style=&quot;border: 0;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/categories/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/categories/BEAM/Atom/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/tags/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>BEAM虚拟机之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/09/20/eli5-vm/"/>
    <id>http://szpzs.oschina.io/2016/09/20/eli5-vm/</id>
    <published>2016-09-20T15:30:05.000Z</published>
    <updated>2016-12-15T01:59:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。</p>
<a id="more"></a>
<h2 id="寄存器和调用"><a href="#寄存器和调用" class="headerlink" title="寄存器和调用"></a>寄存器和调用</h2><p>作为一个寄存器虚拟机就意味着在函数调用的时候不是通过栈而是用寄存器来传递参数。它们与我们所理解的CPU架构中的寄存器不一样，而只是一个Erlang数据结构的值所组成的数组。这样的寄存器有1024个，但是有这么多入参的函数几乎不存在，所以通常虚拟机仅仅使用了前面3到10个寄存器。</p>
<p>例如，当调用一个有三个入参的函数的时候，寄存器x0，x1和x2分别被设置为三个入参值。如果我们需要进行递归调用，我们将不得不改写寄存器并丢失它们的原始值。在这种情况下，我们将需要保存旧的值到栈中。除了栈帧外没有动态栈分配，这是由编译器决定的。</p>
<p>每一个进程有自己的寄存器集。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>BEAM指令集包含大约158个基本指令，它们中的大部分可以通过调用 erlc -S yourfile.erl 生成汇编文件来查看到。每一个指令有零或多个参数。不同的技巧用来在便携方式和紧凑方式编码参数。例如，代码中的位置定位（也叫做标签）是用它们的索引来编码的，并且代码装载器后续会把它们翻译成内存地址。</p>
<p>在BEAM代码装载过程中，一些混合的操作码被更快的操作码替换。这个优化的技巧叫做超级指令。对于每一个操作码，在beam_emu.c文件中都有一个C标签对应的一段代码。一个C标签组成的数组存储在同一个虚拟机循环例程的尾部并且被当作查询表来使用。</p>
<p>请参见：<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-file.html" target="_blank" rel="external">BEAM文件格式</a>。<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-instructions.html" target="_blank" rel="external">BEAM指令代码</a>。</p>
<h2 id="线程虚拟机循环"><a href="#线程虚拟机循环" class="headerlink" title="线程虚拟机循环"></a>线程虚拟机循环</h2><p>虚拟机模拟器循环在 emulator/beam/beam_emu.s 里包含许多代码小片段，每一个代码小片段有一个标签和处理一个BEAM指令。它们都属于一个非常长的函数。一个标签表存储在此相同函数里，它被用来作为查询表。</p>
<p>装载操作码被标签地址替换后，紧跟着它们的是参数。例如，操作码 ＃1，一个来自标签数组第一索引元素被置于在代码内存。</p>
<p>这种方式很容易跳转到处理下一个操作码的 C 代码中的某个位置。只需要读一个 void* 指针并执行一个goto *p 的动作。此功能是C和C++编译器的一个扩展。这种类型的虚拟机循环称为直接线程调度虚拟机循环。</p>
<p>其他虚拟机循环的类型有：</p>
<ul>
<li>切换调度虚拟机（如果C编译器拒绝支持标签扩展，则这种类型被BEAM虚拟机源使用）。它也比直接线程调度虚拟机慢20%至30%；</li>
<li>直接调用线程</li>
<li><a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html" target="_blank" rel="external">其他</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-vm.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-vm.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。&lt;/p&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/categories/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.oschina.io/categories/BEAM/VM/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/tags/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.oschina.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>我最喜欢的erlang程序</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/</id>
    <published>2016-09-20T15:17:15.000Z</published>
    <updated>2016-09-20T15:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。</p>
<p>他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。</p>
<a id="more"></a>
<h1 id="通用服务器"><a href="#通用服务器" class="headerlink" title="通用服务器"></a>通用服务器</h1><p>一般来说服务器都是做特定的事情的。一个HTTP服务器响应HTTP请求而一个FTP服务器响应FTP请求，等等。那么什么是通用服务器呢？我们肯定能归纳出一个服务器的概念，然后做出一个通用服务器，并且我们可以在晚些时候让它变成一个特定的服务器。</p>
<p>下面就是我的通用服务器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">universal_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;become, F&#125; -&gt;</div><div class="line">            F()</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个服务器相当简单。一旦我创建了一个通用服务器，它只是呆在那里等待一个 {become, F}消息，收到这样的消息后，他就变成了F服务器。</p>
<h1 id="阶乘服务器"><a href="#阶乘服务器" class="headerlink" title="阶乘服务器"></a>阶乘服务器</h1><p>一个阶乘服务器就是等待一个整数然后返回这个整数的阶乘。下面就是非常简单的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">factorial_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;From, N&#125; -&gt;</div><div class="line">            From ! factorial(N),</div><div class="line">            factorial_server()</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(N)</span> -&gt;</span> N * factorial(N-<span class="number">1</span>).</div></pre></td></tr></table></figure>
<p>现在我们已经准备好high起来了。</p>
<h1 id="把它们集成起来"><a href="#把它们集成起来" class="headerlink" title="把它们集成起来"></a>把它们集成起来</h1><p>我将写一个小函数来创建一个通用服务器，然后给它发送“变成阶乘服务器”消息，接着我将发送一个整数给它，等它返回结果并打印出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></div><div class="line">    Pid = spawn(fun universal_server/0), Pid ! &#123;become, fun factorial_server/0&#125;,</div><div class="line">    Pid ! &#123;self(), <span class="number">50</span>&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        X -&gt;</div><div class="line">            X</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这些函数都属于这个模块  <a href="http://joearms.github.io/code/fav1.erl" target="_blank" rel="external">/code/fav1.erl</a>.</p>
<p>现在我们需要做的就是启动一个Erlang shell并运行这个测试程序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line"><span class="number">1</span> &gt; c(fav1).</div><div class="line">&#123;ok, fav1&#125;</div><div class="line"><span class="number">2</span> &gt; fav1:test().</div><div class="line"><span class="number">30414093201713378043612608166064768844377641568960512000000000000</span></div></pre></td></tr></table></figure>
<h1 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h1><p>多年前当我在SICS的时候，我接触到 <a href="http://www.planet-lab.org/" target="_blank" rel="external">Planet 实验室</a>。Planet 实验室是一个有9000台计算机的研究网络。加入Planet实验室很容易，你所要做的是买一台标准PC，将它连接到网络并捐献它的使用给Planet实验室组织。你捐献你的机器给这个网络，相应的你可以使用Planet实验室里的所有其他机器。</p>
<p>Planet实验室是一个为分布式应用的真实世界的测试环境，它当前有1171个节点在562个站上。</p>
<p>当时我要用Planet实验室来做什么呢？我也不知道。最终我做的是写一些脚本在所有Planet实验的机器上安装了空转的通用服务器（和本文的代码很相似）。然后我设计了一套goosip算法来给这个网络发送 <strong>become</strong> 消息。这样我就有了一个空转的网络，我可以在数秒内将它变成我想要的任何服务器。</p>
<p>大概一年后，我必须要写一篇论文。作为一个研究者，最不划算的一个事情就是为了挣钱养家你必须要写关于这样或那样的论文，这样的论文所写的从来不是你当时感兴趣的，但是却一定是关于资助你研究的项目所期望读到的。</p>
<p>我已经在Planet实验室上建立了我的gossip网络，我可以让它成为任何服务器，因此我让它成为一个内容分发网络并且用一个gossip算法来将一个同样的文件拷贝到这个网络上的所有机器上。最后我把这件事写成一篇论文然后大家都哈皮了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html" target="_blank" rel="external">http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。&lt;/p&gt;
&lt;p&gt;他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的事件驱动应用</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/</id>
    <published>2016-09-20T14:42:13.000Z</published>
    <updated>2016-09-20T15:16:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://en.wikipedia.org/wiki/Event_%28computing%29" target="_blank" rel="external">事件</a> 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门<a href="http://www.erlang.org/doc/design_principles/events.html" target="_blank" rel="external">一章</a>是关于事件的，还有一种 <a href="http://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="external">事件驱动架构</a> 可以让你的代码和架构更牛X：</p>
<ul>
<li>它更易于将你的代码真正地解耦。</li>
<li>它打开了一扇门，通往令人感兴趣的新的架构模式，比如 <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="external">CQRS</a>（命令查询职责分离模式），<a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="external">event sourcing</a>（事件源模式），和<br><a href="http://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="external">event collaboration</a>（事件合作模式）。</li>
<li>应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。</li>
<li>事件和命令能够被非常小的事件处理器来处理。</li>
<li>如果你真的要用事件来开发系统，那么就可能像<a href="http://www.rabbitmq.com/" target="_blank" rel="external">rabbitmq</a>，<a href="http://www.zeromq.org/" target="_blank" rel="external">0mq</a>一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：</li>
<li>系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。</li>
<li>为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。</li>
<li>一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。</li>
</ul>
<a id="more"></a>
<p>Erlang已经提供了一种方式来实现事件驱动架构：gen_event 行为。<a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event</a> 是 Erlang/OTP 自带的<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id59741" target="_blank" rel="external">默认行为</a>之一。对我来说，它也是Erlang/OTP最酷的特性之一，因为你在许多语言或环境里都无法得到这样开箱即用（并且免费）的特性，因此这真的是非常棒。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>Gen_event 有一个或多个事件管理器、事件处理器，来派发和处理事件：</p>
<p><strong>事件管理器</strong>：一个事件管理器是一个 gen_event 进程。<br><strong>事件处理器</strong>：事件处理器是正真处理事件的回调模块，并且被注册到一个或多个事件管理器。<br><strong>事件</strong>：一个事件是任何erlang term，比如一个元组，一个原子，一个列表，等等。</p>
<p>在某些方面，gen_event 用起来像<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>里的<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external">EventEmitter</a>类，在概念上说也像<a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>。这个概念是有某种事件总线（事件管理器）负责接收来自系统的事件并且将它们路由到相应的监听者。其基本的工作流如下：</p>
<ul>
<li>创建一个或者多个实现 <a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event<br>行为</a><br>的回调模块。在本文末尾的<strong>附录B</strong>里有完整的例子。</li>
<li>启动一个事件管理器进程。</li>
<li>注册一个或者多个事件处理器到事件管理器上。</li>
<li>通过事件管理器派发事件。</li>
<li>在你的事件处理器里异步（同步）处理派发过来的事件。</li>
</ul>
<p>现在让我们按顺序研究上述每一步。</p>
<h1 id="启动一个事件管理器"><a href="#启动一个事件管理器" class="headerlink" title="启动一个事件管理器"></a>启动一个事件管理器</h1><p>这就是调用如下函数一样简单：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start().</div></pre></td></tr></table></figure>
<p>或者你计划把你的事件管理器包含在一个<a href="http://www.erlang.org/doc/design_principles/sup_princ.html" target="_blank" rel="external">监督树</a>里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link().</div></pre></td></tr></table></figure>
<h2 id="用一个给定的名字注册一个事件管理器"><a href="#用一个给定的名字注册一个事件管理器" class="headerlink" title="用一个给定的名字注册一个事件管理器"></a>用一个给定的名字注册一个事件管理器</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start(my_event_bus).</div></pre></td></tr></table></figure>
<p>或者也可以：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link(my_event_bus).</div></pre></td></tr></table></figure>
<p>这些函数与start/0以及start_link/0的目的一样，只是它们允许你用一个指定的名字注册一个新的事件管理器。引述<a href="http://www.erlang.org/doc/man/gen_event.html#start_link-1" target="_blank" rel="external">官方文档</a>如下：</p>
<p>如果 EventMgrName={local, Name}，这个事件管理器被以Name为名字用 register/2 本地注册。</p>
<p>如果 EventMgrName={global, GlobalName}，这个事件管理器被以GlobalName为名字用 global:register_name/2 全局注册。</p>
<p>如果没有名字提供，则这个事件管理器不能被注册。</p>
<p>如果 EventManager={via, Module, ViaName}，这个事件管理器将被Module注册到系统。这个回调模块Module应该导出如下函数 register_name/2 ，unregister_name/1 ，whereis_name/1 and send/2，这些函数和global模块里的相应函数的行为一样。因此，{via, global, GlobalName} 是一个有效的引用。</p>
<h1 id="注册事件处理器"><a href="#注册事件处理器" class="headerlink" title="注册事件处理器"></a>注册事件处理器</h1><p>一旦你已经有了你的事件管理器并且把它运行起来了，就该通过用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_handler/3</a> 来添加一些事件处理器了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>上述函数将添加一个新的事件处理器到指定的事件管理器（你传入的第一个入参所指的）。事件管理器可以用如下几种方式指定：</p>
<ul>
<li>进程PID。</li>
<li>Name，如果事件管理器是本地注册的。</li>
<li>{Name, Node}，如果事件管理器是在另一个节点本地注册的，或者 {global,<br>GlobalName}，如果事件管理器是全局注册的。</li>
<li>{via, Module, ViaName}，如果事件管理器的注册是通过一个替代进程注册的。</li>
</ul>
<p>第二个入参指定事件处理器的模块名，不过它也可以是{Module, Id}，Module是回调模块的名字，而当有多个事件处理器用同一个回调模块的时候，Id则用于识别指定的事件处理器。</p>
<p>紧接着my_event_handler里的回调函数 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:init-1" target="_blank" rel="external">init/1</a> 被调用，传给 add_handler/3 的第三个入参将原封不动地传给 init/1 做入参。init/1 可能返回：</p>
<p>如果成功，函数将返回{ok, State} 或 {ok, State, hibernate}，State是事件处理器内部初始状态。</p>
<p>如果返回{ok, State, hibernate}，事件管理器将通过调用 proc_lib:hibernate/3 进入冬眠状态，一直等到下一个事件发生。</p>
<h2 id="被监督的事件处理器"><a href="#被监督的事件处理器" class="headerlink" title="被监督的事件处理器"></a>被监督的事件处理器</h2><p>你可以用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_sup_handler/3</a> 在调用进程（也就是注册新事件处理器的进程）和事件处理器自己之间建立某种形式的监测（或监督）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_sup_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>正如官方文档描述：</p>
<p>如果调用进程后续因为原因Reason而终止，事件管理器将通过用 {stop, Reason} 作为入参调用 Module:terminate/2 来删除事件处理器。</p>
<p>如果事件处理器后来被删除，事件管理器给调用进程发送一个消息 {gen_event_EXIT, Handler, Reason}。Reaseon是下列之一：</p>
<pre><code>normal，如果事件处理器因为 delete_handler/3 的调用而被删除，或者被一个回调函数（见下面段落）返回 remove_handler 。

shutdown，如果事件处理器因为事件管理器结束而被删除。

{swapped, NewHandler, Pid}，如果进程Pid已经调用 swap_handler/3 或 swap_sup_handler/3 来用另一个事件处理器 NewHandler 替换了当前事件处理器。一个term，如果事件处理器因为一个错误而被删除。term的值是依据错误而来的。
</code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>事件处理器是按顺序执行的，所以要尽量保持它的代码短小。如果你需要有上千个事件处理器，那么实现某种<a href="https://gist.github.com/1230182" target="_blank" rel="external">转发器</a>是更好的选择。转发器的思路是有好几个子gen_event订阅一个主gen_event。这样将负载分发给所有感兴趣的监听者。</p>
<p>另一方面，如果你必需要在一个事件处理器里做费时的操作，你应该尝试用一个 <a href="https://gist.github.com/4474770" target="_blank" rel="external">gen_event caster</a>，他将监听事件并派发独特的（普通的）erlang消息。</p>
<p>我们也要注意，当一个被监督的事件处理器退出的时候，gen_event讲给所有的事件处理器<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L319" target="_blank" rel="external">发送消息</a>，因此要准备好如何处理这些消息。</p>
<h1 id="派发事件"><a href="#派发事件" class="headerlink" title="派发事件"></a>派发事件</h1><p>通过事件管理器派发一个事件实际上是相当简单的，仅仅需要调用 <a href="http://www.erlang.org/doc/man/gen_event.html#notify-2" target="_blank" rel="external">gen_event:notify/2</a> 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>你可以在本文的<strong>附录A</strong>里看到gen_event如何派发一个事件的具体细节。</p>
<p>这个函数将异步地派发这个事件。这意味着这个函数调用将不会阻塞而是立即返回。也有同步派发事件的方式，就是使用函数 <a href="http://www.erlang.org/doc/man/gen_event.html#sync_notify-2" target="_blank" rel="external">gen_event:sync_notify/2</a>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:sync_notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>同步在这里的意思是这个函数的调用将阻塞并仅在所有事件处理器已经被调用并且处理了这个事件后才返回。</p>
<h2 id="用消息替代-Notify-2"><a href="#用消息替代-Notify-2" class="headerlink" title="用消息替代 Notify/2"></a>用消息替代 Notify/2</h2><p>另一种方式来调用事件处理器是通过派发普通消息给事件管理器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pid ! &#123;new_user_created&#125;</div></pre></td></tr></table></figure>
<p>这将调用<strong>所有</strong>注册的事件处理器的 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数，gen_event官方文档说明如下：</p>
<p>当一个事件管理器接收到不是事件或者一个同步请求（或者一个系统消息）的任何其他消息时，每一个已经安装在这个事件管理器上的事件处理器的这个函数被调用。</p>
<h1 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h1><p>为了处理由notify/2派发的事件，你的回调模块需要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_event-2" target="_blank" rel="external">handle_event/2</a> 函数，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div></pre></td></tr></table></figure>
<p>另外，为了处理消息，要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(Info, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"Got message: ~p"</span>, [Info]),</div><div class="line">  &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>上面两个例子里的State是由 init/1 返回的数据。</p>
<p>上述两个函数返回值如下所述（当然我们还是引用官方文档）：</p>
<p>如果这个函数返回 {ok, NewState} 或者 {ok, NewState, hibernate} ，这个事件处理器将留在事件管理器里并且带着可能被修改过的内部状态NewState。</p>
<p>如果{ok, NewState, hibernate} 返回，事件管理器也将进入冬眠状态（通过调用 proc_lib:hibernate/3），并等待下一个事件的发生。只要一个事件处理器返回{ok, NewState, hibernate} 则整个事件管理器进程进入冬眠状态。</p>
<p>如果函数返回 {swap_handler, Args1, NewState, Handler2, Args2}，这个事件处理器将被 Handler2 替代，替换过程首先是调用 Module:terminate(Args1, NewState)，然后再调用 Module2:init({Args2, Term}) ，这里的Term是 Module:terminate/2 的返回值。更多信息可以查看 gen_event:swap_handler/3 。</p>
<p>如果函数返回 remove_handler ，这个事件处理器将通过调用 Module:terminate(remove_handler, State)来被删除。</p>
<h1 id="额外事项"><a href="#额外事项" class="headerlink" title="额外事项"></a>额外事项</h1><h2 id="停止事件管理器"><a href="#停止事件管理器" class="headerlink" title="停止事件管理器"></a>停止事件管理器</h2><p>停止事件管理器有时候是必须的并且通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#stop-1" target="_blank" rel="external">stop/1</a> 很容易就做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:stop(my_event_bus).</div></pre></td></tr></table></figure>
<p>这也会引起在所有已经注册的事件处理器上调用 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 。</p>
<h2 id="在一个事件处理器上调用函数"><a href="#在一个事件处理器上调用函数" class="headerlink" title="在一个事件处理器上调用函数"></a>在一个事件处理器上调用函数</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-3" target="_blank" rel="external">call/3</a> 来确切地调用一个事件处理器上指定的函数，就像你在 gen_server上做的一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;).</div></pre></td></tr></table></figure>
<p>和gen_server一样，你可以在调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-4" target="_blank" rel="external">call/4</a> 到时候指定一个超时时间：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;, <span class="number">5000</span>).</div></pre></td></tr></table></figure>
<p>gen_event将调用事件处理器模块的 handle_call/2 回调函数。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, this_is_my_reply, State&#125;.</div></pre></td></tr></table></figure>
<h2 id="删除事件处理器"><a href="#删除事件处理器" class="headerlink" title="删除事件处理器"></a>删除事件处理器</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#delete_handler-3" target="_blank" rel="external">delete_handler/3</a> 来删除你的事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:delete_handler(my_event_bus, my_event_handler, [arg1, arg2]).</div></pre></td></tr></table></figure>
<p>这个函数将从事件管理器删除这个事件处理器，而且也会将第三个参数传给 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 并调用它并将将调用结果返回。</p>
<p>列出所有已经注册的事件处理器</p>
<p>为了列出一个事件管理器当前注册的所有事件处理器，可以调用 <a href="http://www.erlang.org/doc/man/gen_event.html#which_handlers-1" target="_blank" rel="external">which_handlers/1</a> ：</p>
<p>gen_event:which_handlers(my_event_bus).</p>
<h2 id="替换-交换-事件处理器"><a href="#替换-交换-事件处理器" class="headerlink" title="替换 (交换) 事件处理器"></a>替换 (交换) 事件处理器</h2><p>通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_handler-3" target="_blank" rel="external">swap_handler/3</a> 也可以在运行时更换事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:swap_handler(my_event_bus, &#123;my_event_handler, [arg1]&#125;, &#123;my_new_event_handler, [arg2]&#125;).</div></pre></td></tr></table></figure>
<p>整个过程是：首先调用 my_event_handler:terminate([arg1], State) 然后调用 my_new_event_handler:init([arg2])，用一个新的事件处理器替换一个久的事件处理器。</p>
<p>如果老的事件处理器是被监督的，则新的事件处理器也被监督。你当然可以直接用同样的参数调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_sup_handler-3" target="_blank" rel="external">swap_sup_handler/3</a> 来做到。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>再一次我要感谢 <a href="https://github.com/elbrujohalcon" target="_blank" rel="external">Fernando “El Brujo” Benavides</a> 对本文的总体思考，关于gen_event缺陷的评论，以及他分享的gen_event转发器和caster。</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Marcelo Gornstein <a href="marcelo@inakanetworks.com">marcelo@inakanetworks.com</a></p>
<p>Github: <a href="https://github.com/marcelog" target="_blank" rel="external">marcelog</a></p>
<p>Homepage: <a href="http://marcelog.github.com/" target="_blank" rel="external">http://marcelog.github.com</a></p>
<h1 id="附录-A-gen-event实际上是如何派发一个事件的"><a href="#附录-A-gen-event实际上是如何派发一个事件的" class="headerlink" title="附录 A: gen_event实际上是如何派发一个事件的"></a>附录 A: gen_event实际上是如何派发一个事件的</h1><p>函数 notify/2 的实际调用最终在你的erlang/otp源码的 <a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl" target="_blank" rel="external">lib/stdlib/src/gen_event.erl</a> 文件的504行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="keyword">catch</span> Mod1:Func(Event, State) <span class="keyword">of</span></div></pre></td></tr></table></figure>
<p>Func是原子 handle_event 或 handle_info。所以如果你的事件处理器崩溃或不知何故失败了，事件管理器是不会崩溃的。</p>
<p>如果运行一个被监督的事件处理器（用add_sup_handler/3启动的），在同一个文件的<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L635" target="_blank" rel="external">635行</a>的 terminate/2 函数被调用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Res = (<span class="keyword">catch</span> Mod:terminate(Args, State)),</div></pre></td></tr></table></figure>
<p>另外，被监督的事件处理器，在<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L648" target="_blank" rel="external">648行</a>一个消息被发送给这个事件处理器注册到的进程</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Handler#handler.supervised <span class="keyword">of</span></div><div class="line">  <span class="literal">false</span> -&gt;</div><div class="line">      ok;</div><div class="line">  Pid -&gt;</div><div class="line">      Pid ! &#123;gen_event_EXIT,handler(Handler),Reason&#125;,</div><div class="line">      ok</div><div class="line">  <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="附录-B-回调模块样例"><a href="#附录-B-回调模块样例" class="headerlink" title="附录 B: 回调模块样例"></a>附录 B: 回调模块样例</h1><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_event_handler)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">  init/<span class="number">1</span>, terminate/<span class="number">2</span>, handle_info/<span class="number">2</span>,</div><div class="line">  handle_call/<span class="number">2</span>, code_change/<span class="number">3</span>, handle_event/<span class="number">2</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  &#123;ok, []&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, not_implemented, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(_Event, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Arg, _State)</span> -&gt;</span></div><div class="line">  ok.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://inaka.net/blog/2013/01/21/erlang-event-driven/" target="_blank" rel="external">http://inaka.net/blog/2013/01/21/erlang-event-driven/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Event_%28computing%29&quot;&gt;事件&lt;/a&gt; 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门&lt;a href=&quot;http://www.erlang.org/doc/design_principles/events.html&quot;&gt;一章&lt;/a&gt;是关于事件的，还有一种 &lt;a href=&quot;http://en.wikipedia.org/wiki/Event-driven_architecture&quot;&gt;事件驱动架构&lt;/a&gt; 可以让你的代码和架构更牛X：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它更易于将你的代码真正地解耦。&lt;/li&gt;
&lt;li&gt;它打开了一扇门，通往令人感兴趣的新的架构模式，比如 &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;（命令查询职责分离模式），&lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;event sourcing&lt;/a&gt;（事件源模式），和&lt;br&gt;&lt;a href=&quot;http://martinfowler.com/eaaDev/EventCollaboration.html&quot;&gt;event collaboration&lt;/a&gt;（事件合作模式）。&lt;/li&gt;
&lt;li&gt;应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。&lt;/li&gt;
&lt;li&gt;事件和命令能够被非常小的事件处理器来处理。&lt;/li&gt;
&lt;li&gt;如果你真的要用事件来开发系统，那么就可能像&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;rabbitmq&lt;/a&gt;，&lt;a href=&quot;http://www.zeromq.org/&quot;&gt;0mq&lt;/a&gt;一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：&lt;/li&gt;
&lt;li&gt;系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。&lt;/li&gt;
&lt;li&gt;为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。&lt;/li&gt;
&lt;li&gt;一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="event-driven" scheme="http://szpzs.oschina.io/categories/Erlang/event-driven/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="event-driven" scheme="http://szpzs.oschina.io/tags/event-driven/"/>
    
      <category term="application" scheme="http://szpzs.oschina.io/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS的查询、分页和并发的数据插入</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</id>
    <published>2016-09-20T14:18:06.000Z</published>
    <updated>2016-09-20T14:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">上星期的Erlang Thursday</a>的结尾，我说我们将继续研究ets模块的select函数的特性。</p>
<p>所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">TestOrderedSetTable = ets:new(ordered_set_table, [public, ordered_set]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line"><span class="comment">% 20499</span></div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:give_away(TestOrderedSetTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>接着我们给我们的测试ETS表装载一些测试数据，在数据的序列中留出一些空隙，为了后面我们填补这些空隙。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>然后我们从表里查询所有数据，我们可以看到不同类型的表的数据排序是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;]</span></div></pre></td></tr></table></figure>
<p>ets模块也有一个函数 <a href="http://erlang.org/doc/man/ets.html#select_reverse-2" target="_blank" rel="external">ets:select_reverse</a> ，我们停下来看一看它能做些什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select_reverse(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select_reverse(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;]</span></div></pre></td></tr></table></figure>
<p>我们比较 ets:select/2 和 ets:select_reverse/2 的结果，TestTable的结果是一样的，而TestOrderedSetTable的结果刚好是反序，这个结果和官方文档对 ets:select_reverse/2 描述一样。其实我们思考一下也就明白了。</p>
<p>结束了这个简单的小插曲，我们接着运行我们上面相同的匹配规则只是结果集限制在5个纪录，同时我们得到一个continuation。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;Result, Continuation&#125; = ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;19,19&#125;,&#123;29,29&#125;,&#123;27,27&#125;,&#123;17,17&#125;,&#123;5,5&#125;],</span></div><div class="line"><span class="comment">% &#123;20499,214,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">&#123;OrdSetResult, OrdSetContinuation&#125; = ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;3,3&#125;,&#123;5,5&#125;,&#123;7,7&#125;,&#123;9,9&#125;],&#123;16402,9,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>有了这些continuation，我们看看我们取回来的下一个结果集是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;23,23&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;9,9&#125;],&#123;20499,111,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;11,11&#125;,&#123;13,13&#125;,&#123;15,15&#125;,&#123;17,17&#125;,&#123;19,19&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,19,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>还记得我们用来创建元组的数字序列里留的那些间隙吗？</p>
<p>现在来看看我们填上那些序列间隙，同时我们用已经获取的continuation来查询数据会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>现在我们用前面获取到的continuation重新运行 ets:select/1 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;12,12&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;10,10&#125;,&#123;9,9&#125;],</span></div><div class="line"><span class="comment">%  &#123;20499,224,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;10,10&#125;,&#123;11,11&#125;,&#123;12,12&#125;,&#123;13,13&#125;,&#123;14,14&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,14,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们比较以前的结果，我们看到现在的结果里有了偶数元素在列表里。对于我们的 TestTable ，如果我们看上面的Continuation变量的值，它有一个continuation 的点，值是214，因为它是当前continuation和调用 ets:select(Countinuation) 后的结果continuation里唯一变化的值，所以通过这个值我们很难推断continuation的变化。</p>
<p>另一方面，OrdsetContinuation，它的第二个元素的值是9，也就是ETS表id 16402 后面的元素。而后面其它的continuation的这个值分别是19和14也碰巧和对应结果集的最后元素匹配上。因此在有序集合的情况下，我们能推断作为ordered_set类型的ETS表的continuation的一部分，这个continuation告诉我们返回结果集里最后纪录的键，我们可以不管任何同时插入动作发生而继续从这个纪录开始获取数据。</p>
<p>下次我们将看看 ets:is_compiled_ms/1 这个函数，并基于对官方文档的该函数的阅读，我们如何将匹配规则应用在continuation上。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;的结尾，我说我们将继续研究ets模块的select函数的特性。&lt;/p&gt;
&lt;p&gt;所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/select/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
  </entry>
  
</feed>
