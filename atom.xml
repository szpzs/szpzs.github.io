<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2017-02-01T11:48:47.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elixir入门教程－二进制数据，字符串 和 字符列表</title>
    <link href="http://szpzs.oschina.io/2017/02/01/elixir-getting-started-binaries-strings-and-char-lists/"/>
    <id>http://szpzs.oschina.io/2017/02/01/elixir-getting-started-binaries-strings-and-char-lists/</id>
    <published>2017-02-01T11:43:38.000Z</published>
    <updated>2017-02-01T11:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">UTF-8和Unicode</a></li>
<li><a href="#part-two">二进制数据（和位串）</a></li>
<li><a href="#part-three">字符列表</a></li>
</ol>
<p>在“基本类型”那一章，我们学到了字符串以及使用 is_binary/1 函数来检查它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; string = <span class="string">"hello"</span></div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; is_binary(string)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>在本章，我们将理解二进制数据是什么；它们如何和字符串联系在一起；在Elixir里，被单引号括起来的值，比如 ‘like this’，是什么。</p>
<a id="more"></a>
<h1 id="UTF-8和Unicode"><a href="#UTF-8和Unicode" class="headerlink" title="UTF-8和Unicode"></a><span id="part-one">UTF-8和Unicode</span></h1><p>一个字符串是一个用UTF-8编码的二进制数据。为了确切理解我们的意思，我们需要理解字节和代码点之间的区别。</p>
<p>Unicode标准给我们所知的许多字符赋予了代码点。比如，字母 a 有代码点 97，而字母 ł 有代码点322。当将字符串 “hełło” 写到磁盘上时，我们需要将它的代码点转换为若干字节。如果我们采用的规则是，一个字节表示一个代码点，那么我们将无法写字符串 “hełło” ，因为它使用了代码点322来表示字母 ł ，而一个字节只能表示 0 到 255的数字。理所当然地，你要正确地在屏幕上读出字符串 “hełło” ，它必须被以某种方式表达出来。这就是编码应用之处了。</p>
<p>用字节的方式来表达代码点的时候，我们需要以某种方式编码它们。Elixir选择UTF-8编码作为它主要的和默认的编码。当我们说一个字符串是一个UTF-8编码的二进制数据，我们的意思是一个字符串是以一种方式，比如指定的UTF-8编码，来组织的表达某些代码点的一块二进制数据。</p>
<p>因为我们有字母，像 ł 被赋予代码点322，所以我们的确需要多于一个字节来表达它们。这就是为什么我们看到的 byte_size/1 和 String.length/1 之间有区别：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; string = <span class="string">"hełło"</span></div><div class="line"><span class="string">"hełło"</span></div><div class="line">iex&gt; byte_size(string)</div><div class="line"><span class="number">7</span></div><div class="line">iex&gt; String.length(string)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>byte_size/1 计算的是底层的字节数，而 String.length/1 计算的是字符数。</p>
<blockquote>
<p>注意：如果你用的是Windows，你的终端可能不是默认用UTF-8编码。你可以在运行iex（iex.bat）前通过运行 chcp 65001 来改变你当前会话的编码。</p>
</blockquote>
<p>UTF-8需要一个字节来表达字符 h，e 和 o ，但是需要两个字节表达字符 ł 。在Elixir里，你可以用 ? 来获得一个字符的代码点：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; ?a</div><div class="line"><span class="number">97</span></div><div class="line">iex&gt; ?ł</div><div class="line"><span class="number">322</span></div></pre></td></tr></table></figure>
<p>你也可以用String模块里的函数将一个字符串分割为独立字符串组成的列表，其中每一个字符串是长度为一。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.codepoints(<span class="string">"hełło"</span>)</div><div class="line">[<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"ł"</span>, <span class="string">"ł"</span>, <span class="string">"o"</span>]</div></pre></td></tr></table></figure>
<p>你将看到Elixir已经非常好地支持字符串操作。它也支持许多Unicode操作。实际上，Elixir通过了<a href="http://mortoray.com/2013/11/27/the-string-type-is-broken/" target="_blank" rel="external">“The string type is broken”</a>里的所有测试。</p>
<p>然后，字符串只是本文的一部分内容。如果一个字符串是一个二进制数据，并且我们也对它使用了is_binary/1函数，那么Elixir必须有一个底层类型来支持字符串。它的确是这么做的！下面我们来谈谈二进制数据。</p>
<h1 id="二进制数据（和位串）"><a href="#二进制数据（和位串）" class="headerlink" title="二进制数据（和位串）"></a><span id="part-two">二进制数据（和位串）</span></h1><p>在Elixir里，你可以用&lt;&lt;&gt;&gt;来定义一个二进制数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">iex&gt; byte_size(&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>一个二进制数据是一个字节的序列。这些字节可以用任何方式来组织，甚至这些字节序列不是有效的字符串：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.valid?(&lt;&lt;<span class="number">239</span>, <span class="number">191</span>, <span class="number">191</span>&gt;&gt;)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>字符串的串联操作实际上是二进制数据的串联操作：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>&gt;&gt; &lt;&gt; &lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>在Elixir里的一个通用技巧是将空字节&lt;<0>&gt;串联在一个字符串后以便看看它内部的二进制表示：</0></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hełło"</span> &lt;&gt; &lt;&lt;<span class="number">0</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">104</span>, <span class="number">101</span>, <span class="number">197</span>, <span class="number">130</span>, <span class="number">197</span>, <span class="number">130</span>, <span class="number">111</span>, <span class="number">0</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>赋给一个二进制数据的每一个数字都表示一个字节，由此它的值最大是255。二进制数据允许给定修饰语来存储大于255的数字，或者转换一个代码点为它的UTF-8编码表示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">255</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">255</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span>&gt;&gt; # truncated</div><div class="line">&lt;&lt;<span class="number">0</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: size(<span class="number">16</span>)&gt;&gt; # use <span class="number">16</span> bits (<span class="number">2</span> bytes) to store the number</div><div class="line">&lt;&lt;<span class="number">1</span>, <span class="number">0</span>&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: utf8&gt;&gt; # the number is a code point</div><div class="line"><span class="string">"Ā"</span></div><div class="line">iex&gt; &lt;&lt;<span class="number">256</span> :: utf8, <span class="number">0</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">196</span>, <span class="number">128</span>, <span class="number">0</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>如果一个字节有8位，那么我们只给它一位会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">1</span>::size(<span class="number">1</span>)&gt;&gt;</div><div class="line">iex&gt; &lt;&lt;<span class="number">2</span> :: size(<span class="number">1</span>)&gt;&gt; # truncated</div><div class="line">&lt;&lt;<span class="number">0</span>::size(<span class="number">1</span>)&gt;&gt;</div><div class="line">iex&gt; is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; is_bitstring(&lt;&lt;<span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; bit_size(&lt;&lt; <span class="number">1</span> :: size(<span class="number">1</span>)&gt;&gt;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>结果是这个值不再是一个二进制数据，而是一个位串 – 一些位。所以一个二进制数据是一个位串，它的位的数量被8整除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt;  is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">16</span>)&gt;&gt;)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt;  is_binary(&lt;&lt;<span class="number">1</span> :: size(<span class="number">15</span>)&gt;&gt;)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>我们也可以在二进制数据或位串上进行模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;&gt;</div><div class="line">iex&gt; x</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>注意：在二进制模式中的每一个元素都被期望刚好匹配8位。如果我们想要匹配一个未知大小的二进制数据，在模式的尾部通过使用二进制数据修饰语是可能做到的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, x :: binary&gt;&gt; = &lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">&lt;&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div><div class="line">iex&gt; x</div><div class="line">&lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>相似的结果可以用字符串串联符&lt;&gt;来实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"he"</span> &lt;&gt; rest = <span class="string">"hello"</span></div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; rest</div><div class="line"><span class="string">"llo"</span></div></pre></td></tr></table></figure>
<p>关于二进制数据或位串的构造器&lt;&lt;&gt;&gt;的完整指导可以在<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1" target="_blank" rel="external">Elixir官方文档</a>里找到。到此，我们结束了位串，二进制数据和字符串之旅。字符串是UTF-8编码的二进制数据；二进制数据是位串，它的位的数量被8整除。虽然这表明Elixir提供了处理位和字节的灵活性，不过你的99%的时间将用来处理二进制数据，并且使用 is_binary/1 和 byte_size/1 函数。</p>
<h1 id="字符列表"><a href="#字符列表" class="headerlink" title="字符列表"></a><span id="part-three">字符列表</span></h1><p>一个字符列表就是一个代码点列表。字符列表可以用单引号括起来的字符字面值创建：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; 'hełło'</div><div class="line">[<span class="number">104</span>, <span class="number">101</span>, <span class="number">322</span>, <span class="number">322</span>, <span class="number">111</span>]</div><div class="line">iex&gt; is_list 'hełło'</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; 'hello'</div><div class="line">'hello'</div><div class="line">iex&gt; List.first('hello')</div><div class="line"><span class="number">104</span></div></pre></td></tr></table></figure>
<p>你可以看到，不是包含字节，一个字符列表包含单引号之间的字符的代码点（注意：默认情况下如果任何整数值在ASCII范围外，则IEx将只是输出代码点）。那么，双引号表示字符串（即二进制数据），单引号表示字符列表（即列表）。</p>
<p>在实践中，字符列表主要用于与Erlang交互的时候，特别是不接受二进制数据作为参数的旧库。你可以用 to_charlist/1 和 to_string/1 函数来转换字符列表为字符串或者反之将字符串转换为字符列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; to_charlist <span class="string">"hełło"</span></div><div class="line">[<span class="number">104</span>, <span class="number">101</span>, <span class="number">322</span>, <span class="number">322</span>, <span class="number">111</span>]</div><div class="line">iex&gt; to_string 'hełło'</div><div class="line"><span class="string">"hełło"</span></div><div class="line">iex&gt; to_string :hello</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; to_string <span class="number">1</span></div><div class="line"><span class="string">"1"</span></div></pre></td></tr></table></figure>
<p>注意：这些函数是多态的。它们不仅可以转换字符列表为字符串，也可以转换整数为字符串，转换原子为字符串，等等。</p>
<p>介绍完二进制数据，字符串和字符列表，接下来是时候讲讲键值对数据结构了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;UTF-8和Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;二进制数据（和位串）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;字符列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在“基本类型”那一章，我们学到了字符串以及使用 is_binary/1 函数来检查它：&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; string = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; is_binary(string)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在本章，我们将理解二进制数据是什么；它们如何和字符串联系在一起；在Elixir里，被单引号括起来的值，比如 ‘like this’，是什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="binary-string-char list" scheme="http://szpzs.oschina.io/categories/Elixir/binary-string-char-list/"/>
    
    
      <category term="string" scheme="http://szpzs.oschina.io/tags/string/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="binary" scheme="http://szpzs.oschina.io/tags/binary/"/>
    
      <category term="char list" scheme="http://szpzs.oschina.io/tags/char-list/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－case，cond 和 if</title>
    <link href="http://szpzs.oschina.io/2017/01/31/elixir-getting-started-case-cond-and-if/"/>
    <id>http://szpzs.oschina.io/2017/01/31/elixir-getting-started-case-cond-and-if/</id>
    <published>2017-01-31T11:35:56.000Z</published>
    <updated>2017-01-31T11:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">case</a></li>
<li><a href="#part-two">卫语句里的表达式</a></li>
<li><a href="#part-three">cond</a></li>
<li><a href="#part-four">if 和 unless</a></li>
<li><a href="#part-five">do/end 块</a></li>
</ol>
<p>在本章，我们将学习 case，cond 和 if 这几个控制流结构。</p>
<a id="more"></a>
<h1 id="case"><a href="#case" class="headerlink" title="case"></a><span id="part-one">case</span></h1><p>case允许我们将一个值和许多模式进行比较直到我们找到一个匹配的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; do</div><div class="line">...&gt;   &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; -&gt;</div><div class="line">...&gt;     <span class="string">"This clause won't match"</span></div><div class="line">...&gt;   &#123;<span class="number">1</span>, x, <span class="number">3</span>&#125; -&gt;</div><div class="line">...&gt;     <span class="string">"This clause will match and bind x to 2 in this clause"</span></div><div class="line">...&gt;   _ -&gt;</div><div class="line">...&gt;     <span class="string">"This clause would match any value"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This clause will match and bind x to 2 in this clause"</span></div></pre></td></tr></table></figure>
<p>如果你想模式匹配已经存在的变量，你需要使用 ^ 运算符：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="keyword">case</span> <span class="number">10</span> do</div><div class="line">...&gt;   ^x -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt;   _  -&gt; <span class="string">"Will match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Will match"</span></div></pre></td></tr></table></figure>
<p>分支语句也允许用卫语句来指定额外的条件：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; do</div><div class="line">...&gt;   &#123;<span class="number">1</span>, x, <span class="number">3</span>&#125; <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Will match"</span></div><div class="line">...&gt;   _ -&gt;</div><div class="line">...&gt;     <span class="string">"Would match, if guard condition were not satisfied"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Will match"</span></div></pre></td></tr></table></figure>
<p>上例中第一个分支语句仅在x大于零的时候才被匹配上。</p>
<h1 id="卫语句里的表达式"><a href="#卫语句里的表达式" class="headerlink" title="卫语句里的表达式"></a><span id="part-two">卫语句里的表达式</span></h1><p>Elixir默认导入和允许下述表达式在卫语句里：</p>
<ul>
<li>比较运算符（==，!=，===，!==，&gt;， &gt;=， &lt;， &lt;=）</li>
<li>布尔运算符（and，or，not）</li>
<li>算术运算符（+， -， *， /）</li>
<li>一元算术运算符（+， -）</li>
<li>二进制数据串联运算符 &lt;&gt;</li>
<li>in 运算符，只要它右边是一个范围或者一个列表</li>
<li><p>所有下述类型检查函数：</p>
<pre><code>* is_atom/1
* is_binary/1
* is_bitstring/1
* is_boolean/1
* is_float/1
* is_function/1
* is_function/2
* is_integer/1
* is_list/1
* is_map/1
* is_nil/1
* is_number/1
* is_pid/1
* is_port/1
* is_reference/1
* is_tuple/1
</code></pre></li>
<li><p>加上下面的函数</p>
<pre><code>* abs(number)
* binary_part(binary, start, length)
* bit_size(bitstring)
* byte_size(bitstring)
* div(integer, integer)
* elem(tuple, n)
* hd(list)
* length(list)
* map_size(map)
* node()
* node(pid | ref | port)
* rem(integer, integer)
* round(number)
* self()
* tl(list)
* trunc(number)
* tuple_size(tuple)
</code></pre></li>
</ul>
<p>另外，用户可以定义他们自己的卫语句。例如，Bitwise模块定义作为函数和运算符的卫语句：bnot，~~~，band，&amp;&amp;&amp;，bor，|||，bxor，^^^，bsl，&lt;&lt;&lt;，bsr，&gt;&gt;&gt;。</p>
<p>注意，虽然布尔运算符，比如：and，or 和 not 运行在卫语句里使用，但是更加通用的运算符 &amp;&amp;，|| 和 ! 却不被允许在卫语句里使用。</p>
<p>切记：卫语句里的错误不会被抛出，而是使得卫语句失败：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; hd(<span class="number">1</span>)</div><div class="line">** (ArgumentError) argument error</div><div class="line">iex&gt; <span class="keyword">case</span> <span class="number">1</span> do</div><div class="line">...&gt;   x <span class="keyword">when</span> hd(x) -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt;   x -&gt; <span class="string">"Got #&#123;x&#125;"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"Got 1"</span></div></pre></td></tr></table></figure>
<p>如果没有一个分支匹配，则有错误抛出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">case</span> :ok do</div><div class="line">...&gt;   :error -&gt; <span class="string">"Won't match"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CaseClauseError) no <span class="keyword">case</span> clause matching: :ok</div></pre></td></tr></table></figure>
<p>注意：匿名函数也可以有多个分支和卫语句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; f = fn</div><div class="line">...&gt;   x, y <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt; x + y</div><div class="line">...&gt;   x, y -&gt; x * y</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">12.71889879</span>/<span class="number">2</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; f.(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line"><span class="number">4</span></div><div class="line">iex&gt; f.(-<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">-3</div></pre></td></tr></table></figure>
<p>匿名函数每个分支的入参格式必须相同，否则有错误抛出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; f2 = fn</div><div class="line">...&gt;   x, y <span class="keyword">when</span> x &gt; <span class="number">0</span> -&gt; x + y</div><div class="line">...&gt;   x, y, z -&gt; x * y + z</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) iex:<span class="number">1</span>: cannot mix clauses with different arities in function definition</div></pre></td></tr></table></figure>
<h1 id="cond"><a href="#cond" class="headerlink" title="cond"></a><span id="part-three">cond</span></h1><p>当你要匹配不同的值的时候，case语句有用。然而，在许多情况中，我们想要检查不同的条件并且找到第一个为true的条件。在这样的场景下，可以使用cond：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This will not be true"</span></div><div class="line">...&gt;   <span class="number">2</span> * <span class="number">2</span> == <span class="number">3</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Nor this"</span></div><div class="line">...&gt;   <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> -&gt;</div><div class="line">...&gt;     <span class="string">"But this will"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"But this will"</span></div></pre></td></tr></table></figure>
<p>这和许多命令式语言里的 else if 分支等效（虽然不常在这里使用的方法）。</p>
<p>如果没有一个条件返回true，则一个错误（CondClauseError）被抛出。因为这个原因，增加一个最后条件，它等于true，这个条件将总是可以匹配到，这样的做法可能是必要的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   <span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This is never true"</span></div><div class="line">...&gt;   <span class="number">2</span> * <span class="number">2</span> == <span class="number">3</span> -&gt;</div><div class="line">...&gt;     <span class="string">"Nor this"</span></div><div class="line">...&gt;   <span class="literal">true</span> -&gt;</div><div class="line">...&gt;     <span class="string">"This is always true (equivalent to else)"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This is always true (equivalent to else)"</span></div></pre></td></tr></table></figure>
<p>最后，要注意：cond认为除nil和false外，任何值都是true：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">cond</span> do</div><div class="line">...&gt;   hd([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) -&gt;</div><div class="line">...&gt;     <span class="string">"1 is considered as true"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"1 is considered as true"</span></div></pre></td></tr></table></figure>
<h1 id="if-和-unless"><a href="#if-和-unless" class="headerlink" title="if 和 unless"></a><span id="part-four">if 和 unless</span></h1><p>除了case和cond，Elixir也提供宏：if/2 和 unless/2 ，它们在你需要仅仅检查一个条件的时候很有用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;   <span class="string">"This works!"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This works!"</span></div><div class="line">iex&gt; unless <span class="literal">true</span> do</div><div class="line">...&gt;   <span class="string">"This will never be seen"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">nil</div></pre></td></tr></table></figure>
<p>如果给予if/2的条件返回false或nil，则do/end之间的语句不会被执行，并且if/2的整体返回值是nil。unless/2的情况则相反。</p>
<p>它们也支持else块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> nil do</div><div class="line">...&gt;   <span class="string">"This won't be seen"</span></div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="string">"This will"</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="string">"This will"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：一个关于if/2和unless/2的有趣的注意事项是在Elixir里它们被实现为宏；它们不像在其他语言那样是一个特殊的语言结构。你可以参阅官方文档和<a href="https://hexdocs.pm/elixir/Kernel.html" target="_blank" rel="external">Kernel模块的文档</a>中if/2的说明。Kernel模块里也定义了像+/2这样的运算符和像is_function/2这样的函数，这些函数都默认地被自动导入并在你的代码中可用。</p>
</blockquote>
<h1 id="do-end块"><a href="#do-end块" class="headerlink" title="do/end块"></a><span id="part-five">do/end块</span></h1><p>到此，我们已经学了四种控制结构：case、cond、if 和 unless ，它们都包裹在 do/end 块里。我们也可以像下面这样写 if 控制结构：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span>, do: <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>注意上面的例子在 true 和 do: 之间有一个逗号，这是因为它使用了Elixir的正规语法，每个参数用逗号分割。我们说这个语法是用<em>关键字列表</em>。我们也可以传递 else 使用关键字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">false</span>, do: :this, else: :that</div><div class="line">:that</div></pre></td></tr></table></figure>
<p>do/end是构建于关键字上的语法便利措施。这就是为什么在前面的参数和语句块之间不需要逗号。它的确非常有用，因为当写代码块的时候它删除了冗余。下面的例子是等效的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;   a = <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt;   a + <span class="number">10</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">13</span></div><div class="line">iex&gt; <span class="keyword">if</span> <span class="literal">true</span>, do: (</div><div class="line">...&gt;   a = <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt;   a + <span class="number">10</span></div><div class="line">...&gt; )</div><div class="line"><span class="number">13</span></div></pre></td></tr></table></figure>
<p>有一件事要记住，当你使用do/end的时候，它们总是和最外层函数调用绑定的。例如，下面的表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number <span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) undefined function: is_number/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>将被解析为：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number(<span class="keyword">if</span> <span class="literal">true</span>) do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">** (CompileError) undefined function: is_number/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>这将导致一个未定义函数错误，因为这个调用传递两个参数，而 is_number/2 并不存在。if true 表达式在这里是无效的，因为它需要代码块；而因为 is_number/2 的参数个数不匹配，Elixir根本就没有调用到它。</p>
<p>增加明确的括号就足以绑定代码块到 if ：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_number(<span class="keyword">if</span> <span class="literal">true</span> do</div><div class="line">...&gt;  <span class="number">1</span> + <span class="number">2</span></div><div class="line">...&gt; <span class="keyword">end</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>关键字列表Elixir里扮演很重要的角色，并且在许多函数和宏里普遍存在。在后续的章节里我们将进一步探索它们。接下来，我们讨论“二进制、字符串和字符列表”。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/case-cond-and-if.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/case-cond-and-if.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;case&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;卫语句里的表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;cond&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;if 和 unless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;do/end 块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本章，我们将学习 case，cond 和 if 这几个控制流结构。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="control flow structure" scheme="http://szpzs.oschina.io/categories/Elixir/control-flow-structure/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="control flow structure" scheme="http://szpzs.oschina.io/tags/control-flow-structure/"/>
    
      <category term="case" scheme="http://szpzs.oschina.io/tags/case/"/>
    
      <category term="cond" scheme="http://szpzs.oschina.io/tags/cond/"/>
    
      <category term="if" scheme="http://szpzs.oschina.io/tags/if/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－模式匹配</title>
    <link href="http://szpzs.oschina.io/2017/01/30/elixir-getting-started-pattern-matching/"/>
    <id>http://szpzs.oschina.io/2017/01/30/elixir-getting-started-pattern-matching/</id>
    <published>2017-01-30T11:31:59.000Z</published>
    <updated>2017-01-30T11:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">匹配运算符</a></li>
<li><a href="#part-two">模式匹配</a></li>
<li><a href="#part-three">pin运算符</a></li>
</ol>
<p>在本章，我们将展示给大家 = 运算符在Elixir里如何实际上是一个匹配运算符的以及如何用它来模式匹配数据结构里的数据。最后，我们将学习pin运算符 ^，它被用来访问变量之前被绑定的值。</p>
<a id="more"></a>
<h1 id="匹配运算符"><a href="#匹配运算符" class="headerlink" title="匹配运算符"></a><span id="part-one">匹配运算符</span></h1><p>我们已经用过几次 = 运算符在Elixir里给变量赋值：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; x</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>在Elixir里，= 运算符实际上被称为<em>匹配运算符</em>。让我们来看看究竟：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> = x</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="number">2</span> = x</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们注意到 1 = x 是一个有效表达式，而它匹配的原因是因为左右两边都等于1。当两边不匹配的时候，一个MatchError错误抛出。</p>
<p>变量被赋值的时候只能够处于 = 运算符的左边：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> = unknown</div><div class="line">** (CompileError) iex:<span class="number">1</span>: undefined function unknown/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>因为之前没有定义unknown变量，Elixir就假设你是想尝试调用 unknown/0 这个函数，但是这样的函数并不存在。</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a><span id="part-two">模式匹配</span></h1><p>匹配运算符不仅是用来匹配简单的值，而且对于解构更复杂的数据类型也是有用的。例如，我们可以在元组上进行模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = &#123;:hello, <span class="string">"world"</span>, <span class="number">42</span>&#125;</div><div class="line">&#123;:hello, <span class="string">"world"</span>, <span class="number">42</span>&#125;</div><div class="line">iex&gt; a</div><div class="line">:hello</div><div class="line">iex&gt; b</div><div class="line"><span class="string">"world"</span></div></pre></td></tr></table></figure>
<p>在两边不匹配的情况下模式匹配将出错。例如下面的例子，当元组有不同的大小的时候：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = &#123;:hello, <span class="string">"world"</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;:hello, <span class="string">"world"</span>&#125;</div></pre></td></tr></table></figure>
<p>或者两边的数据类型不一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;a, b, c&#125; = [:hello, <span class="string">"world"</span>, <span class="number">42</span>]</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: [:hello, <span class="string">"world"</span>, <span class="number">42</span>]</div></pre></td></tr></table></figure>
<p>更有趣地是，我们可以在指定的值上进行匹配。比如下面的例子就断言当右边是一个以原子 :ok 开始的元组的时候左边才和右边匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;:ok, result&#125; = &#123;:ok, <span class="number">13</span>&#125;</div><div class="line">&#123;:ok, <span class="number">13</span>&#125;</div><div class="line">iex&gt; result</div><div class="line"><span class="number">13</span></div><div class="line"></div><div class="line">iex&gt; &#123;:ok, result&#125; = &#123;:error, :oops&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;:error, :oops&#125;</div></pre></td></tr></table></figure>
<p>我们也可以在列表上模式匹配：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; a</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>列表也支持匹配它的头部和尾部：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; [head | tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; head</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; tail</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>像 hd/1 和 tl/1 函数一样，我们不能用一个头部和尾部的模式来匹配一个空列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; [h | t] = []</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: []</div></pre></td></tr></table></figure>
<p>[head | tail] 格式不仅用在模式匹配而且也可以用在给列表加元素上：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; [<span class="number">0</span> | list]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>模式匹配允许开发者很容易地解构诸如元组和列表这样的数据类型。正如我们将在接下来的章节看到的，这是Elixir递归的基础之一，并且也应用于像map和二进制数据等其他类型。</p>
<h1 id="pin运算符"><a href="#pin运算符" class="headerlink" title="pin运算符"></a><span id="part-three">pin运算符</span></h1><p>Elixir的变量可以重新绑定：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; x = <span class="number">2</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>当你想模式匹配已经存在的变量的值而不是重新绑定这个变量的时候，pin运算符 ^ 就有用处了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; ^x = <span class="number">2</span></div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: <span class="number">2</span></div><div class="line">iex&gt; &#123;y, ^x&#125; = &#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">iex&gt; y</div><div class="line"><span class="number">2</span></div><div class="line">iex&gt; &#123;y, ^x&#125; = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>因为我们已经将1赋值给变量x，上述最后一个表达式也可以写成下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;y, <span class="number">1</span>&#125; = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>如果一个变量在一个模式里出现了不止一次，则所有对它的引用都应该绑定到相同的模式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;x, x&#125; = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">iex&gt; &#123;x, x&#125; = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">** (MatchError) no match <span class="keyword">of</span> right hand side value: &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>在一些场景里，你不关心模式里的某个特别的值。通用的做法是将这些值绑定到下划线，_ 。例如，如果仅是列表头部是我们需要的，我们可以将尾部赋给下划线：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [h | _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; h</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>变量 _ 在这里很特别，它永远不会被读取。如果尝试取读取它，会得到一个 未绑定变量 的错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; _</div><div class="line">** (CompileError) iex:<span class="number">1</span>: unbound variable _</div></pre></td></tr></table></figure>
<p>虽然模式匹配允许我们构建非常有用的结构，但是它的用法是有限制的。例如，你不能在匹配的左边调用函数。下面的例子就是无效的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; length([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]) = <span class="number">3</span></div><div class="line">** (CompileError) iex:<span class="number">1</span>: illegal pattern</div></pre></td></tr></table></figure>
<p>到此就完成了我们的模式匹配介绍。正如我们将在下一章看到的，模式匹配在Elixir的许多语言构造里是非常普遍的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="">http://elixir-lang.org/getting-started/pattern-matching.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;匹配运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;模式匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;pin运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本章，我们将展示给大家 = 运算符在Elixir里如何实际上是一个匹配运算符的以及如何用它来模式匹配数据结构里的数据。最后，我们将学习pin运算符 ^，它被用来访问变量之前被绑定的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="pattern match" scheme="http://szpzs.oschina.io/categories/Elixir/pattern-match/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="pattern match" scheme="http://szpzs.oschina.io/tags/pattern-match/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－基本运算符</title>
    <link href="http://szpzs.oschina.io/2017/01/29/elixir-getting-started-basic-operators/"/>
    <id>http://szpzs.oschina.io/2017/01/29/elixir-getting-started-basic-operators/</id>
    <published>2017-01-29T12:18:48.000Z</published>
    <updated>2017-01-29T12:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://elixir-lang.org/getting-started/basic-types.html" target="_blank" rel="external">前面的章节</a>，我们看到Elixir提供了 +，-，*，/ 4个算术运算符，另外还有整数的除法和取余的两个函数 div/2 和 rem/2 。</p>
<a id="more"></a>
<p>Elixir也提供了 ++ 和 - - 来操作列表：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ++ [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -- [<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>用 &lt;&gt; 把两个字符串串联起来：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"foo"</span> &lt;&gt; <span class="string">"bar"</span></div><div class="line"><span class="string">"foobar"</span></div></pre></td></tr></table></figure>
<p>Elixir也提供三个布尔运算符：or，and 和 not 。这些运算符严格要求布尔类型数据（true或false）作为它的第一个参数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="literal">false</span> or is_atom(:example)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>如果参数不是布尔型数据则会引起异常：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> <span class="keyword">and</span> <span class="literal">true</span></div><div class="line">** (ArgumentError) argument error: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>or和and都是短路运算符。如果左边不足以决定结果则它们才会执行右边的表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">false</span> <span class="keyword">and</span> raise(<span class="string">"This error will never be raised"</span>)</div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; <span class="literal">true</span> or raise(<span class="string">"This error will never be raised"</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你是Erlang开发者，Elixir的 and 和 or 的确和Erlang里的 andalso 和 orelse 运算符相互映射影射。</p>
</blockquote>
<p>除了这几个布尔运算符，Elixir还提供可以接收任何类型参数的 || ，&amp;&amp; 和 ！。对于这几个运算符，除了 false 和 nil 其他所有值都被认为是true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># or</div><div class="line">iex&gt; <span class="number">1</span> || <span class="literal">true</span></div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; <span class="literal">false</span> || <span class="number">11</span></div><div class="line"><span class="number">11</span></div><div class="line"></div><div class="line"># <span class="keyword">and</span></div><div class="line">iex&gt; nil &amp;&amp; <span class="number">13</span></div><div class="line">nil</div><div class="line">iex&gt; <span class="literal">true</span> &amp;&amp; <span class="number">17</span></div><div class="line"><span class="number">17</span></div><div class="line"></div><div class="line"># !</div><div class="line">iex&gt; !<span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; !<span class="number">1</span></div><div class="line"><span class="literal">false</span></div><div class="line">iex&gt; !nil</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>根据经验，当你想要布尔值的时候就用and，or 和 not。如果有任何参数是非布尔值，则用&amp;&amp;，|| 和 ！。</p>
<p>Elixir也提供 ==，!=，===，!==，&lt;=，&gt;=，&lt; 和 &gt; 作为比较运算符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> == <span class="number">1</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> != <span class="number">2</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> &lt; <span class="number">2</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>== 和 === 不同之处在于，后者在比较整数和浮点数的时候更严格。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> == <span class="number">1.0</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="number">1</span> === <span class="number">1.0</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>在Elixir里，我们可以比较两个不同的数据类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> &lt; :atom</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们可以比较不同数据类型的原因是出于实用主义的考虑。排序算法不需要担心不同数据类型之间的排序问题。全部的排序顺序定义如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring</div></pre></td></tr></table></figure>
<p>你完全不需要记住这个顺序，只需要知道有这个顺序存在就足够了。</p>
<p>有关运算符（和排序）的参考信息，请查阅 <a href="http://elixir-lang.org/docs/master/elixir/operators.html" target="_blank" rel="external">运算符手册页面</a> 。</p>
<p>在下一章，我们将讨论一些基础函数，数据类型转换以及一些控制流。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/basic-operators.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/basic-operators.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://elixir-lang.org/getting-started/basic-types.html&quot;&gt;前面的章节&lt;/a&gt;，我们看到Elixir提供了 +，-，*，/ 4个算术运算符，另外还有整数的除法和取余的两个函数 div/2 和 rem/2 。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="basic operator" scheme="http://szpzs.oschina.io/categories/Elixir/basic-operator/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="basic operator" scheme="http://szpzs.oschina.io/tags/basic-operator/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－基本类型</title>
    <link href="http://szpzs.oschina.io/2017/01/28/elixir-getting-started-basic-types/"/>
    <id>http://szpzs.oschina.io/2017/01/28/elixir-getting-started-basic-types/</id>
    <published>2017-01-28T14:33:44.000Z</published>
    <updated>2017-01-28T14:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><a href="#part-one">基本算术运算</a></li>
<li><a href="#part-two">布尔类型</a></li>
<li><a href="#part-three">原子</a></li>
<li><a href="#part-four">字符串</a></li>
<li><a href="#part-five">匿名函数</a></li>
<li><a href="#part-six">(链接) 列表</a></li>
<li><a href="#part-seven">元组</a></li>
<li><a href="#part-eight">列表还是元组？</a></li>
</ol>
<a id="more"></a>
<p>本章我们将学习更多Elixir的基本数据类型：整数、浮点数、布尔值、原子、字符串、列表和元组。一些基本类型数据如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span>          # 整数</div><div class="line">iex&gt; <span class="number">0</span>x1F       # 整数</div><div class="line">iex&gt; <span class="number">1.0</span>        # 浮点数</div><div class="line">iex&gt; <span class="literal">true</span>       # 布尔值</div><div class="line">iex&gt; :atom      # 原子 / 符号</div><div class="line">iex&gt; <span class="string">"elixir"</span>   # 字符串</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  # 列表</div><div class="line">iex&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  # 元组</div></pre></td></tr></table></figure>
<h1 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a><span id="part-one">基本算术运算</span></h1><p>打开 iex 输入如下表达式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; <span class="number">5</span> * <span class="number">5</span></div><div class="line"><span class="number">25</span></div><div class="line">iex&gt; <span class="number">10</span> / <span class="number">2</span></div><div class="line"><span class="number">5.0</span></div></pre></td></tr></table></figure>
<p>我们注意到 10 / 2 返回了一个浮点数5.0而不是整数5。这是正常的。在Elixir里，运算符 / 总是返回浮点数。如果你想要做整数除法或者想得到除法的余数，你可以调用 div 和 rem 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="keyword">div</span>(<span class="number">10</span>, <span class="number">2</span>)</div><div class="line"><span class="number">5</span></div><div class="line">iex&gt; <span class="keyword">div</span> <span class="number">10</span>, <span class="number">2</span></div><div class="line"><span class="number">5</span></div><div class="line">iex&gt; <span class="keyword">rem</span> <span class="number">10</span>, <span class="number">3</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>注意！Elixir允许你在调用一个命名函数时候省略圆括号。这个特性使得当你写声明和控制流结构的时候由更加简洁的语法。</p>
<p>Elixir也支持快捷符号来输入二进制、八进制以及十六进制数字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">0</span>b1010</div><div class="line"><span class="number">10</span></div><div class="line">iex&gt; <span class="number">0</span>o777</div><div class="line"><span class="number">511</span></div><div class="line">iex&gt; <span class="number">0</span>x1F</div><div class="line"><span class="number">31</span></div></pre></td></tr></table></figure>
<p>浮点数最少要求小数点后有一位数字，并且也支持用e符号表达式表示指数数字：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="number">1.0</span></div><div class="line"><span class="number">1.0</span></div><div class="line">iex&gt; <span class="number">1.0e-10</span></div><div class="line"><span class="number">1.0e-10</span></div></pre></td></tr></table></figure>
<p>在Elixir里浮点数是64位双精度。</p>
<p>你可以调用 round 函数获得与给定的浮点数最接近的整数，或者调用 trunc 函数获得一个浮点数的整数部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; round(<span class="number">3.58</span>)</div><div class="line"><span class="number">4</span></div><div class="line">iex&gt; trunc(<span class="number">3.58</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<h2 id="识别函数"><a href="#识别函数" class="headerlink" title="识别函数"></a>识别函数</h2><p>Elixir里的函数是通过它的名字和函数参数个数来区分的。函数的arity指的是函数的参数个数。从这一点上，我们将在整个文档里使用的函数的名称和它的参数个数来描述函数。round/1 确定函数的名字是round，参数个数是1，而 round/2 确定一个不同（其实是不存在的）的函数，相同的名字，参数个数是2。</p>
<h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><span id="part-two">布尔类型</span></h1><p>Elixir支持 true 和 false 为布尔值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; <span class="literal">true</span> == <span class="literal">false</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>Elixir提供很多断言函数来检查一个值的类型。例如，is_boolean/2 函数可以用来检查一个值是不是布尔类型。</p>
<p>注：Elixir的函数是通过函数名和参数个数（即arity）来区分的。因此，is_boolean/1 表示函数名是is_boolean而且有一个入参。is_boolean/2 （其实并不存在这个函数）表示有相同的函数名却有不同的arity的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_boolean(<span class="literal">true</span>)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_boolean(<span class="number">1</span>)</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>如果入参是一个整数、一个浮点数或者其他数字，你也可以分别用 is_integer/1，is_float/1或is_number/1来检查。</p>
<blockquote>
<p>注：在任何时候，你可以在shell里输入 h() 来打印如何使用shell的信息。这个 h 帮助者也可以用来访问任何函数的文档。例如，输入 h is_integer/1 将打印 is_integer/1 函数的文档。它也可以运用在操作符和其他结构上（试一下 h ==/2）。</p>
</blockquote>
<h1 id="原子"><a href="#原子" class="headerlink" title="原子"></a><span id="part-three">原子</span></h1><p>原子是常量，它们名字就是它们自己的值。其他语言里叫这种数据类型为符号：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; :hello</div><div class="line">:hello</div><div class="line">iex&gt; :hello == :world</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>布尔值 true 和 false 实际上是原子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="literal">true</span> == :<span class="literal">true</span></div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_atom(<span class="literal">false</span>)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_boolean(:<span class="literal">false</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span id="part-four">字符串</span></h1><p>在Elixir里，字符串被包裹在两个双引号中，并且它们被用UTF-8来编码的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hellö"</span></div><div class="line"><span class="string">"hellö"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你在Windows中，你的终端可能默认就不用UTF-8编码。你可以通过在输入IEx前运行chcp 56001来改变当前会话的编码。</p>
</blockquote>
<p>Elixir也支持字符串插入：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="string">"hellö #&#123;:world&#125;"</span></div><div class="line"><span class="string">"hellö world"</span></div></pre></td></tr></table></figure>
<p>字符串内可以有换行符。你可以用转义字符引入它们。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; "hello</div><div class="line">...&gt; world"</div><div class="line">"hello\nworld"</div><div class="line">iex&gt; "hello\nworld"</div><div class="line">"hello\nworld"</div></pre></td></tr></table></figure>
<p>你可以用IO模块内的函数IO.puts/1来打印一个字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; IO.puts <span class="string">"hello\nworld"</span></div><div class="line">hello</div><div class="line">world</div><div class="line">:ok</div></pre></td></tr></table></figure>
<p>注意：IO.puts/1函数在打印字符串后返回原子 :ok 作为结果。</p>
<p>在Elixir内部字符串是用一组字节组成的二进制数据来表示的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; is_binary(<span class="string">"hellö"</span>)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们也可以获得一个字符串内的字节数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; byte_size(<span class="string">"hellö"</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们注意到上述例子的字符串的字节数是6，即使它只有5个字符。这是因为字符 “ö” 用UTF-8来编码的时候占用了两个字节。我们可以通过用String.length/1函数来基于字符数获得字符串的实际长度。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.length(<span class="string">"hellö"</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p><a href="https://hexdocs.pm/elixir/String.html" target="_blank" rel="external">String模块</a>包含了一些操作以Unicode标准定义的字符串的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; String.upcase(<span class="string">"hellö"</span>)</div><div class="line"><span class="string">"HELLÖ"</span></div></pre></td></tr></table></figure>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><span id="part-five">匿名函数</span></h1><p>匿名函数可以在行内被创建，并且它是被关键字fn和end界定的函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">iex&gt; add = fn a, b -&gt; a + b <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">12.71889879</span>/<span class="number">2</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; add.(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="number">3</span></div><div class="line">iex&gt; is_function(add)</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_function(add, <span class="number">2</span>) #检查add是否是一个有两个参数的函数</div><div class="line"><span class="literal">true</span></div><div class="line">iex&gt; is_function(add, <span class="number">1</span>) #检查add是否是一个有一个参数的函数</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>函数在Elixir里是“一等公民”，这意味着它跟整数和字符串一样可以被当作参数传给其他函数。上述例子，我们把持有函数的变量add传给函数is_function/1，得到了正确的结果 true。我们也能够通过调用is_function/2来检查这个函数的参数个数。</p>
<p>注意：在变量和圆括号之间的 点 号（.）在调用一个匿名函数的时候是必须存在的。这个点号确定在调用匿名函数add和命名函数add/2的时候没有歧义。在这个意义上，Elixir使匿名函数和函数名之间有明显的区别。我们将在<a href="http://elixir-lang.org/getting-started/modules.html" target="_blank" rel="external">第八章</a>来看看那些区别。</p>
<p>匿名函数都是闭包，因此它可以访问那些和函数定义在一个范围内的变量。让我们定义一个新的匿名函数，它使用我们前面已经定义的匿名函数的变量add：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; double = fn a -&gt; add.(a, a) <span class="keyword">end</span></div><div class="line">#Function&lt;<span class="number">6.71889879</span>/<span class="number">1</span> in :erl_eval.expr/<span class="number">5</span>&gt;</div><div class="line">iex&gt; double.(<span class="number">2</span>)</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>记住：一个变量在一个函数里被赋值不会影响它周围的环境：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; x = <span class="number">42</span></div><div class="line"><span class="number">42</span></div><div class="line">iex&gt; (fn -&gt; x = <span class="number">0</span> <span class="keyword">end</span>).()</div><div class="line"><span class="number">0</span></div><div class="line">iex&gt; x</div><div class="line"><span class="number">42</span></div></pre></td></tr></table></figure>
<h1 id="（链接）列表"><a href="#（链接）列表" class="headerlink" title="（链接）列表"></a><span id="part-six">（链接）列表</span></h1><p>Elixir用方括号来指定一个若干值组成的列表。这些值可以是任何类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">3</span>]</div><div class="line">iex&gt; length [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>两个列表可以用 ++/2 和 - -/2 操作符来串联和相减：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ++ [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">iex&gt; [<span class="number">1</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">false</span>, <span class="number">3</span>, <span class="literal">true</span>] -- [<span class="literal">true</span>, <span class="literal">false</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">true</span>]</div></pre></td></tr></table></figure>
<p>在本教材中，我们将谈论很多关于列表的头部和尾部的事情。头部是一个列表的第一个元素而尾部则是剩下的部分。它们可以用函数 hd/1 和 tl/1 来获取。让我们将一个列表赋给一个变量然后获取它的头部和尾部：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">iex&gt; hd(list)</div><div class="line"><span class="number">1</span></div><div class="line">iex&gt; tl(list)</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>尝试获取一个空列表的头部或尾部会发生一个错误：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; hd []</div><div class="line">** (ArgumentError) argument error</div></pre></td></tr></table></figure>
<p>有时候你创建一个列表，返回来的是一个用单引号括起来的值。比如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</div><div class="line">'\v\f\r'</div><div class="line">iex&gt; [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]</div><div class="line">'hello'</div></pre></td></tr></table></figure>
<p>当Elixir遇到一个由可打印的ASCII码组成的列表，Elixir将把它当作字符列表打印出来（字面上的字符列表）。当和Erlang代码交互的时候字符列表十分常见。任何时候，当你在Elixir里遇到一个值而你不能十分确定它的类型的时候，你可以用 i/1 函数来获得它的信息。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; i 'hello'</div><div class="line">Term</div><div class="line">  'hello'</div><div class="line">Data type</div><div class="line">  List</div><div class="line">Description</div><div class="line">  ...</div><div class="line">Raw representation</div><div class="line">  [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]</div><div class="line">Reference modules</div><div class="line">  List</div></pre></td></tr></table></figure>
<p>记住：单引号括住的值和双引号括住的值在Elixir里是不想等的，因为它们表示不同的类型：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; 'hello' == <span class="string">"hello"</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>
<p>单引号的是字符列表，双引号的是字符串。我们将在“<a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" target="_blank" rel="external">二进制，字符串和字符列表</a>”章节中详细讨论它们。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a><span id="part-seven">元组</span></h1><p>Elixir用大括号来定义元组。和列表一样，元组可以持有任何类型的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; tuple_size &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>元组会连续将元素存储在内存中。这意味着通过索引访问一个元组的元素或获取元组的大小是一个快速的操作。索引从零开始：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; elem(tuple, <span class="number">1</span>)</div><div class="line"><span class="string">"hello"</span></div><div class="line">iex&gt; tuple_size(tuple)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>用函数 put_elem/3 放置一个元素到一个元组的指定的索引位置也是可能的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; put_elem(tuple, <span class="number">1</span>, <span class="string">"world"</span>)</div><div class="line">&#123;:ok, <span class="string">"world"</span>&#125;</div><div class="line">iex&gt; tuple</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div></pre></td></tr></table></figure>
<p>注意：put_elem/3 返回了一个新的元组。原来存储在tuple变量里的元组没有被修改，因为Elixir的数据类型是不可修改的。由于是不可修改的，Elixir代码更容易推导，因为你永远不用担心是否有特别的代码正在某处修改你的数据结构。</p>
<h1 id="列表还是元组"><a href="#列表还是元组" class="headerlink" title="列表还是元组"></a><span id="part-eight">列表还是元组</span></h1><p>列表和元组有何不同？</p>
<p>列表在内存中就如链接列表，意味着列表中的每一个元素持有它的值和指向后继元素的指针，如此一直到列表的尾部。我们称每一个值和指针对是一个 cons cell：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; list = [<span class="number">1</span> | [<span class="number">2</span> | [<span class="number">3</span> | []]]]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>这意味着访问列表的长度是一个线性操作：我们需要遍历整改列表来计算它的长度。只要我们在列表前面加元素则更新列表是快速的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iex&gt; [<span class="number">0</span> | list]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>相反，元组在内存中连续存储。这意味着获取元组的长度和通过索引获取元素是快速的。然而，元组的修改或增加是昂贵的操作，因为它需要在内存中拷贝整个元组。</p>
<p>这些性能特性决定了两类数据结构的用法。元组的一种非常通用的使用场景是用它们从函数返回额外的信息。例如：File.read/1 是一个可以用来读取文件内容的函数，而它返回的是元组：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; File.read(<span class="string">"path/to/existing/file"</span>)</div><div class="line">&#123;:ok, <span class="string">"... contents ..."</span>&#125;</div><div class="line">iex&gt; File.read(<span class="string">"path/to/unknown/file"</span>)</div><div class="line">&#123;:error, :enoent&#125;</div></pre></td></tr></table></figure>
<p>如果传给File.read/1的路径存在，它返回一个元组，第一个元素是原子 :ok，第一个元素是文件内容。否则，它返回一个由原子 :error 和错误描述组成的元组。</p>
<p>大多数时候，Elixir会引导你做正确的事情。例如，有一个函数 elem/2 用来访问元组元素的，而对于列表则没有对应的内建函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; tuple = &#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">&#123;:ok, <span class="string">"hello"</span>&#125;</div><div class="line">iex&gt; elem(tuple, <span class="number">1</span>)</div><div class="line"><span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>当计算一个数据结构的元素个数的时候，Elixir也遵从一个简单的规则：如果这个操作是在常数时间内的（即是该值是预先计算的）则这个函数命名为szie；或者，如果这个操作是线性的（即是计算长度随着输入数据的增长而越来越慢）则这个函数命名为length。为便于记忆，“长度”和“线性”都是“l”字母开始的。</p>
<p>例如，我们目前已经用过4个计算函数：byte_size/1 （计算字符串的字节数），tuple_size/1 （计算元组大小），length/1 （计算列表长度）以及 String.length/1（计算字符串的字符个数）。也就是说，我们用 byte_size 来获取字符串的字节数是廉价操作，但是用 String.length 获取unicode字符的个数可能是昂贵的操作因为整个字符串需要被遍历。</p>
<p>Elixir也提供 Port，Reference和PID作为数据类型（它们通常用于进程间通信），当我们讨论进程的时候将快速浏览它们一下。接下来，让我们看看在我们基本类型上的一些基本操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/basic-types.html#identifying-functions" target="_blank" rel="external">http://elixir-lang.org/getting-started/basic-types.html#identifying-functions</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#part-one&quot;&gt;基本算术运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-two&quot;&gt;布尔类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-three&quot;&gt;原子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-four&quot;&gt;字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-five&quot;&gt;匿名函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-six&quot;&gt;(链接) 列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-seven&quot;&gt;元组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part-eight&quot;&gt;列表还是元组？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="basic type" scheme="http://szpzs.oschina.io/categories/Elixir/basic-type/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="basic type" scheme="http://szpzs.oschina.io/tags/basic-type/"/>
    
  </entry>
  
  <entry>
    <title>Elixir入门教程－介绍</title>
    <link href="http://szpzs.oschina.io/2017/01/27/elixir-getting-started-introduction/"/>
    <id>http://szpzs.oschina.io/2017/01/27/elixir-getting-started-introduction/</id>
    <published>2017-01-27T12:31:52.000Z</published>
    <updated>2017-01-27T12:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎你的到来！</p>
<p>本教程我们将教你Elixir的基础，语言的语法，如何定义模块，如何处理常见的数据结构和更多的特点。本章将聚焦在确保Elixir已经安装并且你能够成功地运行Elixir的交互Shell，即IEx。</p>
<a id="more"></a>
<p>我们的必要条件是：</p>
<ul>
<li>Elixir － 版本至少是1.4.0</li>
<li>Erlang － 版本至少是18.0</li>
</ul>
<p>让我们开始吧！</p>
<blockquote>
<p>如果你在本教程或本网站上发现任何错误，<a href="https://github.com/elixir-lang/elixir-lang.github.com" target="_blank" rel="external">请报告这个bug或者发一个pull requst到我们的问题跟踪里</a>。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果你还没有安装好Elixir，请到我们的<a href="http://elixir-lang.org/install.html" target="_blank" rel="external">安装指南</a>页面。一旦你安装好Elixir，你就能够运行  elixir –version 来得到当前Elixir的版本。</p>
<h1 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h1><p>当你安装Elixir，你将有三个新的可执行文件：iex，elixir和elixirc。如果你是从源码编译Elixir或者使用预先打包好的版本，你可以在bin目录里找到这三个可执行文件。</p>
<p>现在，让我们运行iex（如果你在Windows下则运行iex.bat），它代表交互式Elixir。在交互模式，我们能够输入任何Elixir表达式并且得到它的结果。让我们用一些基本表达式来热身。</p>
<p>运行iex并输入如下的表达式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex&gt; <span class="number">40</span> + <span class="number">2</span></div><div class="line"><span class="number">42</span></div><div class="line">iex&gt; <span class="string">"hello"</span> &lt;&gt; <span class="string">" world"</span></div><div class="line"><span class="string">"hello world"</span></div></pre></td></tr></table></figure>
<p>看来我们准备好了！我们从下下一章开始将在接下来的章节里大量使用交互shell来进一步熟悉这门语言的构造和基本类型。</p>
<blockquote>
<p>注意：如果你使用的是Windows，你也可以尝试 iex.bat - -werl 根据你正在用的控制台来提供更好的体验。</p>
</blockquote>
<h1 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h1><p>初步熟悉这门语言后，你可能想尝试写简单的程序，这个任务可以通过把下述Elixir代码放到一个文件里来完成：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IO.puts “Hello world from Elixir<span class="string">"</span></div></pre></td></tr></table></figure>
<p>保存文件为simple.exs并且用elixir执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">elixir simple.exs</div><div class="line">Hello world from Elixir</div></pre></td></tr></table></figure>
<p>后续我们将学习如何编译Elixir代码（<a href="http://elixir-lang.org/getting-started/modules.html" target="_blank" rel="external">在第八章</a>）并且如何使用Mix构建工具（在<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix&amp;OTP guide</a>）。现在，让我们进入到<a href="http://elixir-lang.org/getting-started/basic-types.html" target="_blank" rel="external">第二章</a>。</p>
<h1 id="如何问问题"><a href="#如何问问题" class="headerlink" title="如何问问题"></a>如何问问题</h1><p>在本教程的学习过程中，有一些疑问是很常见的，毕竟，这是学习过程的一部分！有很多地方你可以请教他们来更多地了解Elixir：</p>
<ul>
<li><a href="irc://irc.freenode.net/elixir-lang" target="_blank" rel="external">#elixir-lang on freenode IRC</a></li>
<li><a href="https://elixir-slackin.herokuapp.com/" target="_blank" rel="external">Elixir on Slack</a></li>
<li><a href="http://elixirforum.com/" target="_blank" rel="external">Elixir Forum</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/elixir" target="_blank" rel="external">elixir tag on StackOverflow</a></li>
</ul>
<p>当问问题的时候，记住两个技巧：</p>
<ul>
<li>不是问“在Elixir里如何去做X”，而是问“在Elixir里怎样去解决Y”。换句话说，不要问如何实现一个特定的解决方案，而是描述手头上的问题。描述一个问题的时候给予更多的上下文信息以及更少的对一个正确答案的偏见。</li>
<li>如果事情并不如预想的那样，请在你的报告里尽可能多地提供相关信息，比如：你的Elixir版本，代码片段和错误信息以及错误堆栈。使用像Gist这样的网站发布这些信息。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/introduction.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎你的到来！&lt;/p&gt;
&lt;p&gt;本教程我们将教你Elixir的基础，语言的语法，如何定义模块，如何处理常见的数据结构和更多的特点。本章将聚焦在确保Elixir已经安装并且你能够成功地运行Elixir的交互Shell，即IEx。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="introduction" scheme="http://szpzs.oschina.io/categories/Elixir/introduction/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="introduction" scheme="http://szpzs.oschina.io/tags/introduction/"/>
    
  </entry>
  
  <entry>
    <title>监控Erlang的原子</title>
    <link href="http://szpzs.oschina.io/2017/01/25/about-erlang-atoms/"/>
    <id>http://szpzs.oschina.io/2017/01/25/about-erlang-atoms/</id>
    <published>2017-01-25T13:46:29.000Z</published>
    <updated>2017-01-25T14:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你是Erlang用户，你很可能知道<a href="http://learnyousomeerlang.com/starting-out-for-real" target="_blank" rel="external">原子是什么</a>。你也有很高的机会知道在Erlang里关于原子的<a href="http://erlang.org/doc/efficiency_guide/commoncaveats.html#id61937" target="_blank" rel="external">警告</a>：</p>
<blockquote>
<p>原子是不进行垃圾回收的。一旦原子被创建，它就不会被删除。如果原子的数量达到限制值（默认是1,048,576），模拟器就会终止。</p>
</blockquote>
<a id="more"></a>
<p>原子的文本存储在原子表里（每个元素对应唯一一个原子），而且这些数据是不会被垃圾回收的。这个原子表的条目数对应一个可配置的限制值。达到这个限制值（比如动态地不停地生成原子）可以造成Erlang虚拟机崩溃。</p>
<p>原子很棒，但是一定要小心使用它们。动态创建原子（比如通过list_to_atom/1函数）必须要不惜代价避免。毕竟，这是list_to_existing_atom/1函数为什么存在的理由。如果你想知道什么时候应该使用原子，什么时候使用其他东西，你可能喜欢<a href="http://erlang.org/pipermail/erlang-questions/2015-October/086366.html" target="_blank" rel="external">Erlang问题邮件列表里的这个贴子</a>，其中包括Richard A. O’Keefe 和 Joe Armstrong 的回答。既然太多原子可以引起我们的系统非正常崩溃，<strong>那么在运行的生产系统中关注原子表的条目的数量是非常重要的</strong>。但是我们该如何做呢？</p>
<p>在当前的OTP版本（在我写本文的时候是19.2），只有关于原子表使用内存的信息能通过erlang:memory/1函数来获取给予用户。实际上有两个相似的参数可以使用。我们先看第一个：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; erlang:memory(atom).</div><div class="line"><span class="number">202481</span></div></pre></td></tr></table></figure>
<p>这个函数返回原子表自己使用的内存加上那个时点预留给原子字符串的内存。预留给原子字符串的内存以块形式增长。返回值是以字节为单元来表示。</p>
<p>让我们看第二个：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; erlang:memory(atom_used).</div><div class="line"><span class="number">187410</span></div></pre></td></tr></table></figure>
<p>这个函数返回原子表自己使用的内存加上原子字符串空间实际使用的内存。它的返回值也是以字节为单元来表示。谢谢<a href="https://github.com/mikpe" target="_blank" rel="external">Mikael</a>为我确认这个两个函数的不同之处。</p>
<p>但是，我们如何利用这一信息呢？了解原子表分配内存是一回事，但<strong>我们真的很想知道有多少原子在我们的生产系统中</strong>，而且我们是否接近臭名昭著的1百万原子表条目数限制。在经过查阅官方文档之后，我确信这些信息不会暴露给用户。在这一点上，我的同事<a href="https://github.com/dszoboszlay" target="_blank" rel="external">Daniel</a>建议，可以将这个信息从erlang:system_info/1函数的二进制输出提取出来：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; erlang:system_info(info).</div><div class="line">&lt;&lt;<span class="string">"=memory\ntotal: 13227160\nprocesses: 4383720\nprocesses_used: 4383496\nsystem: 8843440\natom: 202481\natom_used: 187410\nbi"</span>...&gt;&gt;</div></pre></td></tr></table></figure>
<p>上述输出被Erlang shell截断了，因此让我们用更加好看的格式打印它的输出（如下的输出示例被截断了）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; io:put_chars(erlang:system_info(info)).</div><div class="line">=memory</div><div class="line">total: <span class="number">13287200</span></div><div class="line">processes: <span class="number">4394640</span></div><div class="line">processes_used: <span class="number">4394416</span></div><div class="line">system: <span class="number">8892560</span></div><div class="line">[...]</div><div class="line">=index_table:atom_tab</div><div class="line">size: <span class="number">8192</span></div><div class="line">limit: <span class="number">1048576</span></div><div class="line">entries: <span class="number">7227</span></div><div class="line">=hash_table:module_code</div><div class="line">[...]</div></pre></td></tr></table></figure>
<p>的确，我们需要的信息就这里面。让我们实现一个简单的助手模块来提取它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(atom_table)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([count/<span class="number">0</span>])</span>.</div><div class="line"><span class="function"><span class="title">count</span><span class="params">()</span> -&gt;</span></div><div class="line">  Info = erlang:system_info(info),</div><div class="line">  Chunks = binary:split(Info, &lt;&lt;<span class="string">"="</span>&gt;&gt;, [global]),</div><div class="line">  [TabInfo] = [X || &lt;&lt;<span class="string">"index_table:atom_tab"</span>, X/binary&gt;&gt; &lt;- Chunks],</div><div class="line">  Lines = binary:split(TabInfo, &lt;&lt;<span class="string">"\n"</span>&gt;&gt;, [global]),</div><div class="line">  Chunks2 = [binary:split(L, &lt;&lt;<span class="string">": "</span>&gt;&gt;) || L &lt;- Lines, L =/= &lt;&lt;&gt;&gt;],</div><div class="line">  binary_to_integer(proplists:get_value(&lt;&lt;<span class="string">"entries"</span>&gt;&gt;, Chunks2)).</div></pre></td></tr></table></figure>
<p>接着我们看看我们的助手的作用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; atom_table:count().</div><div class="line"><span class="number">7085</span></div></pre></td></tr></table></figure>
<p>不是最好的API，但至少我们得到了我们需要的信息。幸运的是，<a href="https://github.com/mikpe" target="_blank" rel="external">Mikael</a>向OTP团队提交了一个<a href="https://github.com/erlang/otp/pull/1286" target="_blank" rel="external">Pull Request</a>，其中包括一个新的API以更好的方式找回我们的小宝贝信息。这个Pull Request最近已经被接受，这就意味着从OTP 20开始，我们将能够用下面的API来获取关于原子使用的数量的信息：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erlang:system_info(atom_count).</div></pre></td></tr></table></figure>
<p>好极了，不是吗？</p>
<p>现在，我们有我们所需要的指标，我们可以设置一个周期性的工作，将我们的生产系统中的原子数发送到我们最喜欢的监控系统，并且如果一个预定义的阈值被超过则引起一个报警。我会用很低的阈值（即小于50%），因为即使在一个巨大的Erlang系统是不大可能看到几十万个原子的，而且达到那么高的数字可能就暴露一些原子动态生成的问题。如果真是这样的情况，我们需要尽快报警。</p>
<p>现在让我们创建一个新的原子，然后再用我们的助手一次：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; roberto.</div><div class="line">roberto</div><div class="line"><span class="number">3</span>&gt; atom_table:count().</div><div class="line"><span class="number">7134</span></div></pre></td></tr></table></figure>
<p>等一等！我们只是创建了一个原子。为什么原子数量从7085跳到7134了？</p>
<p>在运行中的Erlang系统里，原子随时都会被创建。例如，可能一个进程在没有见过的模块中对一个函数执行完全限定的函数调用。这将导致模块加载到系统中，并且一堆原子被添加到原子表。毕竟，模块名是原子，函数名等等也是原子。</p>
<p>现在让我们假设我们的系统原子泄露。我们怎样才能知道哪些原子在产生？有几个方法从一个运行的Erlang系统中获取原子列表，不过我最喜欢的方法是<a href="http://stackoverflow.com/questions/13480462/erlang-can-i-get-a-list-of-all-currently-registered-atoms" target="_blank" rel="external">legoscia在StackOverflow给出的</a>。这个方法真的很邪乎，它使用了外部数据格式的非官方公布特性。</p>
<p><img src="/images/about-erlang-atoms-1.jpeg" style="border:0;"></p>
<p>比如我们可以利用从Stack Overflow获取的代码读取系统中原子的列表，稍等一会儿，然后再次运行它，看两次结果的差异。我们甚至不需要在生产中运行这样的代码，因为本地工作站或测试系统足以发现意外产生这些原子的背后的根本原因。</p>
<p>如果我们发现原子是动态生成的，我们可能想确保它不再发生。在这种情况下，我推荐使用像 Erlang 风格的审阅工具：<a href="https://github.com/inaka/elvis" target="_blank" rel="external">Elvis</a>，我的同事<a href="https://github.com/jfacorro" target="_blank" rel="external">Juan</a>是它的主要贡献者。。</p>
<p>那么你有什么问题吗？有没有其他的你跟踪的Erlang指标（或者你想跟踪）很难获取或另有隐情？请在评论中让我们知道。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@robertoaloi/about-erlang-atoms-a24603a4a6e8#.cm9ha79v7" target="_blank" rel="external">https://medium.com/@robertoaloi/about-erlang-atoms-a24603a4a6e8#.cm9ha79v7</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你是Erlang用户，你很可能知道&lt;a href=&quot;http://learnyousomeerlang.com/starting-out-for-real&quot;&gt;原子是什么&lt;/a&gt;。你也有很高的机会知道在Erlang里关于原子的&lt;a href=&quot;http://erlang.org/doc/efficiency_guide/commoncaveats.html#id61937&quot;&gt;警告&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原子是不进行垃圾回收的。一旦原子被创建，它就不会被删除。如果原子的数量达到限制值（默认是1,048,576），模拟器就会终止。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/categories/Erlang/Atom/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>用Erlang进行分布式计算 -- 第二篇</title>
    <link href="http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-2/"/>
    <id>http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-2/</id>
    <published>2017-01-23T06:01:59.000Z</published>
    <updated>2017-01-23T06:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章里，我们已经看到如何连接一个远程节点并且运行Erlang里内建的模块。本文我们将学习如何可以运行我们自己的模块来做一些任务。例如我们将从远程节点获取分配给它们网络接口的ip地址。</p>
<a id="more"></a>
<p>我们的模块看起来像如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">% 文件名应该是 ourmodule.erl</div><div class="line">-module(ourmodule).</div><div class="line">-export([ getip/0 ]).</div><div class="line">getip()-&gt;</div><div class="line">    % 这是用于Mac终端的</div><div class="line">    % B = os:cmd('ifconfig $2 | grep \"inet \" | awk -F\' \' \'&#123;print    $2&#125;\' | awk \'&#123;print $1&#125;\''),</div><div class="line">    % 这是用于Linux终端的</div><div class="line">    B = os:cmd('ifconfig $2 | grep \"inet \" | awk -F\' \' \'&#123;print $2&#125;\' | awk \'&#123;print $1&#125;\' | awk -F \':\' \'&#123;print $2&#125;\''),</div><div class="line">    io:format("node: ~s ~n ~s ", [node(), B]),</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>保存这份代码为<strong>ourmodule.erl</strong>。</p>
<p>现在让我们来编译我们的模块。首先我们必须去到我们模块存放的目录。然后打开Erlang shell并且编译它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c(ourmodule). %%% 输出是: &#123;ok,ourmodule&#125;</div></pre></td></tr></table></figure>
<p>编译后，我们在同一个目录里将有一个 <strong>ourmodule.beam</strong> 文件，它是这个模块的erlang可执行文件。然后我们必须拷贝这个 <strong>ourmodule.beam</strong> 文件到远程节点。现在从相同的目录（远程节点上该文件存放的目录）让我们打开一个Erlang shell：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name cloud@remote-host -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>做完这些。这些就是我们在远程节点需要做的所有工作。</p>
<p>现在从你的主（也就是本地）节点执行如下命令：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpc:call('cloud@remote-host', ourmodule, getip, []).</div><div class="line"><span class="comment">% 输出是 : 将有节点名和一些ip地址的列表</span></div><div class="line"><span class="comment">%</span></div><div class="line"><span class="comment">% node: cloud@remote-host</span></div><div class="line"><span class="comment">% 127.0.0.1</span></div><div class="line"><span class="comment">% 192.168.1.45</span></div><div class="line"><span class="comment">% ok.</span></div></pre></td></tr></table></figure>
<p>这是一个简单例子，就是我们如何可以在分布式Erlang环境里运行我们自己的模块。我们可以通过增加更多函数来做其他任务，或者我们可以只是为我们的目的写新的模块，然后我们可以分布可执行文件到不同的节点并远程执行它们。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@smirazzakee/distributed-computing-using-erlang-2-c57f3242a2e0#.acwcop39g" target="_blank" rel="external">https://medium.com/@smirazzakee/distributed-computing-using-erlang-2-c57f3242a2e0#.acwcop39g</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇文章里，我们已经看到如何连接一个远程节点并且运行Erlang里内建的模块。本文我们将学习如何可以运行我们自己的模块来做一些任务。例如我们将从远程节点获取分配给它们网络接口的ip地址。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/categories/Erlang/Distributed-Systems/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/tags/Distributed-Systems/"/>
    
  </entry>
  
  <entry>
    <title>用Erlang进行分布式计算 -- 第一篇</title>
    <link href="http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-1/"/>
    <id>http://szpzs.oschina.io/2017/01/23/distributed-computing-using-erlang-1/</id>
    <published>2017-01-23T05:30:17.000Z</published>
    <updated>2017-01-23T05:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文我们将看看Erlang里的分布式系统是如何运作的。</p>
<p>Erlang是一种函数式语言，其最被大家所熟知的是分布式和并发计算。</p>
<a id="more"></a>
<p>一般Erlang程序运行在节点上（<strong>节点名默认是nonode@nohost</strong>）。</p>
<p>在一个分布式系统里，节点间彼此交互。本文我们将用两个节点：<strong>sakib@localhost</strong> 和 <strong>cloud@remote-host</strong> 。</p>
<p>节点<strong>sakib@localhost</strong>运行在我本地系统，节点<strong>cloud@remote-host</strong>运行在远程服务器上。<strong>remote-host</strong>是我的远程服务器的主机名。</p>
<p>连接到远程节点，节点名的后缀（节点名@符号后的部分）和主机名相同是很重要。</p>
<p>现在如下所示打开本地系统的Erlang的shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name sakib@localhost -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>并且如下所示打开远程服务器的Erlang的shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name cloud@remote-host -setcookie <span class="string">"12345"</span></div></pre></td></tr></table></figure>
<p>两个节点的cookie必须一样，或者稍后你可以设置节点的cookie。如果远程节点的cookie没有设置，那么本地节点的cookie将被用来连接远程节点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 给指定的节点设置cookie</span></div><div class="line">erlang:set_cookie('cloud@remote-host', '<span class="number">12345</span>').</div><div class="line"><span class="comment">% 第一个参数是节点名，第二参数是cookie</span></div><div class="line"><span class="comment">% 连接远程节点</span></div><div class="line">net_kernel:connect_node('cloud@remote-host').</div></pre></td></tr></table></figure>
<p>如果响应是true，则连接建立；如果响应是false，则连接失败。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">% 列出已经连接的节点列表</div><div class="line">nodes().</div><div class="line">% 输出是 : ['cloud@remote-host']</div><div class="line">% 因为我们现在仅仅连接了一个远程节点</div></pre></td></tr></table></figure>
<p>现在我们可以用<strong>RPC</strong>来运行远程节点的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpc:call('cloud@remote-host', os, cmd, [whoami]).</div></pre></td></tr></table></figure>
<p>rpc:call()函数有4个入参。</p>
<p>第一个是节点名，第二个是模块名，第三个是函数名，第四个是函数的入参。</p>
<p>上述例子是我们运行<strong>os</strong>模块里的<strong>cmd()</strong>函数，入参是<strong>whoami</strong>。它将返回远程系统的当前用户名。<strong>os</strong>是Erlang的内建模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 使用multicall函数 (跨所有连接的节点执行rpc调用)</span></div><div class="line">rpc:multicall(nodes(), os, cmd, [whoami]).</div><div class="line"><span class="comment">% 与远程节点断开连接</span></div><div class="line">erlang:disconnect_node('cloud@remote-host').</div></pre></td></tr></table></figure>
<p>用同样的方式我们可以将不同的任务分布到不同的节点来处理，然后在主节点上获取结果。这就是在Erlang里一个分布式系统的运作方式。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@sakibsami/distributed-computing-using-erlang-1-cdd051a77c85#.maaswacq4" target="_blank" rel="external">https://medium.com/@sakibsami/distributed-computing-using-erlang-1-cdd051a77c85#.maaswacq4</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文我们将看看Erlang里的分布式系统是如何运作的。&lt;/p&gt;
&lt;p&gt;Erlang是一种函数式语言，其最被大家所熟知的是分布式和并发计算。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/categories/Erlang/Distributed-Systems/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Distributed Systems" scheme="http://szpzs.oschina.io/tags/Distributed-Systems/"/>
    
  </entry>
  
  <entry>
    <title>耗尽弹药时你不能爆炸！</title>
    <link href="http://szpzs.oschina.io/2017/01/13/running-out-of-ammo/"/>
    <id>http://szpzs.oschina.io/2017/01/13/running-out-of-ammo/</id>
    <published>2017-01-13T02:16:13.000Z</published>
    <updated>2017-01-13T02:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文（和<a href="https://medium.com/erlang-battleground/beyond-the-limits-of-an-ets-cdd79fa8300c#.tsfdkduyd" target="_blank" rel="external">上一篇文章</a>一样）也是受我在哥伦比亚卡利的学生的好奇心所启发。这次的问题是：什么时候并且为什么 bang（!）（即消息发送）操作符失败？</p>
<a id="more"></a>
<p><img src="/images/running-out-of-ammo-1.jpeg" style="border:0;"></p>
<h1 id="有时候你有无限的子弹"><a href="#有时候你有无限的子弹" class="headerlink" title="有时候你有无限的子弹"></a>有时候你有无限的子弹</h1><p>那些天我和我的学生讨论的是Erlang的一个核心概念：消息传递。Erlang中消息传递是用发送操作符（即 ！，也叫做bang）来完成的。这次我给他们介绍bang，我用一个Pid放在它的左边。就像这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; Pid = self().</div><div class="line">&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">2</span>&gt; Pid ! &#123;a, message&#125;.</div><div class="line">&#123;a,message&#125;</div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下（当表达式的左边是一个Pid），bang从来不失败。即使Pid表示的是一个死亡进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">4</span>&gt; erlang:is_process_alive(Pid).</div><div class="line"><span class="literal">false</span></div><div class="line"><span class="number">5</span>&gt; Pid ! &#123;another, message&#125;.</div><div class="line">&#123;another,message&#125;</div><div class="line"><span class="number">6</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="有时候你就是不能开枪"><a href="#有时候你就是不能开枪" class="headerlink" title="有时候你就是不能开枪"></a>有时候你就是不能开枪</h1><p>但是Pid并不是在bang左边唯一有效的表达式，你也可以用原子和元组放在bang的左边，例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">7</span>&gt; my ! &#123;third, message&#125;.</div><div class="line">&#123;third,message&#125;</div><div class="line"><span class="number">8</span>&gt; &#123;my, node()&#125; ! &#123;fourth, message&#125;.</div><div class="line">&#123;fourth,message&#125;</div><div class="line"><span class="number">9</span>&gt; flush().</div><div class="line">Shell got &#123;third,message&#125;</div><div class="line">Shell got &#123;fourth,message&#125;</div><div class="line">ok</div><div class="line"><span class="number">10</span>&gt;</div></pre></td></tr></table></figure>
<p>在这种情况下，如果没有进程被注册为这个名字，bang操作可能失败：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>&gt; no_proc ! &#123;fifth, message&#125;.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as no_proc ! &#123;fifth,message&#125;</div><div class="line"><span class="number">11</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="去读官方文档吧！"><a href="#去读官方文档吧！" class="headerlink" title="去读官方文档吧！"></a>去读官方文档吧！</h1><p>所有问题在<a href="http://erlang.org/doc/reference_manual/expressions.html#id80833" target="_blank" rel="external">官方文档</a>里都有清晰的说明。</p>
<blockquote>
<p>Expr1的计算结果必须是一个pid、一个注册的名字（原子），或者是一个格式为{Name, Node}的元组。Name是一个原子而Node是一个节点名字，也是一个原子。</p>
<p>如果Expr1的计算结果是一个名字，但是这个名字没有注册，则一个badarg运行时错误发生。</p>
<p>发送消息给一个pid永远都不会失败，即使这个pid指的是一个不存在的进程。</p>
<p>也就是说，如果Expr1的计算结果是一个格式为{Name, Node}元组（或者是另外一个节点的pid），分布式消息发送也永远不会失败。</p>
</blockquote>
<p><img src="/images/running-out-of-ammo-2.gif" style="border:0;"></p>
<h1 id="是的，不过…"><a href="#是的，不过…" class="headerlink" title="是的，不过…"></a>是的，不过…</h1><p>现在，我们不能只是满足了解这点知识。</p>
<p>正如你可能猜到的，我们没有那样做。我们问自己：</p>
<blockquote>
<p>当没有进程用相关名字注册，而如果发送消息给这个名字时，会抛出badarg错误：<br>1、一个进程可以用一个名字注册，但它却是不存在的？换句话说：bang操作失败意味着这个进程不存在？<br>2、我如何在用<strong>bang</strong>操作前检查是否有进程用相关名字注册。</p>
</blockquote>
<h2 id="问题1：我能注册已经死亡的进程吗？"><a href="#问题1：我能注册已经死亡的进程吗？" class="headerlink" title="问题1：我能注册已经死亡的进程吗？"></a>问题1：我能注册已经死亡的进程吗？</h2><p>为回答问题1，我们必须先检查一些事情。一个进程可以死掉并且还能用一个名字注册吗？我们用两种方法来尝试：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; Pid = self().</div><div class="line">&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">2</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">3</span>&gt; register(my, Pid).</div><div class="line">** exception error: bad argument</div><div class="line">     in function  register/<span class="number">2</span></div><div class="line">        called as register(my,&lt;<span class="number">0.65</span>.<span class="number">0</span>&gt;)</div><div class="line"><span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>首先我们尝试一个已经死亡的进程作为入参来调用erlang:register/2函数，结果我们失败了。然后我们尝试注册一个进程，接着杀掉它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">5</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">6</span>&gt; my ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as my ! message</div><div class="line"><span class="number">7</span>&gt;</div></pre></td></tr></table></figure>
<p>还是失败了。不过这次的失败是因为进程已经死亡了还是因为发送消息的时候它没有被注册？这就带我们进入问题2…</p>
<h2 id="问题2：我怎么能够阻止bagarg错误发生？"><a href="#问题2：我怎么能够阻止bagarg错误发生？" class="headerlink" title="问题2：我怎么能够阻止bagarg错误发生？"></a>问题2：我怎么能够阻止bagarg错误发生？</h2><p>现在，我如何可以找出实际在对某个名字使用bang操作之前是否有一个用这个名字注册的进程？</p>
<p>快速而且非常精确的答案是：你做不到。因为Erlang的并发本质，在你检测进程是否存在的时候和你发送消息的时候这两个时间点之间，这个进程可能已经死掉了（或者一个新的进程使用了相同的名字来注册）。</p>
<p>尽管如此，还是有一个方法来只是检查在你的节点上是否有一个用某个名字注册的进程，并找到那个进程是哪个进程来作为奖赏：<a href="http://erlang.org/doc/man/erlang.html#whereis-1" target="_blank" rel="external">whereis/1</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span>&gt; whereis(my).</div><div class="line">undefined</div><div class="line"><span class="number">8</span>&gt; register(my, self()).</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="number">9</span>&gt; whereis(my).</div><div class="line">&lt;<span class="number">0.75</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">10</span>&gt; <span class="number">1</span> / <span class="number">0</span>.</div><div class="line">** exception error: an error occurred <span class="keyword">when</span> evaluating an arithmetic expression</div><div class="line">     in operator  '/'/<span class="number">2</span></div><div class="line">        called as <span class="number">1</span> / <span class="number">0</span></div><div class="line"><span class="number">11</span>&gt; whereis(my).</div><div class="line">undefined</div><div class="line"><span class="number">12</span>&gt;</div></pre></td></tr></table></figure>
<p>如果whereis/1返回undefined，你就知道在你的节点里没有用那个名字注册的进程。但是，如上所述，您不应该编写像如下的代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> whereis(my) <span class="keyword">of</span></div><div class="line">  undefined -&gt; do_nothing;</div><div class="line">  APid -&gt; APid ! message</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>你那是正在给自己购买了去竞争条件之地的票。你所需要的就如下代码所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> my ! message</div><div class="line"><span class="keyword">catch</span></div><div class="line">  _:badarg -&gt; do_nothing</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><img src="/images/running-out-of-ammo-3.gif" style="border:0;"></p>
<h1 id="但是我们讨厌-try…catch！"><a href="#但是我们讨厌-try…catch！" class="headerlink" title="但是我们讨厌 try…catch！"></a>但是我们讨厌 try…catch！</h1><p>如果你真的不喜欢像上面那样用try…catch来处理每一个消息，这里有一个小技巧。还记得前面官方文档说过的吗？</p>
<blockquote>
<p>也就是说，如果Expr1的计算结果是一个格式为{Name, Node}元组（或者是另外一个节点的pid），分布式消息发送也永远不会失败。</p>
</blockquote>
<p>考虑到这一点，看看你能做些什么来替代上面的做法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">12</span>&gt; my ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as my ! message</div><div class="line"><span class="number">13</span>&gt; &#123;my, node()&#125; ! message.</div><div class="line">message</div><div class="line"><span class="number">14</span>&gt;</div></pre></td></tr></table></figure>
<p>使用元组语法，其中用到了你自己所在节点的名称，如果那个叫做my的进程存在的话，你就正在有效地发送消息给它；而如果这个进程不存在，则会丢弃这些消息。如果你用Pid来替换元组的话，也是这个结果。</p>
<p><img src="/images/running-out-of-ammo-4.gif" style="border:0;"></p>
<h1 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h1><p>我想用我们在卡利发现的另一个比较酷的事情来结束本文。当谈论这些事情的时候，我们并不真正地了解bang操作在Erlang虚拟机内部的运作过程，只是考虑bang操作失败的情况，我们尝试想像Erlang虚拟机内部如何运行。</p>
<h2 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h2><p>首先来考虑这个问题：当bang操作失败的时候，它总是报badarg错误。当你用一个没有注册为进程名字的原子的时候，它会失败，但是你用其他东西，它也会失败。看如下例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; x ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as x ! message</div><div class="line"><span class="number">2</span>&gt; <span class="string">"a list"</span> ! message.</div><div class="line">** exception error: bad argument</div><div class="line">     in operator  !/<span class="number">2</span></div><div class="line">        called as <span class="string">"a list"</span> ! message</div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>用一点想象力，我们可能会认为，当你使用一个原子，Erlang虚拟机转换原子为Pid，然后在其上执行bang操作的原始版。如果它未能把原子转换成Pid，那么当然badarg错误就发生。换句话说，看起来Erlang VM在将下面的语句…</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; x ! message.</div></pre></td></tr></table></figure>
<p>改为如下的语句：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; whereis(x) ! message.</div></pre></td></tr></table></figure>
<p>那么，当whereis 返回 undefined, bang操作失败。</p>
<h2 id="等一等"><a href="#等一等" class="headerlink" title="等一等"></a>等一等</h2><p>哦，不错。但是undefined也是一个原子啊。Erlang虚拟机为何在那里不陷入一个无限的递归循环呢？嗯，它可能有一个处理undefined的特殊分支。在这个分支里，它可以避免把undefined当做其他任何原子来处理。但是，那么，如果我注册一个进程的名字为undefined呢？</p>
<p><img src="/images/running-out-of-ammo-5.jpeg" style="border:0;"></p>
<p>让我们来试试，好吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; register(undefined, self()).</div><div class="line">** exception error: bad argument</div><div class="line">     in function  register/<span class="number">2</span></div><div class="line">        called as register(undefined,&lt;<span class="number">0.69</span>.<span class="number">0</span>&gt;)</div><div class="line"><span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>好吧，我们做不到。实际上<a href="http://erlang.org/doc/man/erlang.html#register-2" target="_blank" rel="external">官方文档</a>说的很清楚。</p>
<blockquote>
<p>badarg<br>如果 RegName 是原子undefined.</p>
</blockquote>
<p>干得不错，Erlang/OTP团队。干得不错，真的！</p>
<p><img src="/images/running-out-of-ammo-6.gif" style="border:0;"></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2#.sm8fbhd9q" target="_blank" rel="external">https://medium.com/erlang-battleground/running-out-of-ammo-769bb28baac2#.sm8fbhd9q</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文（和&lt;a href=&quot;https://medium.com/erlang-battleground/beyond-the-limits-of-an-ets-cdd79fa8300c#.tsfdkduyd&quot;&gt;上一篇文章&lt;/a&gt;一样）也是受我在哥伦比亚卡利的学生的好奇心所启发。这次的问题是：什么时候并且为什么 bang（!）（即消息发送）操作符失败？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="bang" scheme="http://szpzs.oschina.io/categories/Erlang/bang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="bang" scheme="http://szpzs.oschina.io/tags/bang/"/>
    
      <category term="erlang:register/2" scheme="http://szpzs.oschina.io/tags/erlang-register-2/"/>
    
      <category term="whereis/1" scheme="http://szpzs.oschina.io/tags/whereis-1/"/>
    
      <category term="undefined" scheme="http://szpzs.oschina.io/tags/undefined/"/>
    
      <category term="try catch" scheme="http://szpzs.oschina.io/tags/try-catch/"/>
    
  </entry>
  
  <entry>
    <title>Erlang中的通信</title>
    <link href="http://szpzs.oschina.io/2017/01/11/erts-communication/"/>
    <id>http://szpzs.oschina.io/2017/01/11/erts-communication/</id>
    <published>2017-01-11T09:11:22.000Z</published>
    <updated>2017-01-11T13:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>从概念上讲在 Erlang 中的通信是使用异步信号完成的。所有不同的执行实体，比如进程和端口，通过异步信号通信。最常用的信号是消息。其他通用的信号是退出、链接、取消链接、监测和取消监测信号。</p>
<a id="more"></a>
<h1 id="信号的传递"><a href="#信号的传递" class="headerlink" title="信号的传递"></a>信号的传递</h1><p>在信号被发送出去和信号到达目标这之间消耗的时间是不确定的但是肯定存在的。如果接受者已经终止，信号就无法到达，不过这个情况可以触发另一个信号产生。例如，一个发给不存在进程的链接信号触发一个退出信号，这个退出信号被发送回给发送这个链接信号的实体。在分布式环境下通信的时候，如果分布式信道中断了，信号可以被丢失。</p>
<p>只在如下的场景信号的顺序才能被保证：如果一个实体发送多个信号给同一个目标实体，这些信号的顺序是被保证。也就是说，如果A发送一个信号S1给B，然后A再发送一个信号S2给B，S1被保证不在S2之后到达。</p>
<h1 id="同步的通信"><a href="#同步的通信" class="headerlink" title="同步的通信"></a>同步的通信</h1><p>一些通信是同步的。如果分解来看，一个同步通信操作包含两个异步信号：一个请求信号和一个应答信号。比如，第一个入参不是self()的<a href="http://erlang.org/doc/apps/erlang/process_info/2.html" target="_blank" rel="external">erlang:process_info/2</a> 函数调用就是一个同步通信。调用者发送一个请求信息的异步信号然后等待包含所请求信息的应答信号。当请求信号到达它的目标，目标进程用被请求的信息应答。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>在虚拟机里的不同异步信号的实现会随着时间而变化，但是它的行为一直遵循如上所述异步信号在实体间传递的概念。</p>
<p>通过检阅相关实现，你可能注意到一些特定的信号给予比上述更严格的传递保证。关于实现不是用Erlang代码这样来写的知识是极其重要的，因为实现在没有提前通知下随时被修改。</p>
<p>主要的实现修改例子如下：</p>
<ul>
<li>从ERTS 5.5.2开始，发给进程的退出信号是真正地异步传输。</li>
<li>从ERTS 5.10开始，所有从进程发给端口的信号是真正地异步传输。</li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://erlang.org/doc/apps/erts/communication.html" target="_blank" rel="external">http://erlang.org/doc/apps/erts/communication.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从概念上讲在 Erlang 中的通信是使用异步信号完成的。所有不同的执行实体，比如进程和端口，通过异步信号通信。最常用的信号是消息。其他通用的信号是退出、链接、取消链接、监测和取消监测信号。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Communication" scheme="http://szpzs.oschina.io/categories/Erlang/Communication/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Communication" scheme="http://szpzs.oschina.io/tags/Communication/"/>
    
      <category term="signal" scheme="http://szpzs.oschina.io/tags/signal/"/>
    
      <category term="synchronous" scheme="http://szpzs.oschina.io/tags/synchronous/"/>
    
      <category term="asynchronous" scheme="http://szpzs.oschina.io/tags/asynchronous/"/>
    
      <category term="implementation" scheme="http://szpzs.oschina.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>外部数据格式之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2017/01/08/eli5-etf/"/>
    <id>http://szpzs.oschina.io/2017/01/08/eli5-etf/</id>
    <published>2017-01-08T02:35:34.000Z</published>
    <updated>2017-01-08T02:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>与外部世界和其他Erlang节点进行通信，同时保存东西在磁盘上，Erlang都使用特殊编码格式 – 外部数据格式。</p>
<a id="more"></a>
<p>这种格式的主要要求如下：</p>
<ul>
<li>易于人类和机器看懂编码的数据和理解这些数据是什么。一个外部数据总是第一个字节值为131 (0x83)。</li>
<li>压缩的数据有压缩的标志项。数据的头部第一个字节为：131 (0x83)，第二个字节为：80<br>(0x50)，第三到第六个字节为：无符号32位大端的整数表示未压缩的数据长度，这几个元素组成一个标签表示这是一个压缩数据。</li>
<li>为了适用于跨平台，所有整数被编码为<a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">大端序</a>（从最高有效位到最低有效位字节），所有浮点数用大端的<a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">IEEE编码</a>，所有文本用UTF-8<br>或 ISO-8859-1（ASCII超集） 来编码。</li>
</ul>
<p>编码一个数据用erlang:term_to_binary，相反的操作，即解码用erlang:binary_to_term。解码包含有意设定的二进制数据也使得本来不可能构建出来的数据成为可能，比如端口号，进程标识。（注：感谢少帮主的翻译）</p>
<p>通常原子被编码为字符串。在基于网络的分布式模式下，为进一步减少协议的大小，一个分布式头部可以被添加进来。它包含了在已经编码的消息中的原子名称的表。然后在消息中的原子被替换为此表中的索引。</p>
<p>那些从来没出现在Erlang程序中的虚拟机内部值的类型是不可能被编码的，比如THE_NON_VALUE、寄存器的引用、<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cp" target="_blank" rel="external">CP</a>等。</p>
<blockquote>
<p>请参阅<br><a href="http://erlang.org/doc/apps/erts/erl_ext_dist.html" target="_blank" rel="external">外部数据格式文档</a></p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-etf.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-etf.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与外部世界和其他Erlang节点进行通信，同时保存东西在磁盘上，Erlang都使用特殊编码格式 – 外部数据格式。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="External Term Format" scheme="http://szpzs.oschina.io/categories/Erlang/External-Term-Format/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="External Term Format" scheme="http://szpzs.oschina.io/tags/External-Term-Format/"/>
    
  </entry>
  
  <entry>
    <title>基于属性的测试之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2017/01/07/eli5-property-based/"/>
    <id>http://szpzs.oschina.io/2017/01/07/eli5-property-based/</id>
    <published>2017-01-07T13:58:09.000Z</published>
    <updated>2017-01-07T14:07:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设你知道通常的单元测试，可能你就会听说过common test。有另一种方法来检查你的系统，不同于普通的测试方法。它被称为基于属性的测试。</p>
<p>要做测试，应该定义输入数据的类型和范围，系统将在此基础上进行测试。输入数据的定义看起来像一个具有类型和范围参数描述的元组。它们是数据，而你在测试前生成这些数据。</p>
<a id="more"></a>
<p>然后，测试引擎将用定义的输入数据的随机组合来调用你的代码。测试引擎尝试观察被测系统是否仍然展示所定义的属性。</p>
<p>如果在某一时刻没有观察到所需的属性，测试将停止并且引擎将尝试缩小输入。这是试图找到仍然使得测试失败的最简单的输入数据。测试引擎将尽量减少尽可能多的参数的复杂性。</p>
<blockquote>
<p>请参阅：<br>提供了基于属性测试功能的库有：<a href="https://github.com/manopapad/proper" target="_blank" rel="external">PropEr</a> 和 <a href="http://www.quviq.com/products/erlang-quickcheck/" target="_blank" rel="external">Quviq QuickCheck</a> (商用的) (注意：QuickCheck 也有其他语言的版本！)</p>
</blockquote>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>假设你的老板要你写一个fizz_buzz函数。它的需求非常明确，fizz_buzz的入参是1到100之间的整数。另外，入参被3整除，它返回fizz，入参被5整除，它返回buzz，入参被3和5都整除，它返回fizbuzz。</p>
<p>所以输入范围是：1到100之间的整数。</p>
<p>而且我们想要观察的三个属性是：</p>
<ol>
<li>当X rem 15 =:= 0 ，我们想看到返回值是fizzbuzz。</li>
<li>当X rem 3 =:= 0，我们想看到返回值是fizz。</li>
<li>当X rem 5 =:= 0，我们想看到返回值是buzz。</li>
</ol>
<blockquote>
<p>注意：<br>请查阅所选测试库的实际文档。库调用的语法不同。</p>
</blockquote>
<p>测试引擎将尝试从定义的输入范围随机组合的值。测试引擎将确保在运行过程中观察到所有3个属性。</p>
<blockquote>
<p>注意：<br>你可以用这种方式测试任何黑盒系统，而不需要知道它的内部情况。所测试的系统可以是C程序，甚至是真正的硬件！<br>它也可以运行并行测试（确保当并行发生时，并行系统不发生故障）和状态机测试（确保状态机在随机的输入下不会有问题）。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-property-based.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-property-based.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你知道通常的单元测试，可能你就会听说过common test。有另一种方法来检查你的系统，不同于普通的测试方法。它被称为基于属性的测试。&lt;/p&gt;
&lt;p&gt;要做测试，应该定义输入数据的类型和范围，系统将在此基础上进行测试。输入数据的定义看起来像一个具有类型和范围参数描述的元组。它们是数据，而你在测试前生成这些数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="property-based testing" scheme="http://szpzs.oschina.io/categories/Erlang/property-based-testing/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="property-based testing" scheme="http://szpzs.oschina.io/tags/property-based-testing/"/>
    
  </entry>
  
  <entry>
    <title>类型之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2017/01/06/eli5-types/"/>
    <id>http://szpzs.oschina.io/2017/01/06/eli5-types/</id>
    <published>2017-01-06T13:44:11.000Z</published>
    <updated>2017-01-06T13:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang是一种动态类型语言。这意味着任何变量，字段或函数参数可以包含任何允许的值。</p>
<a id="more"></a>
<h1 id="类型规格说明"><a href="#类型规格说明" class="headerlink" title="类型规格说明"></a>类型规格说明</h1><p>有一种类型描述语言，你可以用它来描述你认为你的函数应该有什么样的入参和返回值。这些类型规格说明是可选的，并且即使有不合适的类型存在，编译器也将好像没有任何事情发生一样运行你的程序。为了确认你的类型规格说明彼此没有冲突，我们可以使用另一个工具，它叫做Dialyzer。</p>
<p>在Erlang源文件里，一个类型规格说明就是一条命令，它看起来如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-spec</span> func_name<span class="params">(Arg :: integer(), _, Y :: any())</span> -&gt; float<span class="params">()</span>.</div></pre></td></tr></table></figure>
<p>类型规格说明不是代码，它既不运行也不阻止你的程序被编译。</p>
<blockquote>
<p>请参阅：<br>你可以在<a href="http://erlang.org/doc/reference_manual/typespec.html" target="_blank" rel="external">类型规格说明参考手册</a>和其他已有的书籍，比如：<a href="http://learnyousomeerlang.com/types-or-lack-thereof" target="_blank" rel="external">Learn You Some Erlang</a> 里读到更多关于类型规格说明的内容。</p>
</blockquote>
<h1 id="Dialyzer"><a href="#Dialyzer" class="headerlink" title="Dialyzer"></a>Dialyzer</h1><p>Dialyzer把编译好的BEAM文件或Erlang源文件作为输入，然后尝试猜类型（类型推导）。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>假设你已经写了一个函数f，它有一个入参X并且返回一些值。Dialyzer首先做一个大致的假设，f是一个fun()，它的入参是任何值（(X :: any()）并且返回任何值（any()）。如下是Dialyzer一开始的猜测结果：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-spec</span> f<span class="params">(X :: any())</span> -&gt; any<span class="params">()</span>.</div></pre></td></tr></table></figure>
<p>Any()是最宽泛的类型，它可能包括任何值。然后Dialyzer分析这个函数的用法和它的代码，并尝试缩小入参和返回值类型到更狭窄特定的类型集合。</p>
<p>例如，如果Dialyzer发现仅有两个地方调用你的函数，分别传入整数入参和原子入参，那么X的类型缩小到 integer()|atom() （一个两个类型的集合）。如下就是Dialyzer可能推断出来的结果：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-spec</span> f<span class="params">(X :: integer() | atom())</span> -&gt; any<span class="params">()</span>.</div></pre></td></tr></table></figure>
<p>如果Dialyzer发现了一个矛盾，也就是一些类型其实合并后是一个空类型（none()）或不兼容的类型被发现，Dialyzer会报告一个错误。这些错误看起来令人困惑，不过它们常常（还是一直？）指出代码中存在的问题。</p>
<h1 id="Typer"><a href="#Typer" class="headerlink" title="Typer"></a>Typer</h1><p>Typer是另一个可选工具，在你的OTP环境里可以找到。Typer使用和Dialyzer一样的算法来推导给定模块里的各种类型并且打印它们。你可以把这些输出插入到你的程序里以备将来使用，或者为大的遗留项目做更好的文档。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-types.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-types.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang是一种动态类型语言。这意味着任何变量，字段或函数参数可以包含任何允许的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="TypeSpec" scheme="http://szpzs.oschina.io/categories/Erlang/TypeSpec/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="TypeSpec" scheme="http://szpzs.oschina.io/tags/TypeSpec/"/>
    
      <category term="Dialyzer" scheme="http://szpzs.oschina.io/tags/Dialyzer/"/>
    
      <category term="Typer" scheme="http://szpzs.oschina.io/tags/Typer/"/>
    
  </entry>
  
  <entry>
    <title>gen_tcp 和 active_once</title>
    <link href="http://szpzs.oschina.io/2017/01/05/active-once/"/>
    <id>http://szpzs.oschina.io/2017/01/05/active-once/</id>
    <published>2017-01-05T14:19:10.000Z</published>
    <updated>2017-01-05T14:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>我想理解和测试gen_tcp模块使用的active_once选项。整个过程我写了一些代码，包括三个监督者，一个gen_fsm和一个gen_server。</p>
<p>这是一篇gen_tcp和active_onece选项的概念证明文章。正如我一直说的，这只是我的学习笔记并且我可能是错的。所以查阅OTP文档和其他一些不错的书籍，可以发现关于这一主题的相关内容。</p>
<a id="more"></a>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>目标很简单，就是看看active_once选项如何控制数据流。也许这一次这个博客的简单概念证明的规则被打破了。本文的这个例子并不像以前那么简单，但我认为最终它是值得的。</p>
<h1 id="主动和非主动套接字"><a href="#主动和非主动套接字" class="headerlink" title="主动和非主动套接字"></a>主动和非主动套接字</h1><p>gen_tcp模块提供两种方式来读取套接字流，主动和非主动套接字。后者是传统的方式。通过使用recv/2和recv/3函数，进程决定什么时候从输入流读取数据。这种方式下，进程负责控制输入数据流。</p>
<p>另一方面，主动套接字允许按Erlang消息方式来接收数据。这种方式的问题是，对端进程可以无节制地发送数据来淹没我们进程的接收数据队列，因为我们的进程没有相应的流控策略。</p>
<p>不过现在有办法解决这个问题。通过设置active_once选项为true，进程按Erlang消息方式从套接字接收一次数据。一旦消息被接收到，套接字又转换为非主动方式，如果缓冲区满了，则阻止发送进程发送数据。进程可以再设置active_once选项来从套接字接收下一个Erlang消息来重复这个过程。</p>
<h1 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h1><p>控制进程就是当套接字被设置成主动或active_once的时候从套接字流接收到Erlang消息的那个进程。默认情况下，控制进程就是接收套接字的进程。</p>
<p>正如我们将看到的，可以用controlling_process/2函数来改变谁是控制进程。</p>
<h1 id="概念证明的结构"><a href="#概念证明的结构" class="headerlink" title="概念证明的结构"></a>概念证明的结构</h1><p>实际上，就如下图这么简单。</p>
<p><img src="/images/structure-poc.png" style="border:0;"></p>
<p><strong>main_sup: 主监督者。</strong></p>
<p><strong>listener_sup: 接收链接进程的监督者。</strong></p>
<p><strong>worker_sup: 读取工作者的监督者。</strong></p>
<p><strong>accept_fsm: 接收链接进程。</strong></p>
<p><strong>worker_gen: 套接字读取工作者。</strong></p>
<hr>
<p><strong>main_sup - 主监督者</strong></p>
<p>它使用permanent和one_on_one 重启策略。它有两个也是监督者的子进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(main_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"main_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    RestartStrategy = one_for_one,</div><div class="line">    MaxRestarts = <span class="number">10</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = permanent,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = supervisor,</div><div class="line"></div><div class="line">    ListenerSup = &#123;'listener_sup',</div><div class="line">		   &#123;'listener_sup', start_link, []&#125;,</div><div class="line">		   Restart, Shutdown, Type, ['listener_sup']&#125;,</div><div class="line"></div><div class="line">    WorkerSup = &#123;'worker_sup',</div><div class="line">		   &#123;'worker_sup', start_link, []&#125;,</div><div class="line">		   Restart, Shutdown, Type, ['worker_sup']&#125;,</div><div class="line"></div><div class="line">    ChildList = [ListenerSup, WorkerSup],</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, ChildList&#125;&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>listener_sup: 接收链接进程的监督者。</strong></p>
<p>它使用permanent和one_on_one 重启策略。它的子进程是accept_fsm进程。三个子进程被启动起来是为了准备大量链接的冲击。监听套接字在init函数里被创建，并且它的active属性设置为false，我们想使用默认的流控方式。</p>
<p>需要注意的是，三个子进程是用一个列表解析来创建的，在这里每一个id由build_label函数创建，结果id的格式是 accept_fsm_n，n是进程的顺序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(listener_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    &#123;ok, LSocket&#125; = gen_tcp:listen(<span class="number">2000</span>, [&#123;active, false&#125;]),</div><div class="line"></div><div class="line">    NumberOfWorkers = <span class="number">3</span>,</div><div class="line">    RestartStrategy = one_for_one,</div><div class="line">    MaxRestarts = <span class="number">100</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = permanent,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = worker,</div><div class="line"></div><div class="line">    ChildList = [&#123;build_label(<span class="string">"accept_fsm_"</span>, C),</div><div class="line">		  &#123;'accept_fsm', start_link, [LSocket]&#125;,</div><div class="line">		  Restart, Shutdown, Type, ['accept_fsm']&#125;</div><div class="line">		 || C &lt;- lists:seq(<span class="number">1</span>, NumberOfWorkers)],</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, ChildList&#125;&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">build_label</span><span class="params">(Name, C)</span> -&gt;</span></div><div class="line">    io_lib:format(<span class="string">"~s~w"</span>, [Name, C]).</div></pre></td></tr></table></figure>
<hr>
<p><strong>worker_sup: 读取工作者的监督者。</strong></p>
<p>它使用temporary和simple_on_on_one重启策略按需求来启动进程。它的子进程是worker_gen进程。它导出start_child/1函数，通过传递新的接收的套接字给此函数来启动一个worker_gen子进程。另外它设置新的子进程作为套接字的控制进程，这样该子进程就可以接收到Erlang消息流。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(worker_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, start_child/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:start_link...~n"</span>),</div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_child</span><span class="params">(ASocket)</span> -&gt;</span></div><div class="line">    &#123;ok, Pid&#125; = supervisor:start_child(?MODULE, [ASocket]),</div><div class="line">    gen_tcp:controlling_process(ASocket, Pid),</div><div class="line">    &#123;ok, Pid&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    RestartStrategy = simple_one_for_one,</div><div class="line">    MaxRestarts = <span class="number">100</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = temporary,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = worker,</div><div class="line"></div><div class="line">    AChild = &#123;'worker_gen', &#123;'worker_gen', start_link, []&#125;,</div><div class="line">	      Restart, Shutdown, Type, ['worker_gen']&#125;,</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, [AChild]&#125;&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>accept_fsm: 接收链接进程。</strong></p>
<p>这个进程被实现为一个FSM（有限状态机），而且只有一个状态，即accept状态。它接收一个侦听套接字并且在其上接收链接。当一个新的链接到来，这个进程设置套接收的套接字为active_once并且传递新的接收套接字给worker_sup请求其创建一个新子进程。然后这个进程再回到accept状态。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(accept_fsm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_fsm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_event/<span class="number">3</span>,</span></div><div class="line">	 handle_sync_event/<span class="number">4</span>, handle_info/<span class="number">3</span>, terminate/<span class="number">3</span>, code_change/<span class="number">4</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([accept/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">(LSocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:start_link...~n"</span>),</div><div class="line">    gen_fsm:start_link(?MODULE, [LSocket], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([LSocket])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:init...~n"</span>),</div><div class="line">    gen_fsm:send_event(self(), accept),</div><div class="line">    &#123;ok, accept, LSocket&#125;.</div><div class="line"></div><div class="line"><span class="comment">% Events.</span></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(accept, LSocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:accept...~n"</span>),</div><div class="line">    &#123;ok, ASocket&#125; = gen_tcp:accept(LSocket),</div><div class="line">    inet:setopts(ASocket, [&#123;active, once&#125;, &#123;packet, line&#125;]),</div><div class="line">    worker_sup:start_child(ASocket),</div><div class="line">    gen_fsm:send_event(self(), accept),</div><div class="line">    &#123;next_state, accept, LSocket&#125;.</div><div class="line"></div><div class="line"><span class="comment">% All events.</span></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(accept, _StateName, State)</span> -&gt;</span></div><div class="line">    &#123;next_state, accept, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_sync_event</span><span class="params">(_Any, _From, _StateName, State)</span> -&gt;</span></div><div class="line">    &#123;reply, ok, accept, State&#125;.</div><div class="line"></div><div class="line"><span class="comment">% OTP messeges.</span></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, StateName, State)</span> -&gt;</span></div><div class="line">    &#123;next_state, StateName, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _StateName, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, StateName, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, StateName, State&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>worker_gen: 套接字读取工作者。</strong></p>
<p>本文的概念证明就在这个进程里。它只是打印收到的数据到标准输出上。</p>
<p>为了观察流控的作用，在每次读取数据之间引入了一个延迟。在这种方式下，读取速度将比写的速度慢很多。当写缓冲满的时候会强制写进程停止写数据。</p>
<p>注意：每次读取数据后如何设置active_once选项以及如何设置packet类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(worker_gen)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_call/<span class="number">3</span>, handle_cast/<span class="number">2</span>, handle_info/<span class="number">2</span>,</span></div><div class="line">	 terminate/<span class="number">2</span>, code_change/<span class="number">3</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">(ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"worker_gen:start_link...~n"</span>),</div><div class="line">    gen_server:start_link(?MODULE, [ASocket], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([ASocket])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"worker_gen:init...~n"</span>),</div><div class="line">    &#123;ok, ASocket&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(&#123;tcp, _S, Data&#125;, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"~p~n"</span>, [Data]),</div><div class="line">    inet:setopts(ASocket, [&#123;active, once&#125;, &#123;packet, line&#125;]),</div><div class="line">    timer:sleep(<span class="number">100</span>),</div><div class="line">    &#123;noreply, ASocket&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(&#123;tcp_closed, _S&#125;, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Closed...~n"</span>),</div><div class="line">    &#123;stop, normal, ASocket&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(timeout, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Closed...~n"</span>),</div><div class="line">    &#123;stop, normal, ASocket&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Terminated...~n"</span>),</div><div class="line">    gen_tcp:close(ASocket),</div><div class="line">    ok.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<h1 id="代码的运行"><a href="#代码的运行" class="headerlink" title="代码的运行"></a>代码的运行</h1><p>让我们看看代码如何运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 17 [erts-6.1] [<span class="built_in">source</span>] [64-bit] [smp:4:4] [async-threads:10] [hipe]</div><div class="line">[kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V6.1  (abort with ^G)</div><div class="line">1&gt; l(main_sup).</div><div class="line">&#123;module,main_sup&#125;</div><div class="line">2&gt; main_sup:start_link().</div><div class="line">main_sup:init...</div><div class="line">listener_sup:init...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;0.35.0&gt;&#125;</div><div class="line">3&gt;</div></pre></td></tr></table></figure>
<p>我们链接上一个客户端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;0.35.0&gt;&#125;</div><div class="line">worker_gen:start_link...</div><div class="line">worker_gen:init...</div><div class="line">accept_fsm:accept...</div><div class="line">3&gt;</div></pre></td></tr></table></figure>
<p>然后从客户端写一些文本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;<span class="number">0.35</span>.<span class="number">0</span>&gt;&#125;</div><div class="line">worker_gen:start_link...</div><div class="line">worker_gen:init...</div><div class="line">accept_fsm:accept...</div><div class="line"><span class="string">"Hello World!!!\r\n"</span></div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>我们来写一大块数据并统计它的用时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time man ls|nc -c localhost 2000</div><div class="line"></div><div class="line">real	0m39.517s</div><div class="line">user	0m0.083s</div><div class="line">sys	0m0.019s</div><div class="line">$</div></pre></td></tr></table></figure>
<p>然后我们再做一次，不过这次我们去掉在每次读取数据之间的延迟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time man ls|nc -c localhost 2000</div><div class="line"></div><div class="line">real	0m0.100s</div><div class="line">user	0m0.085s</div><div class="line">sys	0m0.020s</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这两个测试让我们明白写进程是如何停下来等待缓冲区释放空间的。</p>
<p>在压力测试后，我们检查到没有进程泄露。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">3&gt; supervisor:count_children(main_sup).</div><div class="line">[&#123;specs,2&#125;,&#123;active,2&#125;,&#123;supervisors,2&#125;,&#123;workers,0&#125;]</div><div class="line">4&gt; supervisor:count_children(listener_sup).</div><div class="line">[&#123;specs,3&#125;,&#123;active,3&#125;,&#123;supervisors,0&#125;,&#123;workers,3&#125;]</div><div class="line">5&gt; supervisor:count_children(worker_sup).</div><div class="line">[&#123;specs,1&#125;,&#123;active,0&#125;,&#123;supervisors,0&#125;,&#123;workers,0&#125;]</div><div class="line">6&gt;</div></pre></td></tr></table></figure>
<p>我不太清楚这个解决方案有没有什么我不知道的问题。我尝试遵循我读过的Erlang和Elixir相关书籍中关于这个主题里学到模式。我可能有一些错误的地方，所以请阅读那些相关的书籍来获得关于这一主题的准确解释。</p>
<p>有任何更正、评论和建议请联系我，我很乐意听到你的反馈。</p>
<p>本文到此结束。</p>
<p>祝大家玩得开心。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://jmilet.github.io/erlang/2015/02/15/active_once.html" target="_blank" rel="external">http://jmilet.github.io/erlang/2015/02/15/active_once.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想理解和测试gen_tcp模块使用的active_once选项。整个过程我写了一些代码，包括三个监督者，一个gen_fsm和一个gen_server。&lt;/p&gt;
&lt;p&gt;这是一篇gen_tcp和active_onece选项的概念证明文章。正如我一直说的，这只是我的学习笔记并且我可能是错的。所以查阅OTP文档和其他一些不错的书籍，可以发现关于这一主题的相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="gen_tcp" scheme="http://szpzs.oschina.io/categories/Erlang/gen-tcp/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="gen_tcp" scheme="http://szpzs.oschina.io/tags/gen-tcp/"/>
    
      <category term="active" scheme="http://szpzs.oschina.io/tags/active/"/>
    
      <category term="active-once" scheme="http://szpzs.oschina.io/tags/active-once/"/>
    
      <category term="controlling process" scheme="http://szpzs.oschina.io/tags/controlling-process/"/>
    
      <category term="control flow" scheme="http://szpzs.oschina.io/tags/control-flow/"/>
    
  </entry>
  
  <entry>
    <title>总结2016，展望2017</title>
    <link href="http://szpzs.oschina.io/2016/12/31/2016-Summary/"/>
    <id>http://szpzs.oschina.io/2016/12/31/2016-Summary/</id>
    <published>2016-12-31T13:41:47.000Z</published>
    <updated>2016-12-31T13:59:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/my-road.jpg" style="border:0;"></p>
<h1 align="center">2016年：在路上</h1><br><h1 align="center">2017年：往前走</h1><br><h1 align="center">做时间的朋友</h1>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/my-road.jpg&quot; style=&quot;border:0;&quot;&gt;&lt;/p&gt;
&lt;h1 align=&quot;center&quot;&gt;2016年：在路上&lt;/h1&gt;&lt;br&gt;&lt;h1 align=&quot;center&quot;&gt;2017年：往前走&lt;/h1&gt;&lt;br&gt;&lt;h1 align
    
    </summary>
    
    
      <category term="2016" scheme="http://szpzs.oschina.io/tags/2016/"/>
    
      <category term="2017" scheme="http://szpzs.oschina.io/tags/2017/"/>
    
      <category term="Time" scheme="http://szpzs.oschina.io/tags/Time/"/>
    
      <category term="时间" scheme="http://szpzs.oschina.io/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>纯粹且简单的事务性内存</title>
    <link href="http://szpzs.oschina.io/2016/12/29/pure-and-simple-transaction-memories/"/>
    <id>http://szpzs.oschina.io/2016/12/29/pure-and-simple-transaction-memories/</id>
    <published>2016-12-29T05:22:47.000Z</published>
    <updated>2016-12-29T14:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇纯技术文章。</p>
<p>几个并行的程序如何维护一个状态的一致性视图？我的意思是，两个程序，可能处于不同的国家，如何用一致性方式来操作共同的状态变量？他们如何用一种不需要任何锁的方式来做到这点？</p>
<a id="more"></a>
<p>答案是令人吃惊的简单和不可思议的优美，那就是使用叫做事务性内存的方法。</p>
<h1 id="事务性内存是如何运作的？"><a href="#事务性内存是如何运作的？" class="headerlink" title="事务性内存是如何运作的？"></a>事务性内存是如何运作的？</h1><p>首先我必须解释为什么并发地更新数据会是一个问题。</p>
<p><img src="/images/tm1_problem.0.jpg" style="border:0;"></p>
<p>想像有一个服务器<strong>S</strong>有状态变量<strong>X</strong>和两个客户端<strong>C1</strong>和<strong>C2</strong>。客户端从服务器获取数据（图1）。现在两个客户端都认为<strong>X=20</strong>。<strong>C1</strong>给<strong>X</strong>增加<strong>20</strong>同时<strong>C2</strong>给<strong>X</strong>增加<strong>30</strong>。它们修改它们本地的副本（图2），并且将数据写回服务器（图3和图4）。如果这些操作是一个接一个地进行，那么最后服务器上的X的值应该是70而不是50，很明显现在有问题出现了。</p>
<p>解决此问题的常规方法是在独立的事务发生时锁定服务器，但这种方法正如<a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-dont-like-shared-memory.html" target="_blank" rel="external">我前面一篇文章</a>中指出的一样，它会有问题。</p>
<p>为了允许这些更新并行地执行而且不锁资源，我们可以使用叫做<a href="http://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="external">事务性内存</a>的方法。</p>
<h1 id="事务性内存"><a href="#事务性内存" class="headerlink" title="事务性内存"></a>事务性内存</h1><p><img src="/images/tm2_solution.0.jpg" style="border:0;"></p>
<p>一个事务性内存是一个元组（<strong>Var</strong>,<strong>Version</strong>,<strong>Value</strong>）的集合。如上图，X的版本是1而值是20，Y的版本是6而值是true。</p>
<p>版本数字表示这个变量被修改的次数。</p>
<p>现在我们来尝试做一个事务操作。假设我们想修改<strong>X</strong>和<strong>Y</strong>。首先我们给服务器发送消息：<strong>{get,X,Y}</strong>，服务器返回两个变量的值和它们各自的版本数字。</p>
<p>修改变量后，我们向服务器发送消息：{put,(X,1,30),(Y,6,false)}。仅当所有变量的版本数字与服务器中的变量的版本数字匹配，服务器将接收这个消息。然后服务器接受变量的修改并回复消息：<strong>yes</strong>。如果任何变量的版本数字不匹配，则服务器回复消息：<strong>no</strong>。</p>
<p>很明显，如果第二个进程在第一个进程回答之前更新内存，那么版本号将不一致，更新将失败。</p>
<p>请注意，该算法不锁定数据而且在一个分布式的环境中工作得很好，客户端和服务器处于物理上不同的机器上，这些机器之间的传输延迟是未知的。</p>
<p><strong>这不正是很好而且很老的基于set操作之上归纳出来的test-and-set操作吗？</strong></p>
<p>是的，当然是。如果你想想他们如何用信号量实现互斥的就明白了。信号量用一个原子的<strong>test-and-set</strong>指令来实现。一个信号量的值只能为0或1。test-and-set操作就是说，如果这个变量的值是0那么就把它的值改为1，这个操作是原子性的。要保留一个关键区域，它由一个标志保护。如果标志为0，那么它可以被保留，如果标志为1，那么它可以被使用。为了避免两个进程同时保留这个关键区域，test-and-set操作必须是原子性的。事务性内存只是概括了这个方法。</p>
<p>现在让我们用Erlang来实现它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(tm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, addVar/<span class="number">2</span>, getVars/<span class="number">2</span>, putVars/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% new() -&gt; Pid</span></div><div class="line"><span class="comment">%%   创建一个新的事务性内存 (TM)</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% addVar(Pid, Var) -&gt; ok</span></div><div class="line"><span class="comment">%%   增加一个变量到事务性内存</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% getVars([V1,...]) -&gt; [&#123;Vsn,Data&#125;,....]</span></div><div class="line"><span class="comment">%%   在事务性内存里查询变量V1，V2，...</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% putVars([&#123;Var,Vsn,Data&#125;]) -&gt; Bool</span></div><div class="line"><span class="comment">%%   修改事务性内存里的变量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">%% 下面是一个运行的例子</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% 1&gt; c(tm).</span></div><div class="line"><span class="comment">%% &#123;ok,tm&#125;</span></div><div class="line"><span class="comment">%% 2&gt; P=tm:new().</span></div><div class="line"><span class="comment">%% &lt;0.47.0&gt;</span></div><div class="line"><span class="comment">%% 3&gt; tm:addVar(x).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 4&gt; tm:addVar(P,x).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 5&gt; tm:addVar(P,y).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 6&gt; tm:getVars(P, [x,y]).</span></div><div class="line"><span class="comment">%% [&#123;ok,&#123;0,void&#125;&#125;,&#123;ok,&#123;0,void&#125;&#125;]</span></div><div class="line"><span class="comment">%% 7&gt; tm:putVars(P, [&#123;x,0,12&#125;,&#123;y,0,true&#125;]).</span></div><div class="line"><span class="comment">%% yes</span></div><div class="line"><span class="comment">%% 8&gt; tm:putVars(P, [&#123;x,1,25&#125;]).</span></div><div class="line"><span class="comment">%% yes</span></div><div class="line"><span class="comment">%% 9&gt; tm:getVars(P, [x,y]).</span></div><div class="line"><span class="comment">%% [&#123;ok,&#123;2,25&#125;&#125;,&#123;ok,&#123;1,true&#125;&#125;]</span></div><div class="line"><span class="comment">%% 10&gt; tm:putVars(P, [&#123;x,1,15&#125;]).</span></div><div class="line"><span class="comment">%% no</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span> spawn(<span class="keyword">fun</span>() -&gt; loop(dict:new()) <span class="keyword">end</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">addVar</span><span class="params">(Pid, Var)</span> -&gt;</span> rpc(Pid, &#123;create, Var&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">getVars</span><span class="params">(Pid, Vgs)</span> -&gt;</span> rpc(Pid, &#123;get, Vgs&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">putVars</span><span class="params">(Pid, New)</span> -&gt;</span> rpc(Pid, &#123;put, New&#125;).</div><div class="line"></div><div class="line"><span class="comment">%% 内部函数</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% 远程过程调用（RPC）</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Q)</span> -&gt;</span></div><div class="line">   Pid ! &#123;self(), Q&#125;,</div><div class="line">   <span class="keyword">receive</span></div><div class="line">       &#123;Pid, Reply&#125; -&gt; Reply</div><div class="line">   <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(Dict)</span> -&gt;</span></div><div class="line">   <span class="keyword">receive</span></div><div class="line">     &#123;From, &#123;get, Vars&#125;&#125; -&gt;</div><div class="line">        Vgs = lists:map(<span class="keyword">fun</span>(I) -&gt;</div><div class="line">                 dict:find(I, Dict) <span class="keyword">end</span>, Vars),</div><div class="line">        From ! &#123;self(), Vgs&#125;,</div><div class="line">        loop(Dict);</div><div class="line">     &#123;From, &#123;put, Vgs&#125;&#125; -&gt;</div><div class="line">        <span class="keyword">case</span> update(Vgs, Dict) <span class="keyword">of</span></div><div class="line">        no -&gt;</div><div class="line">                From ! &#123;self(), no&#125;,</div><div class="line">                  loop(Dict);</div><div class="line">        &#123;yes, Dict1&#125; -&gt;</div><div class="line">                From ! &#123;self(), yes&#125;,</div><div class="line">                loop(Dict1)</div><div class="line">        <span class="keyword">end</span>;</div><div class="line">    &#123;From, &#123;create, Var&#125;&#125; -&gt;</div><div class="line">       From ! &#123;self(), ok&#125;,</div><div class="line">       loop(create_var(Var, Dict))</div><div class="line">   <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">update</span><span class="params">([&#123;Var,Generation,Val&#125;|T], D)</span> -&gt;</span></div><div class="line">    &#123;G, _&#125; = dict:fetch(Var, D),</div><div class="line">    <span class="keyword">case</span> Generation <span class="keyword">of</span></div><div class="line">     G -&gt; update(T, dict:store(Var, &#123;G+<span class="number">1</span>, Val&#125;, D));</div><div class="line">     _  -&gt; no</div><div class="line">    <span class="keyword">end</span>;</div><div class="line"><span class="function"><span class="title">update</span><span class="params">([], D)</span> -&gt;</span></div><div class="line">    &#123;yes, D&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_var</span><span class="params">(Var, Dict)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> dict:find(Var, Dict) <span class="keyword">of</span></div><div class="line">   &#123;ok, _&#125; -&gt; Dict;</div><div class="line">   error -&gt; dict:store(Var, &#123;<span class="number">0</span>,void&#125;, Dict)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/09/pure-and-simple-transaction-memories.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/09/pure-and-simple-transaction-memories.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是一篇纯技术文章。&lt;/p&gt;
&lt;p&gt;几个并行的程序如何维护一个状态的一致性视图？我的意思是，两个程序，可能处于不同的国家，如何用一致性方式来操作共同的状态变量？他们如何用一种不需要任何锁的方式来做到这点？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="transaction memories" scheme="http://szpzs.oschina.io/categories/Erlang/transaction-memories/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="transaction memories" scheme="http://szpzs.oschina.io/tags/transaction-memories/"/>
    
  </entry>
  
  <entry>
    <title>为什么我不喜欢共享内存</title>
    <link href="http://szpzs.oschina.io/2016/12/26/why-i-dont-like-shared-memory/"/>
    <id>http://szpzs.oschina.io/2016/12/26/why-i-dont-like-shared-memory/</id>
    <published>2016-12-26T13:07:19.000Z</published>
    <updated>2016-12-26T13:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我上一篇博文《<a href="http://armstrongonsoftware.blogspot.com/2006/08/concurrency-is-easy.html" target="_blank" rel="external">并发是容易的</a>》里，我写了关于编写并发系统的一个简单模型。当你写博客的时候，你必须考虑目标受众和你想把博客定位在哪个级别上。它应该是技术先进的，还是应该普及你想谈论的观点？</p>
<a id="more"></a>
<p>我选择了用一个明显的非技术性的方式来谈论并发，我用人们互相交谈来类比并发这个概念。在我的博文里，我认为进程应该表现得很像人。人有私有的记忆并通过消息传递来改变自己的私有记忆。</p>
<p>现在对此文的反应超出了我的预料。首先很多人读我写的东西，这是一个惊喜。几乎没有宣传的情况下，这篇文章达到programming.reddit.com所有文章的第三位。事实上，上个星期三，排名reddit.com编程文章前五位的文章有三篇是关于Erlang的。其次，在reddit.com上有一个关于我这篇博文的讨论开始了。</p>
<p>在这里，我将回答在讨论里提出的第一个问题：</p>
<blockquote>
<p>Dogger说：</p>
<blockquote>
<p>我不太清楚为什么没有共享的内存会如此厉害。他抛出的简单的一问一答消息的例子并不是许多程序的工作机制。我认为发送消息有其地位，共享内存也一样。选择哪一个是最合适的。</p>
</blockquote>
</blockquote>
<p>很棒的评论！我们认为理所当然的事情是我们觉得最不需要解释的事情。现在我认为共享内存是错误的。在过去的二十年里，我一直这样认为，我认为这是不证自明的，而且从来没有真正解释为什么我认为共享内存是一个坏主意。所以在下面我将给出一些为什么我不喜欢共享内存的原因。</p>
<p>Dogger的第二个评论是：“他的例子…并不真正是很多程序的工作机制”，他这个评论当然是正确的。许多程序并不以我建议的方式来运行。关键点是这些程序可以用不同的编程风格编写，完全避免了共享内存和锁，并且利用了细粒度并发和纯消息传递。我也相信这样的程序更容易写和理解，因为我下面列出的所有与共享内存有关的问题都被避免了。请注意，我没有表明我有一个解决任何如下问题的方案。但我会说，这样的问题可以使用不同的编程风格来完全避免。</p>
<p>现在我将开始讲讲为什么我不喜欢共享内存：</p>
<h1 id="问题1：在关键区域崩溃的程序"><a href="#问题1：在关键区域崩溃的程序" class="headerlink" title="问题1：在关键区域崩溃的程序"></a>问题1：在关键区域崩溃的程序</h1><p>当两个或更多程序想要共享内存的时候下面的方法通常被用到。任何程序想操作共享内存必须如下列出的步骤来做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.操作共享内存</div><div class="line">3.释放这个锁</div></pre></td></tr></table></figure>
<p>获取锁之后和释放锁之前程序运行的代码被成为<em>关键区域</em>。在关键区域里的程序在运行期间不应该崩溃，而且在关键区域内不应该花太多时间。</p>
<p>如果程序在关键区域内崩溃的话会发生什么？</p>
<p>如果出现这种情况，则事情会变得很复杂。在理想的世界里，我们想要有这样的事务语义，即程序运行的净效应将是关键区域内的所有内存的改变都成功了，或者没有一个内存的改变成功并且内存的状态和程序进入关键区域前相同。</p>
<p>假设A尝试修改10个内存区域，这些区域叫做M1、M2…M10，那么程序假设如下所列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.修改 M1</div><div class="line">3.修改 M2</div><div class="line">4....</div><div class="line">5.修改 M10</div><div class="line">6.释放这个锁</div></pre></td></tr></table></figure>
<p>但是实际上可能是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.修改 M1</div><div class="line">3.修改 M2</div><div class="line">4.崩溃</div></pre></td></tr></table></figure>
<p>我们运行A想要的结果是，要么M1到M10的修改都成功，要么M1到M10的修改都不成功。因此，在上述第4步崩溃时，我们希望撤消前两个内存修改的结果。</p>
<p>要做到这点非常复杂，要假设有一些监督者程序在崩溃事件里能侦测到线程的崩溃并且恢复内存到原始状态。</p>
<h1 id="问题2：程序在关键区域花费太多时间"><a href="#问题2：程序在关键区域花费太多时间" class="headerlink" title="问题2：程序在关键区域花费太多时间"></a>问题2：程序在关键区域花费太多时间</h1><p>当一个程序位于一个关键区域内时，会发生很多事情，它可以操纵内存，这就是为什么它必须首先处于关键区域；并且它可以执行计算。问题是，这些计算发生时，该程序是在关键区域内。因此，如果这些计算需要很长的时间，那么等待访问共享内存的所有其他程序都将被排队，直到当前程序离开关键区域为止。</p>
<p>写在关键区域内执行的代码是非常困难的，因为我们要避免非常耗时的计算并将它们移到关键区域之外。我们还必须删除关键区域中的远程过程调用之类的东西，以防它们突然占用太长时间。所有这一切都是非常不自然的编程方式，很难难得到正确的结果。</p>
<h1 id="问题3：锁得太多"><a href="#问题3：锁得太多" class="headerlink" title="问题3：锁得太多"></a>问题3：锁得太多</h1><p>非常不幸地是我们经常锁的内存比我们想要的多得多，程序通常都是锁住所有共享内存，却只操作其中的一小段。在允许指针直接修改内存的语言中，可以保护的最小内存大小由页面表的粒度决定。一个典型的页面大小可能在8k到64k字节范围。8k字节的页面，你可能只想保护一个单字节，但你不得不保护最少8k字节。</p>
<p>您的程序可能只需要保护1字节，而系统中的其他程序可能希望修改在同一页的其他部分的内存，但它们必须等待，直到你的程序离开这个关键区域，它们才可以操纵他们相关的内存部分。</p>
<p>现在这一点在一个单CPU上可能并不重要，不同的线程都运行在同一个CPU，CPU总是忙，至少它在做一些事情。但在多核处理器上，这一点确实很重要。在多核CPU上，许多进程会等待获取锁，尽管逻辑上所有这些CPU可以并行运行。</p>
<p>当然，我们可以将共享内存划分成不同的分区，并让程序锁定到他们感兴趣的内存部分，但这样编程变得更加困难。</p>
<h1 id="问题4：分布式共享内存"><a href="#问题4：分布式共享内存" class="headerlink" title="问题4：分布式共享内存"></a>问题4：分布式共享内存</h1><p>现在事情变得真正复杂了。在单个主板上真正只有一个内存可以被不同的CPU访问，但在一个集群或在网络分布式系统，这是不可行的。真正发生的是，系统中的每个节点都有自己的内存，并且读写和锁被应用到本地内存。在任何一个系统中，其中一个内存必须承担某种主导角色，系统中的其他内存承担次要角色，并表现为高速缓存。然后在不同的内存之间运行某种缓存一致性协议，以确保访问该存储器的所有进程具有一致的世界观。</p>
<p>现在所有这一切是非常难以实现的。所以在这一点上，大多数程序员只有放弃并且使用容错分布式数据库。这种数据库通常是相当缓慢的，因为它必须在后台做很多复杂的东西。</p>
<h1 id="问题5：共享限制可扩展性"><a href="#问题5：共享限制可扩展性" class="headerlink" title="问题5：共享限制可扩展性"></a>问题5：共享限制可扩展性</h1><p>共享数据的线程不能独立地和并行地运行。在一个单核CPU上无所谓，但是在一个多核CPU上就有问题了。在线程共享数据的地方执行，它们的执行变成串行而不是并行。线程中的关键区域引入了限制可扩展性的串行瓶颈。</p>
<p>如果我们真的想要高性能，我们必须确保我们的应用程序不共享任何数据，这样我们就可以在许多独立的CPU上复制我们的解决方案。</p>
<h1 id="问题6：共享可以引入死锁"><a href="#问题6：共享可以引入死锁" class="headerlink" title="问题6：共享可以引入死锁"></a>问题6：共享可以引入死锁</h1><p>有时我们试图通过某种形式的细粒度共享来增加并发性。我们的想法是，不是锁定我们所有的内存，而是把内存分成更小的区域，只锁定那些我们感兴趣的内存。现在想象两个线程P和Q想要访问内存区域A和B。假设P锁定内存区域A，然后等待内存区域B，而Q刚好相反，即它先锁定B然后等待A。这导致死锁，P和Q现在无限期暂停。</p>
<h1 id="问题7：共享使得系统容易出错和调试困难"><a href="#问题7：共享使得系统容易出错和调试困难" class="headerlink" title="问题7：共享使得系统容易出错和调试困难"></a>问题7：共享使得系统容易出错和调试困难</h1><p>假设两个线程A和B共享数据。在A里的一个错误能够覆盖B使用的数据。即使B的代码都是正确的，它可能也会崩溃，因为它操作的数据结构被A破坏了。那么所有的系统应该完美地服从 <strong>我的程序不应该能够搞崩溃你的程序</strong>  这样的规则，但是当程序可以共享数据的情况下，这样的规则显然不成立。</p>
<p>调试变得可怕。线程B已经崩溃了，所以假定线程B的代码是不正确的似乎是合理的。这个假设是错误的，因为线程A的代码可能是祸因。这种因果分离使得调试非常困难。</p>
<p>最后，一个更普遍的评论是：</p>
<p><strong>共享不存在于现实世界中</strong></p>
<p>我以前是一个物理学家。在经典物理学中同时忽略量子效应情况下，现实世界中的两个物体不能同时存在于同一地点。</p>
<p>如果我们有两个物体，它们必须在不同的地方。现在，一个对象可以与另一个对象交互的唯一方式就是发送一条消息（比如说用光线）。如果光线编码一些关于状态变化的信息，那么就关心状态变化的接收对象而言，状态的变化只有在它消息收到后它才知道。</p>
<p>在简单的相对论里，同时发生的概念是不存在的。</p>
<p>关键点是现实中的对象不共享状态，我相信在软件中建模现实中不存在的东西不是一个好主意。</p>
<p>事实上您需要共享和锁来实现并行软件的想法是错误的。一切可以用共享和锁实现的，也可以用纯消息传递和无锁来实现。这就是<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>的方式。</p>
<p>在未来的博文中，我将告诉你如何做一个事务内存，它提供了一个无锁的方法在并行进程集里实现细粒度的状态一致性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/09/why-i-dont-like-shared-memory.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/09/why-i-dont-like-shared-memory.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我上一篇博文《&lt;a href=&quot;http://armstrongonsoftware.blogspot.com/2006/08/concurrency-is-easy.html&quot;&gt;并发是容易的&lt;/a&gt;》里，我写了关于编写并发系统的一个简单模型。当你写博客的时候，你必须考虑目标受众和你想把博客定位在哪个级别上。它应该是技术先进的，还是应该普及你想谈论的观点？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="shared-memory" scheme="http://szpzs.oschina.io/categories/Erlang/shared-memory/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="shared-memory" scheme="http://szpzs.oschina.io/tags/shared-memory/"/>
    
  </entry>
  
  <entry>
    <title>并发是容易的</title>
    <link href="http://szpzs.oschina.io/2016/12/25/concurrency-is-easy/"/>
    <id>http://szpzs.oschina.io/2016/12/25/concurrency-is-easy/</id>
    <published>2016-12-25T10:28:54.000Z</published>
    <updated>2016-12-25T10:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们了解并发。</p>
<p>对并发的深入理解已经深植于我们的大脑。我们对刺激的反应非常迅速，这由大脑的被称为杏仁核的一部分负责，没有这个反应系统我们可能会死掉。有意识的想法太慢了，当“刹车”的想法形成的时候，我们已经那么做完了。</p>
<a id="more"></a>
<p><img src="/images/many_cars.0.jpg" style="border:0;"></p>
<p>在高速公路，我潜意识地判断几十或数百辆汽车的位置，这样做是没有经过有意识的思考的。如果我不能这样做，我可能会死掉。</p>
<h1 id="世界是并行的"><a href="#世界是并行的" class="headerlink" title="世界是并行的"></a>世界是并行的</h1><p>如果我们想写的程序的行为和真实世界里事物的行为一样，那么这些程序将有一个并发的结构。</p>
<h1 id="这就是为什么我们应该用并发的编程语言编程"><a href="#这就是为什么我们应该用并发的编程语言编程" class="headerlink" title="这就是为什么我们应该用并发的编程语言编程"></a>这就是为什么我们应该用并发的编程语言编程</h1><p>然而，大多数情况下，我们用顺序的编程语言编程现实世界的应用程序。这肯定很困难。</p>
<p>用被设计为编写并发应用程序的语言（比如<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>）来编程，那么并发编程会变得容易很多。</p>
<h1 id="Erlang程序模型，我们如何思考和交互"><a href="#Erlang程序模型，我们如何思考和交互" class="headerlink" title="Erlang程序模型，我们如何思考和交互"></a>Erlang程序模型，我们如何思考和交互</h1><p>我们没有共享记忆。我有我的记忆，你有你的记忆，我们俩一共有两个大脑，彼此独立，它们不连在一起。为了要改变你的记忆，通过说话或挥动我的手臂的方式我发一个消息给你。你听到或看到，然后你的记忆改变了。但是如果我不问你或者不观察你的反应，我就不知道你是否收到了我发给你的消息。</p>
<p>Erlang进程也是如此。Erlang进程没有共享内存。每个进程有它自己的内存。为了改变其他进程的内存，你必须发送消息给它们并希望它们收到而且理解你发的消息的意思。</p>
<p>为了确认其他进程收到你的消息并改变了它的内存，你必须问它们（通过发送一条消息）。这正是我们人类如何彼此交互的方式。</p>
<p>苏：“嗨，比尔，我的电话号码是45 67 89 12”。</p>
<p>苏：“你听见了吗？”。</p>
<p>比尔：“收到，你的电话号码是45 67 89 12”。</p>
<p>这些互动模式对于我们来说非常熟悉，从出生开始，我们通过观察外部世界，并且通过发送信息给外部世界同时通过观察外部世界的反馈来学习与外部世界交互。</p>
<h1 id="人们作为独立实体通过发送消息进行交互"><a href="#人们作为独立实体通过发送消息进行交互" class="headerlink" title="人们作为独立实体通过发送消息进行交互"></a>人们作为独立实体通过发送消息进行交互</h1><p>这就是Erlang进程的工作方式，也是我们的工作方式，所以我们可以非常容易理解Erlang程序。</p>
<p>Erlang程序由许多小进程组成，这些进程之间总在喋喋不休的交流，就像我们人类。</p>
<p>一个Erlang程序由数十，可能数千，甚至数十万小进程组成。所有这些进程独立地运行。它们彼此通过发送消息来交流。每个进程有自己的私有内存。它们的行为就像一座大房子里的人们一样彼此通过聊天来交流。</p>
<p>这使得Erlang程序天生就容易管理和扩展。假设我们有十个人（进程），他们有太多的工作要做，我们该如何处理？答案就是让更多的人来做。我们怎么管理这些人？简单地朝他们喊指令就行（广播）。</p>
<p>Erlang进程没有共享内存，所以当一块内存被使用的时候就没必要给它上锁。有锁就需要钥匙，只要有锁，就有可能某天会丢失钥匙。当你丢了钥匙，会怎么样？你会惊慌失措。</p>
<p>有锁和钥匙的分布式软件系统总是出错。</p>
<h1 id="如果有人死了，其他人会注意到"><a href="#如果有人死了，其他人会注意到" class="headerlink" title="如果有人死了，其他人会注意到"></a>如果有人死了，其他人会注意到</h1><p>我在一个房间里，突然倒下死了，别人可能会注意到，至少我希望是如此。Erlang进程和我们人是一样的，他们有时也会死。不像人们死去时那样，Erlang进程在它们最后一口气的时候会大声喊出他们到底死于什么。</p>
<p>想象一个有很多人的房间，突然一个人倒下并死掉。就在他死亡的一刻，他说，“我死于心脏病”，或者，“我死于胃出血”。这就是Erlang进程的做法。一个进程死的时候可能会说：“我死于被要求被零除”，另一个进程死的时候可能会说：“我死于被要求查询空列表的最后一个元素是什么”。</p>
<p>现在在我们这个很多人的房间里，我们可以想象有一些人被特别地赋予清理尸体的特殊工作。假设有两个人，简和约翰。如果简死了，约翰会处理简的后事。如果约翰死了，简会处理约翰的后事。简和约翰被一个看不见的约定联系在一起，只要他们中的一个死亡，另一个就会处理后事。</p>
<p>这就是Erlang的错误发现机制，进程可以被链接在一起。如果其中一个进程死掉，其他进程会获得一个错误消息，这个消息告诉他们死亡进程的死亡原因。</p>
<p>基本上就是这样的。</p>
<p>这就是Erlang程序的工作机制。</p>
<h1 id="到目前为止我们学到了什么"><a href="#到目前为止我们学到了什么" class="headerlink" title="到目前为止我们学到了什么"></a>到目前为止我们学到了什么</h1><p>Erlang程序由许多进程组成。这些进程彼此之间可以发送消息。这些消息可能会或可能不会被接收和理解。如果你想知道消息是否被接收和理解，你必须给进程发送一条消息并等待回复。</p>
<p>进程可以被链接在一起。如果链接中的一个进程死掉，其他的进程会被发送一条包含这个进程为什么死掉的消息。</p>
<p>这个简单的编程模型是被我称为面向并发编程模型的一部分。你可以在<a href="http://www.sics.se/~joe/thesis" target="_blank" rel="external">这里</a>参阅更多信息。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/08/concurrency-is-easy.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/08/concurrency-is-easy.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们了解并发。&lt;/p&gt;
&lt;p&gt;对并发的深入理解已经深植于我们的大脑。我们对刺激的反应非常迅速，这由大脑的被称为杏仁核的一部分负责，没有这个反应系统我们可能会死掉。有意识的想法太慢了，当“刹车”的想法形成的时候，我们已经那么做完了。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="concurrency" scheme="http://szpzs.oschina.io/categories/Erlang/concurrency/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="concurrency" scheme="http://szpzs.oschina.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>我们没有走过的路</title>
    <link href="http://szpzs.oschina.io/2016/12/24/road-we-didnt-go-down/"/>
    <id>http://szpzs.oschina.io/2016/12/24/road-we-didnt-go-down/</id>
    <published>2016-12-24T04:58:03.000Z</published>
    <updated>2016-12-24T05:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直在关注Erlang邮件列表里的一个有趣的讨论，在这个讨论里，Steve Vinoski和朋友们告诉我们RPC的问题是什么。</p>
<p>讨论开始在5月22日，共同话题是facebook宣布已部署了一个用Erlang写的聊天服务器。</p>
<p>在其中的一个帖子里Steve写道：</p>
<a id="more"></a>
<blockquote>
<p>“所有那些年的 CORBA 经验教给我的，也就是那个RPC，因为一些原因，总的来说它是一个<strong>真正的坏主意</strong>。它是一个来之不易的教训。Erlang 的 RPC 是很棒的，因为整个 Erlang 系统从根本上设计并将其内置到语言中，但对于普通的语言，RPC 带来的问题比它解决的问题多。”<br><a href="http://www.erlang.org/pipermail/erlang-questions/2008-May/035191.html" target="_blank" rel="external">更多…</a><br>– Steve Vinoski</p>
</blockquote>
<p>后续的帖子要求Steve详细阐述这点。</p>
<p>Steve在Erlang邮件列表里发了一篇很长并且精彩的关于RPC问题总结的帖子：</p>
<blockquote>
<p>“但是如果你没有时间或精力，最根本的问题是，RPC试图使得一个分布式调用看起来像一个本地调用。这是行不通的，因为在分布式系统中的错误模式完全不同于本地系统中的错误模式，……”<br><a href="http://www.erlang.org/pipermail/erlang-questions/2008-May/035207.html" target="_blank" rel="external">更多…</a><br>– Steve Vinoski</p>
</blockquote>
<p>精辟！是的，是的，是的。当我读到这个，我的大脑大叫：是的，是的，是的 - 谢谢你，史提夫。史提夫在《<a href="http://steve.vinoski.net/pdf/IEEE-RPC_Under_Fire.pdf" target="_blank" rel="external">RPC Under Fire</a>》里关于这点写了更多。</p>
<h1 id="这是一条我们没走过的路"><a href="#这是一条我们没走过的路" class="headerlink" title="这是一条我们没走过的路"></a>这是一条我们没走过的路</h1><p>Steve沿着这条路走，看见一些事情，也看到它非常糟糕的地方，但他活着回来，可以告诉我们他所看见的事情。</p>
<p>调用一个远程操作并且包装它看起来像一个本地操作的根本问题是本地的错误模式和远程操作的错误模式是完全不同的。</p>
<p>如果这还不够糟糕，性能方面也完全不同。本地的操作需要几微秒，当通过一个RPC执行的时候，可能忽然就花掉几毫秒。</p>
<p>如果程序员不能判断本地和远程调用之间的不同，那么要写出高效的代码基本不可能。随意放置RPC在一些乱七八糟的软件中可以（必定）破坏性能。</p>
<blockquote>
<p>我亲眼见证了几个大型项目的失败，正是因为本地和远程过程调用之间的区别还不清楚。</p>
</blockquote>
<p>注意：这个因素在有几十个程序员参与的大项目里变得更糟糕。如果是一个小团队，则还有机会挽救，这需要参与者清楚哪些是本地调用，哪些是是远程调用。</p>
<h1 id="在Erlang的世界我们是如何做的？"><a href="#在Erlang的世界我们是如何做的？" class="headerlink" title="在Erlang的世界我们是如何做的？"></a>在Erlang的世界我们是如何做的？</h1><p>所有Erlang程序是由并行进程集合组成的，这些进程可以创建其他进程并且发送和接收消息。这么做非常简单而且是一个轻量操作。</p>
<p>为了错误处理的目的，进程可以彼此链接在一起。如果A链接到B并且A崩溃了，那么B会被发送一个错误信号，反之亦然。链接机制与消息发送/接收机制完全正交。</p>
<p>当我们编写分布式系统，各种形式的RPC通常是非常有用的编程抽象，但RPC的确切形式因问题不同而不同，也因系统架构不同而不同。</p>
<p>RPC的确切形式凝固成一个刚性框架，不顾错误场景是场灾难。</p>
<p>用发送、 接收和链接，Erlang 程序员可以很容易把自定义错误处理“揉进他们自己的RPC”。</p>
<p>在Erlang里没有“标准PRC存根生成器”，Erlang也没有聪明到有一个如此的生成器。</p>
<p>在很多应用里，RPC尽可能最简单的形式就够了，我们可以定义它如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">     &#123;Pid, Response&#125; -&gt;</div><div class="line">        Response</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这一点都不复杂。这段代码只是发送一条消息然后等待回复。</p>
<p>在这个主题上有很多的变化。最简单的RPC将永远等待下去，所以如果回复一直不来的话，客户端就会挂起。我们可以用增加超时来修复这个问题：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request, Time)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    &#123;Pid, Response&#125; -&gt;</div><div class="line">        &#123;ok, Response&#125;</div><div class="line">    <span class="keyword">after</span> Time -&gt;</div><div class="line">        &#123;error, timeout&#125;</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>假设我们希望在一个PRC调用中远程机器死掉的时候一个异常在客户端被抛出，那么我们可以写如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></div><div class="line"> link(Pid),</div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    Response -&gt;</div><div class="line">        Response</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>如果在RPC里有任何差错的话，附加的链接将确保客户端终止。</p>
<p>假设我们想要“并行化两个RPC”，则代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid1, Pid2, Request)</span> -&gt;</span></div><div class="line"> Pid1 ! Pid2 ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    &#123;Pid1, Response1&#125; -&gt;</div><div class="line">        <span class="keyword">receive</span></div><div class="line">            &#123;Pid2, Response2&#125; -&gt;</div><div class="line">                &#123;Response1, Response2&#125;</div><div class="line">        <span class="keyword">end</span></div><div class="line">     <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>（不用担心这段代码的执行，消息的回复顺序是无关紧要的。）</p>
<p>我想通过一些小例子来说明的观点是，RPC的粒度级别和错误特性是在编程人员的精确控制下的。</p>
<p>如果事实证明这些RPC的抽象不是我们真正想要的，然后我们可以很容易地用原始的进程和消息方式来写我们的解决方案。</p>
<p>所以，例如，从一个消息序列图得到Erlang代码是一个简单的编程工作。</p>
<p>“标准”的RPC也做以下的疯狂的假设”，回复应该一定返回到客户”。</p>
<p>互相合作的形式，比如告诉X做Y然后发送结果到Z，这种形式是不可能用一个标准的 RPC 框架（如 SOAP)来表达的，但在Erlang中表达却很简单︰</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(tell,X,toDo,Y,replyTo,Z)</span> -&gt;</span></div><div class="line"> X ! &#123;Z, Y&#125;.</div></pre></td></tr></table></figure>
<p>（这里假设约定我前面一直用发送两个元素的元组当作消息，其中有进程的Id，它被期待当作回复消息的元组的第一元素（在前面的例子例我们用self()，这样就强制要求回复消息返回给原请求者））</p>
<p>假设我们要加版本信息到我们的协议，这也很容易做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request, Vsn)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), vsn, Vsn, Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">     ...</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>关键点是，这里展示的事情，比如像版本信息、错误处理平行化等等都是容易添加的，只要我们暴露消息和函数调用之间的接口并允许用户定制构建他们自己和远程代码的交互形式。</p>
<p>当然，组件间交互的一定通用模式将浮现，它们被加入OTP库。</p>
<h1 id="什么是OTP？"><a href="#什么是OTP？" class="headerlink" title="什么是OTP？"></a>什么是OTP？</h1><p>OTP是在相当常见的场景下像RPC一样做事的一套久经测试验证的方法。OTP方法没有覆盖所有错误场景，不过它们覆盖了通常的场景。我们经常需要跨出OTP框架外设计我们自己特定的错误和恢复策略，不过做这些都很简单，因为OTP它自己是一个消息驱动的框架，所有我们必须要做的是去掉那些存根函数，用我们自己定制的函数来替换它们来发送和接收消息。</p>
<p>OTP应该重新命名为“OTP on rails”，它真的只是一个构建容错系统的框架。</p>
<p>这种没有过度依赖一个特别的RPC方式来构建软件的方法可行吗？</p>
<p>我的回答是可行的，而且肯定可行。</p>
<p>我们用这种方式构建实时服务器软件在爱立信已经有几十年了。我们已经用PLEX, EriPascal, Erlang 和 C++ with Rose-RT好多年了。所有这些的共同点就是不依赖RPC。我们指定协议，然后我们用一些不同的技术实现它们。</p>
<p>这些协议比指定使用的RPC是更复杂的方式，但是通过暴露协议和错误模式，我们可以使得系统高可用。</p>
<p>我一直认为如果我们用RPC来做事情，我们会遇到麻烦。</p>
<p>Steve这么做过也遇到了这些问题，而我们走的是不同的路。</p>
<p>真正有趣的是，史提夫的世界和我们的世界开始碰撞-我们有很多东西要互相学习。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2008/05/road-we-didnt-go-down.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2008/05/road-we-didnt-go-down.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直在关注Erlang邮件列表里的一个有趣的讨论，在这个讨论里，Steve Vinoski和朋友们告诉我们RPC的问题是什么。&lt;/p&gt;
&lt;p&gt;讨论开始在5月22日，共同话题是facebook宣布已部署了一个用Erlang写的聊天服务器。&lt;/p&gt;
&lt;p&gt;在其中的一个帖子里Steve写道：&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="RPC" scheme="http://szpzs.oschina.io/categories/Erlang/RPC/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="RPC" scheme="http://szpzs.oschina.io/tags/RPC/"/>
    
  </entry>
  
</feed>
