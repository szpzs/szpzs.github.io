<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2018-10-18T05:23:27.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Xref删除Erlang死代码</title>
    <link href="http://szpzs.oschina.io/2018/10/18/remove-erlang-dead-code-xref/"/>
    <id>http://szpzs.oschina.io/2018/10/18/remove-erlang-dead-code-xref/</id>
    <published>2018-10-18T05:20:54.000Z</published>
    <updated>2018-10-18T05:23:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你不去管死代码(就像那些不在任何地方使用的函数)，它们就会堆积在大项目中。使用Xref最被低估的特性之一，你将能够检测和删除不再需要的死代码。</p>
<p>我们已经在这个博客里写了几篇关于我们如何大量使用Erlang/OTP来构建我们的实时竞价平台服务器的文章。</p>
<p>这些系统很大，到现在已经存在了很长时间。 就像任何大型旧系统一样，它们包含一些不再使用的代码片段。 需要明确的是：它们没有被破坏，它们甚至被测试所覆盖，但它们都没有在生产中使用。</p>
<p>在Erlang中，这些死代码表现为未使用的函数。 确切地说：它们是未使用的<strong>导出函数</strong>，因为在编译时会检测到未导出并且未使用的函数。</p>
<a id="more"></a>
<p>在一个大系统里找出未使用的导出函数是很困难的。幸运的是，Erlang/OTP已经给我们提供了一个工具来做这个事情，它就是：<a href="http://erlang.org/doc/man/xref.html" target="_blank" rel="external">Xref</a>。</p>
<blockquote>
<p>Xerf是一个交叉引用工具，可用于查找函数、模块、应用程序和发布之间的依赖关系。</p>
</blockquote>
<p>如果你使用<a href="https://rebar3.org/" target="_blank" rel="external">rebar3</a>管理你的项目，那么你就可以运行如下简单的命令来使用<em>Xref</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 xref</div></pre></td></tr></table></figure>
<p>如果你没有在 rebar.config 文件里为 Xref 进行任何配置的话，它将会检查你整个项目，并且进行所有可能的检查。这样的话，对于大项目来说，警告列表就会大量生成，因此，人们常常在 rebar.config 里进行如下配置：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;xref_checks,  [</div><div class="line">	undefined_function_calls,</div><div class="line">	locals_not_used,</div><div class="line">	deprecated_function_calls</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>也就是说，这样的配置产生的报告就是如下三种：</p>
<ul>
<li>调用的函数不存在（undefined_function_calls）</li>
<li>未使用未导出函数（locals_not_used）</li>
<li>调用过期函数（deprecated_function_calls）</li>
</ul>
<p>你可以在<a href="https://www.rebar3.org/docs/configuration#section-xref" target="_blank" rel="external">
</a>里找到所有可检查的列表，但是，我想要你注意的是，后两项是编译器已经检查到的（如果你启用了正确的警告），而真正有效的检查是对 <em>undefined_function_calls</em> 的执行。这是一个很好的运行检查，但它不会帮助我们解决原始的死代码问题。</p>
<p>那么让我们来看看我们没有执行的检查。 通常，<em>undefined_functions</em>将报告与<em>undefined_function_calls</em>相同的结果，但是没有用实际的函数调用（不是很有用）。 <em>deprecated_functions</em>和<em>deprecated_function_calls</em>也是如此。 但是，我们有<em>exports_not_used</em>，这正是我们正在寻找的检查。</p>
<p>把 <em>exports_not_used</em> 添加到我们的配置列表里，它将会报告那些我们导出了但是没有使用的函数。真是太棒了！</p>
<p>但是为什么没有人使用它呢？🤔</p>
<p>使用exports_not_used时有一些注意事项。 我现在列出它们，我会告诉你如何解决或至少让它们正常运作。</p>
<h1 id="动态调用的函数"><a href="#动态调用的函数" class="headerlink" title="动态调用的函数"></a>动态调用的函数</h1><p>Xref将为在代码中找不到使用的每个导出函数报告一个警告。但是，Xref找不到它在哪里被使用，并不意味着实际使用函数的地方不存在。例如，Xref不能处理动态函数调用，但是它们是完全有效的使用方式。假设你有一个模块看起来像下面代码所示（别问我为什么）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(sample)</span>.</div><div class="line">-exports<span class="params">([some_function/<span class="number">1</span>,  some_other_function/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">some_function</span><span class="params">(M)</span>  -&gt;</span></div><div class="line">	M:some_other_function(an_argument).</div><div class="line"></div><div class="line"><span class="function"><span class="title">some_other_function</span><span class="params">(X)</span>  -&gt;</span></div><div class="line">	&#123;called,  X&#125;.</div></pre></td></tr></table></figure>
<p>而在另一些模块里，你可能这么调用：<code>sample:some_function(sample)</code> 。<em>Xref</em>没有足够聪明到探测到 <code>sample:some_other_function/1</code> 被真正使用了，因为它仅仅是通过动态评估来进行检查。上面的例子只是执行函数动态调用的其中一种方式。你可以通过如下示例看看其他方式：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 经典的动态调用</span></div><div class="line">Module:Function(Argument, Argument2),</div><div class="line"></div><div class="line"><span class="comment">% 使用 erlang:apply/3</span></div><div class="line">erlang:apply(Module, Function, Arguments),</div><div class="line"></div><div class="line"><span class="comment">% 使用 spawn[_link]/3</span></div><div class="line">erlang:spawn(Module, Function, Arguments),</div><div class="line"></div><div class="line"><span class="comment">% 使用 timer:tc/3</span></div><div class="line">timer:tc(Module, Function, Arguments),</div><div class="line"></div><div class="line"><span class="comment">% 在监督者的规格说明里</span></div><div class="line">&#123;ChildName, &#123;Module, Function, Arguments&#125;, permanent, <span class="number">5000</span>, worker, dynamic&#125;,</div></pre></td></tr></table></figure>
<p>注：如果添加{xref_warnings，true}. 到你的 rebar.config文件中，Xref至少会为这些无法解析的动态调用打印警告，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sample:  1  unresolved  call</div></pre></td></tr></table></figure>
<p>无论如何，只要你的系统比原型稍微大一点，你就会开始在代码的各处出现导出而未使用的函数。但不要惊慌，实际上有一种方法可以避免这些警告，而且它还有一些额外的好处。这种方法就是使用<code>ignore_xref</code>。</p>
<p>-ignore_xref是一个属性，你可以把它添加到你到模块中来阻止Xref对特定对函数发出警告。它的使用看起来如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(sample)</span>.</div><div class="line">-exports<span class="params">([some_function/<span class="number">1</span>, some_other_function/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% This function should be dynamically invoked through sample:some_function/1</span></div><div class="line">-ignore_xref<span class="params">([&#123;?MODULE, some_other_function, <span class="number">1</span>&#125;])</span>.</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>现在如果你查看OTP中Xref的文档，你不会找到有关这个属性的片言只语。这是因为它不是官方属性。ignore_xref 是 rebar3 xref（<a href="https://hex.pm/packages/xref_runner" target="_blank" rel="external">xref_run</a>也一样） 的未公开文档属性。这个属性可以被添加到你的模块中，在当中列出那些你不想被Xref检查的函数。它的语法如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-ignore_xref<span class="params">([&#123;module(),  function(),  arity()&#125;  |  &#123;module(),  function()&#125;])</span>.</div></pre></td></tr></table></figure>
<p>使用这种方式，你可以有效地移除掉有关那些被导出的只被动态调用的函数的警告。另外，如上例所示，你可以在这个属性的上方添加注释，这些函数将在哪里被使用。</p>
<h1 id="动态生成的代码"><a href="#动态生成的代码" class="headerlink" title="动态生成的代码"></a>动态生成的代码</h1><p>你可能不是一个动态生成代码的发烧友，但是有时候你还真不可避免地要遇到动态生成的代码。</p>
<p>例如，我们在系统的几个地方使用了<code>protobuf</code>，导致我们使用了<a href="https://hex.pm/packages/gpb" target="_blank" rel="external">gpb</a>和它的<code>rebar3</code>插件。当用gpb写模块的时候，它是不知道这个模块是如何被使用的，因此它就无法判断函数是否不需要被导出。这就意味着，当我们使用<code>Xref</code>的时候，会得到由gpb生成的所有被导出而未被使用的函数的警告。</p>
<p>如何避免这些警告呢？我们不能使用 <code>-ignore_xref</code>，因为代码不是我们手写的，而是gpb自动生成的。事实证明，还有另一种方式。 我们可以在rebar.config中使用读起来怪怪的的xref_ignores属性。 它基本上允许你拥有一个可以在任何地方被忽略的全局的函数列表。 它看起来像这样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;xref_ignores, [</div><div class="line">    &#123;my_gpb_generated_module, some_function, <span class="number">1</span>&#125;,</div><div class="line">    &#123;my_gpb_generated_module, some_other_function, <span class="number">0</span>&#125;,</div><div class="line">    &#123;my_gpb_generated_module, a_function_with_various_arities&#125;,</div><div class="line">    ...</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>目前还没有办法忽略一个模块里的所有函数，不过我已经给这个项目提了 <a href="https://github.com/erlang/rebar3/issues/1905" target="_blank" rel="external">issue</a>。或许你也可以把这个问题作为一个 <a href="https://hacktoberfest.digitalocean.com/" target="_blank" rel="external">hacktoberfest</a> 项目来攻克。</p>
<h1 id="导出函数被系统外部使用"><a href="#导出函数被系统外部使用" class="headerlink" title="导出函数被系统外部使用"></a>导出函数被系统外部使用</h1><p>如果你有一些函数仅仅因为当你远程登录到生产中的服务器时，会在shell中使用它们而被导出，那会怎么样？如果它们被外部脚本在你的节点执行RPC调用的时候被使用或诸如此类的情况，那会怎么样？</p>
<p>在这种情况下，我建议你使用 <code>-ignore_xref</code>，并在那里添加一个适当的注释，说明如何/何时/在哪里使用这些函数。我保证，这么做将来会有回报的。</p>
<h1 id="导出函数仅用于测试"><a href="#导出函数仅用于测试" class="headerlink" title="导出函数仅用于测试"></a>导出函数仅用于测试</h1><p>我有时候会遇到另一种不同的场景（特别是有关遗留代码的时候），就是被导出只是为了它们可以被测试。我们的想法是模拟它们或访问一些内部逻辑，否则这些内部逻辑应该隐藏在生产系统中。</p>
<p>首先，如果你使用<a href="http://erlang.org/doc/man/eunit.html" target="_blank" rel="external">
</a>，你就不需要导出那些函数。你可以在测试中使用非导出的函数。</p>
<p>现在，如果你使用通用测试或其他需要在被测模块外部编写测试的框架，那就是另一回事了。 我认为重要的是要考虑导出函数只是为了在测试中使用它们一般是不可取的，因为……</p>
<ul>
<li>如果你的函数未导出和未使用，则编译器会检测它们，如前所述，这允许你更早地发现错误。</li>
<li>如果要添加在生产中不可用的函数并且/或者做不应该在生产中完成的功能，那么你的测试不会准确模拟真实场景，这可能会导致测试通过代码仍然无法如预期一样正常工作。</li>
</ul>
<p>尽管如此，有时候还是没有办法解决它：你需要模拟一些外部世界看不到的东西，你需要验证一些只以非常复杂的格式暴露的数据或者检测真正难以捕获的副作用。 在这些场景中，<code>ignore_xref</code>以及一个简洁的注释对于未来的开发人员来说是避免意外和挫折的好工具，使得他们可以发现一个未使用的函数，决定删除它。</p>
<h1 id="库接口"><a href="#库接口" class="headerlink" title="库接口"></a>库接口</h1><p>最后，还有另外一种情况，你确实需要导出应用程序中没有实际使用的函数：当你的应用程序是一个库时（例如，当你正在构建一个应用程序以便在其他系统中用作依赖项时）。在这种情况下，一些函数构成了应用程序的接口，它们不会被应用程序使用。它们是公开的，所以你的用户可以在他们的应用程序中调用它们。</p>
<p>这些函数都将被报告为未使用的导出函数，并且必须为所有这些函数编写<code>ignore_xref</code> / <code>xref_ignore</code>，这样做不是好的办法。但是真正好的办法是在测试中覆盖它们。如果你这样做了，你就有了避免警告的方法并且实际上只为导出、未使用和未测试的函数生成警告。你可以像如下方式运行<code>Xref</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 as <span class="built_in">test</span> xref</div></pre></td></tr></table></figure>
<p>使用<code>test profile</code>，<code>rebar3</code>将把所有测试模块包含到分析中，并且由于你的接口函数将在这里使用，所以它不会警告您。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然<code>Xref</code>是一个强大的工具，但是它需要一些调整来挖掘它的全部潜力。</p>
<p>首先，你必须使用正确的检查。我们的推荐检查列表是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;xref_checks, [</div><div class="line">    undefined_function_calls,</div><div class="line">    exports_not_used</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>然后，你必须适当地使用<code>-ignore_xref</code>属性和<code>xref_ignores</code>配置参数来标识有意导出和未使用的所有函数。 如果你正在编写库，则还应该使用<code>rebar3 as test xref</code>来考虑分析中的测试。</p>
<p>有了这些，你应该会得到0个警告的报告，因此你可以确定项目中没有任何死代码。</p>
<p>嗯，实际上，你没有任何死函数（未使用的导出）。 但你仍然会有未使用的函数子句，未使用的case子句等形式的死代码，这些代码还不少，<code>Xref</code>将不会检测到这些问题。</p>
<p>为此，你需要一个更强大的工具：<a href="http://erlang.org/doc/man/dialyzer.html" target="_blank" rel="external">dialyzer</a>。 我们不会在本文中介绍它，但请继续关注后续的文章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://tech.adroll.com/blog/dev/2018/10/09/remove-erlang-dead-code-xref.html" target="_blank" rel="external">http://tech.adroll.com/blog/dev/2018/10/09/remove-erlang-dead-code-xref.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你不去管死代码(就像那些不在任何地方使用的函数)，它们就会堆积在大项目中。使用Xref最被低估的特性之一，你将能够检测和删除不再需要的死代码。&lt;/p&gt;
&lt;p&gt;我们已经在这个博客里写了几篇关于我们如何大量使用Erlang/OTP来构建我们的实时竞价平台服务器的文章。&lt;/p&gt;
&lt;p&gt;这些系统很大，到现在已经存在了很长时间。 就像任何大型旧系统一样，它们包含一些不再使用的代码片段。 需要明确的是：它们没有被破坏，它们甚至被测试所覆盖，但它们都没有在生产中使用。&lt;/p&gt;
&lt;p&gt;在Erlang中，这些死代码表现为未使用的函数。 确切地说：它们是未使用的&lt;strong&gt;导出函数&lt;/strong&gt;，因为在编译时会检测到未导出并且未使用的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="xref" scheme="http://szpzs.oschina.io/categories/Erlang/xref/"/>
    
      <category term="dialyzer" scheme="http://szpzs.oschina.io/categories/Erlang/xref/dialyzer/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="xref" scheme="http://szpzs.oschina.io/tags/xref/"/>
    
      <category term="dialyzer" scheme="http://szpzs.oschina.io/tags/dialyzer/"/>
    
  </entry>
  
  <entry>
    <title>Go v1.11中的Go模块介绍，再见GOPATH!</title>
    <link href="http://szpzs.oschina.io/2018/10/12/go-version-1-11-modules/"/>
    <id>http://szpzs.oschina.io/2018/10/12/go-version-1-11-modules/</id>
    <published>2018-10-12T10:21:48.000Z</published>
    <updated>2018-10-18T05:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你开始学习Go时，需要一些时间来了解如何设置你的开发环境。对我来说，理解编译器在搜索依赖项方面是如何工作的有一点学习曲线。</p>
<a id="more"></a>
<p>在设置开发环境时，必须执行的一个强制性步骤是配置GOPATH环境变量。<code>$GOPATH</code>是Go编译器在构建Go应用程序时用来搜索依赖项的。<code>$GOPATH</code>包含源代码和二进制文件。</p>
<p>GOPATH包含以下目录：</p>
<ul>
<li>$GOPATH/src -包含所有Go源代码和第三方源代码依赖项</li>
<li>$GOPATH/pkg -包含包</li>
<li>$GOPATH/bin -包含二进制文件</li>
</ul>
<p>在最新的主要版本<a href="https://golang.org/doc/go1.11" target="_blank" rel="external">Go v1.11</a>中，GOPATH不再是强制性的。 Go团队在这个新版本中引入了<a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="external">模块</a>。 模块是相关Go包的集合。 这是Go团队在Go中改进包管理的重要一步。</p>
<p>使用当前版本1.11，你现在可以在GOPATH之外构建Go应用程序。在1.11中，当你将源代码放在<code>$GOPATH</code>中时，它会忽略模块特性，并使用GOPATH搜索源代码依赖项。但是，如果将源代码放在GOPATH之外，模块支持就会自动启用。这意味着，你现在可以从任意目录构建应用程序!</p>
<p>我创建了一个样例Go模块，你可以用它来学习Go模块的概念。这是源代码的地址：<a href="https://github.com/donvito/hellomod" target="_blank" rel="external">https://github.com/donvito/hellomod</a>。你可以随意fork，并用于你自己的学习。该模块有3个版本。</p>
<p><img src="/images/go-version-1-11-modules-1.png" style="border:0;"> </p>
<p>为了演示如何在应用程序中使用Go模块，让我们假设hellomod是应用程序中需要的第三方模块。</p>
<p>让我们创建一个客户端应用程序来使用<a href="https://github.com/donvito/hellomod/" target="_blank" rel="external">hellomod</a>模块。 如下是我们可以开始的一些代码。 将此代码保存为main.go在你希望的任何目录中。</p>
<p><strong>main.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"></div><div class="line"><span class="string">"github.com/donvito/hellomod"</span></div><div class="line"></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">hellomod.SayHello()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们要初始化对模块的支持。确保GOPATH没有被设置，这样我们就可以自动使用Go 1.11中的模块特性。在终端中执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go mod init hello</div></pre></td></tr></table></figure>
<p>这将创建一个go.mod文件。除了你刚刚初始化的模块名，这里没有什么可以看到的。go.mod将包含如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module hello</div></pre></td></tr></table></figure>
<p>在执行“go mod init hello”之后，执行如下命令来构建你的应用程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build</div></pre></td></tr></table></figure>
<p>“go build”的作用是根据import语句解析应用程序的依赖，并添加最新版本的依赖，然后编译应用程序并生成二进制文件。</p>
<p>由于我们最新版本的hellomod是v1.0.1，go.mod现在包含内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module hello</div><div class="line"></div><div class="line">require github.com/donvito/hellomod v1<span class="number">.0</span><span class="number">.1</span></div></pre></td></tr></table></figure>
<p>“go build”还会创建一个go.sum文件，其中包含特定模块版本内容的预期加密校验和。 它的定义来自这里。<a href="https://github.com/golang/go/wiki/Modules#releasing-modules-all-versions" target="_blank" rel="external">https://github.com/golang/go/wiki/Modules#releasing-modules-all-versions</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">github.com/donvito/hellomod v1<span class="number">.0</span><span class="number">.1</span> h1:tOU3KDwvrGW7QUHXYQnk6YUD+<span class="number">92</span>aTsRmJItJTD9f4I4=</div><div class="line">github.com/donvito/hellomod v1<span class="number">.0</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:DuOSvrBCwGkjX0WS5ohdpC/q67fS0Mde3LEM+<span class="number">2</span>jeHSw=</div></pre></td></tr></table></figure>
<p>以下是我们迄今执行的命令：</p>
<p><img src="/images/go-version-1-11-modules-2.png" style="border:0;"> </p>
<p>你可以运行由“go build”创建的二进制文件来检查我们是否在使用hellomod的1.0.1版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./hello</div><div class="line">Hello World v1.0.1!!!</div></pre></td></tr></table></figure>
<p>假设你想恢复到hellomod模块的先前版本v1.0.0。 你只需执行以下命令即可。 这将使用以前的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/donvito/hellomod@v1.0.0</div><div class="line">$ go build</div><div class="line">$ ./hello</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>作为参考，这是v1.0.0的样子：</p>
<p><strong>hellomod v1.0.0</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hellomod</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//SayHello function</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(<span class="string">"Hello World"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要升级主版本，你需要更import语句中的版本。</p>
<p><strong>main.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"></div><div class="line"><span class="string">"github.com/donvito/hellomod/v2"</span></div><div class="line"></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">hellomod.SayHello(<span class="string">"Melvin"</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后构建应用程序并运行二进制文件“hello”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go build</div><div class="line">$ ./hello</div><div class="line">Hello MelvinHello World v2.0.0!!!</div></pre></td></tr></table></figure>
<p>以下是go.mod在执行“go build”后的样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module hello</div><div class="line"></div><div class="line">require (</div><div class="line">	github.com/donvito/hellomod v1<span class="number">.0</span><span class="number">.0</span></div><div class="line">	github.com/donvito/hellomod/v2 v2<span class="number">.0</span><span class="number">.0</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>是的，可以使用同一模块的不同版本。 一下是一个示例，我们可以看到模块的两个不同版本可以独立使用。 你需要为每个版本使用别名以避免冲突。</p>
<p><strong>main.go ( 客户端应用程序使用两个不同版本的hellomod模块 ) </strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"></div><div class="line">	hellomod <span class="string">"github.com/donvito/hellomod"</span></div><div class="line"></div><div class="line">	hellomodV2 <span class="string">"github.com/donvito/hellomod/v2"</span></div><div class="line"></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	hellomod.SayHello()</div><div class="line"></div><div class="line">	hellomodV2.SayHello(<span class="string">"Melvin"</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本文到此结束！希望你能从这篇文章中学到一些东西！: )</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.melvinvivas.com/go-version-1-11-modules/" target="_blank" rel="external">https://www.melvinvivas.com/go-version-1-11-modules/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你开始学习Go时，需要一些时间来了解如何设置你的开发环境。对我来说，理解编译器在搜索依赖项方面是如何工作的有一点学习曲线。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://szpzs.oschina.io/categories/Go/"/>
    
      <category term="Modules" scheme="http://szpzs.oschina.io/categories/Go/Modules/"/>
    
    
      <category term="Go" scheme="http://szpzs.oschina.io/tags/Go/"/>
    
      <category term="Modules" scheme="http://szpzs.oschina.io/tags/Modules/"/>
    
  </entry>
  
  <entry>
    <title>Rust的所有权（二）</title>
    <link href="http://szpzs.oschina.io/2018/08/10/ownership-in-rust-part-2/"/>
    <id>http://szpzs.oschina.io/2018/08/10/ownership-in-rust-part-2/</id>
    <published>2018-08-10T07:43:30.000Z</published>
    <updated>2018-08-10T08:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们<a href="https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b" target="_blank" rel="external">上次</a>学习Rust中的所有权时，我们学习了Rust如何使用作用域来确定何时应该删除或释放内存中的资源或数据。</p>
<p>我们发现，对于具有“copy trait”的类型(即其数据可以存储在栈上的类型)，所有权模型的行为类似于其他可能使用不同范式的语言，如垃圾收集。但是对于没有这种trait的类型，我们需要更加意识到所有权规则。</p>
<p>尽管所有权可能会带来设计上的妥协，但它以灵活性、明确性和安全性来弥补。</p>
<a id="more"></a>
<h1 id="所有权和函数"><a href="#所有权和函数" class="headerlink" title="所有权和函数"></a>所有权和函数</h1><p><img src="/images/ownership-in-rust-part-2-1.png" style="border:0;"></p>
<center>复制 vs 移动</center>

<p>在第一个例子里，我们先传递一个字符串字面值（它的数据存储在栈上）给函数foo()。在第二个例子里，我们传递一个字符串类型的值（它的值存储在堆上）给不同函数foo()。在这两个例子的main()和foo()的实现，我们把在各自作用域变量的内存地址打印出来。</p>
<p><img src="/images/ownership-in-rust-part-2-2.png" style="border:0;"></p>
<p>在第一个例子中，当我们复制变量的值并将其绑定到一个新变量时，我们看到类似的行为。 这是因为字符串字面量使用栈；存储指针所需的大小在编译时是已知的，因此，我们可以轻松地复制它的值并将其压入栈中。</p>
<p>这意味着函数main()和foo()都拥有自己的存储在变量string的指针副本。 当foo()的作用域结束时，foo()负责删除它自己的string变量，当main()的作用域结束时，它也负责删除它拥有的string变量。</p>
<p><img src="/images/ownership-in-rust-part-2-3.png" style="border:0;"></p>
<p>相反，在第二个例子里，main()把变量string的所有权移交给foo()。这意味着，main()不再有变量string的所有权，即指针指向的内存的所有权。如果在所有权移交后，我们还在main()里尝试访问string变量，我们将收到错误。</p>
<p>复制很昂贵，Rust不复制，而是使得foo()负责内存地址0x7efced01c010的数据，如示例注释所示。</p>
<p>现在，仅当foo()超过作用域，Rust才释放那个地址的内存，从而使指向同一地址的任何其他变量失效。同样，我们这样做是为了避免重复释放的错误。</p>
<h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><p>对于第二个示例，如果我们确实要复制string的值，那么main()和foo()都拥有自己的副本，类似于在栈上使用字符串字面量时，我们可以通过使用clone()方法进行“深度复制” ：</p>
<p><img src="/images/ownership-in-rust-part-2-4.png" style="border:0;"></p>
<center>clone()</center>

<p>如注释所示，main()和foo()有各自的string复制的所有权。虽然这是一个有效的解决方案，但它不是最有效率的，因为Rust每次都需要在堆上进行内存分配的过程。有时你真的希望这两个函数与同一个数据交互！(稍后将详细介绍)。</p>
<h1 id="给予所有权"><a href="#给予所有权" class="headerlink" title="给予所有权"></a>给予所有权</h1><p>正如通过调用另一个函数并传入变量来获取所有权一样，可以通过从不同函数返回来赋予函数所有权。</p>
<p><img src="/images/ownership-in-rust-part-2-5.png" style="border:0;"></p>
<center>给予所有权</center>

<p>foo()现在通过将字符串返回到调用foo()的位置来赋予main()所有权。正如所料，只有当main()的作用域结束时，Rust才会释放0x7fc98be1c010地址的内存。</p>
<h1 id="给予和获取"><a href="#给予和获取" class="headerlink" title="给予和获取"></a>给予和获取</h1><p>如果我们遵循这一趋势，那么我们既可以给予所有权，也可以通过接收foo()返回相同的字符串类型将所有权归还给我们。</p>
<p><img src="/images/ownership-in-rust-part-2-6.png" style="border:0;"></p>
<center>传递所有权</center>

<p>但是，将这些值传入和传出函数似乎很麻烦。 幸运的是，这是Rust维护者考虑到的头痛问题：</p>
<blockquote>
<p>取得所有权然后通过各种函数归还所有权有点单调乏味。 如果我们想让一个函数使用一个值但不取得所有权，该怎么办？ 如果我们想要再次使用它，除了我们可能想要返回的函数体所产生的任何数据之外，我们传入的任何内容都需要传回。 对我们来说幸运的是，Rust有一个这个概念的特性，称为引用。<br>— <a href="https://doc.rust-lang.org/book/second-edition/" target="_blank" rel="external"><em>Rust Book</em></a></p>
</blockquote>
<h1 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h1><p>所有权适用于共享和传递数据，但是，你必须遵循一些规则。</p>
<p>借用看起来像这样：</p>
<p><img src="/images/ownership-in-rust-part-2-7.png" style="border:0;"></p>
<p>main()让foo()访问string，但是，（如果图中的标签所示），main()仍然是string的所有者。这意味着，foo()的作用域结束后，string不会被从内存中释放；main()仍然负责string的内存空间。</p>
<p>以下是我们如何在Rust中编写这种交互：</p>
<p><img src="/images/ownership-in-rust-part-2-8.png" style="border:0;"></p>
<center>传递引用或借用</center>

<p>就像我们的绘图一样，main()将字符串的引用传递给foo()，而foo()接收String类型引用。 引用由＆符号表示。 在foo()的作用域结束之后，执行返回到它的调用者，main()，并且字符串仍然有效。 foo()不必返回所有权，因为它从未获得所有权，只是借用了它。</p>
<p>&amp;表示<em>引用</em>，它允许传递值而不需要放弃所有权！当我们传递引用的时候，Rust知道，所有权以及内存空间的释放的责任依然属于原来的所有者。</p>
<p>Rust允许我们创建任意数量的引用。</p>
<p><img src="/images/ownership-in-rust-part-2-9.png" style="border:0;"></p>
<center>传递同一个值的多个引用</center>

<p>不管我们传递string的引用多少次，它的所有权依然是原来的所有者。（在这种情况下，所有权返回到字符串最初被实例化的地方，但是请记住，我们可以传递所有权，然后创建引用。）</p>
<h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>最后要提到的是可变性。 Rust通常以函数式编写，但作者非常务实，并且理解现代语言并不总是那么非黑即白，因此Rust适应了可变性。</p>
<p><img src="/images/ownership-in-rust-part-2-10.png" style="border:0;"></p>
<center>mut</center>

<p>Rust允许我们使用 mut 关键字来使得值可变。注意内存地址的变化，这表明必须在堆上重新分配字符串。</p>
<p>既然我们有一个可变变量，我们就可以做出一个可变引用！</p>
<p><img src="/images/ownership-in-rust-part-2-11.png" style="border:0;"></p>
<center>传递一个可变引用</center>

<p>此处的语法有点特别，但是我们看到首先我们需要声明一个可变变量 <code>let mut string</code> 。然后当我们传递可变引用的时候，使用 <code>&amp;mut</code>。最后，我们在函数签名上用 <code>&amp;mut</code> 严格声明我们的函数接收一个可变引用。</p>
<p>现在，我们仍然可以确定只有main()负责string变量的销毁，而同时允许其他函数来修改string。</p>
<p>那些熟悉内存管理的人可能会想，如果不加以控制，这将是多么危险。如果几个函数持有一个可变引用，并试图同时异步更新同一内存位置，会发生什么情况；比如当使用线程时？这会导致数据竞争情况。</p>
<blockquote>
<p>当两个或多个线程可以访问共享数据并试图同时更改数据时，就会出现竞争情况。因为线程调度算法可以在任何时候在线程之间切换，所以你不知道线程试图访问共享数据的顺序。因此，数据变化的结果取决于线程调度算法，即两个线程都“竞相”访问或改变数据。<br>— <a href="https://stackoverflow.com/users/142/lehane" target="_blank" rel="external">Lehane</a> &amp; <a href="https://stackoverflow.com/users/3001736/amit-joki" target="_blank" rel="external">Amit Joki</a> 在 <a href="https://stackoverflow.com/a/34550" target="_blank" rel="external">SO</a>上的回答</p>
</blockquote>
<p>当使用低级语言(如Rust )时，这个问题会更加严重。Rust允许我们访问原始指针，这可能会导致许多不安全的情况。</p>
<p>这是所有权被设置来防止的事情，它通过强制实施以下规则来做到这一点：“在任何给定的时间点，你可以有一个可变引用或者任何数量的不可变引用。”</p>
<blockquote>
<p>具有此限制的好处是Rust可以在编译时阻止数据争用。 数据竞争类似于竞争条件，并且在发生以下三种行为时发生：</p>
<ul>
<li>两个或多个指针同时访问相同的数据。</li>
<li>至少有一个指针用于写入数据。</li>
<li>没有用于同步访问数据的机制。</li>
</ul>
<p>数据争用会导致未定义的行为，并且在你尝试在运行时跟踪它们时可能难以诊断和修复；Rust可以防止这个问题的发生，因为它甚至不会编译通过有数据争用的代码！<br>—<a href="https://doc.rust-lang.org/book/second-edition/" target="_blank" rel="external">Rust Book</a></p>
</blockquote>
<p>Rust的所有权规则再次拯救了我们，这被强调为Rust提供的核心安全特性，超过了其他系统语言。这意味着Ruby程序员和我一样，仍然不需要熟悉内存管理的内部工作。</p>
<h1 id="悬空的引用"><a href="#悬空的引用" class="headerlink" title="悬空的引用"></a>悬空的引用</h1><p>最后一件事是，在传递引用时，还有另一个条件会导致称为悬空引用的bug。</p>
<p>悬空引用是指向已释放的数据的指针，例如:</p>
<p><img src="/images/ownership-in-rust-part-2-12.png" style="border:0;"></p>
<center>悬空引用—编译不会成功</center>

<p>在这个例子中，<code>foo()</code> 返回一个 string 的引用。但是，一旦 <code>foo()</code> 的作用域结束，string的内存被释放，这意味着引用指向无效的内存空间！</p>
<p>Rust在编译这样的代码的时候会抛出错误：</p>
<p><img src="/images/ownership-in-rust-part-2-13.png" style="border:0;"></p>
<p>Rust使用者们可以享受所有权带来的好处而不需要理解它提供的保护。然而，理解所有权解决的问题只会帮助我们写出更好的代码而不需要和编译器斗争。</p>
<p>还有一些关于Rust所有权的问题没有涉及到，但是有了这两篇文章，希望你能有足够的机会开始使用这个优雅的解决方案来解决一个其他棘手的问题。</p>
<blockquote>
<p><em>原文链接：</em> <a href="https://medium.com/@thomascountz/ownership-in-rust-part-2-c3e1da89956e" target="_blank" rel="external">https://medium.com/@thomascountz/ownership-in-rust-part-2-c3e1da89956e</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们&lt;a href=&quot;https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b&quot;&gt;上次&lt;/a&gt;学习Rust中的所有权时，我们学习了Rust如何使用作用域来确定何时应该删除或释放内存中的资源或数据。&lt;/p&gt;
&lt;p&gt;我们发现，对于具有“copy trait”的类型(即其数据可以存储在栈上的类型)，所有权模型的行为类似于其他可能使用不同范式的语言，如垃圾收集。但是对于没有这种trait的类型，我们需要更加意识到所有权规则。&lt;/p&gt;
&lt;p&gt;尽管所有权可能会带来设计上的妥协，但它以灵活性、明确性和安全性来弥补。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://szpzs.oschina.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://szpzs.oschina.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="http://szpzs.oschina.io/tags/Ownership/"/>
    
  </entry>
  
  <entry>
    <title>Rust的所有权（一）</title>
    <link href="http://szpzs.oschina.io/2018/08/10/ownership-in-rust-part-1/"/>
    <id>http://szpzs.oschina.io/2018/08/10/ownership-in-rust-part-1/</id>
    <published>2018-08-10T07:43:26.000Z</published>
    <updated>2018-08-10T08:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个Ruby开发者，我所知道的关于内存分配的所有内容都是由一些称为垃圾收集的进程处理的，这是<a href="https://medium.com/@tenderlove" target="_blank" rel="external">Aaron Patterson</a>的问题，而不是我的问题。</p>
<p>因此，当我阅读<a href="https://doc.rust-lang.org/book/second-edition/" target="_blank" rel="external">Rust Book</a>并看到Rust的一个明确的特性是垃圾收集的替代品时，我有点担心。</p>
<p>处理内存管理的责任是不是要摊派到我的身上?</p>
<p>显然，对于其他系统编程语言，如C语言，处理内存分配是一件大事，如果做得不好，可能会产生重大后果。<br>随着所有其他新事物的学习，我觉得事情开始堆积起来。</p>
<a id="more"></a>
<h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><p>不，它不是一个时髦的服装品牌，栈和堆是在运行时管理内存的方法。</p>
<p><img src="/images/ownership-in-rust-part-1-1.png" style="border:0;"></p>
<p>首先，我们有<strong>栈</strong>。栈被认为是快速的，因为它根据顺序存储和访问数据。最后一个放在（推入）栈上的数据是从栈中取出（弹出）的第一个数据。这被称为<em>LIFO</em>，即后进先出，这意味着我们只需要在释放内存的时候跟踪堆栈顶部的位置。</p>
<p>栈很快的另一个原因是堆栈所需的空间量在编译时是已知的。 这意味着我们可以在将任何内容存储到其中之前分配一个固定大小的内存部分。</p>
<p>例如，如果你知道有4来你家吃饭聚会，你就可以预先安排好他们的座位，准备好食物，并在他们到来之前练习如何叫他们的名字。这样非常高效！</p>
<p>接下来，我们有另一个选择，<strong>堆</strong>。当你不能预先知道来你家吃饭聚会的确切人数，你可以使用堆。随着越来越多的人来到你的晚餐聚会，使用堆意味着找到额外的椅子并发出姓名标签。</p>
<p>当运行时需要存储未知大小的数据时，计算机搜索堆上的内存，标记它，并返回指针，指针指向内存中的那个位置。这叫做内存分配。然后，你可以将指针压入栈，但是，当你想要检索实际数据时，你需要跟随指针返回到堆。</p>
<p>当我继续深入研究栈和堆，感觉到似乎在堆中管理数据是很困难的。例如，你需要确保在使用完内存后，允许计算机重新分配内存中的位置。但是，如果代码的某个部分释放了内存中的一个位置，而代码的另一部分仍然有指针指向这个位置，那么就会发生一些奇怪的事情。</p>
<blockquote>
<p>跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上重复数据的数量，清理堆上未使用的数据，以免耗尽空间，这些都是所有权要解决的问题。<br>-<a href="https://doc.rust-lang.org/book/second-edition/" target="_blank" rel="external">Rust Book</a></p>
</blockquote>
<h1 id="所有权和作用域"><a href="#所有权和作用域" class="headerlink" title="所有权和作用域"></a>所有权和作用域</h1><p><img src="/images/ownership-in-rust-part-1-2.png" style="border:0;"></p>
<p>Rust的所有权有三个规则：</p>
<ul>
<li>Rust中的每个值都有一个称为其所有者的变量。</li>
<li>任何时刻只能有一个所有者。</li>
<li>当所有者超出作用域时，该值将被删除。</li>
</ul>
<p>这种所有权魔力的最简单说明是变量的作用域：</p>
<p><img src="/images/ownership-in-rust-part-1-3.png" style="border:0;"></p>
<center>变量作用域</center>

<p>一旦当前函数范围结束，由 <code>}</code> 表示，变量hello超出作用域，并被删除。</p>
<p>“嗯，呸！”这就是我第一次看到这个时的想法。这在大多数其他编程语言中是一样的。这就是我所知道的“局部作用域变量”的行为。”</p>
<p>如果这就是所有权的全部知识，我真就有点不知所措了。</p>
<p>然而，当我们开始传递值并从使用存储在栈中的字符串字面值切换到使用存储在堆中的字符串类型时，事情变得更加有趣。</p>
<p><img src="/images/ownership-in-rust-part-1-4.png" style="border:0;"></p>
<center>复制 vs 移动</center>

<p>我们可以看到，当使用字符串字面量的时候，Rust把hello的值复制到hello1里，这个符合我们的预期。但是当使用String类型的时候，Rust反而是移动值。当我们尝试获取已经被移走的值的时候，Rust会报错：error[E0382]: use of moved value: ‘hello’。</p>
<p>看起来在使用字符串字面量时，Rust会将该一个变量的值复制到另一个变量中，但是当我们使用String类型时，它会移动该值。</p>
<p>要找到哪些类型实现了<code>copy trait</code>，“你可以查看文档，但是一般来说，任何一组简单标量值都可以被复制，任何需要分配或某种形式的资源都不会被复制”。</p>
<h1 id="为什么不复制一切？"><a href="#为什么不复制一切？" class="headerlink" title="为什么不复制一切？"></a>为什么不复制一切？</h1><p><img src="/images/ownership-in-rust-part-1-5.png" style="border:0;"></p>
<center>当使用&amp;str的时候，用Copy trait</center>

<p>字符串字面量”Hello, World!”存储在只读内存的某个地方（既不在栈中也不在堆中），而指向这个字符串字面量的指针存储在栈中。因为它是一个字符串字面量，它通常显示为引用，这意味着我们使用指向永久内存中存储的字符串的指针(关于引用的更多信息，请参见<a href="https://medium.com/@thomascountz/ownership-in-rust-part-2-c3e1da89956e" target="_blank" rel="external">Rust的所有权，第2部分</a>)，并且它保证在整个程序的持续时间内有效，(它有一个静态生命周期)。</p>
<p>这里，hello和hello1中存储的指针正在使用栈。当我们使用=运算符时，Rust将hello中存储的指针的新副本压入栈，并将其绑定到hello1。在作用域的末尾，Rust添加了一个drop调用，从栈中弹出值以释放内存。这些指针可以被存储并容易地复制到栈中，因为它们的大小在编译时是已知的。</p>
<p><img src="/images/ownership-in-rust-part-1-6.png" style="border:0;"></p>
<center>当使用堆，用Move trait</center>

<p>在堆上，字符串类型值为“Hello，World！”使用<code>String : : from</code>方法绑定到变量hello。然而，与字符串字面量不同，绑定到hello的数据不仅仅是指针，这些数据的大小会在运行时发生变化。在这里，=运算符将hello中的数据绑定到新变量hello1，有效地将数据从一个变量移动到另一个变量。可怜的hello现在无效，因为根据所有权第二条规则：“一次只能有一个所有者。”</p>
<p>但是为什么要这样做？Rust为什么不一直仅仅拷贝数据并把它绑定到新变量？</p>
<p>如果我们回想一下栈和堆之间的差异，我们会记得堆上存储的数据大小在编译时是未知的，这意味着我们需要在运行时运行一些内存分配步骤。 这可能是很昂贵的操作。 根据我们存储的数据量，如果我们整天都在制作数据副本，我们可能会快速耗尽内存。</p>
<p>除此之外，Rust的默认行为有助于保护我们免受在其他语言中可能遇到的记忆问题。</p>
<p>在堆上存储数据的一部分是在栈上存储指向该数据的指针。然而，与使用指针定位只读存储器不同，比如当使用字符串字面量时，指向堆的指针末端的数据可能会改变。指针是绑定到存储字符串类型的hello变量的数据的一部分。如果我们将同一个指针数据绑定到两个不同的变量，它可能如下所示:</p>
<p><img src="/images/ownership-in-rust-part-1-7.png" style="border:0;"></p>
<center>复制字符串类型数据的粗略草图</center>

<p>我们有两个变量，hello和hello1，它们共享同一份数据的所有权，这违反所有权第二条规则：“一次只能有一个所有者。”让我们继续往下看。</p>
<p>在hello和hello 1的作用域结束时，我们必须将堆中的内存释放，以便在其他地方再次使用。</p>
<p><img src="/images/ownership-in-rust-part-1-8.png" style="border:0;"></p>
<center>释放hello1</center>

<p>首先，我们对绑定到hello1的指针指向的存储数据调用drop，但是当我们在hello上调用drop时，接下来会发生什么？</p>
<p><img src="/images/ownership-in-rust-part-1-9.png" style="border:0;"></p>
<center>重复释放错误</center>

<p>这称为重复释放错误，我认为对此最好的总结是 <a href="https://stackoverflow.com/a/21057524" target="_blank" rel="external">Stack Overflow 上的回答</a>：</p>
<blockquote>
<p>从技术上讲，在C语言中，重复释放会导致未定义的行为。这意味着程序可以完全任意地运行，并且对所发生的一切都没有把握。发生这种事当然是件坏事！在实践中，重复释放内存块将破坏内存管理器的状态，这可能导致现有内存块被破坏，或者导致未来的分配以奇怪的方式失败(例如，相同的内存被两个连续的不同malloc调用来处理)。<br>重复释放在各种情况下都可能发生。一个相当常见的情况是，多个不同的对象都有指向彼此的指针，并开始通过调用free来清理。当这种情况发生时，如果你不小心，你可能会在清理对象时多次释放同一个指针。不过，还有很多其他的情况。<br>— <a href="https://stackoverflow.com/users/501557/templatetypedef" target="_blank" rel="external">templatetypedef</a></p>
</blockquote>
<p>这就是Rust试图防止发生的！通过使hello无效，编译器知道只在hello1上调用drop（在幕后调用free）。</p>
<p>这一切都很好，但是在某些情况下，我们确实希望复制存储在堆中的数据。Rust为此提供了一种简单的方法，就是<code>clone()</code>函数。</p>
<p><img src="/images/ownership-in-rust-part-1-10.png" style="border:0;"></p>
<center>深度复制</center>

<p>请记住，对clone()的调用可能很昂贵，这就是Rust默认禁止这种“深度复制”的原因。</p>
<p>显然，关于Rust所有权的问题比这里所提到的要多得多；还有一些概念叫做借用、引用和切片！</p>
<p>迄今为止，似乎了解所有权更多的是为了浏览Rust的内存管理解决方案，而不是了解它解决的问题。但是，<a href="https://doc.rust-lang.org/book/second-edition/" target="_blank" rel="external">Rust Book</a>鼓励你去了解为什么语言的作者渴望创造一种更安全的语言，而不是把它当作语言的怪癖。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://doc.rust-lang.org/book/second-edition/" target="_blank" rel="external">Rust Book</a></li>
<li><a href="https://users.rust-lang.org/t/the-copy-trait-what-does-it-actually-copy/18730" target="_blank" rel="external">Rust Language Form Post about The Copy Trait</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em> <a href="https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b" target="_blank" rel="external">https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个Ruby开发者，我所知道的关于内存分配的所有内容都是由一些称为垃圾收集的进程处理的，这是&lt;a href=&quot;https://medium.com/@tenderlove&quot;&gt;Aaron Patterson&lt;/a&gt;的问题，而不是我的问题。&lt;/p&gt;
&lt;p&gt;因此，当我阅读&lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/&quot;&gt;Rust Book&lt;/a&gt;并看到Rust的一个明确的特性是垃圾收集的替代品时，我有点担心。&lt;/p&gt;
&lt;p&gt;处理内存管理的责任是不是要摊派到我的身上?&lt;/p&gt;
&lt;p&gt;显然，对于其他系统编程语言，如C语言，处理内存分配是一件大事，如果做得不好，可能会产生重大后果。&lt;br&gt;随着所有其他新事物的学习，我觉得事情开始堆积起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://szpzs.oschina.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://szpzs.oschina.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="http://szpzs.oschina.io/tags/Ownership/"/>
    
  </entry>
  
  <entry>
    <title>不要害怕Rust的借用检查器</title>
    <link href="http://szpzs.oschina.io/2018/08/01/rust-borrowing-and-ownership/"/>
    <id>http://szpzs.oschina.io/2018/08/01/rust-borrowing-and-ownership/</id>
    <published>2018-08-01T07:47:39.000Z</published>
    <updated>2018-08-01T08:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>我花了几乎一整天的时间，试图弄清楚所有权和借用是如何在Rust里运作的，最终还是弄清楚了。</p>
<p>在这篇文章中，我将通过一些破坏Rust规则的代码示例来演示这些概念是如何工作的，并解释为什么这些代码存在问题。 我假设读者对Rust编程语言知之甚少。 我还在所有代码块中添加了注释来说明代码是否是有效Rust代码。</p>
<a id="more"></a>
<h1 id="第一个例子：添加值到字符串的Vector"><a href="#第一个例子：添加值到字符串的Vector" class="headerlink" title="第一个例子：添加值到字符串的Vector"></a>第一个例子：添加值到字符串的Vector</h1><p>本例中，有两个Vector。其中一个是 myvec ，它预先被添加了一些值，而且它被设置为不可变的。另一个被实例化为可变的，并且不包含任何值。 然后我们从 myvec 取出一个值，并且尝试用函数 <code>Vec::push()</code> 将这个值添加到 othervec 中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"hello"</span>),</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"world"</span>)</div><div class="line">  ];</div><div class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line"></div><div class="line">  <span class="comment">//  `myvec.get(1)` 不是返回一个 `String`, 而是返回一个 `Option`,</span></div><div class="line">  <span class="comment">//  因此需要使用 `.unwrap()` 来从它里面取出值。</span></div><div class="line">  othervec.push(myvec.get(<span class="number">1</span>).unwrap());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这似乎是一件完全合理的事情——在许多其他编程语言中，你可以从数组或列表中获取一个值，并将其粘贴到另一个数据结构中。</p>
<p>但是在Rust里会怎么样呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cargo run</div><div class="line">error[E0308]: mismatched types</div><div class="line">..</div><div class="line">expected struct `std::string::String`, found reference</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可怕的类型不匹配错误！</p>
<p>这里发生的结果是，myvec.get(1)实际上并没有返回类型为String的值，而是返回了对字符串的引用，或叫做 &amp;String。对字符串的引用可以在只读上下文中使用，例如，你可以写如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, myvec.get(<span class="number">1</span>).unwrap())</div></pre></td></tr></table></figure>
<p>但是，由于 othervec 是一个 Vec&lt;String&gt; 类型的 Vector，你不可以将一个 &amp;String 类型的值添加给它。那么，我们可以使用解引用符号 * ，对不对？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line">...</div><div class="line"><span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"hello"</span>), <span class="built_in">String</span>::from(<span class="string">"world"</span>)];</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line">othervec.push(*myvec.get(<span class="number">1</span>).unwrap());</div><div class="line">...</div></pre></td></tr></table></figure>
<p>不对！这次的错误是 “cannot move out of borrowed content”。</p>
<p>编译器在此处告诉我们的是，因为 myvec.get(1) 返回的值是一个 “借用的”值，它不能被赋给别的变量。</p>
<h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>为了更详细地阐述这一点，Rust中的值一次只能分配给一个变量。 将值分配给其他变量会导致无法再使用以前的变量访问该值。 举个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"><span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</div><div class="line"><span class="keyword">let</span> y = x;</div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</div></pre></td></tr></table></figure>
<p>上述代码编译的时候报错：“Use of moved value ‘x’”。这种行为在Rust中非常重要，因为在Rust中，当变量超出作用域时，它们引用的内存被释放 —— 没有垃圾收集。 为了保持这种行为，并防止无效的内存访问，数据一次只能有一个“所有者”。 在此示例中，x是原始所有者，然后y成为所有者。</p>
<p>也就是说，如果数据需要在其他上下文中被读取，例如，在其他函数中，可以将对数据的引用分配给其他变量。例如，以下代码编译成功并可以正常运行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// valid</span></div><div class="line"><span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</div><div class="line"><span class="keyword">let</span> y = &amp;x;</div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</div></pre></td></tr></table></figure>
<p>表达式 &amp;x 就是“借用”的一个例子。变量y被赋予了对x值的借用引用。 默认情况下引用不可变（在Rust中也存在可变引用），并且对它们有其他约束，我将在后面进一步详细解释。</p>
<h2 id="回到例子"><a href="#回到例子" class="headerlink" title="回到例子"></a>回到例子</h2><p>回到我们的原来的例子，<code>myvec.get(1).unwrap()</code> 返回对myvec中索引1处的值的引用，并且没有发生移动。 但是，在将此值分配给变量时，将发生移动。 该值的当前所有者是myvec。 如果我们写如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"><span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[</div><div class="line">  <span class="built_in">String</span>::from(<span class="string">"hello"</span>),</div><div class="line">  <span class="built_in">String</span>::from(<span class="string">"world"</span>)</div><div class="line">];</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line"><span class="keyword">let</span> val = *myvec.get(<span class="number">1</span>).unwrap();</div></pre></td></tr></table></figure>
<p>这会将数据的所有者转给变量val。这是不被允许的，因为你不能移动借用的值。</p>
<p>思考一下能够做到这一点的含义。如果有可能将<code>myvec.get (1)</code>的所有权转移给val，这意味着一旦val超出作用域，myvec中索引为1的元素现在将会指向无效的内存块。</p>
<p>此外，我们也可以做一些可怕的事情：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"hello"</span>),</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"world"</span>)</div><div class="line">  ];</div><div class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line">  othervec.push(myvec.get(<span class="number">1</span>).unwrap());</div><div class="line">  myvec.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 .clear() 释放所有内存，读取 othervec 的值将导致无效内存访问。</p>
<p>要解决这个问题，我们可以将引用分配给变量val，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"><span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[</div><div class="line">  <span class="built_in">String</span>::from(<span class="string">"hello"</span>),</div><div class="line">  <span class="built_in">String</span>::from(<span class="string">"world"</span>)</div><div class="line">];</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line"><span class="keyword">let</span> val = myvec.get(<span class="number">1</span>).unwrap();</div></pre></td></tr></table></figure>
<p>但是我们不能将这个值添加到Vec&lt;String&gt;类型的Vec，因为val是&amp;String类型的。</p>
<p>那么我们如何解决这个问题来实现我们想要的呢？这将取决于我们到底想要完成什么。我们不能将myvecec .get(1)的所有权转移到othervec，所以如果我们想让othervec指向Vector中实际的位置，我们必须将othervec改为&amp;String的一个Vector：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// valid</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"hello"</span>),</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"world"</span>)</div><div class="line">  ];</div><div class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line">  othervec.push(myvec.get(<span class="number">1</span>).unwrap());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后这样写的结果是，我们无法修改 othervec 里的值，我将在下一节中更详细地讨论这个问题。在othervec超出作用域之前，myvec都不能超出作用域。</p>
<p>另一方面，如果我们只关心位置1的值，那么我们可以复制这个字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// valid</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> myvec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"hello"</span>),</div><div class="line">    <span class="built_in">String</span>::from(<span class="string">"world"</span>)</div><div class="line">  ];</div><div class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line">  othervec.push(myvec.get(<span class="number">1</span>).unwrap().to_string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&amp;String上的to_string()方法创建一个新的字符串并将所有权给了othervec。</p>
<h2 id="借用的总结"><a href="#借用的总结" class="headerlink" title="借用的总结"></a>借用的总结</h2><p>Rust具有的这种约束，要求不能将值分配给多个所有者，这解决了其他编程语言（如C）中可能继续读取无效内存的大问题。 解决这个问题的意义也非常疯狂：另一种看待这个问题的方式是，当我们用myvec.get(1).unwrap()从myvec中取出一个值时，得到的值知道它来自哪里， 并且知道因为它有一个所有者，所以不能将它分配给另一个变量。 在其他编程语言中，如果从类似列表的对象中提取变量，就像在下面的Python中一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</div><div class="line">y = x[<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>现在存储在y中的值来自哪里是无关紧要的，它可以像任何其他字符串一样被对待。 在Rust中，情况并非如此！</p>
<p>更多关于借用和所有权的内容，请阅读《Rust程序设计语言》那本书的相关章节：</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/second-edition/ch04-01-what-is-ownership.html" target="_blank" rel="external">所有权</a></li>
<li><a href="https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html" target="_blank" rel="external">引用和借用</a></li>
</ul>
<h1 id="第二个例子：单独的函数"><a href="#第二个例子：单独的函数" class="headerlink" title="第二个例子：单独的函数"></a>第二个例子：单独的函数</h1><p>那么如前所述的一个代码示例，我提到我们可以把othervec构建为一个Vec&lt;&amp;String&gt;，也就是一个字符串引用的Vector。在本节中，我将更详细地介绍处理引用。</p>
<p>为了说明这一点，如下是无效代码的另一部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">copy_to_new_vec</span></span>(myvec: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;, othervec: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; ) -&gt; &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</div><div class="line">  othervec.push(myvec.get(<span class="number">1</span>).unwrap().to_string());</div><div class="line">  <span class="keyword">return</span> othervec;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> myvec = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"hello"</span>), <span class="built_in">String</span>::from(<span class="string">"world"</span>)];</div><div class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line">  <span class="keyword">let</span> newvec: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;  = copy_to_new_vec(&amp;myvec, &amp;<span class="keyword">mut</span> othervec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器会报告如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cargo run</div><div class="line">...</div><div class="line">expected lifetime parameter</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个例子和第一个例子很像。这个例子的主要不同是，我们将从myvec第一个位置拷贝值的逻辑抽取到一个叫做 copy_to_new_vec 函数里。</p>
<p>我们不是将myvec和othervec的所有权传递给copy_to_new_vec，而是传递对myvec的引用，以及对othervec的可变引用。 othervec需要作为可变引用传递，因为我们在copy_to_new_vec中为其写入值。 copy_to_new_vec返回对othervec的引用。 而newvec是对othervec的引用。</p>
<p>这看起来很合理，为什么编译器会报错呢？</p>
<p>返回对其他对象的引用的函数的缺点是，如果被引用的对象超出作用域或被释放，那么从这个函数返回的引用中读取数据将导致无效的内存读取。</p>
<h2 id="引入“生命周期参数”"><a href="#引入“生命周期参数”" class="headerlink" title="引入“生命周期参数”"></a>引入“生命周期参数”</h2><p>为了解决这个问题，Rust有一个叫做“生命周期参数”的概念。你可以给Rust编译器一些信息，告诉它，你的引用正在引用的确切对象。 有了这些信息，如果引用的对象超出作用域而引用仍在作用域内，则Rust编译器会报错。</p>
<p>生命周期参数通常由编译器推断出来，但在此示例中，因为返回值有两个参数可引用，所以必须显式提供生命周期参数。 它们看起来类似于Rust中的泛型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// valid</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">copy_to_new_vec</span></span>&lt;<span class="symbol">'a</span>&gt;(vec: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;, othervec: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; ) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</div><div class="line">  othervec.push(vec.get(<span class="number">1</span>).unwrap().to_string());</div><div class="line">  <span class="keyword">return</span> othervec;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"hello"</span>), <span class="built_in">String</span>::from(<span class="string">"world"</span>)];</div><div class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> othervec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</div><div class="line">  copy_to_new_vec(&amp;vec, &amp;<span class="keyword">mut</span> othervec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在尖角括号之间添加带单引号的字符串可以使用生命周期参数对函数进行参数化。 然后可以将它们附加到参数和返回值（如上所示）以指示关系。 在上述代码里添加了生命周期参数，我们向Rust编译器指出copy_to__new_vec的返回值依赖于第二个参数。 但是，如果我们尝试写如下类似的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// invalid</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">copy_to_new_vec</span></span>&lt;<span class="symbol">'a</span>&gt;(vec: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;, othervec: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; ) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</div><div class="line">  othervec.push(vec.get(<span class="number">1</span>).unwrap().to_string());</div><div class="line">  <span class="keyword">return</span> othervec;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"hello"</span>), <span class="built_in">String</span>::from(<span class="string">"world"</span>)];</div><div class="line">  <span class="keyword">let</span> newvec = copy_to_new_vec(&amp;vec, &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>::new());</div><div class="line">  newvec.get(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器将会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cargo run</div><div class="line">...</div><div class="line">Borrowed value does not live long enough</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个错误的含义是，由于copy_to_new_vec的返回值在作用域范围上比copy_to_new_vec中的othervec更长，这是有问题的。</p>
<p>如果允许这样做，则newvec.get(1)将失败，因为newvec引用的值已经被释放。 这是因为在 <code>let newvec = copy_to_new_vec(&amp;vec, &amp;mut Vec::new());</code> 这行代码后，copy_to_new_vec的第二个参数就已经超出作用域了。</p>
<p>在<a href="https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html" target="_blank" rel="external">这里</a>查看有关Rust生命周期的更多信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望这些例子能帮助你理解Rust中的借用系统。这肯定要花很多时间去适应，一开始可能会很困难。但是一旦你了解了它，这个借用系统就变成了一个难以置信的安全网，它可以防止在其他系统编程语言中常见的许多问题。</p>
<p>祝玩得开心！</p>
<blockquote>
<p><em>原文链接：</em> <a href="http://www.squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html" target="_blank" rel="external">http://www.squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我花了几乎一整天的时间，试图弄清楚所有权和借用是如何在Rust里运作的，最终还是弄清楚了。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将通过一些破坏Rust规则的代码示例来演示这些概念是如何工作的，并解释为什么这些代码存在问题。 我假设读者对Rust编程语言知之甚少。 我还在所有代码块中添加了注释来说明代码是否是有效Rust代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://szpzs.oschina.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://szpzs.oschina.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="http://szpzs.oschina.io/tags/Ownership/"/>
    
      <category term="Lifetimes" scheme="http://szpzs.oschina.io/tags/Lifetimes/"/>
    
      <category term="Borrow" scheme="http://szpzs.oschina.io/tags/Borrow/"/>
    
  </entry>
  
  <entry>
    <title>理解Elixir的&amp;(捕获操作符)</title>
    <link href="http://szpzs.oschina.io/2018/07/31/understand-capture-operator-in-elixir/"/>
    <id>http://szpzs.oschina.io/2018/07/31/understand-capture-operator-in-elixir/</id>
    <published>2018-07-31T06:17:23.000Z</published>
    <updated>2018-07-31T06:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>&amp;</code>是Elixir的捕获操作符，常用来捕获和创建匿名函数。</p>
<h1 id="匿名函数和arity"><a href="#匿名函数和arity" class="headerlink" title="匿名函数和arity"></a>匿名函数和arity</h1><p>在深入捕获操作符之前，让我们先熟悉匿名函数和arity。</p>
<p>例子如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add_one = <span class="keyword">fn</span> x -&gt; x + <span class="number">1</span> <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们定义了一个函数，但是它没有被绑定一个全局名字，所以它是一个匿名函数或者是一个lambda表达式。</p>
<p>这个函数有一个参数，所以它的arity是1。</p>
<a id="more"></a>
<h1 id="如何用-amp"><a href="#如何用-amp" class="headerlink" title="如何用&amp;"></a>如何用<code>&amp;</code></h1><h2 id="捕获函数"><a href="#捕获函数" class="headerlink" title="捕获函数"></a>捕获函数</h2><p>我们先来谈谈捕获函数。捕获就意味着<code>&amp;</code>将一个函数转成匿名函数，这个匿名函数可以被当作参数传递给其他函数，或者被绑定到一个变量。</p>
<p><code>&amp;</code>可以捕获两种类型的函数：</p>
<ul>
<li>模块中给定名称和arity的函数</li>
</ul>
<p>使用的方式：<code>&amp;(module_name.function_name/arity)</code>，例如：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">speak = &amp;(IO.puts/<span class="number">1</span>)</div><div class="line">speak.(<span class="string">"hello"</span>)  <span class="comment"># hello</span></div></pre></td></tr></table></figure></p>
<p>我们从<code>IO</code>模块捕获<code>puts</code>函数并且将它绑定到局部变量<code>speak</code>上。</p>
<ul>
<li>局部函数</li>
</ul>
<p>如下例子中，<code>put_in_columns</code> 和 <code>put_in_one_row</code>被定义在相同的模块里，因此我们可以用 <code>&amp;put_in_one_row/1</code> 来捕获  <code>put_in_one_row</code> ，注意，我们在此没有包含模块名。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Issues</span></span>.TableFormatter <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put_in_columns</span></span>(data_by_columns, format) <span class="keyword">do</span></div><div class="line">     Enum.each(data_by_columns, &amp;put_in_one_row/<span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put_in_one_row</span></span>(fields) <span class="keyword">do</span></div><div class="line">     <span class="comment"># Do some things...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h2 id="创建匿名函数"><a href="#创建匿名函数" class="headerlink" title="创建匿名函数"></a>创建匿名函数</h2><p>捕获操作符也可以用来创建匿名函数，例如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add_one = &amp;(&amp;<span class="number">1</span> + <span class="number">1</span>)</div><div class="line">add_one.(<span class="number">1</span>) <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<p>上述例子和下面的效果一样：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add_one = <span class="keyword">fn</span> x -&gt; x + <span class="number">1</span> <span class="keyword">end</span></div><div class="line">add_one.(<span class="number">1</span>) <span class="comment"># 2</span></div></pre></td></tr></table></figure>
<p>你可以注意到第一个例子里用了 <code>&amp;1</code> 。它叫做值占位符，它标识了这个函数的第几个参数，此例中就是第一个参数。</p>
<p>另外，<code>{}</code> 和 <code>[]</code>在Elixir里也是操作符，<code>&amp;</code>也可以和它们一起使用。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">return_list = &amp;[&amp;<span class="number">1</span>, &amp;<span class="number">2</span>]</div><div class="line">return_list.(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># [1, 2]</span></div><div class="line"></div><div class="line">return_tuple = &amp;&#123;&amp;<span class="number">1</span>, &amp;<span class="number">2</span>&#125;</div><div class="line">return_tuple.(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># &#123;1, 2&#125;</span></div></pre></td></tr></table></figure>
<p>一开始很难理解，我们只需要从另一个角度来思考，如下图：</p>
<p><img src="/images/capture-operator.png" style="border:0;"></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://dockyard.com/blog/2016/08/05/understand-capture-operator-in-elixir" target="_blank" rel="external">https://dockyard.com/blog/2016/08/05/understand-capture-operator-in-elixir</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;是Elixir的捕获操作符，常用来捕获和创建匿名函数。&lt;/p&gt;
&lt;h1 id=&quot;匿名函数和arity&quot;&gt;&lt;a href=&quot;#匿名函数和arity&quot; class=&quot;headerlink&quot; title=&quot;匿名函数和arity&quot;&gt;&lt;/a&gt;匿名函数和arity&lt;/h1&gt;&lt;p&gt;在深入捕获操作符之前，让我们先熟悉匿名函数和arity。&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;add_one = &lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; x -&amp;gt; x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们定义了一个函数，但是它没有被绑定一个全局名字，所以它是一个匿名函数或者是一个lambda表达式。&lt;/p&gt;
&lt;p&gt;这个函数有一个参数，所以它的arity是1。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="capture operator" scheme="http://szpzs.oschina.io/categories/Elixir/capture-operator/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="capture operator" scheme="http://szpzs.oschina.io/tags/capture-operator/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly简介</title>
    <link href="http://szpzs.oschina.io/2018/07/30/intro-to-web-assembly/"/>
    <id>http://szpzs.oschina.io/2018/07/30/intro-to-web-assembly/</id>
    <published>2018-07-30T05:12:40.000Z</published>
    <updated>2018-07-30T05:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在今年的EmberConf大会上有很多非常有趣的讨论话题 - 尤其是Tom Dale和Yehuda Katz的开场主题演讲。 他们通过讨论<a href="https://youtu.be/NhtpXs0ZtUc?t=35m54s" target="_blank" rel="external">使用WebAssembly在glimmer进行的工作</a>来结束演讲。 事实上，他们甚至展示了在WebAssembly中运行的<a href="https://schedule-wasm.emberconf.com/" target="_blank" rel="external">EmberConf网站</a>版本（尽管由于漏洞而在iOS中崩溃）。</p>
<p>大家都对他们的演讲报以掌声，我也做了我通常做的：微笑着点点头，就像我知道发生了什么。</p>
<p><img src="/images/giphy.gif" style="border:0;"></p>
<p>因此，我决定深入研究它，并试图了解WebAssembly是什么，它真正解决了什么问题。</p>
<a id="more"></a>
<h1 id="从高层次看WebAssembly"><a href="#从高层次看WebAssembly" class="headerlink" title="从高层次看WebAssembly"></a>从高层次看WebAssembly</h1><p>如果你阅读过关于WebAssembly(又名WASM)的很多博客文章，你会发现很多人提出的最重要的一点是，它使他们能够用JavaScript以外的语言构建网站。 对于拥有多年其他语言经验的人来说，我知道这可能是一个巨大的好处。 但是，作为一名JavaScript开发人员，我仍然有一个问题：它对我有什么用？</p>
<p>为了回答这个问题，我必须提高我对网站如何运行、JavaScript从何开始执行以及WebAssembly如何融入当前生态系统的知识。</p>
<h1 id="JavaScript有什么问题吗？"><a href="#JavaScript有什么问题吗？" class="headerlink" title="JavaScript有什么问题吗？"></a>JavaScript有什么问题吗？</h1><p>大多数人可能知道，JavaScript是在1995年创建的，目的是使web开发人员能够添加一些功能。它是一种松散类型的语言，希望开发人员能够更快地启动和运行程序。这意味着，与C、C++或Rust等语言不同，它的变量可以从整数开始，更改为字符串，然后更改为对象，而不会导致问题。虽然这使学习变得容易，但这意味着语言的效率相当低。</p>
<p>当一个带有JavaScript的网站运行时，这个过程看起来像这样：</p>
<ol>
<li>解析代码</li>
<li>从头到尾执行代码</li>
<li>任何垃圾收集</li>
</ol>
<p>这是因为JavaScript使用所谓的“解释器”来运行代码。就像现实生活中的专业翻译一样，它会对每一行代码都进行解释和翻译，最终达到系统所理解的语言——就像有人在实时对话中把英语翻译成西班牙语一样。</p>
<p>这里的问题是，当你必须多次运行相同的代码块，循环或函数时它会变得低效。 解释器每次翻译都没有性能提升。 这导致浏览器开始实现<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="external">即时(JIT)编译器</a>，使得用户开始在浏览器中看到巨大的性能提升。</p>
<p>JIT所做的是创建函数的编译版本，以便在后续调用中更有效地运行它们。但是，由于我们使用的仍然是松散类型的语言，因此需要创建这些函数的多个编译版本。如下函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">putTogether</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果a和b是数字，那么我们得到的是它们之和。但是，如果它们是字符串，我们得到则是它们的拼接字符串。这种模式在JavaScript里是可行的，但是低层次语言需要知道a和b的确切类型来执行正确的操作。这就是为什么JIT有一个“监视器”，它创建了这个函数的两个编译版本 —- 一个接收数字，一个接收字符串。 调用该函数时，会找到并执行正确的编译版本。 这就是所谓的基线编译器(<a href="https://blog.mozilla.org/javascript/2013/04/05/the-baseline-compiler-has-landed/" target="_blank" rel="external">Baseline Compiler</a>)。</p>
<p>需要注意的是，JIT的具体内容要复杂很多，但我们会保持简单的示例。 如果你想了解更多信息，我建议你阅读<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" target="_blank" rel="external">Lin Clark写的文章</a>。</p>
<p>因此，现在JIT帮助浏览器更有效地运行，因为它不是解释每一行，而是解释类型并找到函数的正确编译版本。为了进一步提高性能，监视器会观察这些基线编译函数中的哪一个被调用得最多。如果发现一个函数被大量调用，它会将其发送给优化编译器，以创建更快的版本。</p>
<p>例如，如果它发现我们总是使用数字调用<code>putTogether</code>函数，那么它会假设它应该始终以这种方式调用并创建优化版本。 现在我们的函数接近原生速度。</p>
<p>我们新的过程看起来如下：</p>
<ol>
<li>解析代码</li>
<li>编译（基线编译器）</li>
<li>编译（优化编译器）</li>
<li>执行（比以前快得多）</li>
<li>任何垃圾收集</li>
</ol>
<p>虽然我们有更多的步骤，但是在浏览器中引入的JIT在实现的头几年里使站点速度提高了十倍以上。这通常是编译程序与运行时的工作流程。 我们花了一点时间预先编译，但由于我们不再动态翻译，因此执行时间减少，这样会带来重大收益。</p>
<h1 id="好的……但WebAssembly适合哪里？"><a href="#好的……但WebAssembly适合哪里？" class="headerlink" title="好的……但WebAssembly适合哪里？"></a>好的……但WebAssembly适合哪里？</h1><p>上述过程有明显改善，但仍存在一个主要问题。 以我们的<code>putTogether</code>函数为例。 假设我们执行该函数1000次并仅传递数字。 优化编译器就假设它只用数字调用并编写该函数的低级编译版本。</p>
<p>但是，由于某种原因，在第1,001次我们调用函数时，我们传递给它的是字符串。</p>
<p><img src="/images/giphy-2.gif" style="border:0;"></p>
<p>当编译的代码看到它做出错误的假设时，它会废弃优化的函数并开始重新优化的过程。 这就是所谓的“拯救”，如果它发生得足够多，最终优化编译器将放弃，我们永远不会得到最有效的函数版本。</p>
<p>WebAssembly允许你(开发人员)编写自己的这些函数的编译版本。这意味着JIT不再创建函数的基线版本、监视它们、优化它们、拯救和重新优化它们。相反，你会说“我知道我想让这个函数以这种方式运行”，而不需要JIT的任何参与。</p>
<p>所以现在我们的流程看起来像这样：</p>
<ol>
<li>解析（通过WebAssembly编译代码）</li>
<li>执行（和JIT一样快）</li>
<li>任何垃圾收集</li>
</ol>
<p>现在，你可以让部分应用程序以与本机应用程序相同的速度运行。 虽然我们不会完全放弃JavaScript，但可以将大量计算转移到这些较低级别的编译语言。 对于大多数Web开发人员来说，这些收益将来自他们的应用程序使用的第三方软件包，他们不必自己编写任何WebAssembly。 但仅仅因为你可能没有直接写它，这并不意味着不能很好地理其解幕后所发生的事情。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://dockyard.com/blog/2018/05/14/intro-to-web-assembly" target="_blank" rel="external">https://dockyard.com/blog/2018/05/14/intro-to-web-assembly</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在今年的EmberConf大会上有很多非常有趣的讨论话题 - 尤其是Tom Dale和Yehuda Katz的开场主题演讲。 他们通过讨论&lt;a href=&quot;https://youtu.be/NhtpXs0ZtUc?t=35m54s&quot;&gt;使用WebAssembly在glimmer进行的工作&lt;/a&gt;来结束演讲。 事实上，他们甚至展示了在WebAssembly中运行的&lt;a href=&quot;https://schedule-wasm.emberconf.com/&quot;&gt;EmberConf网站&lt;/a&gt;版本（尽管由于漏洞而在iOS中崩溃）。&lt;/p&gt;
&lt;p&gt;大家都对他们的演讲报以掌声，我也做了我通常做的：微笑着点点头，就像我知道发生了什么。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/giphy.gif&quot; style=&quot;border:0;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，我决定深入研究它，并试图了解WebAssembly是什么，它真正解决了什么问题。&lt;/p&gt;
    
    </summary>
    
      <category term="WebAssembly" scheme="http://szpzs.oschina.io/categories/WebAssembly/"/>
    
    
      <category term="WebAssembly" scheme="http://szpzs.oschina.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>如何用Sbroker在Elixir中构建一个反压队列系统</title>
    <link href="http://szpzs.oschina.io/2018/07/26/back-pressure-queuing-system-with-sbroker/"/>
    <id>http://szpzs.oschina.io/2018/07/26/back-pressure-queuing-system-with-sbroker/</id>
    <published>2018-07-26T12:17:37.000Z</published>
    <updated>2018-07-26T12:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在PSPDFKit，我们使用<a href="https://elixir-lang.org/" target="_blank" rel="external">Elixir</a>构建可靠且高性能的分布式系统。 在这样的系统中，我们经常需要调用外部服务，同时异步消息传递允许客户端进行这些调用而不必等待响应。 无法立即处理的消息将排队并稍后处理，但是当队列过载时会发生什么呢？ 由于我们不希望系统崩溃，因此我们必须使用反压机制，以防止队列无限增长。 此文介绍了如何使用<a href="https://github.com/fishcakez/sbroker" target="_blank" rel="external">sbroker</a>库将反压机制应用于Elixir应用程序。</p>
<a id="more"></a>
<h1 id="在Elixir应用中使用sbroker的Erlang库"><a href="#在Elixir应用中使用sbroker的Erlang库" class="headerlink" title="在Elixir应用中使用sbroker的Erlang库"></a>在Elixir应用中使用sbroker的Erlang库</h1><p>sbroker这个Erlang库提供了用于创建池和(或)负载调节器的构建模块。 它使用<a href="https://en.wikipedia.org/wiki/Broker_pattern" target="_blank" rel="external">broker模式</a>，其中与服务worker的通信由负责worker与其调用之间协调的broker处理。</p>
<h1 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h1><p>让我们看一个如何在Elixir应用程序中使用sbroker库的简单示例。</p>
<p>首先我们在命令行运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mix new example</div></pre></td></tr></table></figure>
<p>它将在当前目录下创建一个样例工程，名字就叫做 “example” 。在该示例中，我们将模拟在一个worker中对外部服务的调用并由broker处理相关通信。为此，我们编辑example/mix.exs文件，以便将sbroker库添加到我们的应用程序中：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [</div><div class="line">      <span class="symbol">app:</span> <span class="symbol">:example</span>,</div><div class="line">      <span class="symbol">version:</span> <span class="string">"0.1.0"</span>,</div><div class="line">      <span class="symbol">elixir:</span> <span class="string">"~&gt; 1.5"</span>,</div><div class="line">      <span class="symbol">start_permanent:</span> Mix.env == <span class="symbol">:prod</span>,</div><div class="line">      <span class="symbol">deps:</span> deps()</div><div class="line">    ]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">    [</div><div class="line">      <span class="symbol">applications:</span> [<span class="symbol">:sbroker</span>],</div><div class="line">      <span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">      <span class="symbol">mod:</span> &#123;Example, []&#125;</div><div class="line">    ]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></div><div class="line">    [&#123;<span class="symbol">:sbroker</span>, <span class="string">"~&gt; 1.0-beta"</span>&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们将sbroker库添加到上面的依赖项和应用程序中。我们也在18行指定了我们应用的模块 mod: {Example, []}，这个模块我们稍后创建。现在我们准备添加一个broker，所以我们在example/lib/example/broker.ex中创建我们对broker模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span>.Broker <span class="keyword">do</span></div><div class="line">  <span class="variable">@behaviour</span> <span class="symbol">:sbroker</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>() <span class="keyword">do</span></div><div class="line">    start_link(<span class="symbol">timeout:</span> <span class="number">10000</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>(opts) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:sbroker</span>.start_link(&#123;<span class="symbol">:local</span>, __MODULE_<span class="number">_</span>&#125;, __MODULE_<span class="number">_</span>, opts, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(opts) <span class="keyword">do</span></div><div class="line">    <span class="comment"># See `DBConnection.Sojourn.Broker`.</span></div><div class="line"></div><div class="line">    <span class="comment"># 使broker的“左”侧成为一个FIFO队列，在超时后丢弃请求。</span></div><div class="line">    client_queue =</div><div class="line">      &#123;<span class="symbol">:sbroker_timeout_queue</span>,</div><div class="line">       %&#123;</div><div class="line">         <span class="symbol">out:</span> <span class="symbol">:out</span>,</div><div class="line">         <span class="symbol">timeout:</span> opts[<span class="symbol">:timeout</span>],</div><div class="line">         <span class="symbol">drop:</span> <span class="symbol">:drop</span>,</div><div class="line">         <span class="symbol">min:</span> <span class="number">0</span>,</div><div class="line">         <span class="symbol">max:</span> <span class="number">128</span></div><div class="line">       &#125;&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 使broker对“右”侧成为一个FIFO队列，这个队列没有超时。</span></div><div class="line">    worker_queue =</div><div class="line">      &#123;<span class="symbol">:sbroker_drop_queue</span>,</div><div class="line">       %&#123;</div><div class="line">         <span class="symbol">out:</span> <span class="symbol">:out_r</span>,</div><div class="line">         <span class="symbol">drop:</span> <span class="symbol">:drop</span>,</div><div class="line">         <span class="symbol">timeout:</span> <span class="symbol">:infinity</span></div><div class="line">       &#125;&#125;</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:ok</span>, &#123;client_queue, worker_queue, []&#125;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>上面的模块实现了sbroker行为。在第9行我们启动sbroker，并且在选项里设置超时为10秒。这个超时的意思是，当这些调用在队列里等候worker的时间超过10秒，它们将被丢弃。在init/1函数里，我们给broker定义了客户端和worker的队列。我们定义了broker模块后，我们需要定义worker模块，它负责定义worker，并且向broker请求任务。我们在 example/lib/example/worker.ex里定义worker模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span>.Worker <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> GenServer</div><div class="line"></div><div class="line">  <span class="keyword">alias</span> Example.&#123;Broker&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>() <span class="keyword">do</span></div><div class="line">    GenServer.start_link(__MODULE_<span class="number">_</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment">#</span></div><div class="line">  <span class="comment"># GenServer 的回调函数</span></div><div class="line">  <span class="comment">#</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>([]) <span class="keyword">do</span></div><div class="line">    state =</div><div class="line">      ask(%&#123;</div><div class="line">        <span class="symbol">tag:</span> make_ref()</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:ok</span>, state&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_info</span></span>(&#123;tag, &#123;<span class="symbol">:go</span>, ref, &#123;pid, &#123;<span class="symbol">:fetch</span>, [params]&#125;&#125;, <span class="number">_</span>, <span class="number">_</span>&#125;&#125;, %&#123;<span class="symbol">tag:</span> tag&#125; = s) <span class="keyword">do</span></div><div class="line">    send(pid, &#123;ref, fetch_from_external_resource(params)&#125;)</div><div class="line">    &#123;<span class="symbol">:noreply</span>, ask(s)&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 当sborker发现有匹配的任务，它将给我们发送 &#123;tag, &#123;:go, ref, req, _, _&#125;&#125; 消息</span></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">ask</span></span>(%&#123;<span class="symbol">tag:</span> tag&#125; = s) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:await</span>, ^tag, <span class="number">_</span>&#125; = <span class="symbol">:sbroker</span>.async_ask_r(Broker, <span class="keyword">self</span>(), &#123;<span class="keyword">self</span>(), tag&#125;)</div><div class="line">    s</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">fetch_from_external_resource</span></span>(params) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 模拟处理工作</span></div><div class="line">    Process.sleep(<span class="number">1000</span>)</div><div class="line">    &#123;<span class="symbol">:ok</span>, <span class="string">"External service called with <span class="subst">#&#123;inspect(params)&#125;</span>"</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><code>fetchfrom_external_resource/1</code>函数是一个简单的模拟函数，它将使得进程等待一秒，然后返回 {:ok, “External service called with #{inspect(params)}”} 。当worker这个GenServer进程收到 {tag, {:go, ref, {pid, {:fetch, [params]}},<em>, </em>}} 这样的消息时，这个函数将被调用。这个元组中的tag变量是一个唯一标识符，它被用来标识worker并且被存储在GenServer进程的状态中。</p>
<p>在worker获得所需数据后，它会向broker请求新的任务。我们已经定义了broker和worker模块，因此我们现在可以定义一个监督者，它将启动broker和一个worker池。监督者在 example/lib/example/supervisor.ex 里定义：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span>.Supervisor <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Supervisor</div><div class="line"></div><div class="line">  <span class="keyword">alias</span> Example.&#123;Broker, Worker&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span>() <span class="keyword">do</span></div><div class="line">    Supervisor.start_link(__MODULE_<span class="number">_</span>, [])</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>(_args) <span class="keyword">do</span></div><div class="line">    pool_size = <span class="number">5</span></div><div class="line">    broker = worker(Broker, [], <span class="symbol">id:</span> <span class="symbol">:broker</span>)</div><div class="line"></div><div class="line">    workers =</div><div class="line">      <span class="keyword">for</span> id &lt;- <span class="number">1</span>..pool_size <span class="keyword">do</span></div><div class="line">        worker(Worker, [], <span class="symbol">id:</span> id)</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    worker_sup_opts = [<span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>, <span class="symbol">max_restarts:</span> pool_size]</div><div class="line">    worker_sup = supervisor(Supervisor, [workers, worker_sup_opts], <span class="symbol">id:</span> <span class="symbol">:workers</span>)</div><div class="line"></div><div class="line">    supervise([broker, worker_sup], <span class="symbol">strategy:</span> <span class="symbol">:one_for_one</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们的worker池有5个worker。我们基本完成工作了，还剩下要创建一个application模块，这个模块定义在 example/lib/example.ex 中：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Application</div><div class="line">  <span class="keyword">alias</span> Example.&#123;Broker&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(_type, _args) <span class="keyword">do</span></div><div class="line">    Example.Supervisor.start_link()</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetch_from_external_resource</span></span>(params) <span class="keyword">do</span></div><div class="line">    perform(&#123;<span class="symbol">:fetch</span>, [params]&#125;)</div><div class="line">    |&gt; inspect()</div><div class="line">    |&gt; IO.puts()</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">perform</span></span>(&#123;action, args&#125; = params) <span class="keyword">do</span></div><div class="line">    <span class="keyword">case</span> <span class="symbol">:sbroker</span>.ask(Broker, &#123;<span class="keyword">self</span>(), params&#125;) <span class="keyword">do</span></div><div class="line">      &#123;<span class="symbol">:go</span>, ref, worker, <span class="number">_</span>, _queue_time&#125; -&gt;</div><div class="line">        monitor = Process.monitor(worker)</div><div class="line"></div><div class="line">        receive <span class="keyword">do</span></div><div class="line">          &#123;^ref, result&#125; -&gt;</div><div class="line">            Process.demonitor(monitor, [<span class="symbol">:flush</span>])</div><div class="line">            result</div><div class="line"></div><div class="line">          &#123;<span class="symbol">:DOWN</span>, ^monitor, <span class="number">_</span>, <span class="number">_</span>, reason&#125; -&gt;</div><div class="line">            exit(&#123;reason, &#123;__MODULE_<span class="number">_</span>, action, args&#125;&#125;)</div><div class="line">        <span class="keyword">end</span></div><div class="line"></div><div class="line">      &#123;<span class="symbol">:drop</span>, _time&#125; -&gt;</div><div class="line">        &#123;<span class="symbol">:error</span>, <span class="symbol">:overload</span>&#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这个模块启动监督者，并且它有一个函数：fetch_from_external_resource/1，这个函数向broker请求一个worker，当broker能够为我们的请求分配一个worker的时候，会向这个worker发送了消息 {:fetch, [params]} 。当broker不能分配给我们worker的时候，返回的是 {:drop, time} 消息，这样的话，我们的私有函数 perform/1，将返回 {:error, :overload} 。函数 fetch_from_external_resource/1 将打印worker的返回值，或者因为broker丢弃了我们的请求而打印 {:error, :overload} 。</p>
<p>我们现在可以在iex里测试这个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex -S mix run</div></pre></td></tr></table></figure>
<p>然后我们可以运行如下语句来从外部资源获取数据：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Example.fetch_from_external_resource(<span class="string">"test"</span>)</div></pre></td></tr></table></figure>
<p>一秒后在iex里会输出如下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;:ok, <span class="string">"External service called with \"test\""</span>&#125;</div><div class="line">:ok</div></pre></td></tr></table></figure>
<p>为了模拟和测试更多的调用，我们可以通过运行以下语句多次并行地调用 Example.fetch_from_external_resource(“test”) ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Enum.each(<span class="number">1</span>..<span class="number">500</span>, <span class="keyword">fn</span> <span class="number">_</span> -&gt;</div><div class="line">    Task.start(<span class="keyword">fn</span> -&gt;</div><div class="line">      Example.fetch_from_external_resource(<span class="string">"test"</span>)</div><div class="line">    <span class="keyword">end</span>)</div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<p>这将打印相同的行并一次打印五行，因为我们的示例worker池包含五个worker。我们也将得到 {:error, :overload} 响应，因为broker不能分配worker并且任务在队列等待太长时间。 {:error, :overload} 响应是用于防止外部服务过载的反压力示例。例如，我们的系统现在可以通过HTTP / 1.1 429 Too Many Requests回复请求服务的客户端，并且它不会因为过载而崩溃。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>使用带有worker池和队列的异步进程来扩展系统是一种很好的方式，但是由于我们不希望系统崩溃，我们还应该考虑处理过载的方法。一种方法是将反压机制应用到我们的系统中。在Elixir应用程序中，可以使用sbroker库轻松完成此任务。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://pspdfkit.com/blog/2018/back-pressure-queuing-system-with-sbroker/" target="_blank" rel="external">https://pspdfkit.com/blog/2018/back-pressure-queuing-system-with-sbroker/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PSPDFKit，我们使用&lt;a href=&quot;https://elixir-lang.org/&quot;&gt;Elixir&lt;/a&gt;构建可靠且高性能的分布式系统。 在这样的系统中，我们经常需要调用外部服务，同时异步消息传递允许客户端进行这些调用而不必等待响应。 无法立即处理的消息将排队并稍后处理，但是当队列过载时会发生什么呢？ 由于我们不希望系统崩溃，因此我们必须使用反压机制，以防止队列无限增长。 此文介绍了如何使用&lt;a href=&quot;https://github.com/fishcakez/sbroker&quot;&gt;sbroker&lt;/a&gt;库将反压机制应用于Elixir应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="back-pressure" scheme="http://szpzs.oschina.io/categories/Elixir/back-pressure/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="back-pressure" scheme="http://szpzs.oschina.io/tags/back-pressure/"/>
    
      <category term="sbroker" scheme="http://szpzs.oschina.io/tags/sbroker/"/>
    
  </entry>
  
  <entry>
    <title>通过插图学习Go的并发</title>
    <link href="http://szpzs.oschina.io/2018/06/23/learning-gos-concurrency-through-illustrations/"/>
    <id>http://szpzs.oschina.io/2018/06/23/learning-gos-concurrency-through-illustrations/</id>
    <published>2018-06-23T03:12:10.000Z</published>
    <updated>2018-06-23T03:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>你很可能或多或少听说过Go。 它越来越受欢迎。 Go快速，简单，并且拥有一个很棒的社区。 并发模型是学习这门语言最令人兴奋的方面之一。 Go的并发原语使创建并发的多线程程序变得简单而有趣。 我将通过插图介绍Go的并发原语，希望能够将这些概念讲清楚以供将来学习。 本文适用于Go的新手，以及想要了解Go的并发原语：go routine 和 channel 的学习者。</p>
<a id="more"></a>
<h1 id="单线程与多线程程序"><a href="#单线程与多线程程序" class="headerlink" title="单线程与多线程程序"></a>单线程与多线程程序</h1><p>你可能以前编写过多个单线程程序。编程中的一个常见模式是具有执行特定任务的多个函数，但是直到程序的前一部分为下一个函数准备好数据时，才会调用这些函数。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-1.jpeg" style="border:0;"></p>
<p>这就是我们最初设定的第一个例子，即开采矿石。 本例中的函数执行：寻找矿石、开采矿石和冶炼矿石。 在我们的例子中，矿和矿石被表示为一个字符串数组，每个函数接收并返回一个“已处理的”字符串数组。 对于单线程应用程序，程序设计如下。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-2.jpeg" style="border:0;"></p>
<p>有3个主要函数。 <code>finder</code>，<code>miner</code> 和 <code>smelter</code>。 在这个版本的程序中，我们的函数在单个线程上运行，一个接一个地运行 -- 而这个单线程（名为Gary的土拨鼠）需要完成所有工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> theMine := [<span class="number">5</span>]<span class="keyword">string</span>&#123;“rock”, “ore”, “ore”, “rock”, “ore”&#125;</div><div class="line"> foundOre := finder(theMine)</div><div class="line"> minedOre := miner(foundOre)</div><div class="line"> smelter(minedOre)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在每个函数的末尾打印得到的“矿石”数组，我们得到以下输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">From Finder: [ore ore ore]</div><div class="line"></div><div class="line">From Miner: [minedOre minedOre minedOre]</div><div class="line"></div><div class="line">From Smelter: [smeltedOre smeltedOre smeltedOre]</div></pre></td></tr></table></figure>
<p>这种编程方式具有易于设计的优点，但是当你希望利用多线程并执行彼此独立的函数时，会发生什么情况呢？这就是并发编程发挥作用的地方。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-3.jpeg" style="border:0;"></p>
<p>这种采矿设计效率要高得多。现在多线程( 土拨鼠们 )独立工作；因此，整个过程并不全由Gray这土拨鼠来做。有一个地鼠寻找矿石，有一个土拨鼠在开采矿石，另一个土拨鼠在冶炼矿石——可能所有这些都是同时发生的。</p>
<p>为了将这种功能引入我们的代码，我们需要两件事：一是创建独立工作的土拨鼠，二是土拨鼠相互通信(发送矿石 )的方式。这就是Go的并发原语: goroutine 和 channel。</p>
<h1 id="Go-routine"><a href="#Go-routine" class="headerlink" title="Go routine"></a>Go routine</h1><p>Go routine可以被认为是轻量的线程。创建一个go routine只需在调用函数的前面加上 <code>go</code> 这个关键字如此简单。</p>
<p>举个简单的例子，让我们创建两个寻找矿石的函数，使用<code>go</code>关键字调用它们，并让它们在每次发现矿井中的“矿石”时把他们打印出来。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-4.jpeg" style="border:0;"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> theMine := [<span class="number">5</span>]<span class="keyword">string</span>&#123;“rock”, “ore”, “ore”, “rock”, “ore”&#125;</div><div class="line"> <span class="keyword">go</span> finder1(theMine)</div><div class="line"> <span class="keyword">go</span> finder2(theMine)</div><div class="line"> &lt;-time.After(time.Second * <span class="number">5</span>) <span class="comment">//现在你可以忽略这行代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是我们程序的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Finder 1 found ore!</div><div class="line">Finder 2 found ore!</div><div class="line">Finder 1 found ore!</div><div class="line">Finder 1 found ore!</div><div class="line">Finder 2 found ore!</div><div class="line">Finder 2 found ore!</div></pre></td></tr></table></figure>
<p>从上面的输出可以看出，寻找矿石函数同时运行。谁先找到矿石没有真正的顺序，当多次运行时，顺序并不总是一样的。</p>
<p>这是很大的进步！现在我们有一个简单的方法来建立多线程(多个土拨鼠 )程序，但是当我们需要独立的<code>goroutine</code>来相互通信时会发生什么呢？欢迎来到神奇的<code>channel</code>世界。</p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p><img src="/images/learning-gos-concurrency-through-illustrations-5.jpeg" style="border:0;"></p>
<p><code>channel</code>允许<code>goroutine</code>相互通信。你可以将<code>channel</code>视为管道，<code>goroutine</code>可以从管道发送和接收来自其他<code>goroutine</code>的信息。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-6.jpeg" style="border:0;"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myFirstChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div></pre></td></tr></table></figure>
<p><code>goroutine</code>可以在一个<code>channel</code>上发送和接收数据。这是通过使用指向数据方向的箭头( &lt;- )来实现的。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-7.jpeg" style="border:0;"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFirstChannel &lt;- <span class="string">"hello"</span> <span class="comment">// 发送数据</span></div><div class="line">myVariable := &lt;- myFirstChannel <span class="comment">// 接收数据</span></div></pre></td></tr></table></figure>
<p>现在通过使用一个<code>channel</code>，我们可以让我们的寻找矿石的土拨鼠立即将它们发现的矿石发送给我们的矿石采集土拨鼠，而无需等待发现所有矿石后才将矿石送给矿石采集土拨鼠。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-8.jpeg" style="border:0;"></p>
<p>我已经更新了示例代码，以便将寻找矿石函数和采矿函数设置为未命名的函数。 如果你从来没有见过<code>lambda</code>函数就先不需要太关注程序的那部分，只要知道每个函数都是用<code>go</code>关键字调用的，所以它们就运行在自己的<code>goroutine</code>里。 重要的是要注意如何使用叫做<code>oreChan</code>的<code>channel</code>来相互传递数据。 别担心，我会在最后解释未命名的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> theMine := [<span class="number">5</span>]<span class="keyword">string</span>&#123;“ore1”, “ore2”, “ore3”&#125;</div><div class="line"> oreChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div><div class="line"></div><div class="line"> <span class="comment">// Finder</span></div><div class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(mine [5]<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> _, item := <span class="keyword">range</span> mine &#123;</div><div class="line">   oreChan &lt;- item <span class="comment">//发送数据</span></div><div class="line">  &#125;</div><div class="line"> &#125;(theMine)</div><div class="line"></div><div class="line"> <span class="comment">// Ore Breaker</span></div><div class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">   foundOre := &lt;-oreChan <span class="comment">//接收数据</span></div><div class="line">   fmt.Println(“Miner: Received “ + foundOre + “ from finder”)</div><div class="line">  &#125;</div><div class="line"> &#125;()</div><div class="line"> &lt;-time.After(time.Second * <span class="number">5</span>) <span class="comment">// 现在依然可以不用管这行代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在下面的输出中，你可以看到我们的矿工通过三次读取叫做“oreChan”的<code>channel</code>，每一次收到一块“矿石”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Miner: Received ore1 from finder</div><div class="line"></div><div class="line">Miner: Received ore2 from finder</div><div class="line"></div><div class="line">Miner: Received ore3 from finder</div></pre></td></tr></table></figure>
<p>太好了，现在我们可以在程序中的不同<code>goroutine</code>( 土拨鼠 )之间发送数据了。在我们开始编写带有<code>channel</code>的复杂程序之前，让我们先介绍一些理解<code>channel</code>属性的关键内容。</p>
<h1 id="Channel的阻塞"><a href="#Channel的阻塞" class="headerlink" title="Channel的阻塞"></a>Channel的阻塞</h1><p>在各种情况下，<code>channel</code>会阻塞<code>goroutine</code>。这就让我们的<code>goroutine</code>在各自独立快乐的道路上同步了一会儿。</p>
<h2 id="发送端阻塞"><a href="#发送端阻塞" class="headerlink" title="发送端阻塞"></a>发送端阻塞</h2><p><img src="/images/learning-gos-concurrency-through-illustrations-9.jpeg" style="border:0;"></p>
<p>一旦一个<code>goroutine</code>（土拨鼠）在<code>channel</code>上发送数据，这个发送数据的<code>goroutine</code>就会阻塞，直到另一个<code>goroutine</code>从<code>channel</code>接收到发送的数据。</p>
<h2 id="接收端阻塞"><a href="#接收端阻塞" class="headerlink" title="接收端阻塞"></a>接收端阻塞</h2><p><img src="/images/learning-gos-concurrency-through-illustrations-10.jpeg" style="border:0;"></p>
<p>类似于在<code>channel</code>上发送数据之后的阻塞，<code>goroutine</code>可以阻塞在等待从没有任何数据的<code>channel</code>上获取数据。</p>
<p>一开始阻塞这个概念可能有点让人不好理解，但你可以把它看作是两个<code>goroutine</code>( 土拨鼠 )之间的事务。无论一个土拨鼠是在等钱还是在送钱，它都要等到交易中的另一个伙伴出现。</p>
<p>现在我们已经了解了<code>goroutine</code>在通过<code>channel</code>进行通信时阻塞的不同方式，让我们讨论两种不同类型的<code>channel</code>：无缓冲<code>channel</code>和缓冲<code>channel</code>。选择你使用的<code>channel</code>类型可以改变程序的行为方式。</p>
<h2 id="无缓冲channel"><a href="#无缓冲channel" class="headerlink" title="无缓冲channel"></a>无缓冲<code>channel</code></h2><p><img src="/images/learning-gos-concurrency-through-illustrations-11.jpeg" style="border:0;"></p>
<p>在前面的例子中，我们一直使用无缓冲<code>channel</code>。使它们独一无二的是，一次只有一条数据适合通过<code>channel</code>。</p>
<h2 id="缓冲channel"><a href="#缓冲channel" class="headerlink" title="缓冲channel"></a>缓冲<code>channel</code></h2><p><img src="/images/learning-gos-concurrency-through-illustrations-12.jpeg" style="border:0;"></p>
<p>在并发程序中，时序并不总是完美的。 在我们的采矿案例中，我们可能会遇到这样一种情况：我们的寻找矿石土拨鼠可以在采矿土拨鼠处理一块矿石的时间内找到三块矿石。 为了不让寻找矿石的土拨鼠将大部分时间花费在发送矿石给采矿土拨鼠并一直等待它接收处理完成，我们可以使用缓冲<code>channel</code>。 让我们开始做一个容量为3的缓冲<code>channel</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bufferedChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>缓冲<code>channel</code>的工作原理与非缓冲<code>channel</code>相似，只是有一点需要注意：我们可以在需要另外的<code>goroutine</code>读取<code>channel</code>之前将多条数据发送到<code>channel</code>。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-13.jpeg" style="border:0;"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bufferedChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"> bufferedChan &lt;- <span class="string">"first"</span></div><div class="line"> fmt.Println(<span class="string">"Sent 1st"</span>)</div><div class="line"> bufferedChan &lt;- <span class="string">"second"</span></div><div class="line"> fmt.Println(<span class="string">"Sent 2nd"</span>)</div><div class="line"> bufferedChan &lt;- <span class="string">"third"</span></div><div class="line"> fmt.Println(<span class="string">"Sent 3rd"</span>)</div><div class="line">&#125;()</div><div class="line"></div><div class="line">&lt;-time.After(time.Second * <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"> firstRead := &lt;- bufferedChan</div><div class="line"> fmt.Println(<span class="string">"Receiving.."</span>)</div><div class="line"> fmt.Println(firstRead)</div><div class="line"> secondRead := &lt;- bufferedChan</div><div class="line"> fmt.Println(secondRead)</div><div class="line"> thirdRead := &lt;- bufferedChan</div><div class="line"> fmt.Println(thirdRead)</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>我们两个<code>goroutine</code>之间的打印顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Sent 1st</div><div class="line">Sent 2nd</div><div class="line">Sent 3rd</div><div class="line">Receiving..</div><div class="line">first</div><div class="line">second</div><div class="line">third</div></pre></td></tr></table></figure>
<p>为了简单起见，我们不会在最终示例程序中使用缓冲<code>channel</code>，但了解并发工具中可用的<code>channel</code>类型很重要。</p>
<blockquote>
<p>注意：使用缓冲<code>channel</code>不会阻止发生阻塞。 例如，如果寻矿土拨鼠比采矿土拨鼠快10倍，并且他们通过大小为2的缓冲<code>channel</code>进行通信，则寻矿土拨鼠仍将在程序中多次被阻塞。</p>
</blockquote>
<h1 id="把这些概念放在一起"><a href="#把这些概念放在一起" class="headerlink" title="把这些概念放在一起"></a>把这些概念放在一起</h1><p>现在通过<code>goroutine</code>和<code>channel</code>的强大功能，我们可以编写一个程序，使用Go的并发原语充分利用多个线程。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-14.jpeg" style="border:0;"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">theMine := [<span class="number">5</span>]<span class="keyword">string</span>&#123;<span class="string">"rock"</span>, <span class="string">"ore"</span>, <span class="string">"ore"</span>, <span class="string">"rock"</span>, <span class="string">"ore"</span>&#125;</div><div class="line">oreChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div><div class="line">minedOreChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div><div class="line"></div><div class="line"><span class="comment">// Finder</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(mine [5]<span class="keyword">string</span>)</span></span> &#123;</div><div class="line"> <span class="keyword">for</span> _, item := <span class="keyword">range</span> mine &#123;</div><div class="line">  <span class="keyword">if</span> item == <span class="string">"ore"</span> &#123;</div><div class="line">   oreChannel &lt;- item <span class="comment">//发送数据给 oreChannel</span></div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;(theMine)</div><div class="line"></div><div class="line"><span class="comment">// Ore Breaker</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">  foundOre := &lt;-oreChannel <span class="comment">//从 oreChannel 读取数据</span></div><div class="line">  fmt.Println(<span class="string">"From Finder: "</span>, foundOre)</div><div class="line">  minedOreChan &lt;- <span class="string">"minedOre"</span> <span class="comment">//发送数据给 minedOreChan</span></div><div class="line"> &#125;</div><div class="line">&#125;()</div><div class="line"></div><div class="line"><span class="comment">// Smelter</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">  minedOre := &lt;-minedOreChan <span class="comment">//从 minedOreChan 读取数据</span></div><div class="line">  fmt.Println(<span class="string">"From Miner: "</span>, minedOre)</div><div class="line">  fmt.Println(<span class="string">"From Smelter: Ore is smelted"</span>)</div><div class="line"> &#125;</div><div class="line">&#125;()</div><div class="line"></div><div class="line">&lt;-time.After(time.Second * <span class="number">5</span>) <span class="comment">// 依然可以忽略这行代码</span></div></pre></td></tr></table></figure>
<p>上述代码的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">From Finder:  ore</div><div class="line"></div><div class="line">From Finder:  ore</div><div class="line"></div><div class="line">From Miner:  minedOre</div><div class="line"></div><div class="line">From Smelter: Ore is smelted</div><div class="line"></div><div class="line">From Miner:  minedOre</div><div class="line"></div><div class="line">From Smelter: Ore is smelted</div><div class="line"></div><div class="line">From Finder:  ore</div><div class="line"></div><div class="line">From Miner:  minedOre</div><div class="line"></div><div class="line">From Smelter: Ore is smelted</div></pre></td></tr></table></figure>
<p>这比我们原来的例子有了很大的改进！现在，我们的每个函数都是独立运行的。而且，每次有一块矿石被加工，它就进入我们采矿线的下一个阶段。</p>
<p>为了将注意力集中在理解<code>channel</code>和<code>goroutine</code>上，我上面没有提到一些重要的信息——如果你不知道这些信息，在你开始编程时可能会引起一些麻烦。现在你已经了解了<code>goroutine</code>和<code>channel</code>的工作方式，让我们先看一看你应该知道的一些信息，然后再开始使用<code>goroutine</code>和<code>channel</code>进行编程。</p>
<h1 id="在你出发前，你应该知道"><a href="#在你出发前，你应该知道" class="headerlink" title="在你出发前，你应该知道.."></a>在你出发前，你应该知道..</h1><h2 id="匿名goroutine"><a href="#匿名goroutine" class="headerlink" title="匿名goroutine"></a>匿名<code>goroutine</code></h2><p><img src="/images/learning-gos-concurrency-through-illustrations-15.jpeg" style="border:0;"></p>
<p>与我们如何用关键字 <code>go</code> 设置一个函数运行在它自己的<code>goroutine</code>里相似，我们可以用如下格式来创建一个匿名函数运行在它自己的<code>goroutine</code>里：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匿名`goroutine`</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"> fmt.Println(<span class="string">"I'm running in my own go routine"</span>)</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>如此一来，如果我们只需要调用一次函数，我们可以将它放在它自己的<code>goroutine</code>中运行，而不用创建正式的函数声明。</p>
<h2 id="主函数是一个goroutine"><a href="#主函数是一个goroutine" class="headerlink" title="主函数是一个goroutine"></a>主函数是一个<code>goroutine</code></h2><p><img src="/images/learning-gos-concurrency-through-illustrations-16.jpeg" style="border:0;"></p>
<p>主函数确实在其自己的<code>goroutine</code>中运行！ 更重要的是要知道，一旦主函数返回，它将关闭当前正在运行的其他所有<code>goroutine</code>。 这就是为什么我们在主函数底部有一个定时器 -- 它创建了一个<code>channel</code>，并在5秒后发送了一个值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;-time.After(time.Second * <span class="number">5</span>) <span class="comment">//5秒后从channel获得一个值</span></div></pre></td></tr></table></figure>
<p>还记得一个<code>goroutine</code>会如何在一个<code>channel</code>读取数据的时候一直阻塞到有数据发送给了这个<code>channel</code>吗？ 通过添加上面的代码，主函数会阻塞，给我们其他的<code>goroutine</code>5秒额外的时间来运行。</p>
<p>现在有更好的方法来处理阻塞主函数，直到所有其他的<code>goroutine</code>完成。 通常的做法是创建 <code>done</code> <code>channel</code>，主函数在它上面读取数据从而被阻塞。 一旦你完成你的工作，写入这个<code>channel</code>，程序将结束。</p>
<p><img src="/images/learning-gos-concurrency-through-illustrations-17.jpeg" style="border:0;"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> doneChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div><div class="line"></div><div class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">// Do some work…</span></div><div class="line">  doneChan &lt;- “I’m all done!”</div><div class="line"> &#125;()</div><div class="line"></div><div class="line"> &lt;-doneChan <span class="comment">// 阻塞到上面的goroutine给这个doenChan写入数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="你可以在channel上使用range"><a href="#你可以在channel上使用range" class="headerlink" title="你可以在channel上使用range"></a>你可以在<code>channel</code>上使用<code>range</code></h2><p>在前面的一个例子中，我们让矿工从for循环中经过3次迭代从<code>channel</code>中读取数据。如果我们不知道到底有多少矿石会从发现者那里送过来，会发生什么？好吧，类似于在集合上使用<code>range</code>，你可以在一个<code>channel</code>使用<code>range</code>。</p>
<p>更新我们以前的矿工函数，我们可以写成这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Ore Breaker</span></div><div class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> foundOre := <span class="keyword">range</span> oreChan &#123;</div><div class="line">   fmt.Println(“Miner: Received “ + foundOre + “ from finder”)</div><div class="line">  &#125;</div><div class="line"> &#125;()</div></pre></td></tr></table></figure>
<p>因为矿工需要读取寻矿者发送给他的所有内容，所以通过在这里的<code>channel</code>使用<code>range</code>可以确保我们收到发送的所有内容。</p>
<blockquote>
<p>注意：在一个<code>channel</code>上使用<code>range</code>将被阻塞，直到在<code>channel</code>上发送了另一个数据。在所有需要发送的数据发送完后，停止<code>goroutine</code>被阻塞的唯一方法是用“close(channel)”关闭<code>channel</code></p>
</blockquote>
<h2 id="你可以在channel上进行非阻塞读取"><a href="#你可以在channel上进行非阻塞读取" class="headerlink" title="你可以在channel上进行非阻塞读取"></a>你可以在<code>channel</code>上进行非阻塞读取</h2><p>但你不是刚刚告诉我们<code>channel</code>如何阻塞<code>goroutine</code>的吗？！ 确实如此，但有一种技术可以使用Go的select case结构在<code>channel</code>上进行非阻塞式读取。 通过使用下面的结构，如果有某些事情发生，你的<code>goroutine</code>将从<code>channel</code>中读取，或运行默认情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">myChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div><div class="line"></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line"> myChan &lt;- “Message!”</div><div class="line">&#125;()</div><div class="line"></div><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"> <span class="keyword">case</span> msg := &lt;- myChan:</div><div class="line">  fmt.Println(msg)</div><div class="line"> <span class="keyword">default</span>:</div><div class="line">  fmt.Println(“No Msg”)</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;-time.After(time.Second * <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"> <span class="keyword">case</span> msg := &lt;- myChan:</div><div class="line">  fmt.Println(msg)</div><div class="line"> <span class="keyword">default</span>:</div><div class="line">  fmt.Println(“No Msg”)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，上述例子的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">No Msg</div><div class="line">Message!</div></pre></td></tr></table></figure>
<h2 id="你也可以在channel上进行非阻塞发送"><a href="#你也可以在channel上进行非阻塞发送" class="headerlink" title="你也可以在channel上进行非阻塞发送"></a>你也可以在<code>channel</code>上进行非阻塞发送</h2><p>非阻塞发送使用相同的select case结构来执行它们的非阻塞操作，唯一的区别是我们的情况看起来像发送而不是接收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"> <span class="keyword">case</span> myChan &lt;- “message”:</div><div class="line">  fmt.Println(“sent the message”)</div><div class="line"> <span class="keyword">default</span>:</div><div class="line">  fmt.Println(“no message sent”)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="下一步学习"><a href="#下一步学习" class="headerlink" title="下一步学习"></a>下一步学习</h1><p><img src="/images/learning-gos-concurrency-through-illustrations-18.jpeg" style="border:0;"></p>
<p>有很多讲座和博客文章涵盖<code>channel</code>和<code>goroutine</code>的更详细内容。 既然你对这些工具的目的和应用有了深刻的理解，那么你应该能够充分利用以下文章和讲座。</p>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=f6kdp27TYZs&amp;t=938s" target="_blank" rel="external">Google I/O 2012 — Go Concurrency Patterns</a><br> <a href="https://www.youtube.com/watch?v=cN_DpYBzKso" target="_blank" rel="external">Rob Pike — ‘Concurrency Is Not Parallelism’</a><br><a href="https://www.youtube.com/watch?v=ltqV6pDKZD8&amp;t=1315s" target="_blank" rel="external">GopherCon 2017: Edward Muller — Go Anti-Patterns</a></p>
</blockquote>
<p>谢谢你抽出时间来阅读这篇文章。我希望你能够了解<code>goroutine</code>、<code>channel</code>以及它们为编写并发程序带来的好处。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@trevor4e/learning-gos-concurrency-through-illustrations-8c4aff603b3" target="_blank" rel="external">https://medium.com/@trevor4e/learning-gos-concurrency-through-illustrations-8c4aff603b3</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你很可能或多或少听说过Go。 它越来越受欢迎。 Go快速，简单，并且拥有一个很棒的社区。 并发模型是学习这门语言最令人兴奋的方面之一。 Go的并发原语使创建并发的多线程程序变得简单而有趣。 我将通过插图介绍Go的并发原语，希望能够将这些概念讲清楚以供将来学习。 本文适用于Go的新手，以及想要了解Go的并发原语：go routine 和 channel 的学习者。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://szpzs.oschina.io/categories/Go/"/>
    
      <category term="concurrency" scheme="http://szpzs.oschina.io/categories/Go/concurrency/"/>
    
      <category term="goroutine" scheme="http://szpzs.oschina.io/categories/Go/concurrency/goroutine/"/>
    
      <category term="channel" scheme="http://szpzs.oschina.io/categories/Go/concurrency/goroutine/channel/"/>
    
    
      <category term="concurrency" scheme="http://szpzs.oschina.io/tags/concurrency/"/>
    
      <category term="Go" scheme="http://szpzs.oschina.io/tags/Go/"/>
    
      <category term="goroutine" scheme="http://szpzs.oschina.io/tags/goroutine/"/>
    
      <category term="channel" scheme="http://szpzs.oschina.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>用铁路的方法简化Erlang的case嵌套问题</title>
    <link href="http://szpzs.oschina.io/2018/06/15/railway-oriented-development-with-erlang/"/>
    <id>http://szpzs.oschina.io/2018/06/15/railway-oriented-development-with-erlang/</id>
    <published>2018-06-15T03:13:20.000Z</published>
    <updated>2018-06-15T07:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文提出了另一种可以构建你的程序的方法，它的灵感来自Elixir的管道宏’|&gt;’，此方法就是使用我最近编写的小型<a href="https://github.com/oltarasenko/epipe" target="_blank" rel="external">epipe</a>库，而不用令人可怕的parse transforms。 Epipe本身的灵感来源于Scott Wlaschin发表的<a href="https://fsharpforfunandprofit.com/rop/" target="_blank" rel="external">这篇文章</a>。</p>
<a id="more"></a>
<h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><p>我们来执行一个小实践任务，它将演示这种铁路方式的函数式编程方法。</p>
<p>考虑一下我们使用Erlang构建POP3电子邮件客户端的情况。 我们的目标是实现与POP服务器建立连接的控制流程。</p>
<p>下图说明完成此操作所需的步骤：</p>
<p><img src="/images/railway-oriented-development-with-erlang-steps.png" style="border:0;"></p>
<p>首先，让我们写一个函数来实现建立连接的功能：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">connect</span><span class="params">(Addr, Port, ConnOptions, User, Password)</span> -&gt;</span></div><div class="line">    &#123;ok, Socket&#125; = ssl:connect(Addr, Port, ConnOptions),</div><div class="line">    ok = receive_greetings(Socket),</div><div class="line">    ok = send_user(Socket, User),</div><div class="line">    ok = send_password(Socket, Password).</div></pre></td></tr></table></figure>
<p>上述代码非常漂亮，仅仅四行就完成了我们想要的功能。但是等等……上面的实现是非常完美的场景。 显然我们需要添加一些错误处理来应对边界条件的场景 :( 。我的意思是，“可能会出错的地方”？</p>
<h2 id="增加错误处理"><a href="#增加错误处理" class="headerlink" title="增加错误处理"></a>增加错误处理</h2><p>让我们总结如下图中所有可能的边界情况：</p>
<p><img src="/images/railway-oriented-development-with-erlang-cases.png" style="border:0;"></p>
<p>我们增加错误处理的代码，然后看看代码变成什么样子！</p>
<p>剧透：下面的例子很简单，可以通过将操作分成单独的函数来美化，但是嵌套的case语句是不可避免的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">connect</span><span class="params">(Addr, Port, ConnOptions, User, Password)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> ssl:connect(Addr, Port, ConnOptions) <span class="keyword">of</span></div><div class="line">        &#123;ok, Socket&#125; -&gt;</div><div class="line">            <span class="keyword">case</span> receive_greetings(Socket) <span class="keyword">of</span></div><div class="line">                ok -&gt;</div><div class="line">                    <span class="keyword">case</span> send_user(Socket, User) <span class="keyword">of</span></div><div class="line">                        ok -&gt;</div><div class="line">                            <span class="keyword">case</span> send_password(Socket, Password) <span class="keyword">of</span></div><div class="line">                                ok -&gt; ok;</div><div class="line">                                _Err -&gt; error_logger:error_msg(<span class="string">"Auth error"</span>)</div><div class="line">                            <span class="keyword">end</span>;</div><div class="line">                        _Err -&gt;</div><div class="line">                            error_logger:error_msg(<span class="string">"Unknown user"</span>)</div><div class="line">                    <span class="keyword">end</span>;</div><div class="line">                Err -&gt; error_logger:error_msg(<span class="string">"Could not receive_greetings"</span>)</div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        _Error -&gt; error_logger:error_msg(<span class="string">"Could not connect"</span>)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>现在我们添加了所有的错误处理代码。但是，代码的大小增加了400 %……可读性也相应降低了！</p>
<p>也许有一个更清晰的方式来实现这一点？</p>
<h2 id="用“铁路”的方法来设计更好的错误处理（理论）"><a href="#用“铁路”的方法来设计更好的错误处理（理论）" class="headerlink" title="用“铁路”的方法来设计更好的错误处理（理论）"></a>用“铁路”的方法来设计更好的错误处理（理论）</h2><p><a href="https://fsharpforfunandprofit.com/rop/" target="_blank" rel="external">铁路</a>方法背后的想法是用铁路道岔作为模拟物来分解“每一步”功能块：</p>
<p><img src="/images/railway-oriented-development-with-erlang-switch1.jpg" style="border:0;"></p>
<p>这种方法可以翻译为如下的Erlang代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">switch_component</span><span class="params">(Input)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> some_action() <span class="keyword">of</span></div><div class="line">        &#123;ok, Response&#125; -&gt; &#123;ok, Response&#125;; <span class="comment">% Green track</span></div><div class="line">        Error          -&gt; &#123;error, Error&#125;  <span class="comment">% Red track</span></div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>一旦为所有需要的操作创建了两种方式( ok / error )切换分支，就可以像在铁路上一样优雅地组合它们:</p>
<p><img src="/images/railway-oriented-development-with-erlang-switch2.jpg" style="border:0;"></p>
<p>所以，简单来说，确切的情况是:<br>在成功的情况下，所有功能(“铁路道岔”)都按顺序执行，我们沿着“成功轨道”行进。否则，我们的列车将切换到“错误轨道”，并沿该路线行驶，绕过所有其他步骤:</p>
<p><img src="/images/railway-oriented-development-with-erlang-switch3.jpg" style="border:0;"></p>
<h2 id="用“铁路”的方法来设计更好的错误处理"><a href="#用“铁路”的方法来设计更好的错误处理" class="headerlink" title="用“铁路”的方法来设计更好的错误处理"></a>用“铁路”的方法来设计更好的错误处理</h2><p>我们发布了一个很小的<a href="https://github.com/oltarasenko/epipe" target="_blank" rel="external">Erlang库</a>，它简化了Erlang的“铁路道岔”分解方式。那么，考虑上面的例子，让我们来看一下如何使用Epipe实现我们的用例:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-record</span><span class="params">(connection, &#123;</span></div><div class="line">    socket,</div><div class="line">    user,</div><div class="line">    addr,</div><div class="line">    port,</div><div class="line">    passwd</div><div class="line">&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">connect</span><span class="params">(Addr, Port, User, Password)</span> -&gt;</span></div><div class="line">    Connection = #connection&#123;</div><div class="line">        user = User,</div><div class="line">        passwd = Password,</div><div class="line">        add = Addr,</div><div class="line">        port = Port</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">% 定义要遵循的铁路道岔列表</span></div><div class="line">    ConnectionSteps = [</div><div class="line">        &#123;get_socket, fun get_socket/1&#125;,</div><div class="line">        &#123;recv_greetings, fun recv_greetings/1&#125;,</div><div class="line">        &#123;send_user, fun send_user/1&#125;,</div><div class="line">        &#123;send_passwd, fun send_passwd/1&#125;</div><div class="line">    ],</div><div class="line">    <span class="comment">% 通过道岔运行</span></div><div class="line">    <span class="keyword">case</span> epipe:run(ConnectionSteps, Connection) <span class="keyword">of</span></div><div class="line">        &#123;error, Step, Reason, _State&#125; -&gt;</div><div class="line">            error_logger:error_msg(<span class="string">"Failed to establish connection. Reason: ~p"</span>, [Step]),</div><div class="line">            &#123;error, Reason&#125;;</div><div class="line">        &#123;ok, _Conn&#125; = Success -&gt; Success</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">% 构建功能块。注意：每一个函数可以返回 &#123;ok, Connection&#125; 或 &#123;error, Reason&#125;</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">get_socket</span><span class="params">(Connection)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> ssl:connect(Addr, Port, ExtraOptions) <span class="keyword">of</span></div><div class="line">        &#123;ok, Socket&#125; -&gt; &#123;ok, Connection#connection&#123;socket = Socket&#125;&#125;;</div><div class="line">        Error        -&gt; &#123;error, Error&#125;</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">recv_greetings</span><span class="params">(Connection)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> recv(Connection) <span class="keyword">of</span></div><div class="line">        &#123;ok, &lt;&lt;<span class="string">"+OK"</span>, _Rest/binary&gt;&gt;&#125;   -&gt; &#123;ok, Connection&#125;;</div><div class="line">        &#123;ok, &lt;&lt;<span class="string">"-ERR "</span>, Error/binary&gt;&gt;&#125; -&gt; &#123;error, Error&#125;;</div><div class="line">        Err                             -&gt; &#123;error, Err&#125;</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">send_user</span><span class="params">(Connection = #connection&#123;user = User&#125;)</span> -&gt;</span></div><div class="line">    Msg = list_to_binary(User),</div><div class="line">    send(Connection, &lt;&lt;<span class="string">"USER "</span>, Msg/binary&gt;&gt;),</div><div class="line"></div><div class="line">    <span class="keyword">case</span> recv(Connection) <span class="keyword">of</span></div><div class="line">        &#123;ok, &lt;&lt;<span class="string">"+OK"</span>, _Rest/binary&gt;&gt;&#125;   -&gt; &#123;ok, Connection&#125;;</div><div class="line">        &#123;ok, &lt;&lt;<span class="string">"-ERR "</span>, Error/binary&gt;&gt;&#125; -&gt; &#123;error, Error&#125;;</div><div class="line">        Err                             -&gt; &#123;error, Err&#125;</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">send_passwd</span><span class="params">(Connection = #connection&#123;passwd = Passwd&#125;)</span> -&gt;</span></div><div class="line">    Msg = list_to_binary(Passwd),</div><div class="line">    send(Connection, &lt;&lt;<span class="string">"PASS "</span>, Msg/binary&gt;&gt;),</div><div class="line"></div><div class="line">    <span class="keyword">case</span> recv(Connection) <span class="keyword">of</span></div><div class="line">        &#123;ok, &lt;&lt;<span class="string">"+OK"</span>, _Rest/binary&gt;&gt;&#125;   -&gt; &#123;ok, Connection&#125;;</div><div class="line">        &#123;ok, &lt;&lt;<span class="string">"-ERR "</span>, Error/binary&gt;&gt;&#125; -&gt; &#123;error, Error&#125;;</div><div class="line">        Err                             -&gt; &#123;error, Err&#125;</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与嵌套的case语句实现相比，最终的代码在代码行方面不会更小，但它确实更具可读性，使得调试和支持变得更加容易。</p>
<p>如果你希望看到真实的实现案例，请查看使用铁路方法执行的<a href="https://github.com/oltarasenko/erlpop/blob/master/src/epop_client.erl#L38-L115" target="_blank" rel="external">重构例子</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/railway-oriented-development-with-erlang.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/railway-oriented-development-with-erlang.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文提出了另一种可以构建你的程序的方法，它的灵感来自Elixir的管道宏’|&amp;gt;’，此方法就是使用我最近编写的小型&lt;a href=&quot;https://github.com/oltarasenko/epipe&quot;&gt;epipe&lt;/a&gt;库，而不用令人可怕的parse transforms。 Epipe本身的灵感来源于Scott Wlaschin发表的&lt;a href=&quot;https://fsharpforfunandprofit.com/rop/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="case" scheme="http://szpzs.oschina.io/categories/Erlang/case/"/>
    
      <category term="epipe" scheme="http://szpzs.oschina.io/categories/Erlang/case/epipe/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="case" scheme="http://szpzs.oschina.io/tags/case/"/>
    
      <category term="nested" scheme="http://szpzs.oschina.io/tags/nested/"/>
    
      <category term="nested case" scheme="http://szpzs.oschina.io/tags/nested-case/"/>
    
      <category term="epipe" scheme="http://szpzs.oschina.io/tags/epipe/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Web应用程序配置</title>
    <link href="http://szpzs.oschina.io/2018/05/27/spring-boot-web-application-configuration/"/>
    <id>http://szpzs.oschina.io/2018/05/27/spring-boot-web-application-configuration/</id>
    <published>2018-05-26T21:18:58.000Z</published>
    <updated>2018-05-26T21:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇短文中，我们将介绍<strong>Spring Boot Web应用程序配置</strong>的一些有趣方面。 我们将介绍一些Web应用程序最常用的配置。</p>
<a id="more"></a>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Spring Boot带有智能构建功能，可以轻松创建Web或独立应用程序。Spring Boot可以为我们做很多事情，甚至不需要我们为Web应用程序编写一行代码。本文中，我们只介绍其中几个配置。</p>
<h1 id="2-HTTP端口"><a href="#2-HTTP端口" class="headerlink" title="2. HTTP端口"></a>2. HTTP端口</h1><p>web应用最常见的一个配置是HTTP端口号，我们可以用下列几种方式轻松地为我们的web应用配置HTTP端口号：</p>
<ul>
<li>使用application.properties文件</li>
<li>通过基于YAML的配置</li>
<li>以编程方式设置HTTP端口号</li>
</ul>
<h2 id="2-1-通过配置来设置HTTP端口"><a href="#2-1-通过配置来设置HTTP端口" class="headerlink" title="2.1 通过配置来设置HTTP端口"></a>2.1 通过配置来设置HTTP端口</h2><p>对于properties文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.port=9001</div></pre></td></tr></table></figure>
<p>对于YAML文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">        port:</span> <span class="number">8083</span></div></pre></td></tr></table></figure>
<h2 id="2-2-以编程方式设置HTTP端口号"><a href="#2-2-以编程方式设置HTTP端口号" class="headerlink" title="2.2 以编程方式设置HTTP端口号"></a>2.2 以编程方式设置HTTP端口号</h2><p>我们也可以在Spring Boot中编程设置HTTP端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfiguration</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Customize the specified &#123;<span class="doctag">@link</span> ConfigurableEmbeddedServletContainer&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> container the container to customize</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</div><div class="line">        container.setPort(<span class="number">9001</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3-Context-路径"><a href="#3-Context-路径" class="headerlink" title="3. Context 路径"></a>3. Context 路径</h1><p>Spring Boot Web应用程序的默认上下文路径是“/”，Spring Boot提供了通过配置或以编程方式设置上下文路径的选项。</p>
<h2 id="3-1-通过配置来设置Context路径"><a href="#3-1-通过配置来设置Context路径" class="headerlink" title="3.1 通过配置来设置Context路径"></a>3.1 通过配置来设置Context路径</h2><p>对于properties文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.contextPath=/javadevjournal</div></pre></td></tr></table></figure>
<p>对于YAML文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">        contextPath:</span>/javadevjournal</div></pre></td></tr></table></figure>
<h2 id="3-2-通过编程来设置Context路径"><a href="#3-2-通过编程来设置Context路径" class="headerlink" title="3.2 通过编程来设置Context路径"></a>3.2 通过编程来设置Context路径</h2><p>我们在Spring Boot中也可以通过编程来设置Context路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfiguration</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Customize the specified &#123;<span class="doctag">@link</span> ConfigurableEmbeddedServletContainer&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> container the container to customize</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</div><div class="line">        container.setPort(<span class="number">9001</span>);</div><div class="line">        container.setContextPath(<span class="string">"/javadevjournal"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-BasicErrorController"><a href="#4-BasicErrorController" class="headerlink" title="4. BasicErrorController"></a>4. BasicErrorController</h1><p>如果你正在用Spring Boot应用程序，那么你应该熟悉 <strong>While Label Error Page</strong>。 如果我们没有指定自己的自定义bean，Spring Boot会自动注册BasciErrorController bean。 我们可以通过扩展ErrorController来定制这个bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/error"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = PATH)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"errorHandling"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the path of the error page.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> the error path</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> PATH;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-自定义错误页面"><a href="#5-自定义错误页面" class="headerlink" title="5. 自定义错误页面"></a>5. 自定义错误页面</h1><p>Spring Boot提供了一种基于错误代码使用我们自己的自定义错误页面的方法。 我们需要在/error目录下添加基于错误代码的页面，并且Spring Boot将根据错误代码使用正确的页面。</p>
<p>我们可以使用静态HTML，也可以使用模板来构建我们的自定义错误页面。 文件的名称应该是确切的状态码或系列通配符。</p>
<p>我们可以使用类似的结构来组织我们的模板。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">src/</div><div class="line"> +- main/</div><div class="line">          +- java/</div><div class="line">          |      + &lt;source code&gt;</div><div class="line">          +- resources/</div><div class="line">                  +- public/</div><div class="line">                          +- error/</div><div class="line">                           |     +- 404.html</div><div class="line">                           +- &lt;other public assets&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">src/</div><div class="line"> +- main/</div><div class="line">          +- java/</div><div class="line">          |      + &lt;source code&gt;</div><div class="line">          +- resources/</div><div class="line">                  +- public/</div><div class="line">                          +- error/</div><div class="line">                           |     +- 5xx.html</div><div class="line">                           +- &lt;other public assets&gt;</div></pre></td></tr></table></figure>
<h1 id="6-配置日志"><a href="#6-配置日志" class="headerlink" title="6. 配置日志"></a>6. 配置日志</h1><p>Spring Boot对日志记录没有必要的依赖（通用日志API除外）。 Spring Boot内部使用LoggingSystem，试图根据类路径的内容配置日志。</p>
<p>我们可以在 <em>application.properties</em> 文件里用 logging.level 这个前缀来设置日志级别从而可以微调Spring Boot应用的日志输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">logging.level.org.springframework.web=DEBUG</div><div class="line">logging.level.org.hibernate=ERROR</div></pre></td></tr></table></figure>
<p>我们可以在Spring Boot应用程序中使用不同的日志框架（Logback，Log4j2）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们介绍了<strong>Spring Boot Web应用程序配置</strong>，这是为正确设置Web应用程序或按照你的需要设置所必需的。 有关更多详细信息，你可以随时参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="external">Spring Boot文档</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/spring-boot-web-application-configuration/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/spring-boot-web-application-configuration/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇短文中，我们将介绍&lt;strong&gt;Spring Boot Web应用程序配置&lt;/strong&gt;的一些有趣方面。 我们将介绍一些Web应用程序最常用的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
      <category term="Web" scheme="http://szpzs.oschina.io/tags/Web/"/>
    
      <category term="Configuration" scheme="http://szpzs.oschina.io/tags/Configuration/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Boot创建Web应用程序</title>
    <link href="http://szpzs.oschina.io/2018/05/25/creating-a-web-application-with-spring-boot/"/>
    <id>http://szpzs.oschina.io/2018/05/25/creating-a-web-application-with-spring-boot/</id>
    <published>2018-05-25T07:33:52.000Z</published>
    <updated>2018-05-25T07:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们将探讨使用Spring Boot创建Web应用程序的细节。 我们将探索Spring Boot如何帮助你加速应用程序开发。我们将使用Spring Boot构建一个简单的Web应用程序，并为其添加一些有用的服务。</p>
<a id="more"></a>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>启动一个新项目的主要挑战之一是该项目的初始设置。 我们需要对不同的目录结构进行调用，并且需要确保我们遵循所有行业标准。对于使用Spring Boot创建Web应用程序，我们需要以下工具：</p>
<ul>
<li>我们自己喜欢的IDE (我将使用IntelliJ)</li>
<li>Maven</li>
<li>JDK 1.8+</li>
</ul>
<h1 id="2-创建项目结构"><a href="#2-创建项目结构" class="headerlink" title="2. 创建项目结构"></a>2. 创建项目结构</h1><p>有多种方式可以使用Spring Boot Initializr为你生成项目结构：</p>
<ol>
<li>使用<a href="https://start.spring.io/" target="_blank" rel="external">Spring Initializr</a> Web界面。</li>
<li>使用Spring Boot CLI工具。</li>
<li>使用你的IDE</li>
</ol>
<p>为了简化这篇文章，我们使用Spring Initializer的网页界面来生成项目结构。</p>
<p>用你的浏览器访问<a href="https://start.spring.io/" target="_blank" rel="external">Spring Initializr Web界面</a>，你将看到一个向导来开始你的配置。</p>
<p><img src="/images/spring-init-2.png" style="border:0;"></p>
<p>你需要填写网页界面中的一些信息才能开始。</p>
<ol>
<li>你想要生成什么类型的项目（Maven或Gradle）</li>
<li>你选择什么语言（除了Java，你还可以选择Kotlin或Groovy）？</li>
<li>Spring Boot版本</li>
<li>标准的项目组和工件细节。</li>
<li>依赖</li>
</ol>
<p>依赖是Web界面中的一个有趣功能，根据你选择的依赖，Web界面会自动在生成的pom.xml文件中添加Spring Boot Starter依赖。如果你希望对生成的项目结构进行更多控制，或者不确定所有你想要添加到项目中的依赖，请单击“Switch to the full version”按钮。</p>
<p>在本文中，我们将使用Web和Thymeleaf（用于用户界面）两个Starter。</p>
<h1 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h1><p>Spring Boot不需要任何特定的代码布局或结构。我们始终可以遵循Spring Boot团队提出的一些最佳实践，但最终结构将由你的项目需求驱动。</p>
<p>下图是我们例子应用的项目结构：</p>
<p><img src="/images/spring-boot-web-2.png" style="border:0;"></p>
<h1 id="4-pom-xml"><a href="#4-pom-xml" class="headerlink" title="4. pom.xml"></a>4. pom.xml</h1><p>我们来看看pom.xml文件，详细地了解Spring Boot配置。 我将仅涵盖pom.xml中与Spring Boot相关的更改。 以下是我们示例项目中的pom.xml文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javadevjournal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javadevspringboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>javadevspringboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Java Dev Journal project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot的主要特性之一是“Starter”，它们是在我们的类路径中添加所需依赖项（jar包）的简单方法。 当使用Spring Boot时，我们不必在我们的类路径中添加jar包或依赖项（如果starter不可用，你可能必须将这些依赖项添加到pom.xml中，或者可以创建自己的自定义starter）。 我们只需要在我们的pom.xml文件中添加正确的“Starter”，Spring Boot将确保自动添加这些依赖。</p>
<h1 id="5-主应用"><a href="#5-主应用" class="headerlink" title="5. 主应用"></a>5. 主应用</h1><p>如下所示是我们的Spring Boot应用程序主类，它也是一个Spring配置类。 注解@SpringBootApplication启用Spring上下文以及Spring Boot的所有启动魔法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      SpringApplication.run(WebApplication.class, args);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-1-SpringBootApplication-注解"><a href="#5-1-SpringBootApplication-注解" class="headerlink" title="5. 1 @SpringBootApplication 注解"></a>5. 1 @SpringBootApplication 注解</h2><p>@SpringBootApplication相当于使用@Configuration，@EnableAutoConfiguration和@ComponentScan以及它们的默认值。如果要开始项目，建议使用这个注解。</p>
<p>在主类中使用@SpringBootApplication相当于同时使用以下3个注解：</p>
<ul>
<li>@Configuration作为bean定义的来源。</li>
<li>@EnableAutoConfiguration，它为Spring Boot提供了如何配置应用程序。</li>
<li>@ComponentScan自动获取所有Spring组件，包括@Configuration类。</li>
</ul>
<h2 id="5-2-主方法"><a href="#5-2-主方法" class="headerlink" title="5. 2 主方法"></a>5. 2 主方法</h2><p>我们主类的另一个有趣特点是主方法。 这是遵循标准Java工作流程的标准方法。 我们的主类将把控制权交给Spring Boot SpringApplication类。</p>
<p>SpringApplication类的run方法将用于引导一个应用程序。</p>
<h1 id="6-Welcome-Controller"><a href="#6-Welcome-Controller" class="headerlink" title="6. Welcome Controller"></a>6. Welcome Controller</h1><p>我们设置的最后一部分，我们将创建一个welcome controller，负责通过返回View的名称（在本例中为“welcome”）处理/greeting的GET请求。 视图负责呈现HTML内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="string">"welcome"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的控制器，但在我们的设置中涵盖了很多要点。</p>
<ul>
<li>@Controller注解表示被注解的类是“控制器”（例如Web controller）。</li>
<li>@RequestMapping注解可确保将对/welcome的HTTP请求映射到welcome()方法。</li>
<li>我们没有为@RequestMapping注解指定任何HTTP方法，因此默认情况下，映射所有HTTP方法。</li>
<li>由于我们使用Thymeleaf进行视图技术并从welcome()方法返回“welcome”，因此Thymeleaf会解析模板welcome.html并生成输出。</li>
</ul>
<h2 id="6-1-UI-Template"><a href="#6-1-UI-Template" class="headerlink" title="6. 1 UI Template"></a>6. 1 UI Template</h2><p>如下我们简单的Thymeleaf HTML模板。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">Hello and Welcome to our Web Application</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当使用Thymeleaf作为我们的模板引擎时，Spring Boot将通过在视图名称前后加上前缀和后缀（配置参数分别是：spring.thymeleaf.prefix和spring.thymeleaf.suffix，它们的默认的值是：’classpath:/templates/‘和’html’）。</p>
<h1 id="7-运行程序"><a href="#7-运行程序" class="headerlink" title="7. 运行程序"></a>7. 运行程序</h1><p>我们完成了我们简单的Web应用程序，现在是时候运行我们的应用程序了。 尽管可以将此服务作为传统WAR文件打包以部署到外部应用程序服务器上，但更简单的方法是创建独立应用程序。 要从IDE运行我们的应用程序，我们需要将我们的Web应用程序作为独立的Java应用程序运行。</p>
<ul>
<li>如果使用Maven，我们可以使用mvn spring-boot:run命令运行应用程序。</li>
<li>我们可以使用mvn clean package命令构建Jar包，并使用java -jar target/demo-app-0.1.0.jar运行这个jar包。</li>
</ul>
<p>现在，该网站已启动并正在运行，请访问 <a href="http://localhost:8080/welcome" target="_blank" rel="external">http://localhost:8080/welcome</a> ，如果一切正常，则应在Web浏览器中输出以下内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello and Welcome to our Web Application</div></pre></td></tr></table></figure>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>在这篇文章中，我们学习了使用Spring Boot创建Web应用程序。 Spring Boot具有许多功能，可以更快，更轻松地创建和运行Web应用程序。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring/creating-a-web-application-with-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring/creating-a-web-application-with-spring-boot/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我们将探讨使用Spring Boot创建Web应用程序的细节。 我们将探索Spring Boot如何帮助你加速应用程序开发。我们将使用Spring Boot构建一个简单的Web应用程序，并为其添加一些有用的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
      <category term="Web" scheme="http://szpzs.oschina.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Erlang私有函数的私有程度如何？</title>
    <link href="http://szpzs.oschina.io/2018/05/25/how-private-are-erlang-private-functions/"/>
    <id>http://szpzs.oschina.io/2018/05/25/how-private-are-erlang-private-functions/</id>
    <published>2018-05-24T23:41:19.000Z</published>
    <updated>2018-05-24T23:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天我在推特上看到一条引起我注意的推文：</p>
<p><img src="/images/erlang-private-function.png" style="border:0;"></p>
<a id="more"></a>
<p>出于科学的考虑，Erlang的私有函数是私有的！这与Python中的情况不同，在Python中，<a href="https://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private" target="_blank" rel="external">你在各处添加了几个下划线</a>，突然之间，两秒钟前是私有的，现在已经公开了。在Erlang，我们的私有函数在保险箱里安全地呆了25年！没有人可以调用我们声明为私有的函数！或者……有办法吗？</p>
<p><img src="/images/erlang-private-function2.gif" style="border:0;"></p>
<center>我会告诉你</center>

<p>事实证明，在Erlang中调用私有函数的方式并不那么简单，即使假设代码已经在启用<a href="http://erlang.org/doc/man/compile.html" target="_blank" rel="external">debug_info</a>的情况下编译。 让我们看看事情是如何运作的。</p>
<p>我们首先定义一个名为test的模块。 该模块包含两个函数，其中只有一个被导出：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(test)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([public/<span class="number">0</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">public</span><span class="params">()</span> -&gt;</span></div><div class="line"> i_am_public.</div><div class="line"></div><div class="line"><span class="function"><span class="title">private</span><span class="params">()</span> -&gt;</span></div><div class="line"> i_am_private.</div></pre></td></tr></table></figure>
<p>让我们编译模块，并确保包含调试信息。 注意在Erlang中如何包含调试信息是相当常见的，因为包括调试器，交叉引用工具和覆盖分析工具在内的许多工具都需要这些信息才能工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ erlc +debug_info test.erl</div><div class="line">test.erl:8: Warning: <span class="keyword">function</span> private/0 is unused</div></pre></td></tr></table></figure>
<p>编译器通知我们该私有函数不可访问，这是预期到会有的。 现在让我们打开一个shell并尝试调用这两个函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP <span class="number">19</span> [erts-<span class="number">8.3</span>.<span class="number">5.3</span>] [...]</div><div class="line"></div><div class="line">Eshell V8.<span class="number">3.5</span>.<span class="number">3</span>  (abort with ^G)</div><div class="line"><span class="number">1</span>&gt; l(test).</div><div class="line">&#123;module,test&#125;</div><div class="line"><span class="number">2</span>&gt; test:public.</div><div class="line">i_am_public</div><div class="line"><span class="number">3</span>&gt; test:private().</div><div class="line">** exception error: undefined function test:private/<span class="number">0</span></div></pre></td></tr></table></figure>
<p>我们可以调用公共函数，但不能调用私有函数。没什么新鲜的。现在，让我们定义一个小的匿名函数(我马上将解释它的作用)，并将其绑定到变量Open：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span>&gt; Open = <span class="keyword">fun</span>(Module) -&gt;</div><div class="line">    Which = code:which(Module),</div><div class="line">    &#123;ok,&#123;_,[&#123;_,&#123;_,A&#125;&#125;]&#125;&#125; = beam_lib:chunks(Module, [abstract_code]),</div><div class="line">    &#123;ok, Module, Binary&#125; = compile:forms(A, [export_all]),</div><div class="line">    code:load_binary(Module, Which, Binary)</div><div class="line">   <span class="keyword">end</span>.</div><div class="line">#Fun&lt;erl_eval.<span class="number">6.118419387</span>&gt;</div></pre></td></tr></table></figure>
<p>然后让我们调用Open函数，将test模块作为参数传递给它：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span>&gt; Open(test).</div><div class="line">&#123;module, test&#125;</div></pre></td></tr></table></figure>
<p>现在让我们尝试访问私有函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span>&gt; test:private().</div><div class="line">i_am_private.</div></pre></td></tr></table></figure>
<p>保险箱现在大开着。</p>
<p><img src="/images/erlang-private-function3.gif" style="border:0;"></p>
<center>我的天哪。</center>

<p>那么，Open函数背后有什么样的黑魔法？ 实际上并不多。 让我们再看一遍：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">fun</span><span class="params">(Module)</span> -&gt;</span></div><div class="line">  Which = code:which(Module),</div><div class="line">  &#123;ok,&#123;_,[&#123;_,&#123;_,A&#125;&#125;]&#125;&#125; = beam_lib:chunks(Module, [abstract_code]),</div><div class="line">  &#123;ok, Module, Binary&#125; = compile:forms(A, [export_all]),</div><div class="line">  code:load_binary(Module, Which, Binary)</div><div class="line"><span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>在向code server请求test模块的绝对文件名路径之后，我们使用强大的beam_lib接口从test模块的beam文件中包含的调试信息中提取抽象语法形式（还记得我们使用debug_info选项编译它吗？)，然后我们从这些语法形式开始重新编译模块，并添加臭名昭著的export_all选项，这将导致导出模块中定义的所有函数。我们重新加载了模块的新版本。</p>
<p>为了简单起见，在上面的例子中有一些情况是Open函数没有考虑的，但你应该明白它的要点。</p>
<p>快乐黑客！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/about-erlang/how-private-are-erlang-private-functions-36382c6abfa4" target="_blank" rel="external">https://medium.com/about-erlang/how-private-are-erlang-private-functions-36382c6abfa4</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我在推特上看到一条引起我注意的推文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/erlang-private-function.png&quot; style=&quot;border:0;&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="private function" scheme="http://szpzs.oschina.io/categories/Erlang/private-function/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="private function" scheme="http://szpzs.oschina.io/tags/private-function/"/>
    
      <category term="debug_info" scheme="http://szpzs.oschina.io/tags/debug-info/"/>
    
      <category term="beam_lib" scheme="http://szpzs.oschina.io/tags/beam-lib/"/>
    
      <category term="export_all" scheme="http://szpzs.oschina.io/tags/export-all/"/>
    
  </entry>
  
  <entry>
    <title>为gen_event辩护</title>
    <link href="http://szpzs.oschina.io/2018/05/24/in-defense-of-gen-event/"/>
    <id>http://szpzs.oschina.io/2018/05/24/in-defense-of-gen-event/</id>
    <published>2018-05-24T06:10:09.000Z</published>
    <updated>2018-05-24T07:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>gen_event曾一度引起Erlang和Elixir开发人员的不满。他们已经撰写了许多文章，并就gen_event的各种替代办法举行了一次以上的会议。在这篇文章中，我要说明的是，尽管gen_event存在缺陷，但它仍然是一个非常有用的模块。我也认为它的核心设计最终要比许多人认为的灵活得多。</p>
<a id="more"></a>
<p>某些设计决策会产生灵活的系统。例如，Erlang的异步消息发送和带有超时的同步消息接收为开发人员提供了全面的消息传递行为。如果要同步消息的发送，最好带上一个唯一(reference)引用来发送消息，然后执行receive语句，对这个引用进行接收模式匹配。这基本上就是使用gen_*:call这一类函数调用时内部的实际情况。如果要异步接收消息，则可以使用带有 after 0 的receive语句，在没有匹配的消息的情况下，立即超时。下面是示例代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sync_send</span><span class="params">(Pid, Msg)</span> -&gt;</span></div><div class="line">    Ref = make_ref(),</div><div class="line">    Pid ! &#123;Ref, Msg&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;Ref, Reply&#125; -&gt; Reply</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">async_recv</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        M -&gt; &#123;ok, M&#125;</div><div class="line">    <span class="keyword">after</span></div><div class="line">        <span class="number">0</span> -&gt; none</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>问题：如果Erlang给提供你同步发送和异步接收，你将如何去实现异步发送和同步接收？</p>
<p>Erlang消息传递的核心设计足够灵活，可以表达默认情况下未实现的消息传递语义。 当我们将注意力转向gen_event时，请记住这一点。</p>
<p>对于那些不熟悉gen_event的人来说，它的工作方式或多或少可能像这样：gen_event:start_link启动所谓的事件管理器进程。 当你编写一个实现gen_event行为的模块时，你正在编写所谓的事件处理程序。 事件管理器有一个已安装事件处理程序的列表，每个事件处理程序都有自己的状态。 当进程调用gen_event:notify时，事件管理器将一次调用一个其安装的处理程序（毕竟，事件管理器只是一个进程）。 我会重复重点：事件管理器进程一次执行一个所安装的事件处理程序。 这个设计引发了一些争议，特别是José Valim，他有一篇关于如何用监督者（作为事件管理器）和一堆gen_server（作为事件处理程序）替换gen_event的<a href="http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/" target="_blank" rel="external">博客文章</a>。</p>
<p>我知道我有点怪，但是我认为gen_event的默认行为非常好，并且最终比José建议的并发处理程序的解决方案灵活得多。如果希望并发处理事件，则可以通过安装事件处理程序(将消息转发到现有进程或派生进程以执行事件处理代码)来轻松实现事件的扇出。但是，如果事件的并发处理是默认行为，你将如何实现事件的顺序处理呢？我怀疑你最终会实现一个效率较低的gen_event版本；因为你将发送不必要的消息，这导致效率较低。</p>
<p>问题：如果gen_event在默认情况下并发运行事件处理程序，那么你将如何依次运行处理程序呢？</p>
<p>总之，gen_event很像Erlang的消息传递，它提供了一个灵活的基础，你可以轻松地实现不同的行为。 我很高兴gen_event的存在，并且它被设计为顺序处理事件是默认行为。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/" target="_blank" rel="external">http://www.rkallos.com/blog/2018/05/22/in-defense-of-gen-event/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gen_event曾一度引起Erlang和Elixir开发人员的不满。他们已经撰写了许多文章，并就gen_event的各种替代办法举行了一次以上的会议。在这篇文章中，我要说明的是，尽管gen_event存在缺陷，但它仍然是一个非常有用的模块。我也认为它的核心设计最终要比许多人认为的灵活得多。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="gen_event" scheme="http://szpzs.oschina.io/categories/Erlang/gen-event/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="gen_event" scheme="http://szpzs.oschina.io/tags/gen-event/"/>
    
      <category term="message passing" scheme="http://szpzs.oschina.io/tags/message-passing/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Starters简介</title>
    <link href="http://szpzs.oschina.io/2018/05/24/spring-boot-starters/"/>
    <id>http://szpzs.oschina.io/2018/05/24/spring-boot-starters/</id>
    <published>2018-05-24T02:46:53.000Z</published>
    <updated>2018-05-24T03:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们将向你介绍Spring Boot Starters，并将讨论Spring Boot Starters的优点和优势。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在启动任何项目(无论是小型项目还是企业级应用程序)之前，其中关键的方面之一是依赖管理，手动为小型应用程序执行依赖管理并不是一项困难的工作，但对于复杂的应用程序，手动管理所有项目依赖并不理想，容易出现许多问题以及浪费时间，而这些时间可以用于项目的其他一些重要方面。</p>
<p>Spring Boot背后的基本原理之一就是解决类似的问题。Spring Boot Starter是一套方便的依赖描述符，可以很容易地包含在任何级别的应用程序中。这些Starters作为Spring相关技术的引导过程，我们 不再需要担心依赖关系，它们将由Spring Boot Starters自动管理。</p>
<p>Starters包含了许多你需要的依赖项，以使项目快速启动和运行，并且具有一致的、被支持的一组管理传递依赖项。</p>
<h1 id="1-为什么我们需要Starters？"><a href="#1-为什么我们需要Starters？" class="headerlink" title="1. 为什么我们需要Starters？"></a>1. 为什么我们需要Starters？</h1><p>当我们用Spring Boot开始开发应用时，我们想到的一个基本问题就是为什么我们需要Spring Boot Starters？ 或者这些Starters在我的应用中如何帮助到我？</p>
<p>如前所述，这些Starters用于引导应用程序，我们需要的只是在应用程序中包括正确的Starters，而Spring Boot将确保所选Starters所需的所有依赖项都在你的classpath中。</p>
<p>为了更清楚地理解它，我们举一个例子，我们想构建一个简单的Spring Web MVC应用程序，我们需要在开始编写我们的Web应用程序代码之前考虑以下几点。</p>
<ul>
<li>正确的Spring MVC依赖</li>
<li>Web技术所需的依赖（例如，我们想要使用Thymeleaf）</li>
<li>我们需要确保所有这些依赖是兼容的</li>
</ul>
<p>使用Spring Boot Starters来引导我们的Spring MVC Web应用程序非常简单，我们需要在我们的pom.xml中包含spring-boot-starter-web 这个starter：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上pom.xml中的条目将确保所有必需的依赖项都应位于classpath中，因此我们都准备好开始开发web应用程序了。</p>
<p>目前，Spring Boot提供的Starters约有50多个，这还不包括第三方的Starters。有关Starters的更新列表，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" title="Spring Boot Starter" target="_blank" rel="external">Spring Boot Starter</a></p>
<p>接下来，我将介绍一些常用的Starters。</p>
<h1 id="2-Web-Starter"><a href="#2-Web-Starter" class="headerlink" title="2. Web Starter"></a>2. Web Starter</h1><p>这是最常用的Spring Boot Starter之一，该Starter将确保创建Spring Web应用程序（包括REST）所需的所有依赖包括在你的calsspath中，它还将添加tomcat-starter作为默认服务器来运行我们的Web应用程序。 要在我们的应用程序中包含Web Starter，请在pom.xml中添加以下条目。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>现在我们可以创建我们的Spring MVC Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@RestController</span></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</div><div class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你运行应用程序并访问<a href="http://localhost:8080/greeting，你应该能够获得&quot;Hello" target="_blank" rel="external">http://localhost:8080/greeting，你应该能够获得&quot;Hello</a> Word”作为响应。我们使用最少的代码创建了一个REST控制器。</p>
<h1 id="3-Data-JPA-Starter"><a href="#3-Data-JPA-Starter" class="headerlink" title="3. Data JPA Starter"></a>3. Data JPA Starter</h1><p>大多数应用程序需要一些持久性机制，而JPA是持久性的标准，Spring Boot Starters带有JPA Starters，你不再需要手动配置这些JPA依赖，而是可以通过在应用程序中添加JPA Starter轻松实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring JPA Starter提供对H2，Derby和Hsqldb的自动支持。让我们看看使用JPA starter创建一个JPA样例应用程序是多么容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String firstName;</div><div class="line">    <span class="keyword">private</span> String lastName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">        <span class="comment">//this.id = id;</span></div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</div><div class="line">                <span class="string">"id="</span> + id +</div><div class="line">                <span class="string">", firstName='"</span> + firstName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", lastName='"</span> + lastName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下是我们的UserRepository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</div><div class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByLastName</span><span class="params">(String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们可以测试我们的代码了，如下是JUnit代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpademoApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Autowired</span></div><div class="line">   UserRepository userRepository;</div><div class="line"></div><div class="line">   <span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        User user = userRepository.save(<span class="keyword">new</span> User(<span class="string">"Demo"</span>,<span class="string">"User"</span>));</div><div class="line">        User searchUser= userRepository.findOne(user.getId());</div><div class="line"></div><div class="line">        assertNotNull(searchUser);</div><div class="line">        assertEquals(user.getFirstName(),searchUser.getFirstName());</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如我们在上面的代码中看到的那样，你不再需要指定那些数据库配置或额外的数据库配置，通过添加JPA starter，我们无需配置或编码即可获得许多开箱即用的功能。</p>
<p>如果需要，你始终可以修改或自定义这些配置。</p>
<h1 id="4-Mail-Starter"><a href="#4-Mail-Starter" class="headerlink" title="4. Mail Starter"></a>4. Mail Starter</h1><p>从应用程序发送电子邮件是非常常见的任务，现在每个应用程序都需要从系统发送电子邮件。Spring Boot Mail starter提供了一种隐藏所有复杂性的简单方法来处理此功能。</p>
<p>我们可以通过在应用程序中添加Mail starter来启用电子邮件支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我正在使用Mailgun作为我的SMTP服务器，以下是添加到我的application. properties文件中的SMTP详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">spring.mail.host=smtp.mailgun.org</div><div class="line">spring.mail.username=postmaster@domain.com</div><div class="line">spring.mail.password=mypassword</div><div class="line">spring.mail.properties.mail.transport.protocol=smtp</div><div class="line">spring.mail.properties.mail.smtp.port=587</div><div class="line">spring.mail.properties.mail.smtp.auth=true</div></pre></td></tr></table></figure>
<p>我们的EmailService类负责发送邮件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaEmailService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaEmailService</span><span class="params">(JavaMailSender mailSender)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mailSender = mailSender;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line">        MimeMessagePreparator messagePreparator = mimeMessage -&gt; &#123;</div><div class="line"></div><div class="line">            MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</div><div class="line">            helper.setFrom(<span class="string">"noreply@javadevjournal.com"</span>);</div><div class="line">            helper.setTo(<span class="string">"xxx@gmail.com"</span>);</div><div class="line">            helper.setSubject(<span class="string">"Sample mail subject"</span>);</div><div class="line">            helper.setText(<span class="string">"Test Email"</span>);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        mailSender.send(messagePreparator);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用Spring提供的JavaMailSender来发送电子邮件。 JUnit测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    JavaEmailService javaEmailService;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        javaEmailService.sendEmail();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，只需简单的代码和配置即可发送一封简单的电子邮件，Spring Boot Mail Starter确保所有必需的工具已经到位，以快速开始解决实际问题。</p>
<p>请注意，我们在JavaEmailService bean中使用JavaMailSender - 该bean是由Spring Boot自动创建的。</p>
<h1 id="5-Test-Starter"><a href="#5-Test-Starter" class="headerlink" title="5. Test Starter"></a>5. Test Starter</h1><p>我们通常使用Junit、Mockito或Spring Test来测试我们的应用程序。我们可以通过添加Spring Boot Test starter轻松地将所有这些库包含在我们的应用程序中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot会自动找到我们正确的版本用于我们的应用程序测试。 这是一个JUnit示例测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    JavaEmailService javaEmailService;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        javaEmailService.sendEmail();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这些starter之外，下面还有其他常用的Spring Boot Starter</p>
<ul>
<li>spring-boot-starter-security</li>
<li>spring-boot-starter-web-services</li>
<li>spring-boot-starter-integration</li>
<li>spring-boot-starter-validation</li>
<li>spring-boot-starter-actuator</li>
</ul>
<p>如前所述，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" title="Spring Boot Starter" target="_blank" rel="external">Spring Boot Starter</a>获取Spring Boot提供的Starter的最新列表。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文提供了一个Spring Boot Starters简介，我们讨论了为什么我们需要这些Starter以及他们如何帮助我们快速引导我们的应用程序。 我们探索了一些最常用的Spring Boot Starter。</p>
<p>建议阅读：<br><a href="https://www.javadevjournal.com/spring/introduction-to-spring-boot/" title="Building an Application with Spring Boot" target="_blank" rel="external">使用Spring Boot构建应用程序</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">https://www.javadevjournal.com/spring/spring-boot-starters/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我们将向你介绍Spring Boot Starters，并将讨论Spring Boot Starters的优点和优势。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
      <category term="Spring boot starter" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/Spring-boot-starter/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
      <category term="Spring boot starter" scheme="http://szpzs.oschina.io/tags/Spring-boot-starter/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Boot构建应用程序</title>
    <link href="http://szpzs.oschina.io/2018/05/21/introduction-to-spring-boot/"/>
    <id>http://szpzs.oschina.io/2018/05/21/introduction-to-spring-boot/</id>
    <published>2018-05-21T07:32:25.000Z</published>
    <updated>2018-05-21T07:50:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们将探讨使用Spring Boot构建应用程序。 我们将介绍Spring Boot的不同方面以及使用Spring Boot构建应用程序的不同选项。</p>
<a id="more"></a>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Spring Boot有自己一套的约定，而且约定优于配置。Spring Boot通过用Spring平台自有的约定来消除大部分项目设置，这样新用户和现有用户就可以快速到达他们需要的开发节点。Spring Boot使创建一个以Spring为动力的企业应用程序变得非常容易，而且操作简单。</p>
<h1 id="2-Spring-Boot特性"><a href="#2-Spring-Boot特性" class="headerlink" title="2. Spring Boot特性"></a>2. Spring Boot特性</h1><p>Spring Boot提供以下开箱即用的功能：</p>
<ol>
<li>它通过采用预定义的约定简化了Spring依赖关系（我们将会更详细地讨论它）。</li>
<li>Spring Boot提供了一组预先配置的技术/框架来减少容易出错的配置，因此我们作为开发人员专注于构建业务逻辑而不是考虑项目设置。</li>
<li>你真的不需要为你的项目配置那些大的XML配置。</li>
<li>直接内嵌Tomcat、Jetty 或 Undertow。</li>
<li>提供预定义的Maven POM来简化你的配置。</li>
</ol>
<h1 id="3-创建Spring-Boot项目"><a href="#3-创建Spring-Boot项目" class="headerlink" title="3. 创建Spring Boot项目"></a>3. 创建Spring Boot项目</h1><p>启动一个项目的最主要挑战之一是初始化该项目的配置。我们需要对不同的目录结构进行调用，并且需要确保我们遵循所有行业标准。如果你使用的是Maven，那么你可能已经在使用Maven启动工件，它可以帮助我们更快地完成初始设置。</p>
<p>Spring Initializr是另外一个非常棒的快速启动一个Spring Boot项目的工具。Spring Initializr是一个生成Spring Boo项目的web应用。请记住，它只会生成项目结构，而不会根据你的偏好为你生成任何代码( Maven或Gradle )。如果你正在启动你的项目，我的推荐是使用Spring Initializr。</p>
<p>有几种方式来使用Spring Boot Initializr为你生成项目结构：</p>
<ol>
<li>使用Spring Initializr Web界面</li>
<li>使用Spring Boot CLI工具</li>
<li>使用你的IDE</li>
</ol>
<h2 id="3-1-使用Spring-Initializr-Web界面"><a href="#3-1-使用Spring-Initializr-Web界面" class="headerlink" title="3.1 使用Spring Initializr Web界面"></a>3.1 使用Spring Initializr Web界面</h2><p>这是为你的应用生成项目结构的最简单方式。在你的浏览器打开Spring Initializr Web界面，你将看到一个向导来开始你的配置。</p>
<p><img src="/images/spring-init.png" style="border:0;"></p>
<p>你需要在这个web界面填写一些信息：</p>
<ol>
<li>你要生成哪一类项目（Maven还是Gradle）</li>
<li>你想用什么语言（除了Java，你还可以选择Kotlin或Groovy）</li>
<li>Spring Boot的版本</li>
<li>项目的 GroupID和ArtifactID</li>
<li>选择所需依赖</li>
</ol>
<p>在web界面里选择依赖是一个有趣的功能。基于你选择的依赖，web界面将自动在生成的pom.xml文件中增加 <a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">Spring Boot Starter</a> 依赖。如果你想要更多地控制生成的项目结构，或者不确定要添加到项目中的依赖，请单击“切换到完整版”。</p>
<p><img src="/images/Spring-Full.png" style="border:0;"></p>
<p>使用完整版本界面，你可以选择Java版本，打包模式（比如用于传统部署的war包）以及为项目选择依赖的选项。一旦你点击“生成项目”按钮，Spring Initializr将生成项目，你将下载得到一个zip文件。 你可以在IDE中将解压缩的项目作为基于Maven 或 Gradle的项目导入。</p>
<p>我将不会详细介绍如何在IDE中导入项目。 有关更多详细信息，请参阅相关的IDE文档。</p>
<h2 id="3-2-使用Spring-Boot-CLI"><a href="#3-2-使用Spring-Boot-CLI" class="headerlink" title="3.2 使用Spring Boot CLI"></a>3.2 使用Spring Boot CLI</h2><p>我们也可以使用Srping Boot CLI来生成项目的结构。只要你安装了CLI，就可以打开终端输入spring。如果你正确安装了CLI，输入spring，回车后将看到如下类似的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">localhost:~ javadevjournal$ spring</div><div class="line">usage: spring [--help] [--version]</div><div class="line">       [&lt;args&gt;]</div><div class="line"></div><div class="line">Available commands are:</div><div class="line"></div><div class="line">  run [options]  [--] [args]</div><div class="line">    Run a spring groovy script</div></pre></td></tr></table></figure>
<p>我们可以在spring命令后使用init作为额外的参数来创建一个新的项目。Spring Boot CLI将在其内部使用start.spring.io来为你创建项目结构。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">localhost:~ javadevjournal$ spring init --dependencies=web springboot-demo-project</div><div class="line">Using service at https://start.spring.io</div><div class="line">Project extracted to &apos;/Users/umesh/springboot-demo-project&apos;</div></pre></td></tr></table></figure>
<p>上述命令将创建一个基于Maven的使用spring-boot-starter-web的项目，目录名为springboot-demo-project。这和使用start.spring.io的web界面创建的项目是一样的效果。我们可以传递不同的参数来自定义项目的生成。</p>
<p>比如，我们想创建基于Java 1.7的项目，我们可以传递 --java-version=1.7 作为额外参数给Spring Boot CLI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring init --java-version=1.7  --dependencies=web springboot-demo-project</div></pre></td></tr></table></figure>
<p>当执行上面的命令后，在项目的pom.xml文件里自动增加了Java 1.7相关的信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你不确认Spring init的功能有什么，可以带上标志 --list ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring init --list</div></pre></td></tr></table></figure>
<h1 id="4-查看pom-xml的内容"><a href="#4-查看pom-xml的内容" class="headerlink" title="4. 查看pom.xml的内容"></a>4. 查看pom.xml的内容</h1><p>我们来看看pom.xml文件的内容，来更详细地了解Spring Boot的配置。我将只关注pox.xml里与Spring Boot有关的变化。如下是我们创建样例项目的pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.umeshawasthi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ems<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ems<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Employee Management System outline Spring Boot Features<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- project properties repository --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Spring boot test depedency --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Spring Boot最主要的特色就是“<a href="https://www.javadevjournal.com/spring/spring-boot-starters/" title="Spring Boot Starters" target="_blank" rel="external">Starters</a>”，它们是增加依赖包到classpath的便捷方式。使用Spring Boot的时候，我们不需要增加jar包或依赖到classpath（如果一个starter不可用了，你可以自己增加所需依赖到classpath，或者创建你自己的starter）。我们仅需要增加正确的“Starters”到我们的pom.xml里，Spring Boot会确保自动增加那些依赖。</p>
<h1 id="5-应用程序入口"><a href="#5-应用程序入口" class="headerlink" title="5. 应用程序入口"></a>5. 应用程序入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmsApplication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">     SpringApplication.run(EmsApplication.class, args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-1-SpringBootApplication注解"><a href="#5-1-SpringBootApplication注解" class="headerlink" title="5.1 @SpringBootApplication注解"></a>5.1 @SpringBootApplication注解</h2><p>我们的主类用了@SpringBootApplication注解。@SpringBootApplication等同于同时使用@Configuration、@EnableAutoConfiguration和@ComponentScan。如果你启动你的项目，建议使用这个注解。使用@SpringBootApplication等同于同时使用如下三个注解：</p>
<ol>
<li><code>@Configuration</code>  作为bean定义的来源。</li>
<li><code>@EnableAutoConfiguration</code>  它使得Spring Boot自动配置应用程序。</li>
<li><code>@ComponentScan</code>  它会自动扫描所有的Spring组件，包括使用了<code>@Configuration</code>注解的类。</li>
</ol>
<h2 id="5-2-主方法"><a href="#5-2-主方法" class="headerlink" title="5.2 主方法"></a>5.2 主方法</h2><p>我们主类的另一个有趣的地方是主方法。它是遵循标准Java工作流程的标准方法。 我们的主类将把控制权交给Spring Boot的 SpringApplication类。 SpringApplication类的run方法将用于引导应用程序。 我们将在后面更深入地观察SpringApplication。</p>
<h1 id="6-Hello-World-控制器"><a href="#6-Hello-World-控制器" class="headerlink" title="6. Hello World 控制器"></a>6. Hello World 控制器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.javadevjournal.demo.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="string">"Hello World!!"</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制器非常简单。它是使用Spring MVC标准注解的Spring MVC控制器。</p>
<h1 id="7-运行应用"><a href="#7-运行应用" class="headerlink" title="7. 运行应用"></a>7. 运行应用</h1><p>是时候运行我们第一个Spring Boot程序了。我们有几种方式来运行我们的Spring Boot程序。</p>
<ol>
<li>如果我们使用IDE, 我们可以用IDE来运行我们Spring Boot程序。</li>
<li>我们可以在项目根目录下用  <code>mvn spring-boot:run</code>  命令来启动我们的第一个Spring Boot程序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> .   ____          _            __ _ _</div><div class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</div><div class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="line"> =========|_|==============|___/=/_/_/_/</div><div class="line"> :: Spring Boot ::        (v1.5.4.RELEASE)</div><div class="line"></div><div class="line">2017-07-08 15:49:50.319  INFO 1238 --- [           main] com.javadevjournal.demo.EmsApplication   : Starting EmsApplication on localhost with</div></pre></td></tr></table></figure>
<p>打开浏览器，输入 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> ，回车，我们将看到 Hello World 。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring Boot为基于Spring的应用程序提供了很好的推动力。在这篇文章中，我们学习了使用Spring Boot构建应用程序的不同选项。设置新项目始终是一项具有挑战性的任务，我们需要确保管理所有依赖，但是使用Spring Boot，这些都变得非常容易，我们能够只用几行代码就能运行第一个web应用程序，而无需过多考虑所需的依赖或程序的部署。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/introduction-to-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/introduction-to-spring-boot/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我们将探讨使用Spring Boot构建应用程序。 我们将介绍Spring Boot的不同方面以及使用Spring Boot构建应用程序的不同选项。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot是什么？</title>
    <link href="http://szpzs.oschina.io/2018/05/18/spring-boot-what-is-spring-boot/"/>
    <id>http://szpzs.oschina.io/2018/05/18/spring-boot-what-is-spring-boot/</id>
    <published>2018-05-18T06:24:59.000Z</published>
    <updated>2018-05-18T12:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这将是更侧重于介绍Spring Boot的短文，我们将讨论“什么是Spring Boot”？ 以及Spring Boot如何帮助构建基于Java的企业应用程序。</p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作为一名Java开发人员，我们很可能已经直接或间接地在工作中使用基于Spring Framework的应用程序。<strong>Spring</strong>有许多方法来配置它的行为，它提供三种方式进行配置，基于XML的配置或基于注解的配置，以及基于Java的配置，而基于Java的配置正在成为新的Spring应用程序的事实标准。尽管这些选项看起来非常好，但大型企业应用程序涉及数百个模块和复杂的业务规则，但这些配置可能会变得非常复杂。 以下是大型应用程序可以带来的一些复杂情况。</p>
<ul>
<li>每个模块有它自己的配置</li>
<li>每个模块有它自己的依赖（第三方依赖）</li>
<li>升级应用（例如从Spring 4.x 升级到Spring 5.x）将会很复杂，因为我们需要确认所有的依赖都正确地升级</li>
<li>如果一些依赖不能正常工作，试图找出根本原因是一个大型应用程序非常复杂和具有挑战性。</li>
</ul>
<p>以上所有问题或多或少都与确保我们拥有一切，然后开发团队才能开始处理实际任务有关。 现在让我们来谈谈另一个情况，我们用它来处理任何基于Spring的应用程序。假设我们要创建一个基于Web的应用程序，下面是我们大多数人常用的常用步骤：</p>
<ul>
<li>使用我们选择的Maven或IDE创建一个Web应用程序。</li>
<li>复制标准的Web应用程序配置（Spring MVC应用程序的web.xml配置）。</li>
<li>根据我们的要求调整以上配置。</li>
<li>配置Spring MVC标准bean，如ViewResolver，MessageSource等。</li>
<li>配置要用于我们的应用程序的数据库属性。</li>
<li>建立数据库层并确保底层数据库连接已经就位，然后才能开始使用它（EntityManagerFactory，TransactionManager等）</li>
</ul>
<p>上面的列表可以根据我们的应用程序的类型显着增长。</p>
<h2 id="1-Spring-Boot是什么？"><a href="#1-Spring-Boot是什么？" class="headerlink" title="1. Spring Boot是什么？"></a>1. Spring Boot是什么？</h2><p>以上所有步骤对我们来说都很重要，但是它们给开发团队增加了很多开销，而不是专注于解决实际的业务问题，最初的时间将被消耗在确保一切都就位后才开始实际的工作。我们可以将Spring Boot视为可以自动完成这些初始任务的工具。Spring Boot对我们所使用的Spring平台有自己的视角，并确保团队可以快速开始解决实际业务问题，而不是花时间在初始配置和设置上。</p>
<p>Spring Boot提供以下开箱即用的功能：</p>
<ol>
<li>它通过采用自己的视角简化了Spring依赖关系（我们将会更详细地讨论它）。</li>
<li>Spring Boot提供了一组预先配置的技术/框架来减少容易出错的配置，因此我们作为开发人员专注于构建业务逻辑而不是考虑项目设置。</li>
<li>你真的不需要为你的项目配置那些大的XML配置。</li>
<li>直接内嵌Tomcat、Jetty 或 Undertow。</li>
<li>提供预定义的Maven POM来简化您的配置。</li>
</ol>
<p>使用Spring Boot，可以轻松管理和处理介绍部分突出显示的问题。在升级过程中，我们不需要手动搜索兼容的jar包，Spring Bug将确保我们的应用程序升级到正确的版本（这称为麻烦最小化开发应用程序）。</p>
<p>让我们来看看我们的Web应用程序的一个示例pom.xml，以了解Spring Boot例子程序的配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javadevjournal.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sample web application<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>rWeb Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hateoas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>请看&lt;packaging&gt;标签，Spring Boot可以灵活地将我们的应用程序作为jar包来运行，而不是强迫我们将war作为所需的打包类型。</p>
<h2 id="2-更好的依赖管理"><a href="#2-更好的依赖管理" class="headerlink" title="2. 更好的依赖管理"></a>2. 更好的依赖管理</h2><p>只要仔细检查配置，你不会找到所有这些Spring依赖项的条目（如web MVC，核心，AOP，ORM，验证API等等），你可能已经注意到类似的条目spring-boot-starter- *，这是Spring Boot依赖管理过程。 我们在我们的pom.xml中添加了spring-boot-starter-web，Spring Boot将拉取所有为Spring MVC应用程序必需的依赖（不再需要手动配置）。</p>
<h2 id="3-自动配置"><a href="#3-自动配置" class="headerlink" title="3.自动配置"></a>3.自动配置</h2><p>自动配置是Spring Boot的另一个有趣功能，这就是为什么Spring Boot团队认为它有意思的地方。以下是Spring Boot为你做的一些工作：</p>
<ol>
<li>它将添加所有依赖，如第2点中所述。</li>
<li>自动配置表明Spring Boot具有一些合理的默认设置，即基于配置的Spring Boot将猜测应用程序的类型，并提供运行应用程序所需的默认实现，以防我们未在应用程序中定义这些应用程序。 如果你定义了这些，Spring Boot将确保这些默认值将被取消，并让你的自定义配置将负责应用程序。</li>
<li>为了更清晰的理解，假设你已经为JPA定义了依赖，并且没有定义任何数据库配置，Spring Boot会自动为我们创建所需的配置。</li>
</ol>
<p>请阅读这篇<a href="https://www.javadevjournal.com/spring/spring-boot-starters/" target="_blank" rel="external">文章</a>以更加深入地理解<strong>Spring boot的自动配置</strong></p>
<h2 id="3-Servlet容器"><a href="#3-Servlet容器" class="headerlink" title="3. Servlet容器"></a>3. Servlet容器</h2><p>每当我们做出那些小的改变，并且需要将你的应用程序部署到应用服务器来测试我们的改变时，你是否记得在Servlet容器（Tomcat等）上部署它们的过程？Spring Boot提供对嵌入式Servlet容器的支持，我们不再需要在应用服务器上部署我们的应用程序（这可以使用标准main方法轻松运行），同时我们可以使用http://\<host>:\<port>在浏览器上访问我们的应用程序。</port></host></p>
<p>我们的pom.xml中的Spring-boot-starter-web配置条目将为我们的Web应用程序提供嵌入式servlet容器，Apache Tomcat是Spring Boot提供的默认servlet容器，然而，Spring boot也提供了使用其他servlet容器的方法（我们所要做的就是将相应的 starter 添加到pom.xml中）。</p>
<p>请阅读我们的文章<a href="https://www.javadevjournal.com/spring/introduction-to-spring-boot/" target="_blank" rel="external">使用Spring Boot构建应用程序</a>来开始使用Spring Boot构建你的应用程序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们了解了Spring Boot，我们介绍了什么是Spring Boot？ Spring Boot有什么好处？ 我们讨论了Spring Boot的不同特性。 Spring Boot内部为我们做了很多事情，这对我们来说似乎很神奇。 在本系列文章中，我们将揭开Spring Boot的所有内部细节。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.javadevjournal.com/spring-boot/what-is-spring-boot/" target="_blank" rel="external">https://www.javadevjournal.com/spring-boot/what-is-spring-boot/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将是更侧重于介绍Spring Boot的短文，我们将讨论“什么是Spring Boot”？ 以及Spring Boot如何帮助构建基于Java的企业应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/categories/Spring/"/>
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/categories/Spring/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="http://szpzs.oschina.io/tags/Spring-boot/"/>
    
      <category term="Spring" scheme="http://szpzs.oschina.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Rust的内存安全革命</title>
    <link href="http://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/"/>
    <id>http://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/</id>
    <published>2018-04-28T08:31:55.000Z</published>
    <updated>2018-04-28T09:09:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的核心特性：内存管理。 该核心特性是Rust的主要创新之一，它的许多独特的特点是基于这种核心特性的。</p>
<p>本文是写给不知道Rust或刚刚开始学习它的程序员的。对于熟悉C、C++或其他使用手动管理内存以及使用垃圾回收器语言的读者来说会更容易理解Rust的特点。 本文是一个旨在介绍Rust核心概念并鼓励进一步学习的高层次介绍。本文不是教程，最后也没有Hello Wrold的Rust例子。</p>
<a id="more"></a>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>现代应用程序使用计算机的内存主要有两种方式：栈和堆。这可能不适用于使用汇编或编写嵌入式系统软件的情况，但让我们还是关注一般的应用程序的场景。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>随着程序进入和退出某些区域（通常是函数），以及循环和分支代码块，栈会自动扩展和缩小。所有现代的、高于汇编语言的语言都会自动执行此操作。它们的行为都是相似的，程序员声明变量，使用它，然后丢弃它。 编译器基于代码区域边界知道何时必须保留内存以及何时清除内存。 这是一个严格的流程，但它快速、安全且易于使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = 1       // 创建 A</div><div class="line">    loop &#123;</div><div class="line">        B = 2   // 创建 B</div><div class="line">                // 删除 B</div><div class="line">    &#125;</div><div class="line">                // 删除 A</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>对堆的处理更自由。 程序员可以从代码中的任何一点来请求它的一部分，然后在任何其他点释放它。 它并不明显与程序流程结合，编译器无法确定何时以及如何处理它。程序员有责任对其进行正确处理。</p>
<p>内存<strong>首先</strong>必须被获取到，<strong>然后</strong>被使用，<strong>最后</strong>被仅释放<strong>一次</strong>。这三个步骤似乎很简单，但将其与其他应用程序的流程混合会变得棘手，并且违反其中一个步骤都是灾难性的。 有时候一个错误可能没有任何后果，但是在其他时候，应用程序可能会被终止，甚至更糟糕的是，它的内存可能会悄无声息地被破坏。 这种行为不是确定性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">    release(A)      // 释放</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><p>当内存没有被正确释放当时候，泄露就发生了。内存泄漏成为一个致命的负担，使得应用程序比实际所需使用更多的资源。在极端情况下，如果所有的内存都被占用，并且仍然有更多的需求，它会使程序甚至整个系统崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">                    // &lt;运行时错误&gt; 从未释放</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="释放后使用"><a href="#释放后使用" class="headerlink" title="释放后使用"></a>释放后使用</h3><p>当内存被释放后程序还尝试去使用这块内存，这就是释放后使用。如果内存被还给了操作系统，而我们又尝试去访问它，这会导致致命的段错误，程序会立即被结束。另一个有趣的部分是当被释放的内存被分配器缓存并在下次获取时被重用，这使两个随机部分的代码使用相同位置的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    release(A)      // 释放</div><div class="line">    do_stuff(A)     // &lt;运行时错误&gt; 使用无效指针</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重复释放"><a href="#重复释放" class="headerlink" title="重复释放"></a>重复释放</h3><p>内存被释放两次就是重复释放。如果内存被还回操作系统，它就终止程序对它对访问。重复释放的后果很大程度上取决于分配器，释放内存在其他地方使用或只是崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // 获取</div><div class="line">    do_stuff(A)     // 使用</div><div class="line">    release(A)      // 释放</div><div class="line">    release(A)      // &lt;运行时错误&gt; 释放无效指针</div><div class="line">                    // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="传统解决方法"><a href="#传统解决方法" class="headerlink" title="传统解决方法"></a>传统解决方法</h1><p>堆管理是个非常古老的问题，程序员发明了许多工具来减轻它。有两种主要的方法，都被证明是有用的，但每一种都有严重缺陷。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>这是一个简单的方法。程序获得特殊的机制检测到从某时刻开始给定的内存块将永远不会被使用，因此它可以安全释放。该方法防止了内存泄露、释放后使用、重复释放。证明内存永远不会被再次使用的最简单的方法是证明它是不可访问的。当程序将内存的地址存储在栈上、静态变量或堆上时，该内存是可到访问的，堆本身是可到达的，因此可以在不猜测的情况下获得。而内存本身是可访问的，因此可以毫无疑问地获得它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">   ...</div><div class="line">   A = &lt;pointer to&gt;──────┐</div><div class="line">   ...                   |</div><div class="line">&#125;                        │</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ AA = &quot;reachable&quot;         ║</div><div class="line">║ AB = &lt;pointer to&gt;──────┐ ║</div><div class="line">╚════════════════════════│═╝</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ ABA = &quot;also reachable&quot;   ║</div><div class="line">╚══════════════════════════╝</div><div class="line"></div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ BA = &quot;unreachable&quot;       ║</div><div class="line">║ BB = &lt;pointer to&gt;──────┐ ║</div><div class="line">╚════════════════════════│═╝</div><div class="line">                         ▼</div><div class="line">╔══ HEAP ALLOCATED ════════╗</div><div class="line">║ BBA = &quot;also unreachable&quot; ║</div><div class="line">╚══════════════════════════╝</div></pre></td></tr></table></figure>
<p>有许多智能的策略来检查可访问性，但它们都会产生显著的开销。例如，引用计数器会增加内存使用量并为每个堆访问增加开销。另一方面，追踪垃圾回收器允许自由访问，但引入了大量的内存可访问性分析，这些分析可以在后台不断运行，或者为了清理内存可以完全停止程序的执行。 无论如何，垃圾回收器都会为应用程序增加额外的工作量并增加内存使用量。</p>
<h2 id="严格的规则"><a href="#严格的规则" class="headerlink" title="严格的规则"></a>严格的规则</h2><p>因此垃圾回收器是一个很好但消耗大量资源的解决方案。但是，如果成本难以承受或者根本没有可能使用它，我们可以做些什么呢？ 程序员发明了一个特殊的规则，它使内存管理更容易。 它是基于所有权和生命周期的规则。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>所有权是这样的一个想法，可以有很多指向分配内存的指针，但只有其中一个被视为拥有该内存。当拥有所有权的指针被销毁时，应该使用它来释放分配给它的内存。非所有权的指针可以被创建和销毁任意个，但它们永远不应该用于释放内存。这使得内存管理更加清晰，因为只有一个重要指针要跟踪和释放。它还解决了前面提到的三个堆问题中的两个问题：泄漏和重复释放。所有权可能是API和程序流程中的一个软性协议，但某些语言和库提供的工具使得此策略的执行更加明确且不易出错。例如，现代C++提供了内置的智能指针，它明确表示有拥有权的指针并实现像销毁时释放的合适行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()      // 获取</div><div class="line">    do_stuff(A)         // 使用</div><div class="line">    release(A)          // 释放, 指针拥有内存</div><div class="line">                        // 删除指针</div><div class="line">&#125;</div><div class="line"></div><div class="line">do_stuff(B) &#123;</div><div class="line">    do_more_stuff(B)    // 使用</div><div class="line">                        // 不会释放，该指针不是所有权的指针</div><div class="line">                        // 删除指针</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期是程序执行过程中的一段时间，而这段时间内一段特定的数据被有效使用。处理堆分配的内存指针时，这是非常重要的属性，这些指针并不拥有内存。 只要拥有内存的指针不释放内存，它们就可以安全使用。而有所有权的指针释放内存之后，再使用它们就是错误，因为它们的生命周期结束了。值得注意的是，任何包含给定生命期周期的指针的结构都应该被认为具有不超过指针的生命期周期。这不是一个可以执行的简单的规则，但它可以防止前面提到的第三个堆内存问题：释放后使用。 这补充了所有权的保证，使得程序的完全内存安全，而无需垃圾回收器这样的开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">main &#123;</div><div class="line">    A = allocate()  // A&apos;s lifetime begins</div><div class="line">    do_stuff(A)     // use A</div><div class="line">    B = A           // B&apos;s lifetime begins</div><div class="line">    do_stuff(B)     // use B</div><div class="line">    release(A)      // release, A&apos;s and B&apos;s lifetimes end</div><div class="line">    do_stuff(A)     // &lt;RUN TIME FAIL&gt; use A after its lifetime ended</div><div class="line">    do_stuff(B)     // &lt;RUN TIME FAIL&gt; use B after its lifetime ended</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><p>有时Rust被描述为混合解决方案。 实际上，它所做的只是强化代码中的所有权和生命周期规则，然而结果是，用Rust写代码非常安全和无忧无虑，它类似于垃圾回收语言。编译器进行静态校验该程序是内存安全的，如果无法校验它是内存安全的，编译器会产生一个指出潜在风险的错误。 当编译通过后，代码保证不会导致内存损坏。 因为这些校验在构建输出二进制文件之前都发生了，所以这个过程对程序的执行没有任何影响，就像它是用纯C或C++编写的一样轻量。</p>
<h2 id="所有权-1"><a href="#所有权-1" class="headerlink" title="所有权"></a>所有权</h2><p>Rust有非常严格的所有权概念。每一块被分配的内存被一些结构的单独实例所拥有。这些结构可以是任何类型，但通常他们最终是某种来自标准库的集合或Box（Rust的智能指针）。这些包装器负责在自己被销毁的时候释放所拥有的内存。没有简单的方法来显式分配内存和获取原始指针，而不需要任何负责任的包装器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_fn</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(<span class="number">1234</span>);    <span class="comment">// 获取</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_box);         <span class="comment">// 使用</span></div><div class="line">                                    <span class="comment">// 删除 my_box,</span></div><div class="line">                                    <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归销毁"><a href="#递归销毁" class="headerlink" title="递归销毁"></a>递归销毁</h3><p>所有权是递归的，所以如果一个结构存储另一个结构的值，它将获得后者及其所有子结构的所有权。这也意味着，当容器被销毁时，它必须递归地销毁其所有内容。Rust处理这样的情况可以说是开箱即用一样轻松。所有结构都定义了析构器，它遍历所有字段并首先销毁它们。结构的作者可以在销毁期间添加自己的步骤，例如在编写客户端时关闭数据库连接，但是在此之后字段仍然会被逐一销毁。默认的处理行为在绝大多数情况下都是足够的，因此结构很少会定义析构函数，但是不管有没有定义析构函数，它们都不会泄漏内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;                       <span class="comment">// 结构定义</span></div><div class="line">    my_box: <span class="built_in">Box</span>&lt;<span class="keyword">u32</span>&gt;,                   <span class="comment">// 它只有一个字段,</span></div><div class="line">                                        <span class="comment">// 在堆上一个持有整数的Box类型数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">my_fn</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> my_struct = MyStruct &#123;          <span class="comment">// 创建结构实例</span></div><div class="line">        my_box: <span class="built_in">Box</span>::new(<span class="number">1234</span>),         <span class="comment">// 获取内存</span></div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_struct.my_box);   <span class="comment">// 使用</span></div><div class="line">                                        <span class="comment">// 删除 my_struct,</span></div><div class="line">                                        <span class="comment">// 同时删除 my_box,</span></div><div class="line">                                        <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="用栈替代堆"><a href="#用栈替代堆" class="headerlink" title="用栈替代堆"></a>用栈替代堆</h3><p>Rust的所有权模式带来了一个强大的特性：复杂的堆管理简化为简单的栈管理。程序员不需要担心如何分配和释放内存，这些工作都通过使用局部变量来处理。甚至即使结构里嵌套了许多堆内存的引用，在栈上也总是只有一个根结构，当程序不再需要它的时候，它会自动销毁。</p>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><p>不幸的是，编写那些访问数据需要拥有这些数据的程序并不方便。Rust提供普通的、非智能的、没有所有权的引用，这种引用使得没有所有权的访问成为可能。当这样的引用被创建时，它引用的值是借用的。借用会创建一个双向关系：引用必须具有不超过它引用的值的生命周期，但该值在引用的生命周期内不得移动。这两条规则任何一条被破坏的话，引用所指向的就是无效内存。Rust静态地跟踪并强制执行生命周期的正确性并拒绝危险的程序执行流程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">valid_flow</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value);          <span class="comment">// 使用值但是没有移动它</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, borrow);         <span class="comment">// 使用借用</span></div><div class="line">                                    <span class="comment">// 删除借用</span></div><div class="line">                                    <span class="comment">// 安全地删除值，</span></div><div class="line">                                    <span class="comment">// 因为它不再被借用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrow_outlives_value</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="keyword">return</span> borrow                   <span class="comment">// 借用没有被删除</span></div><div class="line">                                    <span class="comment">// &lt;编译时错误&gt; 删除值,</span></div><div class="line">                                    <span class="comment">// 但是它仍然被借用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_moved_during_borrow_lifetime</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(value);   <span class="comment">// &lt;编译时错误&gt; 值被移动了</span></div><div class="line">                                    <span class="comment">// 而它还被借用着</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归借用"><a href="#递归借用" class="headerlink" title="递归借用"></a>递归借用</h3><p>结构的生命周期永远不能超过它们的任何字段的生命周期。如果其中一个字段恰好是引用，则必须证明整个结构实例在引用值之前被销毁。如果存在对具有生命周期限制的结构的引用，则引用本身的生命周期不能超过结构。只要编译器可以证明它是安全的，这种关系就可以嵌套并绑定任意次数。当编译器无法猜测正确的关系时，可以用简单的语法明确定义它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">nested_borrow_outlives_value</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"abc"</span>.to_string();  <span class="comment">// 创建值</span></div><div class="line">    <span class="keyword">let</span> borrow = &amp;value;            <span class="comment">// 创建借用</span></div><div class="line">                                    <span class="comment">// 使用的是值的生命周期</span></div><div class="line">    <span class="keyword">let</span> my_box = <span class="built_in">Box</span>::new(borrow);  <span class="comment">// 创建 my_box</span></div><div class="line">                                    <span class="comment">// 用的是借用的生命周期,</span></div><div class="line">                                    <span class="comment">// 这是值的生命周期</span></div><div class="line">    <span class="keyword">return</span> my_box                   <span class="comment">// &lt;编译时错误&gt;</span></div><div class="line">                                    <span class="comment">// my_box 没有被删除,</span></div><div class="line">                                    <span class="comment">// 但是值被删除了,</span></div><div class="line">                                    <span class="comment">// 这造成借用的生命周期</span></div><div class="line">                                    <span class="comment">// 超过了值的生命周期</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="规则的妥协"><a href="#规则的妥协" class="headerlink" title="规则的妥协"></a>规则的妥协</h1><p>认为每一个系统都可以用限制性的、静态证明的安全性代码来表达是天真的想当然。在绝大多数的情况下，规则可以胜任，但有时规则也必须进行妥协，Rust提供工具来做这件事。</p>
<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><p>标准库提供一些包装器将所有权和借用的检查推迟到运行时。这就使有效性检查程序不那么繁忙，并提供了灵活性和很少的运行时开销。例如，Rc是一个没有所有者的Box（带有智能指针的内存）。 它是一个有引用计数器的可被垃圾回收的内存，它的最后一个引用消失的时候，它就被销毁。 Rust提供了更多的包装器，但它们稍微超出了本介绍的范围，它们适用于运行时规则，本文没有涉及。</p>
<h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>当在库和工具中进入足够低的层次时，Rust的安全保证变得无法应用。 例如，box和集合触及内存分配和指针，但没有安全保证，因为它们自己做安全保证。 它们可以写在Rust中，因为它们的代码明确标记为不安全。这使得完全忽略安全检查，但这非常危险。 所有外部C库包装器在某些层次也必须使用不安全的代码。 他们定义安全规则，使其与其余代码无缝集成。 不安全的代码是Rust强大能力的来源，但它带来了巨大的责任。 应尽可能避免使用它。</p>
<h1 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h1><p>Rust看起来不错，它是由聪明的人使用其他聪明人的学术研究设计的，但它真的有用吗？是的，的确有用。大多数情况下，它只会强制元素之间的明确关系，进行合理安全的设计。毕竟，Rust是与Firefox Web浏览器的未来引擎Servo并行设计的。从一开始，它不仅在理论上是好的，而且在实际的、复杂的软件开发中也被证明是可用的。经过一年使用Rust进行商业编程后，我可以确认，Rust的规则不是一种负担，而是在架构和稳定性保证方面提供了很大的帮助。 我真的相信，Rust这种语言是属于未来的，我强烈推荐大家使用它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://anixe.pl/content/news/rust_memory_safety_revolution" target="_blank" rel="external">https://anixe.pl/content/news/rust_memory_safety_revolution</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的核心特性：内存管理。 该核心特性是Rust的主要创新之一，它的许多独特的特点是基于这种核心特性的。&lt;/p&gt;
&lt;p&gt;本文是写给不知道Rust或刚刚开始学习它的程序员的。对于熟悉C、C++或其他使用手动管理内存以及使用垃圾回收器语言的读者来说会更容易理解Rust的特点。 本文是一个旨在介绍Rust核心概念并鼓励进一步学习的高层次介绍。本文不是教程，最后也没有Hello Wrold的Rust例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://szpzs.oschina.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://szpzs.oschina.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="http://szpzs.oschina.io/tags/Ownership/"/>
    
      <category term="Lifetimes" scheme="http://szpzs.oschina.io/tags/Lifetimes/"/>
    
  </entry>
  
  <entry>
    <title>以NIF的方式在Elixir里使用C</title>
    <link href="http://szpzs.oschina.io/2018/04/03/using-c-from-elixir-with-nifs/"/>
    <id>http://szpzs.oschina.io/2018/04/03/using-c-from-elixir-with-nifs/</id>
    <published>2018-04-03T06:54:22.000Z</published>
    <updated>2018-04-03T07:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang支持一种方式，就是用C来实现函数，并在Erlang中透明地使用它们。这些函数被叫做NIFs（原生实现的函数）。在两种场景下，NIF被证明是完美的解决方案：当你需要原始的计算速度时；当你需要从Erlang调用已有的C接口时。在本文中，我们一起来看看这两种场景。</p>
<a id="more"></a>
<p>请注意，如果我们想要使用C程序（也就是我们想要与现有的C程序进行交互），那么NIF并不是我们唯一的选择。Erlang有其他方式处理外部函数接口来与其他语言交互。其中之一就是Port；如果你想深入了解，可以阅读 Sasa Juric 写的非常棒的<a href="http://theerlangelist.com/article/outside_elixir" target="_blank" rel="external">文章</a>。</p>
<p>我们将全面了解NIF。首先，我们将看看如何写简单的NIF来执行算术计算；接着，我们看看如何在Elixir里使用这些NIF。然后，我们了解如何从NIF里访问已有的C程序。最后，我们学习如何将C的编译合并到我们Elixir代码编译中。</p>
<p>我在本文中所讲的绝大部分内容都可以在Erlang官方文档中 <a href="http://www.erlang.org/doc/man/erl_nif.html" target="_blank" rel="external">erl_nif C 库</a> 中阅读到更多细节。</p>
<p>本文中讨论的内容适用于Erlang和Elixir，只需进行最小限度的调整。 我会在Elixir中展示我所有的例子，但我会随时提及Erlang和Elixir两者。</p>
<h1 id="严肃的NIF警告"><a href="#严肃的NIF警告" class="headerlink" title="严肃的NIF警告"></a>严肃的NIF警告</h1><p>NIF是危险的。我猜你肯定听说过Erlang（Elixir）如何可靠、容错，进程是如何隔离的，一个进程内部的崩溃只会影响到它自己，以及其他的很棒的特性。当你开始玩NIF的时候，你可以和所有Erlang好的东西说再见。一个NIF里的崩溃（比如可怕的段错误）将会使得整个Erlang虚拟机崩溃。没有监督者来恢复，没有容错，没有隔离。这意味着当你使用NIF的时候需要极度的小心谨慎，并且你应该总是确信你有一个好的理由来使用它。</p>
<p>另一个值得注意的是NIF不会被Erlang的调度器抢占：一个NIF做为一个单独的计算单元，它不会被中断。这意味着你的NIF应该尽可能地快; 正如Erlang的NIF文档所建议的那样，一个很好的经验法则是将NIF保持在毫秒级的执行时间内。查看Erlang文档，了解当你的NIF需要更多时间完成时应采取的措施。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>NIF的工作方式简单：你写一个C文件，然后在一些Erlang提供的设施下导出一些函数，然后编译这个文件。接着，你定义一个Erlang/Elixir文件，在里面调用 :erlang.load_nif/2 。这个函数将把C文件里的所有NIF定义为调用模块里的函数。</p>
<p>在实践中更容易明白这一点。</p>
<p>让我们从容易的开始：写一个没有副作用的NIF，它有一个入参和一个返回值。为完成这个例子，我们写一个 fast_compare 函数，它有两个整数入参，然后比较它们，如果相等就返回0，如果第一个比第二个小，就返回-1，否则就返回1。</p>
<h2 id="定义一个NIF"><a href="#定义一个NIF" class="headerlink" title="定义一个NIF"></a>定义一个NIF</h2><p>我们开始写 fast_compare.c 文件。首先我们必须包含 erl_nif.h 这个头文件，它包含了使用NIF的时候，我们需要的所有东西（类型、函数、宏）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div></pre></td></tr></table></figure>
<p>C编译器并不知道erl_nif.h在哪里，因此，当稍后我们编译我们的程序的时候，必须指出它的所在。</p>
<p>现在，定义NIF的所有C文件有相似的结构：C函数列表，接着是被导出到Erlang/Elixir的C函数列表（以及它们的名字），最后，调用 ERL_NIF_INIT 宏，它执行把所有这个一切串联起来的神秘的事情。</p>
<p>在我们的例子里，C函数列表就只有 fast_compare 函数。这个函数的签名如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="comment">// cool stuff here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个NIF的特定类型：ERL_NIF_TERM 和 ErlNifEnv。</p>
<p>ERL_NIF_TERM 是一个“包装”类型，它表示在C里所有的Erlang数据类型（像binary，list，tuple，等等）。我们必须使用 erl_nif.h 提供的函数来将一个 ERL_NIF_TERM 转换为一个C的值（或者多个C的值），反之亦然。</p>
<p>ErlNifEnv仅仅是NIF被执行所在的Erlang环境，我们绝大多数只是把它在函数中进行传递而不必实际对它进行操作。</p>
<p>我们来看看 fast_compare 的参数（所有的NIF参数都如此）：</p>
<ul>
<li>env 如上所述，仅是NIF被执行所在的Erlang环境，我们不比太关心它。</li>
<li>argc 当从Erlang调用NIF的时候，传递给它的参数个数。后面我们将详述。</li>
<li>argv 传递给NIF的参数的数组。</li>
</ul>
<h2 id="读取Erlang-Elixir类型的值为C类型的值"><a href="#读取Erlang-Elixir类型的值为C类型的值" class="headerlink" title="读取Erlang/Elixir类型的值为C类型的值"></a>读取Erlang/Elixir类型的值为C类型的值</h2><p>我们从Elixir调用 fast_compare ，如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fast_compare(<span class="number">99</span>, <span class="number">100</span>)</div><div class="line"><span class="comment">#=&gt; -1</span></div></pre></td></tr></table></figure>
<p>当执行 fast_compare ，argc为2，argv 是 99 和 100 组成的数组。然而，这些参数的类型是 ERL_NIF_TERM ，因此我们必须将它们“转换”为C的数据类型才能操作它们。erl_nif.h 提供了函数将Erlang的数据类型转换为C的数据类型。在本例子里，我们需要用enif_get_int这个函数。enif_get_int的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">enif_get_int</span><span class="params">(ErlNifEnv *env, ERL_NIF_TERM term, <span class="keyword">int</span> *ip)</span></span>;</div></pre></td></tr></table></figure>
<p>我们必须传入变量 env，我们需要转换的Erlang数据（从argv中取出的），以及转换得到的值所存储的地址。</p>
<h2 id="将C类型的值转换为Erlang类型的值"><a href="#将C类型的值转换为Erlang类型的值" class="headerlink" title="将C类型的值转换为Erlang类型的值"></a>将C类型的值转换为Erlang类型的值</h2><p>erl_nif.h 提供了几个 enif_make_* 类似的函数来将C类型的值转换为Erlang类型的值。它们都有相似的签名（只是根据被转换的数据类型不同而有差别），并且它们都返回 ERL_NIF_TERM类型的值。在本例子中，我们需要 enif_make_int 函数，它的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">ERL_NIF_TERM <span class="title">enif_make_int</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> i)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="编写NIF"><a href="#编写NIF" class="headerlink" title="编写NIF"></a>编写NIF</h2><p>我们已经知道如何在Erlang类型数据和C类型数据之间进行转换，那么编写NIF就很直观了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  <span class="comment">// Fill a and b with the values of the first two args</span></div><div class="line">  enif_get_int(env, argv[<span class="number">0</span>], &amp;a);</div><div class="line">  enif_get_int(env, argv[<span class="number">1</span>], &amp;b);</div><div class="line"></div><div class="line">  <span class="comment">// Usual C unreadable code because this way is more true</span></div><div class="line">  <span class="keyword">int</span> result = a == b ? <span class="number">0</span> : (a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> enif_make_int(env, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="连接我们的C"><a href="#连接我们的C" class="headerlink" title="连接我们的C"></a>连接我们的C</h2><p>我们现在必须将我们写的函数导出到Erlang。我们必须使用ERL_NIF_INIT这个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERL_NIF_INIT(erl_module, functions, load, upgrade, unload, reload)</div></pre></td></tr></table></figure>
<ul>
<li>erl_module 是Erlang模块，我们导出的函数将被定义在里面。它不需要被双引号括起来，因为它将被ERL_NIF_INIT字符串化（例如，用my_module而不是用”my_module”）；</li>
<li>functions 是ErlNifFunc结构类型数据的数组，它定义哪些NIF被导出，以及对应的Erlang函数和它的参数个数；</li>
<li>load，upgrade，unload，reload是函数指针，它们指向那些NIF被装载卸载等操作的回调函数；我们现在不太关心这些回调函数，把它们全部设置为NULL。</li>
</ul>
<p>我们所需的所有元素都准备好了。完整的C文件如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">fast_compare</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  enif_get_int(env, argv[<span class="number">0</span>], &amp;a);</div><div class="line">  enif_get_int(env, argv[<span class="number">1</span>], &amp;b);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> result = a == b ? <span class="number">0</span> : (a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> enif_make_int(env, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Let's define the array of ErlNifFunc beforehand:</span></div><div class="line"><span class="keyword">static</span> ErlNifFunc nif_funcs[] = &#123;</div><div class="line">  <span class="comment">// &#123;erl_function_name, erl_function_arity, c_function&#125;</span></div><div class="line">  &#123;<span class="string">"fast_compare"</span>, <span class="number">2</span>, fast_compare&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ERL_NIF_INIT(Elixir.FastCompare, nif_funcs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</div></pre></td></tr></table></figure>
<p>要记得我们必须要在ERL_NIF_INIT宏里使用Elixir模块的全名的原子（是Elixir.FastCompare而不是FastCompare）。</p>
<h2 id="编译我们的C代码"><a href="#编译我们的C代码" class="headerlink" title="编译我们的C代码"></a>编译我们的C代码</h2><p>NIF文件应该编译为 .so 共享库。编译标志在不同的系统和编译器中有所不同，但它们应该看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cc <span class="_">-f</span>PIC -I$(ERL_INCLUDE_PATH) \</div><div class="line">     -dynamiclib -undefined dynamic_lookup \</div><div class="line">     -o fast_compare.so fast_compare.c</div></pre></td></tr></table></figure>
<p>使用这个命令，我们用一些为了生产动态代码的标志把 fast_compare.c 编译为 fast_compare.so （-o fast_compare.so）。注意我们如何把 $(ERL_INCLUDE_PATH) 包含在搜索路径里：这个路径包含了erl_nif.h 头文件。这个路径通常在Erlang的安装目录里，即 lib/erts-VERSION/include。</p>
<h2 id="在Elixir中装载NIF"><a href="#在Elixir中装载NIF" class="headerlink" title="在Elixir中装载NIF"></a>在Elixir中装载NIF</h2><p>剩下的事情是装载在Elixir模块 FastCompare 里定义的NIF。如Erlang中关于NIF的文档所建议，钩子 @on_load 是做这件事的最适合的地方。</p>
<p>请注意，对于我们要定义的每个NIF，我们也需要在加载模块中定义相应的Erlang / Elixir函数。 这可以被利用来在NIF不可用的情况下定义例如回退代码。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># fast_compare.ex</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">FastCompare</span></span> <span class="keyword">do</span></div><div class="line">  <span class="variable">@on_load</span> <span class="symbol">:load_nifs</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load_nifs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:erlang</span>.load_nif(<span class="string">'./fast_compare'</span>, <span class="number">0</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fast_compare</span></span>(_a, _b) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"NIF fast_compare/2 not implemented"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>:erlang.load_nif/2 的第二个参数可以是任何东西，它会被传递给我们上面提到的load回调函数。 你可以看看<a href="http://www.erlang.org/doc/man/erlang.html#load_nif-2" target="_blank" rel="external">erlang.load_nif/2</a>的文档以获取更多信息。</p>
<p>搞定！我们可以在IEx里测试一下我们的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; c <span class="string">"fast_compare.ex"</span></div><div class="line">iex&gt; FastCompare.fast_compare(<span class="number">99</span>, <span class="number">100</span>)</div><div class="line">-<span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>写“纯”的NIF（没有副作用，只是转换）非常有用。我非常喜欢的一个例子是 <a href="https://github.com/devinus/markdown" target="_blank" rel="external">devinus/markdown</a> 这个Elixir库：这个库用NIF封装了一个C的markdown解析器。这个用例是完美的，因为将Markdown转换为HTML可能是一项昂贵的任务，而通过将该工作委托给C来做可以获得更好的性能。</p>
<h1 id="有用的东西：资源"><a href="#有用的东西：资源" class="headerlink" title="有用的东西：资源"></a>有用的东西：资源</h1><p>正如我上面提到的，NIF的一个非常有用的地方是包装已有的C库。然而，这些库常常提供它们自己的数据抽象和数据结构。例如，一个C的数据库驱动导出一个 db_conn_t 类型来表示一条数据库链接，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// fields</span></div><div class="line">&#125; <span class="keyword">db_conn_t</span>;</div></pre></td></tr></table></figure>
<p>相应的函数初始化链接、发起查询、释放链接，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">db_conn_t</span> *db_init_conn();</div><div class="line"><span class="function">db_type <span class="title">db_query</span><span class="params">(<span class="keyword">db_conn_t</span> *conn, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_free_conn</span><span class="params">(<span class="keyword">db_conn_t</span> *conn)</span></span>;</div></pre></td></tr></table></figure>
<p>如果我们能够在Erlang/Elixir里处理db_conn_t数据类型并且在NIF调用之间传递它们的话，这将非常有用。NIF的API有一个叫做 <strong>resources</strong> 的概念。没有比用Erlang的官方文档更好的方式来快速解释什么是 <strong>resources</strong> 。</p>
<blockquote>
<p><strong>资源对象的使用是一种从NIF返回指向原生数据结构的指针的安全方法。 资源对象只是一块内存。 […].</strong></p>
</blockquote>
<p>资源是内存块，我们可以构建并返回指向该内存的安全指针作为Erlang的类型数据。</p>
<p>让我们来探讨一下如何在NIF内部包装上面简单的API。 我们将从这个骨架C文件开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"db.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"erl_nif.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// fields here</span></div><div class="line">&#125; <span class="keyword">db_conn_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">db_conn_t</span> *db_init_conn();</div><div class="line"><span class="function">db_type <span class="title">db_query</span><span class="params">(<span class="keyword">db_conn_t</span> *conn, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">db_free_conn</span><span class="params">(<span class="keyword">db_conn_t</span> *conn)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="资源的创建"><a href="#资源的创建" class="headerlink" title="资源的创建"></a>资源的创建</h2><p>要创建一个资源，我们必须要使用 enif_alloc_resource 函数的帮助来分配一些内存。从这个函数的签名你可以看出它和 malloc 函数相似（原则上）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">enif_alloc_resource</span><span class="params">(ErlNifResourceType *res_type, <span class="keyword">unsigned</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>enif_alloc_resource 的第一个参数是一个资源类型（这只是我们用来区分不同类型资源的东西），第二个参数是需要分配的内存大小，返回值是已分配内存的指针。</p>
<h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>资源类型是用 enif_open_resource_type 函数来创建的。我们可以在我们的C文件里声明资源类型作为全局变量。同时，利用传递给 ERL_NIF_INIT的load回调函数的便利性来创建资源类型并且把它们赋值给全局变量。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ErlNifResourceType *DB_RES_TYPE;</div><div class="line"></div><div class="line"><span class="comment">// 每次当一个资源被释放的时候这个函数被调用</span></div><div class="line"><span class="comment">// 资源被释放在enif_release_resource函数被调用</span></div><div class="line"><span class="comment">// 以及Erlang回收内存的时候发生</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">db_res_destructor</span><span class="params">(ErlNifEnv *env, <span class="keyword">void</span> *res)</span> &#123;</div><div class="line">  db_free_conn((<span class="keyword">db_conn_t</span> *) res);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">load</span><span class="params">(ErlNifEnv *env, <span class="keyword">void</span> **priv_data, ERL_NIF_TERM load_info)</span> &#123;</div><div class="line">  <span class="keyword">int</span> flags = ERL_NIF_RT_CREATE | ERL_NIF_RT_TAKEOVER;</div><div class="line">  DB_RES_TYPE =</div><div class="line">    enif_open_resource_type(env, <span class="literal">NULL</span>, <span class="string">"db"</span>, db_res_destructor, flags, <span class="literal">NULL</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h3><p>我们现在可以包装db_init_conn并且创建我们的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">db_init_conn_nif</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="comment">// 让我们给一个 db_conn_t 指针分配内存</span></div><div class="line">  <span class="keyword">db_conn_t</span> **conn_res = enif_alloc_memory(DB_RES_TYPE, <span class="keyword">sizeof</span>(<span class="keyword">db_conn_t</span> *));</div><div class="line"></div><div class="line">  <span class="comment">// 让我们创建一条链接并且把它拷贝到指针所指的内存</span></div><div class="line">  <span class="keyword">db_conn_t</span> *conn = db_init_conn();</div><div class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *) conn_res, (<span class="keyword">void</span> *) &amp;conn, <span class="keyword">sizeof</span>(<span class="keyword">db_conn_t</span> *));</div><div class="line"></div><div class="line">  <span class="comment">// 我们现在可以让Erlang类型数据持有这个资源...</span></div><div class="line">  ERL_NIF_TERM term = enif_make_resource(env, conn_res);</div><div class="line">  <span class="comment">// ...然后释放这个资源以便在Erlang垃圾回收的时候它将被释放</span></div><div class="line">  enif_release_resource(conn_res);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> term;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><p>为了包装db_query，我们需要获取 db_init_conn_nif 返回的资源。为实现这个功能，我们需要使用 enif_get_resource 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM</span></div><div class="line"><span class="title">db_query_nif</span><span class="params">(ErlNifEnv *env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span> &#123;</div><div class="line">  <span class="keyword">db_conn_t</span> **conn_res;</div><div class="line">  enif_get_resource(env, argv[<span class="number">0</span>], DB_RES_TYPE, (<span class="keyword">void</span> *) conn_res);</div><div class="line"></div><div class="line">  <span class="keyword">db_conn_t</span> *conn = *conn_res;</div><div class="line"></div><div class="line">  <span class="comment">// 我们现在可以运行我们的查询</span></div><div class="line">  db_query(conn, ...);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> argv[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在Elixir里使用资源"><a href="#在Elixir里使用资源" class="headerlink" title="在Elixir里使用资源"></a>在Elixir里使用资源</h3><p>让我们跳过在DB模块里导出我们创建的NIF，直接跳到IEx shell环节，而且假设C代码已经编译并被DB模块装载进虚拟机了。正如我前面所述，当资源返回给Erlang/Elixir的时候完全是一个不透明的数据。它们表现得就像是空的的二进制数据。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; conn_res = DB.db_conn_init()</div><div class="line"><span class="string">""</span></div><div class="line">iex&gt; DB.db_query(conn_res, ...)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>因为资源是不透明的数据，除了将它们回传给其他NIF，你无法在Erlang/Elixir里对它进行任何有意义的处理。它们的行为和看起来像二进制数据，这甚至可以导致问题，因为他们可以被误认为二进制数据。基于这个缘故，我建议将资源包装到结构当中。这样我们可以限制我们的公共API仅能处理结构并且在内部处理资源。我们也可以通过实现结构的 Inspect 协议来获得好处，这种方式使得我们可以安全地检测资源，而隐藏了它们看起来像是二进制数据的事实。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">DBConn</span></span> <span class="keyword">do</span></div><div class="line">  defstruct [<span class="symbol">:resource</span>]</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">defimpl</span> <span class="title">Inspect</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="用Mix编译"><a href="#用Mix编译" class="headerlink" title="用Mix编译"></a>用Mix编译</h1><p>Mix提供了一个特性，叫做<a href="http://elixir-lang.org/docs/stable/mix/Mix.html#compilers/0" target="_blank" rel="external">Mix 编译器</a>。每一个Mix项目在编译的时候可以指定一个编译器列表来运行。新的Mix编译器是自动编译C源代码的完美场所。对于本节的范围，假设我们正在构建一个叫做 :my_nifs 的Elixir应用程序，该应用程序将使用my_nifs.c C源文件中的NIF。</p>
<p>首先我们创建 Makefile 来编译C源码（反正我们可能会这么做）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ERL_INCLUDE_PATH=$(...)</div><div class="line"></div><div class="line">all: priv/my_nifs.so</div><div class="line"></div><div class="line">priv/my_nifs.so: my_nifs.c</div><div class="line">  cc <span class="_">-f</span>PIC -I$(ERL_INCLUDE_PATH) -dynamiclib -undefined dynamic_lookup -o my_nifs.so my_nifs.c</div></pre></td></tr></table></figure>
<p>这个 Makefile 文件假设 my_nifs.c 存储在我们的Mix项目的根目录。我们将把 .so 共享库存放在我们应用的 priv 目录中，以便在发布的时候它是可用的。现在，无论何时，只要我们修改了 my_nifs.c ，然后运行 make ，priv/my_nifs.so 都会被重新编译。</p>
<p>我们现在可以挂接一个只调用make的新的Mix编译器。在 mix.exs 中，我们来实现之：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Mix</span></span>.Tasks.Compile.MyNifs <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(_args) <span class="keyword">do</span></div><div class="line">    &#123;result, _errcode&#125; = System.cmd(<span class="string">"make"</span>, [], <span class="symbol">stdout_to_stderr:</span> <span class="keyword">true</span>)</div><div class="line">    IO.binwrite(result)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们调用 IO.binwrite/1 来将 make 的运行结果输出到终端。在一个真实的场景里，我们肯定要检查 make 的结果，同时也要确认 cc 和 make 已经安装到系统里，并且其路径可用；不过在这里，我们简单地忽略了这些步骤。</p>
<p>我们现在需要将 :my_nifs 编译器添加到 :my_nifs 应用的编译器列表。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in mix.exs</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">MyNifs</span></span>.Mixfile <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> Mix.Project</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">project</span></span> <span class="keyword">do</span></div><div class="line">    [<span class="symbol">app:</span> <span class="symbol">:my_nifs</span>,</div><div class="line">     <span class="symbol">compilers:</span> [<span class="symbol">:my_nifs</span>] ++ Mix.compilers,</div><div class="line">     ...]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在，任何时候我们运行 $ mix compiler ，我们的C代码就被自动重新编译（如果需要）。当其他库把 :my_nifs 作为依赖的话，这个过程也会一样地执行，因为现在运行 make 是 :my_nifs 项目编译的一个过程。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这是一个很长的帖子，但我希望我覆盖了NIF的大部分内容。如你所见，在Erlang/Elixir里使用NIF是相当方便的。正如本文开头提到的那样，由于NIF的脆弱性（记住NIF可能导致整个Erlang虚拟机崩溃）和速度要求，因此要谨慎使用NIF，而且它并不总是正确的工具。</p>
<p>感谢您的阅读！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/" target="_blank" rel="external">http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang支持一种方式，就是用C来实现函数，并在Erlang中透明地使用它们。这些函数被叫做NIFs（原生实现的函数）。在两种场景下，NIF被证明是完美的解决方案：当你需要原始的计算速度时；当你需要从Erlang调用已有的C接口时。在本文中，我们一起来看看这两种场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/categories/Elixir/NIF/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/tags/NIF/"/>
    
      <category term="C" scheme="http://szpzs.oschina.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用“with”宏更好地控制执行流程</title>
    <link href="http://szpzs.oschina.io/2018/04/02/better-control-flow-using-the-with-macro/"/>
    <id>http://szpzs.oschina.io/2018/04/02/better-control-flow-using-the-with-macro/</id>
    <published>2018-04-02T05:46:11.000Z</published>
    <updated>2018-04-02T05:59:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>从Elixir1.2开始就可以用with宏来写出更有表现力的流程控制语句。与需要深度嵌套的 case 和 if/else 语句不同，你可以只使用一个 with 语句来表达一样的逻辑，而且方式上更加优雅可读性也更好。下面我将探索如何利用它们来改进你的代码。</p>
<h1 id="with-的基础"><a href="#with-的基础" class="headerlink" title="with 的基础"></a>with 的基础</h1><p>with 后跟一个句子列表，这些句子将按顺序执行。如果所有句子的结果都是正常，那么 do 后面的语句将被执行。当其中一个句子的结果有问题，则 do 后面的句子就不执行，而且相关错误值将返回给调用者。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"10"</span>) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">100</span></div><div class="line"></div><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"foo"</span>) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="symbol">:error</span></div><div class="line"></div><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>你也可以在那些句子中使用when子句。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; <span class="keyword">when</span> int != <span class="number">0</span> &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;   <span class="number">99</span> / int</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">11.0</span></div></pre></td></tr></table></figure>
<p>另外，你可以使用else来捕获相关可能的异常。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="symbol">:error</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_an_int</span>&#125; <span class="comment"># error for bad parsing</span></div><div class="line">...&gt;   <span class="keyword">false</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:not_even</span>&#125; <span class="comment"># error for odd number</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:not_even</span>&#125;</div></pre></td></tr></table></figure>
<p>或者，你可以忽略所有错误值，只返回一个统一的错误。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      <span class="keyword">true</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   <span class="number">10</span> * int</div><div class="line">...&gt; else</div><div class="line">...&gt;   <span class="number">_</span> -&gt; &#123;<span class="symbol">:error</span>, <span class="symbol">:invalid_value</span>&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">&#123;<span class="symbol">:error</span>, <span class="symbol">:invalid_value</span>&#125;</div></pre></td></tr></table></figure>
<p>你甚至可以在这些句子中赋值。不过要小心，如果你进行了错误的赋值，可能会得到 MatchError 错误。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iex&gt; with &#123;int, <span class="number">_</span>&#125; &lt;- Integer.parse(<span class="string">"9"</span>),</div><div class="line">...&gt;      squared = int * int,</div><div class="line">...&gt;      <span class="keyword">false</span> &lt;- Integer.is_even(int) <span class="keyword">do</span></div><div class="line">...&gt;   squared + <span class="number">1</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="number">82</span></div><div class="line"></div><div class="line">iex&gt; with <span class="number">1</span> = <span class="string">"1"</span>, <span class="symbol">do:</span> <span class="symbol">:ok</span></div><div class="line">** (MatchError) no match of right hand side <span class="symbol">value:</span> <span class="string">"1"</span></div></pre></td></tr></table></figure>
<p>with的语法请看官方的<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">详细文档</a>。</p>
<h1 id="一个实际的例子"><a href="#一个实际的例子" class="headerlink" title="一个实际的例子"></a>一个实际的例子</h1><p>让我们来看看一个的例子。你可能遇到这样的情况，你需要在一个控制器里修改一个已经存在的记录并且发送一些通知消息出去。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> Documents.get(params[<span class="string">"id"</span>]) <span class="keyword">do</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, document&#125; -&gt;</div><div class="line">      <span class="keyword">case</span> Documents.update(document, params) <span class="keyword">do</span></div><div class="line">        &#123;<span class="symbol">:ok</span>, document&#125; -&gt;</div><div class="line">          Notifications.push_document_updated(document)</div><div class="line">          json(conn, document)</div><div class="line"></div><div class="line">        &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">          render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们很明显地看到我们用嵌套case语句来获得我们需要的执行路径。我们用 with 来重写的话，将会使代码简洁明了得多。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  with &#123;<span class="symbol">:ok</span>, document&#125; &lt;- Documents.get(params[<span class="string">"id"</span>]),</div><div class="line">       &#123;<span class="symbol">:ok</span>, updated_document&#125; &lt;- Documents.update(document, params) <span class="keyword">do</span></div><div class="line">    Notifications.push_document_updated(updated_document)</div><div class="line">    json(conn, document)</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>通过用 with 来重写代码，我们可以很清晰地看到我们期望的执行路径以及捕获的具体错误是什么。</p>
<h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>通常，你会发现自己需要在具有相似错误值的数据中进行匹配，这样会使得处理错误情况更加复杂。我喜欢用的一个小技巧是，使用像 {:my_atom, “expected_value”} 这样的有唯一标识的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(conn, params \\ %&#123;&#125;) <span class="keyword">do</span></div><div class="line">  user = conn.assigns.user</div><div class="line">  with &#123;<span class="symbol">:ok</span>, document&#125; &lt;- Document.get(params[<span class="string">"id"</span>]),</div><div class="line">       &#123;<span class="symbol">:can_view?</span>, <span class="keyword">true</span>&#125; &lt;- &#123;<span class="symbol">:can_view?</span>, Authorizer.can_view?(document, user)&#125;,</div><div class="line">       &#123;<span class="symbol">:can_edit?</span>, <span class="keyword">true</span>&#125; &lt;- &#123;<span class="symbol">:can_edit?</span>, Authorizer.can_edit?(document, user)&#125;</div><div class="line">       &#123;<span class="symbol">:ok</span>, updated_document&#125; &lt;- Documents.update(document, params) <span class="keyword">do</span></div><div class="line">    Notifications.push_document_updated(updated_document)</div><div class="line">    json(conn, document)</div><div class="line">  else</div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:not_found</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:can_view?</span>, <span class="keyword">false</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"404"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:can_edit?</span>, <span class="keyword">false</span>&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"403"</span></span>)</div><div class="line"></div><div class="line">    &#123;<span class="symbol">:error</span>, %Ecto.Changeset&#123;&#125; = changeset&#125; -&gt;</div><div class="line">      render(conn, ErrorView, <span class="symbol">:<span class="string">"400"</span></span>, changeset)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>增加一个唯一原子使得更易于标识特定的错误然后返回适当的结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>with 帮助我们在不牺牲错误处理功能和可读性上写出更加整洁，更富表达性的代码。任何时候，当你需要处理复杂的逻辑流程的时候，都记得使用这个宏的优点。最后别忘了仔细阅读<a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="external">官方关于 with 的文档</a>。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://dockyard.com/blog/2018/03/30/better-control-flow-using-the-with-macro" target="_blank" rel="external">https://dockyard.com/blog/2018/03/30/better-control-flow-using-the-with-macro</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从Elixir1.2开始就可以用with宏来写出更有表现力的流程控制语句。与需要深度嵌套的 case 和 if/else 语句不同，你可以只使用一个 with 语句来表达一样的逻辑，而且方式上更加优雅可读性也更好。下面我将探索如何利用它们来改进你的代码。&lt;/p&gt;
&lt;h1 id=&quot;with-的基础&quot;&gt;&lt;a href=&quot;#with-的基础&quot; class=&quot;headerlink&quot; title=&quot;with 的基础&quot;&gt;&lt;/a&gt;with 的基础&lt;/h1&gt;&lt;p&gt;with 后跟一个句子列表，这些句子将按顺序执行。如果所有句子的结果都是正常，那么 do 后面的语句将被执行。当其中一个句子的结果有问题，则 do 后面的句子就不执行，而且相关错误值将返回给调用者。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; with &amp;#123;int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;&amp;#125; &amp;lt;- Integer.parse(&lt;span class=&quot;string&quot;&gt;&quot;10&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; with &amp;#123;int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;&amp;#125; &amp;lt;- Integer.parse(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;:error&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iex&amp;gt; with &amp;#123;int, &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;&amp;#125; &amp;lt;- Integer.parse(&lt;span class=&quot;string&quot;&gt;&quot;9&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;      &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; &amp;lt;- Integer.is_even(int) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt;   &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&amp;gt; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/categories/Elixir/macro/"/>
    
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="with" scheme="http://szpzs.oschina.io/tags/with/"/>
    
      <category term="macro" scheme="http://szpzs.oschina.io/tags/macro/"/>
    
  </entry>
  
</feed>
