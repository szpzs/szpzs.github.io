<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2016-12-10T16:53:48.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang调度器的细节以及它为何重要</title>
    <link href="http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/"/>
    <id>http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/</id>
    <published>2016-12-10T16:50:08.000Z</published>
    <updated>2016-12-10T16:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">Erlang垃圾回收细节以及它为何重要</a>》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。</p>
<a id="more"></a>
<h1 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度"></a>什么是调度</h1><p>通常来说，调度就是一种分派工作给工作者的机制。所谓的工作可能是一个算数运算、字符串处理或者数据抽取，而工作者是一些资源，比如像<a href="https://en.wikipedia.org/wiki/Green_threads" target="_blank" rel="external">Green Thread</a>这样虚拟的资源或者像<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Native Thread</a>这样的物理资源。调度器以一种方式执行调度活度，最大限度地提高吞吐量和公平性，最大限度地降低响应时间和延时。调度是像操作系统和虚拟机这样的多任务系统的重要组成部分，它被分为两种类型：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29" target="_blank" rel="external">抢占式</a>：一个抢占式调度器在执行的任务间进行上下文切换，它有权力抢占（中断）任务并且在不需要被抢占任务的配合下的稍后恢复执行它们。实现这样的功能是基于如下几个因素，比如：任务的优先级，时间切片或者规约数。</li>
<li><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="external">协作式</a>：一个协作式调度器需要任务协作来进行上下文切换。在这种方式下，调度器简单地让任务周期性地或者空闲地时候自愿地释放控制权，然后启动一个新的任务并且再一次等待它自愿地归还控制权。</li>
</ul>
<p>现在的问题是，哪一种调度机制适合软实时系统，也就是这个系统必须在指定的时间内响应。协作式调度系统不能满足软实时系统的要求，因为其运行的任务可能永远也不会返还控制权或者在规定时限后返还控制权。所以软实时系统通常采用抢占式调度。</p>
<h1 id="Erlang的调度"><a href="#Erlang的调度" class="headerlink" title="Erlang的调度"></a>Erlang的调度</h1><p>Erlang作为一个多任务软实时平台采用的就是抢占式调度。Erlang调度器的职责就是选择一个进程并执行它的代码。它也处理垃圾回收和内存管理。如何选择一个进程来执行是基于每个进程可配置的优先级，并且同一优先级的进程是轮询地被调度的。另外，执行中的进程被抢占的因素是基于自上次该进程被选中执行后一定数量的<strong>规约数</strong>而不管它的优先级如何。规约数是每个进程的一个计数器，一般每调用一次函数，它就加一。当一个进程的计数器达到最大规约数时，就会抢占进程和进行上下文切换。例如，在Erlang/OTP R12B 计数器的最大值是2000规约数。</p>
<p>Erlang的任务调度有很长的发展历史。它随着时间而改变。这些改变受Erlang的SMP（对称多处理器）特性的改变而被影响。</p>
<h2 id="R11B之前的调度"><a href="#R11B之前的调度" class="headerlink" title="R11B之前的调度"></a>R11B之前的调度</h2><p>在R11B之前，Eralng还不支持SMP，因此它只有一个调度器运行在操作系统主进程的线程里，并且相应的只有一个<strong>运行队列</strong>。调度器从运行队列选择可运行的Erlang进程和IO任务来执行。</p>
<p><img src="/images/scheduling-before-r11b.png" style="border:0;"></p>
<p>这种方式不需要锁数据结构，但是这么写的应用无法利用并行的好处。</p>
<h2 id="R11B和R12B的调度"><a href="#R11B和R12B的调度" class="headerlink" title="R11B和R12B的调度"></a>R11B和R12B的调度</h2><p>SMP支持被加入Erlang虚拟机里，所以它可以有1到1024个运行在操作系统进程的线程里的调度器。然而，这个版本的调度器只能从一个共用运行队列里选取可执行任务。</p>
<p><img src="/images/scheduling-in-r11b-and-r12b.png" style="border:0;"></p>
<p>由于这种方式造成并行，使得所有共享数据结构都要用锁保护起来。例如运行队列本身就是一个必须被保护起来的共享数据结构。虽热锁会造成一些性能损失，但是新的调度器在多核处理器上带来的性能提升还是很可观的。</p>
<p>在这个版本里的一些瓶颈如下：</p>
<ul>
<li>当调度器增加后，共用运行队列成为瓶颈。</li>
<li>增加ETS表相关的锁，同时也影响到Mnesia。</li>
<li>当许多进程同时给一个进程发送消息的时候增加锁的冲突。</li>
<li>一个进程等待获取一个锁的时候会阻塞它的调度器。</li>
</ul>
<p>然而，每一个调度器分配一个运行队列的方案在下一个版本被选择来解决这些瓶颈。</p>
<h2 id="R13B后的调度"><a href="#R13B后的调度" class="headerlink" title="R13B后的调度"></a>R13B后的调度</h2><p>在这个版本，每个调度器有它自己的运行队列。在多核多调度器的系统里，这将减少锁冲突数量并且提升系统整体性能。</p>
<p><img src="/images/scheduling-after-r13b.png" style="border:0;"></p>
<p>这种方式在访问运行队列时锁冲突解决了，不过却引入了一些新问题：</p>
<ul>
<li>如何在运行队列中分配任务做到公平？</li>
<li>如果一个调度器被分配了过多的任务而另外的调度器却很清闲，这个问题如何解决？</li>
<li>基于什么样的命令一个调度器可以从一个过载的调度器偷任务？</li>
<li>要是我们启动了很多调度器，但是却很少任务，如何处理？</li>
</ul>
<p>这些问题使得Erlang开发团队引入一个概念使得调度公平和高效，这个概念就是<strong>迁移逻辑</strong>。它尝试在基于从系统收集来的统计数据上控制和平衡运行队列。</p>
<p>然而我们不应该让我们的调度一直维持现状，因为它很可能在将来的版本变得更好。</p>
<h1 id="控制和监督API"><a href="#控制和监督API" class="headerlink" title="控制和监督API"></a>控制和监督API</h1><p>有一些Erlang模拟器启动标志和一些内部控制和监督函数与调度器行为有关。</p>
<h2 id="调度线程"><a href="#调度线程" class="headerlink" title="调度线程"></a>调度线程</h2><p>当用erl启动脚本启动Erlang模拟器的时候，可以通过给+S标志传递两个用冒号分割的数字来指定最大可用调度线程数和在线调度线程数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S MaxAvailableSchedulers:OnlineSchedulers</div></pre></td></tr></table></figure>
<p>最大可用调度线程数只能在启动的时候指定而且在运行时是固定不变的，但是在线调度线程数可以在启动和运行时被指定和修改。例如我们可以在启动一个模拟器的时候指定16个最大调度线程和8个在线调度线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S 16:8</div></pre></td></tr></table></figure>
<p>然后在shell里在线调度线程可以被修改，如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; erlang:system_info(schedulers). <span class="comment">%% =&gt; returns 16</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_flag(schedulers_online, <span class="number">16</span>). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 16</span></div></pre></td></tr></table></figure>
<p>另外，使用+SP标志可以用百分比的方式设置这两个值。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>如前所述调度器基于进程的优先级来选择它们来执行。优先级可以在进程内通过调用erlang:process_flag/2函数来设置。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PID = spawn(<span class="keyword">fun</span>() -&gt;</div><div class="line">   <span class="comment">%% ...</span></div><div class="line">   <span class="keyword">end</span>).</div></pre></td></tr></table></figure>
<p>优先级可以是 low、normal、high、max 这些原子中的任何一个。默认优先级是normal，max优先级是保留给Erlang运行时内部使用不应被一般进程使用。</p>
<h2 id="运行队列统计"><a href="#运行队列统计" class="headerlink" title="运行队列统计"></a>运行队列统计</h2><p>如前所述运行队列持有准备好执行但未被调度器选中执行的进程。可以通过调用erlang:statistics(run_queue)获取在所有可用运行队列已经准备好可运行的进程数。作为一个真实例子，让我启动Erlang模拟器，给它4个在线调度器，并且给它们10个非常消耗CPU的并发进程。这些进程<a href="https://gist.github.com/hamidreza-s/9e3ed289f65759048875" target="_blank" rel="external">计算一个很大数字的素数</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%% 就绪</span></div><div class="line">&gt; erlang:statistics(online_schedulers). <span class="comment">%% =&gt; 4</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div><div class="line"></div><div class="line"><span class="comment">%% 并发创建10个重型进程</span></div><div class="line">&gt; [spawn(<span class="keyword">fun</span>() -&gt; calc:prime_numbers(<span class="number">10000000</span>) <span class="keyword">end</span>) || _ &lt;- lists:seq(<span class="number">1</span>, <span class="number">10</span>)].</div><div class="line"></div><div class="line"><span class="comment">%% 运行队列中还有任务要做</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 8</span></div><div class="line"></div><div class="line"><span class="comment">%% Erlang shell依然可以响应，非常棒！</span></div><div class="line">&gt; calc:prime_numbers(<span class="number">10</span>). <span class="comment">%% =&gt; [2, 3, 5, 7]</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 4</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div></pre></td></tr></table></figure>
<p>因为并发进程数大于在线调度器，这将花些时间让调度器执行运行队列里的进程并最终清空运行队列。有趣的是，创建了这些重型进程后，Erlang模拟器任然因为它的抢占式调度可以响应其他请求。Erlang的抢占式调度不会让这些重型进程消耗掉所有运行时，其他轻量并且重要的进程也可以被执行，这个特性在实现一个软实时系统的时候是非常棒的。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>虽然实现一个抢占式调度系统可能很复杂，但是在Erlang里这些不是开发者的责任，因为抢占式调度特性已经在Erlang虚拟机里。另一方面，当在一个软实时系统里系统以高水平的公平性和即时的响应需要扩展到所有处理资源的时候，跟踪、平衡、执行、迁移和抢占进程这些额外的处理成本是完全可负担的。顺便值得一提的是，完全抢占式调度是几乎所有操作系统都支持的特性，但在高层次的平台，语言或库里，Erlang虚拟机几乎是唯一完全抢占式调度的，因为JVM依赖于操作系统的调度器，CAF这个C++ actor库用协作式调度，Go也不是完全抢占式调度，还有诸如Python的Twisted，Ruby的Event Machine和Nodejs也不是完全抢占式调度的。这并不意味着对于所有的挑战这都是最好的选择，而是说我们如果要实现一个低延时的软实时系统，Erlang是一个好的选择。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/doc/man/erl.html" target="_blank" rel="external">erl脚本官方文档</a></li>
<li><a href="http://erlang.org/doc/man/erlang.html" target="_blank" rel="external">erlang模块官方文档</a></li>
<li><a href="http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html" target="_blank" rel="external">Erlang如何调度</a></li>
<li><a href="http://www.erlang.org/euc/08/euc_smp.pdf" target="_blank" rel="external">深入Erlang虚拟机</a></li>
<li><a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html" target="_blank" rel="external">Erlang调度器：它是如何工作的</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《&lt;a href=&quot;https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html&quot;&gt;Erlang垃圾回收细节以及它为何重要&lt;/a&gt;》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Scheduler" scheme="http://szpzs.oschina.io/categories/Erlang/Scheduler/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Scheduler" scheme="http://szpzs.oschina.io/tags/Scheduler/"/>
    
  </entry>
  
  <entry>
    <title>用Rebar3热更新Erlang代码</title>
    <link href="http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/"/>
    <id>http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/</id>
    <published>2016-12-09T13:16:16.000Z</published>
    <updated>2016-12-09T13:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：</p>
<blockquote>
<p>代码热更新就是一门给正在飞奔的汽车换引擎的艺术。</p>
</blockquote>
<p>简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。</p>
<a id="more"></a>
<p>我们将创建一个样例项目，然后学习如何来做代码热更新。这个项目的代码我已经放在<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">这里</a>。让我们用rebar3来创建一个模版项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new release nine9s</div></pre></td></tr></table></figure>
<p>现在我们在我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config" target="_blank" rel="external">rebar.config</a>文件里增加cowboy和lager为依赖。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [</div><div class="line">	&#123;lager, &#123;git, <span class="string">"git://github.com/basho/lager.git"</span>, &#123;tag, <span class="string">"2.1.1"</span>&#125;&#125;&#125;,</div><div class="line">	&#123;cowboy, &#123;git, <span class="string">"https://github.com/ninenines/cowboy.git"</span>, &#123;tag, <span class="string">"2.0.0-pre.1"</span>&#125;&#125;&#125;</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>为了更加真实的体验，请按如下修改我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config#L14-L15" target="_blank" rel="external">rebar.config</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;relx, [</div><div class="line">		&#123;release, &#123;'nine9s', <span class="string">"0.1.0"</span>&#125;, ['nine9s', sasl]&#125;,</div><div class="line">		&#123;sys_config, <span class="string">"./config/sys.config"</span>&#125;,</div><div class="line">		&#123;vm_args, <span class="string">"./config/vm.args"</span>&#125;,</div><div class="line">		&#123;dev_mode, false&#125;,</div><div class="line">		&#123;include_erts, true&#125;,</div><div class="line">		&#123;extended_start_script, true&#125;</div><div class="line">	]</div><div class="line">&#125;.</div></pre></td></tr></table></figure>
<p>你可能想知道这个“nine9s”应用将会做些什么？我的想法是先让这个应用做成一个hello world的web服务，然后再热更新它的代码。修改你的nine9s_app.erl文件以便让start/2看起来像下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line"> Dispatch = cowboy_router:compile(</div><div class="line">                                  [&#123;‘_’, [</div><div class="line">                                          &#123;“/”, default_handler, []&#125;</div><div class="line">                                         ]&#125;</div><div class="line">                                  ]),</div><div class="line"> &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line"> [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line"> ‘nine9s_sup’:start_link().</div></pre></td></tr></table></figure>
<p>现在我们创建一个模块，它叫做default_handler.erl。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-module(default_handler).</div><div class="line">-export([init/2]).</div><div class="line">init(Req, Opts) -&gt;</div><div class="line">    Req2 = cowboy_req:reply(200, [ &#123;&lt;&lt;”content-type"&gt;&gt;,</div><div class="line">                                    &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                            &lt;&lt;”Hello world!”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>接下来，我们编译并运行这个应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile &amp;&amp; rebar3 release</div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 console</div></pre></td></tr></table></figure>
<p>现在你已经运行了你的应用，你可以浏览<a href="http://localhost:9090" target="_blank" rel="external">http://localhost:9090</a>来验证一下。请保持这个应用一直运行，因为我们将创建这个应用的一个新版本并且尝试在线进行代码热更新。</p>
<p>上述代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0分支</a>里。</p>
<p>我们开始添加一些新的特性到我们的项目里，这样将形成我们项目的0.2.0版本，然后我们将尝试在运行着的0.1.0版本上在线进行代码热更新。版本0.2.0的代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0分支</a>。</p>
<p>我们想统计我们的default_handler已经响应的请求数。这个很好解决，我们创建一个模块<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/state_handler.erl" target="_blank" rel="external">state_handler.erl</a>，它是一个gen_server，它将存储default_handler.erl被调用的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(state_handler)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"><span class="comment">%% API functions</span></div><div class="line"><span class="keyword">-export</span><span class="params">([hello_world/<span class="number">0</span>,</span></div><div class="line">         get_hello_world_count/<span class="number">0</span>,</div><div class="line">         start_link/<span class="number">0</span>]).</div><div class="line"><span class="comment">%% gen_server callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>,</span></div><div class="line">         handle_call/<span class="number">3</span>,</div><div class="line">         handle_cast/<span class="number">2</span>,</div><div class="line">         handle_info/<span class="number">2</span>,</div><div class="line">         terminate/<span class="number">2</span>,</div><div class="line">         code_change/<span class="number">3</span>]).</div><div class="line"><span class="keyword">-record</span><span class="params">(state, &#123;count = <span class="number">0</span>&#125;)</span>.</div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="comment">%%% API functions</span></div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="function"><span class="title">hello_world</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:cast(?MODULE, hello_world).</div><div class="line"><span class="function"><span class="title">get_hello_world_count</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:call(?MODULE, hello_world_count).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:start_link(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="comment">%%% callback functions</span></div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    &#123;ok, #state&#123;&#125;&#125;.</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(hello_world_count, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, State#state.count, State&#125;;</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    Reply = ok,</div><div class="line">    &#123;reply, Reply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(hello_world, State)</span> -&gt;</span></div><div class="line">    Count = State#state.count,</div><div class="line">    &#123;noreply, State#state&#123;count = Count + <span class="number">1</span>&#125;&#125;;</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>我们修改我们的<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/default_handler.erl" target="_blank" rel="external">default_handler.erl</a>，以便每次它接收到请求的时候就通知state_handler。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(default_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    state_handler:hello_world(),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         &lt;&lt;”Hello world <span class="number">2</span> !”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>我们的state_handler将是<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_sup.erl" target="_blank" rel="external">nine9s_sup</a>监督者下的一个工作进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_sup’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(CHILD(Id, Mod, Args, Restart, Type)</span>, &#123;Id, &#123;Mod, start_link, Args&#125;, Restart, 60000, Type, [Mod]&#125;).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?SERVER&#125;, ?MODULE, []).</div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    State_Handler = ?CHILD(state_handler, state_handler, [], transient, worker),</div><div class="line">    &#123;ok, &#123; &#123;one_for_all, <span class="number">0</span>, <span class="number">1</span>&#125;, [State_Handler]&#125; &#125;.</div></pre></td></tr></table></figure>
<p>既然我们已经记录了default_handler的访问次数，我们就想有一个cowboy的路由来给出当前的访问次数，所以我们修改<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_app.erl" target="_blank" rel="external">nine9s_sup.erl</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_app’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(application)</span>.</div><div class="line"><span class="comment">%% Application callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">2</span></span></div><div class="line">         ,stop/<span class="number">1</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([set_routes_new/<span class="number">0</span></span></div><div class="line">        ,set_routes_old/<span class="number">0</span> ]).</div><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line">    Dispatch = cowboy_router:compile([&#123;‘_’, get_new_routes()&#125;]),</div><div class="line">    &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line">    [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line">    ‘nine9s_sup’:start_link().</div><div class="line"><span class="function"><span class="title">stop</span><span class="params">(_State)</span> -&gt;</span> ok.</div><div class="line"><span class="function"><span class="title">get_new_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/count”, count_handler, []&#125;] ++ get_old_routes().</div><div class="line"><span class="function"><span class="title">get_old_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/”, default_handler, []&#125;].</div><div class="line"><span class="function"><span class="title">set_routes_new</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_new_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div><div class="line"><span class="function"><span class="title">set_routes_old</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_old_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div></pre></td></tr></table></figure>
<p>请注意，我们把路由分成两部分，一部分是版本0.1.0里就有的，也就是老路由，还有一部分就是新路由。函数set_routes_new/0和set_routes_old/0我们将在后面解释。</p>
<p>下述代码是count_handler模块，就是处理路由 “/count”的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(count_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    Count = state_handler:get_hello_world_count(),</div><div class="line">    BCount = integer_to_binary(Count),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         BCount, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>最后，我们将修改在<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s.app.src#L3" target="_blank" rel="external">nine9s.app.src</a>和<a href="https://github.com/kansi/nine9s/blob/0.2.0/rebar.config#L7" target="_blank" rel="external">rebar.config</a>里的版本数字。版本0.2.0的特性就完成了。现在我们将尝试将正在运行的0.1.0版本升级到版本0.2.0。</p>
<p>为了升级到新的版本，我们需要创建一个appup文件，也就是nine9s.app.src文件，它描述了如何从版本0.1.0升级到0.2.0。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"vsn in app.src"</span>,</div><div class="line">    [ &#123;<span class="string">"upgrade from vsn"</span>, Instructions1&#125;],</div><div class="line">    [ &#123;<span class="string">"downgrade to vsn"</span>, Instructions2&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>appup文件是一个三元素组成的元组文件。第一个元素是和.app.src文件里一样的版本号（也就是当前版本）。第二个元素是一个元组列表，它的第一个元素是将要被升级的版本号，它的第二个元素是一些指令组成的列表，这些指令指示该如何从这个版本升级到新的版本。第三个元素也是一个元组列表，它的第一个元素是将要降级到的版本号，它的第二个元素是也是一些指令组成的列表，这些指令指示该如何降级到这个版本。</p>
<p>下面是应用nine9s的appup文件内容：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;“<span class="number">0.2</span>.<span class="number">0</span>”,</div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;add_module, state_handler&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, restart_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;add_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_new, [] &#125;&#125; ] &#125;],</div><div class="line"></div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, terminate_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, delete_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;delete_module, state_handler&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_old, [] &#125;&#125;</div><div class="line">             ,&#123;delete_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ]</div><div class="line">&#125;]&#125;.</div></pre></td></tr></table></figure></p>
<p>现在我们先来解释一下升级指令。注意：这些指令是按它们在文件中的先后顺序来执行的。</p>
<ul>
<li>{add_module, state_handler} : 指示增加state_handler模块到运行环境里。</li>
<li>{update, nine9s, supervisor} : 这条指令将修改监督者的内部状态，也就是改变重启策略和最大重启频率，同时也改变子进程规格说明。最终将增加state_handler这个模块到监督者的子进程规格说明里。</li>
<li>{apply, {supervisor, restart_child, [nine9s, state_handler]}} : “apply”指令接收{M,F,A}做为参数，然后执行 M:F(A1, … An)。所以我们实际上是执行supervisor:restart_child(nine9s, state_handler)，这将在nine9s_sup监督者下启动state_handler做为工作进程。请注意：上述三条指令的顺序。首先我们增加state_handler模块，然后改变监督者的状态，最后创建state_handler进程。</li>
<li>{load_module, default_handler} : 这条指令将重新装载default_handler模块，替换它的老版本代码。</li>
<li>{add_module, count_handler} : 增加count_handler模块。</li>
<li>{load_module, nine9s_app} : 我们重新装载nine9s_app，从而我们新增加的函数被装载进虚拟机。</li>
<li>{apply, {nine9s_app, set_routes_new, [ ] }} ] } ] : 既然我们装载了新的函数，我就执行 nine9s_app:set_routes_new() 增加新的路由到我们的服务器。</li>
</ul>
<p>接下来的元素是如何降级的指令，它的工作模式和前一个元素相似，但是是用老模块替换新模块。</p>
<ul>
<li>{load_module, default_handler} : 这个指令将装载老的default_handler模块。</li>
<li>{apply, {supervisor, terminate_child, [nine9s_sup, state_handler]}} : 终止state_handler进程。</li>
<li>{apply, {supervisor, delete_child, [nine9s_sup, state_handler]}} : 从nine9s_sup里删除state_handler这个子进程规格。</li>
<li>{update, nine9s_sup, supervisor} : 修改监督者nine9s_sup的内部状态。</li>
<li>{delete_module, state_handler} : 删除state_handler模块。</li>
<li>{apply, {nine9s_app, set_routes_old, [ ] }} : 设置路由为老版本路由。</li>
<li>{delete_module, count_handler} : 删除count_handler模块。</li>
<li>{load_module, nine9s_app} : 装载老的nine9s_app模块。</li>
</ul>
<p>既然我们的appup文件准备好了，我们就开始升级到最新的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先我们拷贝appup文件到lib目录下nine9s/ebin下</span></div><div class="line">$ cp apps/nine9s/src/nine9s.appup.src _build/default/lib/nine9s/ebin/nine9s.appup</div><div class="line"><span class="comment"># 接着我们编译和发布应用</span></div><div class="line">$ rebar3 compile</div><div class="line">$ rebar3 release</div><div class="line"><span class="comment"># 生成relup到前一个版本</span></div><div class="line">$ rebar3 relup -n nine9s -v <span class="string">"0.2.0"</span> -u <span class="string">"0.1.0"</span></div><div class="line"><span class="comment"># 生成新版本的tar文件</span></div><div class="line">$ rebar3 tar -n nine9s -v <span class="string">"0.2.0"</span></div><div class="line">$ mv _build/default/rel/nine9s/nine9s-0.2.0.tar.gz _build/default/rel/nine9s/releases/0.2.0/nine9s.tar.gz</div><div class="line"><span class="comment"># 升级到新的版本</span></div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 upgrade <span class="string">"0.2.0"</span></div></pre></td></tr></table></figure>
<p>搞定！如果所有执行都成功，那么我们就升级到0.2.0版本了。你可以浏览 <a href="http://localhost:9090和http://localhost:9090/count来验证一下。" target="_blank" rel="external">http://localhost:9090和http://localhost:9090/count来验证一下。</a></p>
<p>项目有两个分支<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0</a>和<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0</a>。你可以先编译和运行分支0.1.0，然后切换到0.2.0分支，使用python脚本<a href="https://github.com/kansi/nine9s/blob/0.2.0/upgrade.py" target="_blank" rel="external">upgrade.py</a>来升级到0.2.0版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4" target="_blank" rel="external">https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码热更新就是一门给正在飞奔的汽车换引擎的艺术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/tags/Rebar3/"/>
    
      <category term="热更新" scheme="http://szpzs.oschina.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>rebar3 shell</title>
    <link href="http://szpzs.oschina.io/2016/12/07/rebar3-shell/"/>
    <id>http://szpzs.oschina.io/2016/12/07/rebar3-shell/</id>
    <published>2016-12-07T13:39:29.000Z</published>
    <updated>2016-12-08T01:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。</p>
<a id="more"></a>
<p>它有很多好的特性，不过在我的观点来看，这些是一个Erlang shell工具最少要支持的。因此，尝试展示这些特性听起来好像是吹嘘你该做的本分事情一样；多说无益，下面就进入正题。</p>
<p>不过，一些Erlang的东西的可用性一直很糟糕，我们（贡献者）已经在rebar3上做了很多工作来尝试解决这些糟糕的体验。我不得不说，很多社区已经有大量的非常好的工具，但是它们都是独立的，如何用好它们必须要读者自己去逐个尝试。这个时候，rebar3横空出世了。</p>
<p>当使用rebar3 shell命令的时候首先吸引人的是，它会自动编译项目（如果项目还没有被编译）并且将编译后的项目加入你的代码搜索路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; vegur:module_info().</div><div class="line">[&#123;module,vegur&#125;,</div><div class="line">&#123;exports,[&#123;start_http,3&#125;,</div><div class="line">&#123;start_proxy,3&#125;,</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个功能作用于所有项目。这至少摆脱很多需要你自己手写默认设置的许多烦恼。现在这些都由rebar3 shell来做。</p>
<p>对于一个编程语言来说，一个好的shell环境就是关于它的互动性。期望能够快速地重编译代码或者运行测试，并且重新装载代码而不需要任何中断或丢失状态。rebar3 shell有一个代理，隐藏在r3模块背后，它准备着所有需要重新编译代码或者运行任务的状态的管理。所以，例如任何存在的项目，我可以要求重新编译或者任何其他任务运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; r3:do(compile).</div><div class="line">===&gt; This feature is experimental <span class="keyword">and</span> may be modified or removed at any time.</div><div class="line">Verifying dependencies...</div><div class="line">Compiling vegur</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(ct).</div><div class="line">Verifying dependencies...</div><div class="line">Fetching websocket_client (&#123;git,<span class="string">"git@github.com:jeremyong/websocket_client.git"</span>,</div><div class="line">&#123;tag,<span class="string">"v0.7"</span>&#125;&#125;)</div><div class="line">Linking _build/default/lib/cowboyku to _build/test/lib/cowboyku</div><div class="line">Linking _build/default/lib/cowlib to _build/test/lib/cowlib</div><div class="line">Linking _build/default/lib/erequest_id to _build/test/lib/erequest_id</div><div class="line">...</div><div class="line">Running Common Test suites...</div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_callback: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_timeout: OK</span></div><div class="line">...</div><div class="line">All <span class="number">140</span> tests passed.</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(dialyzer).</div><div class="line">Verifying dependencies...</div><div class="line">...</div><div class="line">Analyzing <span class="number">19</span> files with <span class="string">"/home/ferd/code/self/vegur/_build/default/rebar3_18.1.5_plt"</span>...</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>如上述例子等等。所有这些任务都会用你的最新版本的rebar.config文件来运行它的任务和切换路径重装载模块等等。</p>
<p>rebar3的代理还有一个名字使得可以在外部调用它。你可以用一个名字来启动一个shell（rebar3 shell –name my_shell 或 rebar3 shell –sname my_shell）然后远程向它发送消息或者直接RPC调用当作指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --sname=my_shell</div><div class="line">erl -sname remote -eval <span class="string">'rpc:call(my_shell@localhost, r3, do, [ct]), halt(0).'</span> -noshell</div></pre></td></tr></table></figure>
<p>当作人们的工具的目的应该是可以被用来从你的IDE或编辑器里增加钩子到Erlang shell里。</p>
<p>被写出来的和rebar3代理一起工作的插件也是一种选择。例如，通过监控硬盘，<a href="https://www.rebar3.org/docs/using-available-plugins#auto-compile-and-load" target="_blank" rel="external">rebar3_atuo 能够被用来自动重新编译修改过的文件</a>，这样也省了这个的功能要和IDE或编辑器合成的需求。</p>
<p>这提供了一个非常好的改进，例如，在运行调试周期，在测试，代码分析和交互式调试都可以在同一个环境进行。</p>
<p>为了使得开发周期更加与你的项目成长无缝对接，rebar3 shell将在构建工具里自动侦测<a href="https://www.rebar3.org/docs/releases" target="_blank" rel="external">release配置</a>，并且以你的release遵循的的<a href="https://www.rebar3.org/docs/releases#section-application-configuration" target="_blank" rel="external">应用配置</a>【1】启动你的系统。</p>
<p>这意味着只要你的代码库配置成装配为一个可执行版本，你可以在它里面访问shell的代码重装载特性，使用的是同样的工具，而这些工具你可能以别的方式使用。</p>
<p>如果你不使用release呢？应用可以在你的rebar.config文件里被指定为{shell, [{apps, [myapp]}]}  或者在命令行里的参数里指定（–apps app1,app2）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --apps vegur</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">...</div><div class="line">===&gt; Booted midjan</div><div class="line">===&gt; Booted quickrand</div><div class="line">===&gt; Booted uuid</div><div class="line">===&gt; Booted erequest_id</div><div class="line">===&gt; Booted vegur</div></pre></td></tr></table></figure>
<p>万一你的开发环境和生产环境不匹配，任意的代码可以被运行来设置shell并且通过escript来设置它。这些设置指定的动态环境变量或启动外部依赖的模拟模块是特别有用的。为了进一步解释，下面的例子将展示我们如何不让shell启动，除非所有需要设置的环境变量都设置好了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env escript</div><div class="line"></div><div class="line"><span class="function"><span class="title">main</span><span class="params">(_)</span> -&gt;</span></div><div class="line">	OSVars = [<span class="string">"USER"</span>, <span class="string">"PASS"</span>],</div><div class="line">	[check_is_set(Var) || Var &lt;- OSVars].</div><div class="line"></div><div class="line"><span class="function"><span class="title">check_is_set</span><span class="params">(Var)</span> -&gt;</span></div><div class="line">	<span class="keyword">case</span> os:getenv(Var) <span class="keyword">of</span></div><div class="line">		<span class="literal">false</span> -&gt;</div><div class="line">			rebar_api:error(<span class="string">"Missing var ~s"</span>, [Var]),</div><div class="line">			halt(<span class="number">1</span>);</div><div class="line">		_ -&gt;</div><div class="line">			ok</div><div class="line">	<span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个escript文件可以通过增加{shell, [{script_file, “path/to/file”}]}到你的rebar.config文件配置成总是执行，或者通过在命令行被直接调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --script_file <span class="built_in">test</span>/check_env.escript</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; ===&gt; Missing var PASS</div></pre></td></tr></table></figure>
<p>希望这些工具比那些开箱即用的更可以让Erlang开发者的生活轻松些。</p>
<p>【1】这里有些警告：因为rebar3 shell是一个开发工具，诸如Erlang虚拟机配置的选项（例如，调度器的数量）已经在运行时里有了而且不能被修改。它不能复制所有release的配置，因此，你应该在生产环境保持使用release。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">http://ferd.ca/rebar3-shell.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3 Shell" scheme="http://szpzs.oschina.io/tags/Rebar3-Shell/"/>
    
  </entry>
  
  <entry>
    <title>用Rebar3构建你的第一个Erlang应用</title>
    <link href="http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/"/>
    <id>http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/</id>
    <published>2016-12-05T03:17:42.000Z</published>
    <updated>2016-12-05T11:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rebar3是Erlang的构建工具和包管理工具。归功于<a href="http://www.rebar3.org/" target="_blank" rel="external">Rebar3</a>以及它的插件<a href="https://hex.pm/" target="_blank" rel="external">Hex</a>，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。</p>
<a id="more"></a>
<h1 id="下载Rebar3"><a href="#下载Rebar3" class="headerlink" title="下载Rebar3"></a>下载Rebar3</h1><p>从Rebar3官方网站下载最新版本的Rebar3，网址：<a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -O https://s3.amazonaws.com/rebar3/rebar3</div></pre></td></tr></table></figure>
<p>用chmod赋予其可执行权限，并将它加入你的环境变量PATH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x rebar3</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:rebar3所在目录</div></pre></td></tr></table></figure>
<h1 id="你的第一个Erlang应用"><a href="#你的第一个Erlang应用" class="headerlink" title="你的第一个Erlang应用"></a>你的第一个Erlang应用</h1><p>使用rebar3 new命令采用内建模块app可以创建一个新的项目。在本例子里我们创建一个叫做myapp的项目。其他可用内建模版是：release、lib、plugin、escript、cmake。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new app myapp</div><div class="line">===&gt; Writing myapp/src/myapp_app.erl</div><div class="line">===&gt; Writing myapp/src/myapp_sup.erl</div><div class="line">===&gt; Writing myapp/src/myapp.app.src</div><div class="line">===&gt; Writing myapp/rebar.config</div><div class="line">===&gt; Writing myapp/.gitignore</div><div class="line">===&gt; Writing myapp/LICENSE</div><div class="line">===&gt; Writing myapp/README.md</div></pre></td></tr></table></figure>
<p>代码在src目录里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> myapp</div><div class="line">$ tree</div><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── rebar.config</div><div class="line">└── src</div><div class="line">    ├── myapp.app.src</div><div class="line">    ├── myapp_app.erl</div><div class="line">    └── myapp_sup.erl</div></pre></td></tr></table></figure>
<p>因为Rebar3只处理 <a href="http://www.erlang.org/doc/design_principles/applications.html" target="_blank" rel="external">OTP结构的项目</a> ，所以约定成俗用一个 .app.src 文件定义你的应用是一个OTP应用。看起来是不是很熟悉？这个文件也是Erlang文件。你可以阅读 <a href="http://www.erlang.org/doc/design_principles/applications.html#id73836" target="_blank" rel="external">详细的指引</a> 来看看它都能包括些什么元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp.app.src</div><div class="line">&#123;application, <span class="string">'myapp'</span>,</div><div class="line"> [&#123;description, <span class="string">"An OTP application"</span>&#125;,</div><div class="line">  &#123;vsn, <span class="string">"0.1.0"</span>&#125;,</div><div class="line">  &#123;registered, []&#125;,</div><div class="line">  &#123;mod, &#123;<span class="string">'myapp_app'</span>, []&#125;&#125;,</div><div class="line">  &#123;applications,</div><div class="line">   [kernel,</div><div class="line">    stdlib</div><div class="line">   ]&#125;,</div><div class="line">  &#123;env,[]&#125;,</div><div class="line">  &#123;modules, []&#125;</div><div class="line"> ]&#125;.</div></pre></td></tr></table></figure>
<p>src/myapp_app.erl是一个非常简单的代码框架。它只是让你可以启动和停止你的Erlang应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp_app.erl</div><div class="line">-module(<span class="string">'myapp_app'</span>).</div><div class="line">-behaviour(application).</div><div class="line">-export([start/2, stop/1]).</div><div class="line">start(_StartType, _StartArgs) -&gt;</div><div class="line">    <span class="string">'myapp_sup'</span>:start_link().</div><div class="line">stop(_State) -&gt;</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>Rebar3用rebar.config来指定一些额外的元数据，比如<a href="https://github.com/rebar/rebar/wiki/Dependency-management" target="_blank" rel="external">依赖</a>。rebar.config还可以包含很多配置项。你可以参考 <a href="https://github.com/rebar/rebar/blob/master/rebar.config.sample" target="_blank" rel="external">详细例子</a> 来学习各种配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat rebar.config</div><div class="line">&#123;erl_opts, [debug_info]&#125;.</div><div class="line">&#123;deps, []&#125;.</div></pre></td></tr></table></figure>
<p>现在我们用Rebar3启动一个Erlang shell，它包含了你的应用及依赖的路径。然后运行 application:start(myapp). 来确认你的应用被正确地装载了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling myapp</div><div class="line">Erlang R16B03-1 (erts-5.10.4) [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line">Eshell V5.10.4  (abort with ^G)</div><div class="line">1&gt; application:start(myapp).</div><div class="line">ok</div><div class="line">2&gt; application:stop(myapp).</div><div class="line">ok</div><div class="line">3&gt;</div><div class="line">=INFO REPORT==== 29-Jun-2015::16:14:10 ===</div><div class="line">    application: myapp</div><div class="line">    exited: stopped</div><div class="line">    <span class="built_in">type</span>: temporary</div></pre></td></tr></table></figure>
<p><a href="https://github.com/ferd" target="_blank" rel="external">Fred Hebert</a> （<a href="http://learnyousomeerlang.com/" target="_blank" rel="external">Learn You Some Erlang</a> 的作者）写了一篇很好的<a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">文章</a>介绍rebar3 shell的命令。</p>
<h1 id="Erlang的包"><a href="#Erlang的包" class="headerlink" title="Erlang的包"></a>Erlang的包</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要安装一个叫做<a href="https://github.com/hexpm/rebar3_hex" target="_blank" rel="external">rebar3_hex</a>的插件来从<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>（Erlang和Elixir的包管理者）获取和安装Erlang包。简单地把如下一行加入到rebar.config文件中（你需要Erlang/OTP17.4或以上版本）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;plugins, [rebar3_hex]&#125;.</div></pre></td></tr></table></figure>
<p>然后运行命令：rebar3 update 来启用这个插件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rebar3 update</div><div class="line">===&gt; Fetching jsx (&#123;pkg,&lt;&lt;<span class="string">"jsx"</span>&gt;&gt;,&lt;&lt;<span class="string">"2.6.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching ssl_verify_hostname (&#123;pkg,&lt;&lt;<span class="string">"ssl_verify_hostname"</span>&gt;&gt;,</div><div class="line">                                           &lt;&lt;<span class="string">"1.0.5"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching rebar3_hex (&#123;pkg,&lt;&lt;<span class="string">"rebar3_hex"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.6.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling ssl_verify_hostname</div><div class="line">===&gt; Compiling jsx</div><div class="line">===&gt; Compiling rebar3_hex</div><div class="line">===&gt; Updating package index…</div></pre></td></tr></table></figure>
<p>如果你想避免每次创建一个新Erlang应用都要做这个步骤，则将上述配置添加到全局的配置文件rebar.config中，并把这个配置文件放置在如下目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.config/rebar3/rebar.config</div></pre></td></tr></table></figure>
<h2 id="查找Erlang包"><a href="#查找Erlang包" class="headerlink" title="查找Erlang包"></a>查找Erlang包</h2><p>搜索命令让你远程查找在<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>上发布的Erlang包。你可以在查询语句里用正则表达式字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 hex search cowboy</div><div class="line">cloudi_service_http_cowboy</div><div class="line">cowboy</div></pre></td></tr></table></figure>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>Rebar3能下载和安装Erlang包以及任何必要的依赖。在你的rebar.config文件里增加应用名字到deps配置项，然后运行命令：rebar3 compile。下面的例子，我们尝试使用两个Erlang包，cowboy和meck。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [cowboy, meck]&#125;.</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Fetching ranch (&#123;pkg,&lt;&lt;<span class="string">"ranch"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching meck (&#123;pkg,&lt;&lt;<span class="string">"meck"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.8.2"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowlib (&#123;pkg,&lt;&lt;<span class="string">"cowlib"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowboy (&#123;pkg,&lt;&lt;<span class="string">"cowboy"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling cowlib</div><div class="line">===&gt; Compiling ranch</div><div class="line">===&gt; Compiling meck</div><div class="line">===&gt; Compiling cowboy</div><div class="line">===&gt; Compiling myapp</div></pre></td></tr></table></figure>
<p>想要安装一个Erlang包的指定版本？在配置中把应用名字和版本写在一个元组中。你可以在<a href="https://hex.pm/" target="_blank" rel="external">Hex主页</a>上查询Erlang包的可用版本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [&#123;cowboy, “<span class="number">1.0</span>.<span class="number">2</span>”&#125;, &#123;meck, <span class="string">"0.8.3"</span>&#125;]&#125;.</div></pre></td></tr></table></figure>
<h2 id="列出已安装的包"><a href="#列出已安装的包" class="headerlink" title="列出已安装的包"></a>列出已安装的包</h2><p>rebar3 deps 命令列出你本地已经安装的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div><div class="line">meck (locked package 0.8.2)</div></pre></td></tr></table></figure>
<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>要卸载一个包，你首先要在rebar.config文件中将它删除，然后使用命令：rebar unlock。现在我们卸载meck包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 unlock</div><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div></pre></td></tr></table></figure>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz" target="_blank" rel="external">https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rebar3是Erlang的构建工具和包管理工具。归功于&lt;a href=&quot;http://www.rebar3.org/&quot;&gt;Rebar3&lt;/a&gt;以及它的插件&lt;a href=&quot;https://hex.pm/&quot;&gt;Hex&lt;/a&gt;，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/tags/Rebar3/"/>
    
  </entry>
  
  <entry>
    <title>红回调和绿回调</title>
    <link href="http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/"/>
    <id>http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/</id>
    <published>2016-12-01T07:11:46.000Z</published>
    <updated>2016-12-01T07:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。</p>
<p>为了解释这个问题，我必须先回过头来讲讲I/O。</p>
<a id="more"></a>
<h1 id="Erlang的并发I-O"><a href="#Erlang的并发I-O" class="headerlink" title="Erlang的并发I/O"></a>Erlang的并发I/O</h1><p>Erlang是如何处理并发I/O的？相当简单！假设我们有三个进程A、B和C，它们在并行执行。我用如下的方式描述这个场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A || B || C</div></pre></td></tr></table></figure>
<p>上述描述假设三个进程A、B、C正在进行I/O操作。</p>
<p>进程A如下所描述做一些事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A: --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>进程B则如下描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B: ---- write --- write --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>C进程也大致如此。虚线表示一些顺序的计算。进程A的Erlang代码框架如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">a</span><span class="params">()</span> -&gt;</span></div><div class="line">    ...</div><div class="line">    X = read(),</div><div class="line">    ...</div><div class="line">    Y = read(),</div><div class="line">    ...</div><div class="line">    write(...),</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>进程B和进程C的代码也和这个差不多。</p>
<p>Erlang里实际上是没有read()这个函数的。Erlang有  <a href="http://www.erlang.org/course/concurrent_programming.html#select" target="_blank" rel="external">select receive</a>  模式来处理消息，所以我们实际上定义的read()函数像如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        Pattern1 -&gt;</div><div class="line">           ...</div><div class="line">        Pattern2 -&gt;</div><div class="line">           ...</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>select receive 模式如何工作的细节不是本次讨论的重点，因此本文我将忽略这些细节。</p>
<p>重点是我在进程A的代码里如下所写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">X = read()</div><div class="line">...</div></pre></td></tr></table></figure>
<p>那么，我们的进程将在read函数处被挂起（或者叫做阻塞）直到read函数执行完毕。因此我们的代码“看起来像”是正在做一个同步阻塞的读动作。</p>
<p>看起来像是用双引号括起来的，因为它不是一个真正的阻塞读，而是一个真正的异步读，这个读操作不阻塞其他任何Erlang进程。</p>
<p>这真是棒极了，因为从一开始，程序就等待读请求完成，然后获得读取到的数据，程序继续运行。</p>
<h1 id="理解并发"><a href="#理解并发" class="headerlink" title="理解并发"></a>理解并发</h1><p>Erlang的I/O非常特别。当我们有两个并行的进程A和B，A进程里的一个读请求将明显地阻塞A进程，但是不会对其他任何并行的进程（这里指B）有影响。</p>
<p>所以A和B可以都同时执行写入操作就好像它们是连续的进程。</p>
<p>现在假设我们没有一个合适的基础并发模型。假设所有我们要做的事情都放入一个单独线程来执行。假设我们做一个读操作（它是阻塞的）而其他事情都在等待。啊！亲！我们的编程模型是更加清晰简单了，但是我们却浪费了CPU的宝贵资源。</p>
<p>现在在一些语言（正是我在研究的Javascript）没有多进程和多线程。不确切地说，它有一个线程，所有的事情都揉进这个线程里。在Javascript里要写与读相关操作的代码，你不得不用红回调，并且发明你自己的并发概念。</p>
<h1 id="红回调"><a href="#红回调" class="headerlink" title="红回调"></a>红回调</h1><p>在Javascript里你肯定不想在主线程里做一个阻塞同步读操作（记住它只有一个线程），那么你必需设置一个回调，当读操作完成的时候触发这个回调。我叫这样的回调为红回调。你写的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; ... do something <span class="keyword">with</span> x ..&#125;;</div><div class="line"><span class="keyword">var</span> error = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; .... x …&#125;</div><div class="line">read(Something, &#123;onSuccess:done, onError:error&#125;);</div><div class="line">... ... more code ...</div></pre></td></tr></table></figure>
<p>这样的代码搞得我脑袋一团浆糊。</p>
<p>当程序正在上述代码 more code 的某个地方执行的时候，读操作完成了，则必需立即回到done这个函数来执行，然后再回到前面 more code 中断的地方。我发现这个方式非常难以理解。</p>
<p>这的确很糟糕，每一个要解决并发问题的Javascript程序员必需要发明他自己的并发模型。问题就在于他们不知道他们正在做的是什么。每次一个Javascript程序员写下一行代码，说是“此处就该这么做”的时候，他实际上是在发明一个新的并发模型，并且在这些代码执行的时候他是没有任何线索知道这些代码是怎样交织在一起的。</p>
<p>（其实我对Javascript又爱又恨，它的大部分我都喜欢，但是就是恨它的并发模型。不过好笑的是，Javascript是没有并发模型的，所以对它也无从可恨了。:-）</p>
<p>更加难以理解的是错误。在共享内存的多线程回调代码里的错误更加是令我极度头痛！</p>
<h1 id="绿回调"><a href="#绿回调" class="headerlink" title="绿回调"></a>绿回调</h1><p>只是为了使得生活更加困惑，在Erlang里我们大量使用了回调。我把这些回调称为“绿回调”。因此回调并不一定是不好的。在Erlang里，我们可以在一个进程的上下文里更清晰地看到回调的执行，所以我们没有如何查看回调执行过程的问题。</p>
<p>如下是Erlang里一个绿回调的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">loop</span><span class="params">(F)</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;new_callback, F1&#125; -&gt;</div><div class="line">            loop(F1);</div><div class="line">        Msg -&gt;</div><div class="line">            F(Msg),</div><div class="line">            loop(F)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>当一个进程运行这段代码的时候收到一个消息Msg，它就执行函数F(Msg)。这里没有任何不确定的，当回调被触发的时候我们确切地知道。在收到消息Msg后，这个回调被立即触发。</p>
<p>这一小段代码却非常漂亮。如果你给进程发送一个消息{new_callbak, F1}，那么它将改变它的行为，在下一次调用的时候，它将执行新的回调。</p>
<p>我不知道你在Javascript里如何写出这样的代码。我写过大量的JQurey代码并且明白如何设置和删除回调。但是在删除一个事件处理并新增一个事件处理这期间里，这个事件被触发了，这会发生什么？我不知道。生命如此短暂如何花的起那么多时间来找这个答案。</p>
<h1 id="Erlang的I-O是如何工作的"><a href="#Erlang的I-O是如何工作的" class="headerlink" title="Erlang的I/O是如何工作的"></a>Erlang的I/O是如何工作的</h1><p>我们实际上并没有给进程发送消息。我们给进程的邮箱发送消息。每一个进程有一个邮箱，当我们给一个进程发送消息，这个消息被放入这个进程的邮箱（如果快递小子能找到这个进程的话）。</p>
<p>想像一下，Erlang的进程是有邮箱的房子。发送消息就好比你把你的消息给快递小子。快递小子的工作就是做两件事：把邮件放入目的邮箱并敲门说：“有新信到了”。</p>
<p>进程可能在忙着也可能在睡觉，就如一个房东一个样，他可能在干这活或者在睡觉。如果他在睡觉，那么当邮递员来了并敲响了房门，房东就会走到邮箱那里检查是否有令人感兴趣的邮件。</p>
<p>如果房东此时把手头的活干完后，正在做其他事情的时候，房东可能会走到邮箱那里检查是否有新的邮件到了，</p>
<p>这就是Erlang的消息工作机制。每一个房子（进程）有它自己的生命周期。邮递员投递邮件，房东根据自己的意愿决定什么时候去检查邮箱。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html" target="_blank" rel="external">http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。&lt;/p&gt;
&lt;p&gt;为了解释这个问题，我必须先回过头来讲讲I/O。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="callback" scheme="http://szpzs.oschina.io/categories/Erlang/callback/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="callback" scheme="http://szpzs.oschina.io/tags/callback/"/>
    
  </entry>
  
  <entry>
    <title>Erlang(和Elixir)无epmd之分布式</title>
    <link href="http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/"/>
    <id>http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/</id>
    <published>2016-11-22T02:50:54.000Z</published>
    <updated>2016-11-22T03:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：</p>
<ul>
<li>epmd（Erlang端口映射守护进程）端口4369，</li>
<li>Erlang节点自己的端口，一个不可预知的大数字端口。</li>
</ul>
<p>这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的<a href="http://erlang.org/doc/man/kernel_app.html" target="_blank" rel="external">kernel文档</a>里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。</p>
<a id="more"></a>
<p>但是如果我们限制了Erlang节点在一个单独的端口，那么我们还真的需要一个端口映射吗？运行epmd有以下几个潜在的缺点：</p>
<ul>
<li>我们可能想要以运行Erlang节点的用户来运行epmd，但是正如我们将见到的，这个很难得到保证。</li>
<li>我们可能想要配置epmd监听一个特定的端口，但是这依赖于在本机上我们如何第一次运行epmd。</li>
<li>任何人无需身份验证可以连接epmd并且可以列出本地的所有Erlang节点。</li>
<li>与epmd的连接都没有加密，即使你按 <a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">Erlang distribution over TLS</a> 这篇文章的方法去做，与epmd的连接也是不受保护的，并且有被中间人攻击的潜在风险。</li>
<li>虽然epmd很稳定，它也有发生崩溃的可能。一旦它崩溃了，任何已经存在的分布式Erlang节点将继续运行，即使epmd恢复了，这些节点也不会重新连接empd。这意味着存在的分布式连接继续工作着，但是与这些节点的新的连接将不起作用。阅读俄文博客 <a href="https://habrahabr.ru/post/49535/" target="_blank" rel="external">Экстренная реанимация epmd</a> 可能可以在不重启epmd的情况下解决这个问题。</li>
</ul>
<p>那么我们来研究一下epmd是如何工作的，然后我们如何做就可以在不用epmd的情况下运行一个Erlang集群。</p>
<h1 id="epmd是如何第一次启动的？"><a href="#epmd是如何第一次启动的？" class="headerlink" title="epmd是如何第一次启动的？"></a>epmd是如何第一次启动的？</h1><p>让我们来读读源码！epmd是在<a href="https://github.com/erlang/otp/blob/OTP-19.1.1/erts/etc/common/erlexec.c#L1234-L1279" target="_blank" rel="external">erlexec.c文件的start_epmd函数</a>里被启动的。实际上，每一次一个Erlang分布式节点启动epmd都无条件地被启动。如果一个epmd实例已经在运行，新的epmd在侦听端口4369的时候将失败，它将因此悄无声息地结束运行。</p>
<p>事实上，这就是即使由另一个用户启动的epmd实例存在系统将发生的事情。任何epmd实例都非常乐意为由任何用户启动的Erlang节点服务，因此这个通常不会引起任何问题。</p>
<h1 id="那么谁可以连接epmd？"><a href="#那么谁可以连接epmd？" class="headerlink" title="那么谁可以连接epmd？"></a>那么谁可以连接epmd？</h1><p>任何人都可以！默认情况下，epmd侦听在所有有效的接口上，并且响应关于当前有哪些节点以及这些节点所侦听的端口的查询。一听到这个场景，系统管理员应该有点紧张。</p>
<p>你可以在epmd启动前通过手工指定 -address 选项或设定ERL_EPMD_ADDRESS 环境变量启动epmd来改变上述情况。这个方法在<a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="external">官方文档</a>里有描述。这个方法需要在你第一次启动epmd的时候来做，否则，已经存在的epmd实例将不受影响地继续运行。</p>
<h1 id="为什么我们需要一个端口映射守护进程？"><a href="#为什么我们需要一个端口映射守护进程？" class="headerlink" title="为什么我们需要一个端口映射守护进程？"></a>为什么我们需要一个端口映射守护进程？</h1><p>很明显，epmd就是一个中间人。我们可以绕过这个中间人吗？</p>
<p>我们可以让每个Erlang节点侦听在一个大家熟知的端口–如果我们打算去除掉epmd的话，我们可以用empd默认保留的端口，4369。但是这就意味着我们只能够在每个主机上运行一个Erlang节点（当然，在某些场景下这就足够了）。</p>
<p>那么让我们指定一些其他端口。前面我们提到变量 inet_dist_listen_min 和 inet_dist_listen_max 。这两个变量定义一个端口范围，不过如果我们设置它们为相同的值，我们就把范围缩小到一个端口：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">erl -sname foo \</div><div class="line">    -kernel inet_dist_listen_min <span class="number">4370</span> \</div><div class="line">            inet_dist_listen_max <span class="number">4370</span></div></pre></td></tr></table></figure>
<p>这个方法不错，不过我们也需要告诉其他节点不要再去询问epmd来获取端口号，而是只用这个端口号来代替。如果我们在同一个主机上有几个节点，我们需要为这些节点配置不同的端口号。</p>
<h1 id="用别的方法"><a href="#用别的方法" class="headerlink" title="用别的方法"></a>用别的方法</h1><p>在Erlang/OTP 19.0里，有两个新的命令行选项：</p>
<ul>
<li>当我们指定 -start_epmd false，Erlang将不会在启动一个分布式节点的时候尝试去启动epmd；</li>
<li>选项 -epmd_module foo 让你指定一个不同的模块替代默认的模块erl_epmd，用来节点名字注册和查询。</li>
</ul>
<p>接下来我们来构建一些代码！</p>
<p>我想用一个无状态的方式来实现这个方法：既然发起连接的节点知道了它要连接的节点的名字，那么我就用这个名字作为资源来得到相应的端口号。我选择4370这个端口作为基准端口，它比epmd的端口大一。接着我从节点名称的“节点”部分抽取出数字，比如节点名称为 myapp3@foo.example.com 抽取的数字是3。最后我把这个数字和基准端口相加。由此得知，节点 myapp3@foo.example.com 侦听在端口4373。如果节点名字最后不是数字，我这种情况将处理为0。这意味着节点 myapp3 和 myotherapp3 不能运行在同一个主机上，但是我准备好了处理对这种场景。（感谢 Luca Favatella 的完美建议）</p>
<p>为此我们来写一个小模块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([dist_port/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% 返回被一个指定节点使用的端口号。</span></div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_atom</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    dist_port(atom_to_list(Name));</div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_list</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 获取基端口号。如果没有在 kernel 的环境变量</span></div><div class="line">    <span class="comment">%% inet_dist_base_port 里指定, 则默认为</span></div><div class="line">    <span class="comment">%% 4370, 比epmd端口大1。</span></div><div class="line">    BasePort = application:get_env(kernel, inet_dist_base_port, <span class="number">4370</span>),</div><div class="line"></div><div class="line">    <span class="comment">%% 现在，算出我们相对于基端口号的偏移值。</span></div><div class="line">    <span class="comment">%% 这个偏移值就是我们节点名的@符号左边的数字。</span></div><div class="line">    <span class="comment">%% 如果这个数字不存在，则偏移量设置为0。</span></div><div class="line">    <span class="comment">%%</span></div><div class="line">    <span class="comment">%% 同时我们也处理主机名没有指定的情况。</span></div><div class="line">    NodeName = re:replace(Name, <span class="string">"@.*$"</span>, <span class="string">""</span>),</div><div class="line">    Offset =</div><div class="line">        <span class="keyword">case</span> re:run(NodeName, <span class="string">"[0-9]+$"</span>, [&#123;capture, first, list&#125;]) <span class="keyword">of</span></div><div class="line">            nomatch -&gt;</div><div class="line">                <span class="number">0</span>;</div><div class="line">            &#123;match, [OffsetAsString]&#125; -&gt;</div><div class="line">                list_to_integer(OffsetAsString)</div><div class="line">        <span class="keyword">end</span>,</div><div class="line"></div><div class="line">    BasePort + Offset.</div></pre></td></tr></table></figure>
<p>同时我们还要写一个模块用作 -epmd_module。有一点小复杂就是因为OTP19.0期望这个模块导出 register_node/2 函数，而从OTP19.1开始则是期望导出 register_node/3 函数。我们把这两个函数都包含进去。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_epmd_client)</span>.</div><div class="line"></div><div class="line"><span class="comment">%% epmd_module 回调函数</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>,</span></div><div class="line">         register_node/<span class="number">2</span>,</div><div class="line">         register_node/<span class="number">3</span>,</div><div class="line">         port_please/<span class="number">2</span>,</div><div class="line">         names/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="comment">%% 监督者模块 erl_distribution 尝试着把我们当做一个被监督的子进程。</span></div><div class="line"><span class="comment">%% 我们不需要子进程，所以返回 ignore 。</span></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    ignore.</div><div class="line"></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(_Name, _Port)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 本函数是我们连接epmd并告诉它我们监听哪个端口，</span></div><div class="line">    <span class="comment">%% 不过因为我们是无epmd的，所以我们不需要做这些。</span></div><div class="line"></div><div class="line">    <span class="comment">%% 需要返回一个1到3的 ”creation” 数字。</span></div><div class="line">    Creation = rand:uniform(<span class="number">3</span>),</div><div class="line">    &#123;ok, Creation&#125;.</div><div class="line"></div><div class="line"><span class="comment">%% 从Erlang/OTP19.1开始，register_node/3函数替代register_node/2函数，</span></div><div class="line"><span class="comment">%% 该函数多了一个地址族的入参，取值为 ‘inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line"><span class="comment">%% 这一点对我们来说没有多大的改动。</span></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(Name, Port, _Family)</span> -&gt;</span></div><div class="line">    register_node(Name, Port).</div><div class="line"></div><div class="line"><span class="function"><span class="title">port_please</span><span class="params">(Name, _IP)</span> -&gt;</span></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line">    <span class="comment">%% 分布式协议版本从Erlang/OTP16开始就是5。</span></div><div class="line">    Version = <span class="number">5</span>,</div><div class="line">    &#123;port, Port, Version&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">names</span><span class="params">(_Hostname)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 因为我们没有epmd，所以我们真的不知道此处是否有其他节点。</span></div><div class="line">    &#123;error, address&#125;.</div></pre></td></tr></table></figure>
<p>正如你所见，大多数事情基本完成了。</p>
<p>当这个模块被加为 erl_distribution 监督者的子进程的时候，start_link/0 将被调用。我们并不需要在这个启动一个进程，因此我们只是返回 ignore。</p>
<p>register_node函数通常会连接epmd并告诉它我们使用哪一个端口。epmd将返回一个“creation”数字。“creation”数字上一个介于1和3的整数。epmd跟踪每一个节点名字的“creation”数字并且当一个确定名字的节点重连的时候增加这个数字。这意味着它可以区分先前某一个节点“存活期间”的进程id。</p>
<p>既然我们没有epmd，那么我们就没有获得它跟踪节点生命周期的好处。在这里我们返回一个随机数，它有三分之二的机会不同于前面的“creation”数字。</p>
<p>port_please/2 获取远程主机的IP地址以便连接它的epmd，但是我们不关心这些；我们用我们自己的算法来算出我们的端口号。</p>
<p>我们也需要返回一个分布式协议版本号。从Erlang/OTP 6开始它就是5（参阅 <a href="http://erlang.org/doc/apps/erts/erl_dist_protocol.html" target="_blank" rel="external">分布式协议官方文档</a> ），就这么简单。</p>
<p>最后，names/1 函数被调用来返回某个主机上的Erlang节点列表。我们没有办法知道这些信息，所以让我们假装我们连接不上这个主机。</p>
<p>目前为止，一起都顺利。但是我们需要一个方法来确认我们正侦听在合适的端口上。我认为最好的方法是写一个新的分布式协议模块，该模块仅是设置端口号而让真正的协议模块做它自己的事情：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_dist)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([listen/<span class="number">1</span>,</span></div><div class="line">         select/<span class="number">1</span>,</div><div class="line">         accept/<span class="number">1</span>,</div><div class="line">         accept_connection/<span class="number">5</span>,</div><div class="line">         setup/<span class="number">5</span>,</div><div class="line">         close/<span class="number">1</span>,</div><div class="line">         childspecs/<span class="number">0</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">listen</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 在此处我们算出我们想要侦听在什么端口。</span></div><div class="line"></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line"></div><div class="line">    <span class="comment">%% 设置 “最小” 和 “最大” 两个变量，强制侦听端口为一个值。</span></div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_min, Port),</div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_max, Port),</div><div class="line"></div><div class="line">    <span class="comment">%% 最后运行真正的函数！</span></div><div class="line">    inet_tcp_dist:listen(Name).</div><div class="line"></div><div class="line"><span class="function"><span class="title">select</span><span class="params">(Node)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:select(Node).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept_connection</span><span class="params">(AcceptPid, Socket, MyNode, Allowed, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">setup</span><span class="params">(Node, Type, MyNode, LongOrShortNames, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:setup(Node, Type, MyNode, LongOrShortNames, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">close</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:close(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">childspecs</span><span class="params">()</span> -&gt;</span></div><div class="line">    inet_tcp_dist:childspecs().</div></pre></td></tr></table></figure>
<p>几乎所有的代码都在这。listen/1函数在将控制权交给真正的处理模块inet_tcp_dist前，根据我们的节点名来设置inet_dist_listen_min和inet_dist_listen_max两个变量。</p>
<p>（请注意：虽然inet_tcp_dist是默认的处理模块，但是它仅提供基于IPv4上的未加密连接。如果你想用IPv6，你应该用inet6_tcp_dist，而如果你想用<a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">基于TLS上的Erlang分布式功能</a>，那就应该选择inet_tsl_dist或inet6_tsl_dist。增加这些弹性的尝试留给读者自己练习。）</p>
<p>我们准备好了！现在我们启动两个节点，foo1和foo2，并且使它们彼此互连：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo1</div><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo2</div></pre></td></tr></table></figure>
<p>系统能正常运行吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(foo2@poki-sona-sin)<span class="number">1</span>&gt; net_adm:ping('foo1@poki-sona-sin').</div><div class="line">pong</div></pre></td></tr></table></figure>
<p>看起来没问题！</p>
<h1 id="接着在Elixir下尝试"><a href="#接着在Elixir下尝试" class="headerlink" title="接着在Elixir下尝试"></a>接着在Elixir下尝试</h1><p>当然，因为Erlang和Elixir都运行在同样的虚拟机上，那么就没有什么可以阻止我们在Elixir里实现上述功能了。</p>
<p>在Elixir里，我们可以将所有代码放在一个单独文件里，编译器会将它编译成我们需要的不同的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个包含根据一个节点名来决定端口号的函数的模块。</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_atom(name) <span class="keyword">do</span></div><div class="line">    dist_port Atom.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_list(name) <span class="keyword">do</span></div><div class="line">    dist_port List.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_binary(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 算出基端口。如果没有指定则用</span></div><div class="line">    <span class="comment"># inet_dist_base_port 这个kernel的环境变量,</span></div><div class="line">    <span class="comment"># 默认值是4370, 比epmd的端口大1。</span></div><div class="line">    base_port = <span class="symbol">:application</span>.get_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_base_port</span>, <span class="number">4370</span></div><div class="line"></div><div class="line">    <span class="comment"># 现在，基于基端口算出我们的“偏移量”。</span></div><div class="line">    <span class="comment"># 偏移量就是一个我们节点名@符号左边的整数。</span></div><div class="line">    <span class="comment"># 如果这个整数不存在，则偏移量是0。</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># 也处理主机名没有指定的情况。</span></div><div class="line">    node_name = Regex.replace ~r/@.*<span class="variable">$/</span>, name, <span class="string">""</span></div><div class="line">    offset =</div><div class="line">      <span class="keyword">case</span> Regex.run ~r/[<span class="number">0</span>-<span class="number">9</span>]+<span class="variable">$/</span>, node_name <span class="keyword">do</span></div><div class="line">    <span class="keyword">nil</span> -&gt;</div><div class="line">      <span class="number">0</span></div><div class="line">    [offset_as_string] -&gt;</div><div class="line">      String.to_integer offset_as_string</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    base_port + offset</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_dist</span></span> <span class="keyword">do</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 此处我们算出我们想要侦听的端口。</span></div><div class="line"></div><div class="line">    port = Epmdless.dist_port name</div><div class="line"></div><div class="line">    <span class="comment"># 设置“min”和“max”变量，强制两个端口为一个值。</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_min</span>, port</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_max</span>, port</div><div class="line"></div><div class="line">    <span class="comment"># 最后运行真正的函数！</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.listen name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(node) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.select node</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept_connection</span></span>(accept_pid, socket, my_node, allowed, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept_connection accept_pid, socket, my_node, allowed, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>(node, type, my_node, long_or_short_names, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.setup node, type, my_node, long_or_short_names, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.close listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">childspecs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.childspecs</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_epmd_client</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># erl_distribution想要我们启动一个工作进程，然而我们并不需要。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ignore</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 因为Erlang/OTP 19.1用register_node/3来替换register_node/2，</span></div><div class="line">  <span class="comment"># 只是多传了一个参数：地址族，’inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line">  <span class="comment"># 这对于我们来说没什么问题。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(name, port, _family) <span class="keyword">do</span></div><div class="line">    register_node(name, port)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(_name, _port) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 在此处我们应该连接epmd并告诉它哪个是我们侦听的端口，</span></div><div class="line">    <span class="comment"># 但是因为我们是无epmd的，所以我们不需要这么做。</span></div><div class="line"></div><div class="line">    <span class="comment"># 需要返回一个介于1和3的"creation”数字。</span></div><div class="line">    creation = <span class="symbol">:rand</span>.uniform <span class="number">3</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, creation&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">port_please</span></span>(name, _ip) <span class="keyword">do</span></div><div class="line">    port = Epmdless.dist_port name</div><div class="line">    <span class="comment"># 分布式协议版本数字从Erlang/OTP R6开始就是5。</span></div><div class="line">    version = <span class="number">5</span></div><div class="line">    &#123;<span class="symbol">:port</span>, port, version&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">names</span></span>(_hostname) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 既然我们没有epmd，那么我们就不真正需要知道其他节点。</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:address</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们启动Elixir，我们需要用 - -erl 来传递一些参数来使得功能启用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --erl <span class="string">"-proto_dist Elixir.Epmdless -start_epmd false -epmd_module Elixir.Epmdless_epmd_client"</span> --sname foo3</div></pre></td></tr></table></figure>
<p>让我们ping我们前面已经启动的两个节点：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">1</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo1@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">2</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo2@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div></pre></td></tr></table></figure>
<p>它们都连通了并且没有epmd参与！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文描述的只是其中一种不需要epmd的Erlang分布式方式；我相信你可以用别的办法来更好地符合你的需求。我希望上述的示例代码是有用的指南！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epmd（Erlang端口映射守护进程）端口4369，&lt;/li&gt;
&lt;li&gt;Erlang节点自己的端口，一个不可预知的大数字端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的&lt;a href=&quot;http://erlang.org/doc/man/kernel_app.html&quot;&gt;kernel文档&lt;/a&gt;里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="distribution" scheme="http://szpzs.oschina.io/categories/Erlang/distribution/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="epmd" scheme="http://szpzs.oschina.io/tags/epmd/"/>
    
  </entry>
  
  <entry>
    <title>Erlang快速安装</title>
    <link href="http://szpzs.oschina.io/2016/09/28/erlang-quick-install/"/>
    <id>http://szpzs.oschina.io/2016/09/28/erlang-quick-install/</id>
    <published>2016-09-28T14:01:48.000Z</published>
    <updated>2016-10-13T12:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/erlang-logo.png" style="border:0;"><br>在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的<a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank" rel="external">完全安装指引</a>。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。</p>
<ul>
<li><a href="#part1">在Mac OS X上安装Erlang</a></li>
<li><a href="#part2">在Linux上安装Erlang</a></li>
<li><a href="#part3">在Windows上安装Erlang</a></li>
<li><a href="#part4">用最新版本预编译包安装Erlang</a></li>
<li><a href="#part5">从源码编译安装Erlang</a></li>
</ul>
<a id="more"></a>
<h2 id="在Mac-OS-X上安装Erlang"><a href="#在Mac-OS-X上安装Erlang" class="headerlink" title="在Mac OS X上安装Erlang"></a><span id="part1">在Mac OS X上安装Erlang</span></h2><p><strong>使用HomeBrew来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install erlang</div></pre></td></tr></table></figure>
<p><strong>用MacPorts来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install erlang</div></pre></td></tr></table></figure>
<h2 id="在Linux上安装Erlang"><a href="#在Linux上安装Erlang" class="headerlink" title="在Linux上安装Erlang"></a><span id="part2">在Linux上安装Erlang</span></h2><p>大多数操作系统在它们的包管理系统里有预构建的Erlang发行版本。</p>
<p><strong>在Ubuntu和Debian下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install erlang</div></pre></td></tr></table></figure>
<p><strong>在Fedora下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<p><strong>在FreeBSD下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pkg update</div><div class="line">sudo pkg install erlang</div></pre></td></tr></table></figure>
<h2 id="在Windows上安装Erlang"><a href="#在Windows上安装Erlang" class="headerlink" title="在Windows上安装Erlang"></a><span id="part3">在Windows上安装Erlang</span></h2><p><a href="http://www.erlang.org/download.html" target="_blank" rel="external">直接下载安装程序来安装</a></p>
<h2 id="用最新版本预编译包安装Erlang"><a href="#用最新版本预编译包安装Erlang" class="headerlink" title="用最新版本预编译包安装Erlang"></a><span id="part4">用最新版本预编译包安装Erlang</span></h2><p>你在寻找最新的稳定Erlang版本或者前一个Erlang版本吗？<a href="https://www.erlang-solutions.com/" target="_blank" rel="external">Erlang Solutions</a> 给OS X，Windows，Ubuntu，Debian，Fedora，CentOS，Raspbian 以及其他平台都提供了一个<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp" target="_blank" rel="external">预编译安装包</a>。它们也提供了一个企业级Erlang发行版。</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="external">从Erlang Solutions下载</a></p>
<h2 id="从源码编译安装Erlang"><a href="#从源码编译安装Erlang" class="headerlink" title="从源码编译安装Erlang"></a><span id="part5">从源码编译安装Erlang</span></h2><p>你可以用Kerl脚本在你自己的机器上从源码来构建Erlang。Kerl是一个脚本，它使得你用几个命令就轻松地构建不同版本的Erlang。</p>
<p><strong>下载Kerl指令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O https://raw.githubusercontent.com/spawngrid/kerl/master/kerl</div><div class="line">chmod +x kerl</div></pre></td></tr></table></figure>
<p>选择一个可用的Erlang源码发行版本并且像如下指令一样来构建它（在这个例子里，我们选择18.0版本并且命名它为mybuild-18.0）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list releases</div><div class="line">./kerl build 18.0 mybuild-18.0</div></pre></td></tr></table></figure>
<p>选择一个目录来安装，例如 ~/erlang-r16b03</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list builds</div><div class="line">./kerl install mybuild-18.0 ~/erlang-18.0</div></pre></td></tr></table></figure>
<p>最后，把目录 ~/erlang-18.0/bin 加到你的环境变量 $PATH 里。</p>
<p><strong>搞定！</strong></p>
<p>在你的终端运行erl来启动一个Erlang shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 18 [erts-7.0] [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.0  (abort with ^G)</div><div class="line">1&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634" target="_blank" rel="external">https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/erlang-logo.png&quot; style=&quot;border:0;&quot;/&gt;&lt;br&gt;在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的&lt;a href=&quot;http://www.erlang.org/doc/installation_guide/INSTALL.html&quot;&gt;完全安装指引&lt;/a&gt;。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#part1&quot;&gt;在Mac OS X上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part2&quot;&gt;在Linux上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part3&quot;&gt;在Windows上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part4&quot;&gt;用最新版本预编译包安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part5&quot;&gt;从源码编译安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/categories/Erlang/install/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/tags/install/"/>
    
      <category term="HomeBrew" scheme="http://szpzs.oschina.io/tags/HomeBrew/"/>
    
      <category term="MacPorts" scheme="http://szpzs.oschina.io/tags/MacPorts/"/>
    
      <category term="Kerl" scheme="http://szpzs.oschina.io/tags/Kerl/"/>
    
  </entry>
  
  <entry>
    <title>往Elixir里的Map塞东西</title>
    <link href="http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/"/>
    <id>http://szpzs.oschina.io/2016/09/27/putting-things-into-maps-in-elixir/</id>
    <published>2016-09-27T10:57:03.000Z</published>
    <updated>2016-09-27T11:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Elixir的<a href="http://elixir-lang.org/docs/stable/elixir/Map.html" target="_blank" rel="external">Map</a>模块提供了一些不同的函数来操作map数据结构。其中一个函数就是<a href="http://elixir-lang.org/docs/stable/elixir/Map.html#put/3" target="_blank" rel="external">Map.put/3</a> 。这个函数允许你将一个健值对放入一个map中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">9</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.put(pokemon, <span class="symbol">:squirtle</span>, <span class="number">10</span>)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果这个键对于此map来说是新的话，这个键值对就简单地加入map。如果这个键对于此map来说是已存在的，那么对应的老的值则被新的值替换。</p>
<p>同样的效果可以用Map.merge/2来实现。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>&#125;</div><div class="line">&gt; Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">9</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">10</span>&#125;)</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">&gt; pokemon = Map.merge(pokemon, %&#123;<span class="symbol">squirtle:</span> <span class="number">11</span>, <span class="symbol">bulbasaur:</span> <span class="number">14</span>&#125;)</div><div class="line">%&#123;<span class="symbol">bulbasaur:</span> <span class="number">14</span>, <span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">11</span>&#125;</div></pre></td></tr></table></figure>
<p>Map.merge/2的优势是它的灵活性。它能够更容易地在不同情况下使用。它甚至允许一次增加并且替换多个健值对。因为两个入参都是map，它让我们感觉到更容易阅读。</p>
<p>也有一个语法糖的方法，就是用map字面符号和一个管道来替换已经存在的键值对。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pokemon = %&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">9</span>&#125;</div><div class="line">&gt; pokemon = %&#123;pokemon | <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div><div class="line">%&#123;<span class="symbol">charmander:</span> <span class="number">22</span>, <span class="symbol">squirtle:</span> <span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>这个是最简洁的方法，但是，它仅仅是用来替换一个健值对。如果这个键不存在map中，则一个错误将发生。</p>
<p>除此之外当然还有其他函数来设置值到map中，包括 <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/3" target="_blank" rel="external">Kernel.put_in/3</a> 和 <a href="http://elixir-lang.org/docs/stable/elixir/Map.html#get_and_update/3" target="_blank" rel="external">Map.get_and_update/3</a> 。然而上述几个方法是我自己最经常接触到的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/" target="_blank" rel="external">http://joshbranchaud.com/2016/09/25/putting-things-into-maps-in-elixir/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elixir的&lt;a href=&quot;http://elixir-lang.org/docs/stable/elixir/Map.html&quot;&gt;Map&lt;/a&gt;模块提供了一些不同的函数来操作map数据结构。其中一个函数就是&lt;a href=&quot;http://elixir-lang.org/docs/stable/elixir/Map.html#put/3&quot;&gt;Map.put/3&lt;/a&gt; 。这个函数允许你将一个健值对放入一个map中。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = %&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = Map.put(pokemon, &lt;span class=&quot;symbol&quot;&gt;:squirtle&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;squirtle:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; pokemon = Map.put(pokemon, &lt;span class=&quot;symbol&quot;&gt;:squirtle&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%&amp;#123;&lt;span class=&quot;symbol&quot;&gt;charmander:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;squirtle:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/categories/Elixir/"/>
    
      <category term="Map" scheme="http://szpzs.oschina.io/categories/Elixir/Map/"/>
    
    
      <category term="merge" scheme="http://szpzs.oschina.io/tags/merge/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="Map" scheme="http://szpzs.oschina.io/tags/Map/"/>
    
      <category term="put" scheme="http://szpzs.oschina.io/tags/put/"/>
    
  </entry>
  
  <entry>
    <title>原子之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/09/20/eli5-atoms/"/>
    <id>http://szpzs.oschina.io/2016/09/20/eli5-atoms/</id>
    <published>2016-09-20T15:36:59.000Z</published>
    <updated>2016-09-21T00:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img alt="Atom Table" src="/images/eli5-atom-tab.png" style="border: 0;"><br><a id="more"></a><br>原子表是一个全局表，它将原子内部值（一个整数值）映射到一个字符串。同时也有一个反向的查询表，它将一个字符串映射到一个原子内部值。原子表有一个固定的记录条数上限：1048576。如果它一旦到达了这个上限，当前节点将崩溃 －－ 这就是为什么在运行时动态创建原子是很危险的做法。原子表的记录条数上限可以通过给erl命令指定 +t 标签来设置。</p>
<p>原子是在运行时不能改变它的值的一个符号。当一个新的原子被创建，它得到一个唯一的值来给当前节点来使用。原子在系统内部仅仅是指向原子表对应记录索引的整数值。这就是为什么原子的操作如此廉价的原因。</p>
<p>BEAM装载器例程读取原子值并且在原子表里查询它们。它将它们的整数值标记为原子<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>来替代原子名称。然后代码只是操作这些立即数而不是它们的名称。</p>
<p>这些内部值不能当做整数（通过网络或磁盘）离开节点。这是因为其他节点对于相通的原子有不同的内部值。因此当原子离开当前节点的时候都被转换为字符串。这会影响到BEAM文件，外部pid，外部port，Mnesia或DETS里的原子等等。这就是为什么一些开发者更喜欢给数据库字段名使用短原子名称的原因 －－ 它们将以字符串的形式出现在数据库数据中。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-atoms.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img alt=&quot;Atom Table&quot; src=&quot;/images/eli5-atom-tab.png&quot; style=&quot;border: 0;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/categories/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/categories/BEAM/Atom/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/tags/BEAM/"/>
    
      <category term="Atom" scheme="http://szpzs.oschina.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>BEAM虚拟机之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/09/20/eli5-vm/"/>
    <id>http://szpzs.oschina.io/2016/09/20/eli5-vm/</id>
    <published>2016-09-20T15:30:05.000Z</published>
    <updated>2016-09-20T15:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。</p>
<a id="more"></a>
<h2 id="寄存器和调用"><a href="#寄存器和调用" class="headerlink" title="寄存器和调用"></a>寄存器和调用</h2><p>作为一个寄存器虚拟机就意味着在函数调用的时候不是通过栈而是用寄存器来传递参数。它们与我们所理解的CPU架构中的寄存器不一样，而只是一个Erlang数据结构的值所组成的数组。这样的寄存器有1024个，但是有这么多入参的函数几乎不存在，所以通常虚拟机仅仅使用了前面3到10个寄存器。</p>
<p>例如，当调用一个有三个入参的函数的时候，寄存器x0，x1和x2分别被设置为三个入参值。如果我们需要进行递归调用，我们将不得不改写寄存器并丢失它们的原始值。在这种情况下，我们将需要保存旧的值到栈中。除了栈帧外没有动态栈分配，这是由编译器决定的。</p>
<p>每一个进程有自己的寄存器集。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>BEAM指令集包含大约158个基本指令，它们中的大部分可以通过调用 erlc -S yourfile.erl 生成汇编文件来查看到。每一个指令有零或多个参数。不同的技巧用来在便携方式和紧凑方式编码参数。例如，代码中的位置定位（也叫做标签）是用它们的索引来编码的，并且代码装载器后续会把它们翻译成内存地址。</p>
<p>在BEAM代码装载过程中，一些混合的操作码被更快的操作码替换。这个优化的技巧叫做超级指令。对于每一个操作码，在beam_emu.c文件中都有一个C标签对应的一段代码。一个C标签组成的数组存储在同一个虚拟机循环例程的尾部并且被当作查询表来使用。</p>
<p>请参见：<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-file.html" target="_blank" rel="external">BEAM文件格式</a>。<br>详细解释：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-beam-instructions.html" target="_blank" rel="external">BEAM指令代码</a>。</p>
<h2 id="线程虚拟机循环"><a href="#线程虚拟机循环" class="headerlink" title="线程虚拟机循环"></a>线程虚拟机循环</h2><p>装载操作码被标签地址替换后，紧跟着它们的是参数。例如，操作码 ＃1，一个来自标签数组第一索引元素被置于在代码内存。</p>
<p>这种方式很容易跳转到处理下一个操作码的 C 代码中的某个位置。只需要读一个 void* 指针并执行一个goto *p 的动作。此功能是C和C++编译器的一个扩展。这种类型的虚拟机循环称为直接线程调度虚拟机循环。</p>
<p>其他虚拟机循环的类型有：</p>
<ul>
<li>切换调度虚拟机（如果C编译器拒绝支持标签扩展，则这种类型被BEAM虚拟机源使用）。它也比直接线程调度虚拟机慢20%至30%；</li>
<li>直接调用线程</li>
<li><a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html" target="_blank" rel="external">其他</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-vm.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-vm.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BEAM是Bogdan/Björn Erlang Abstract machine的缩写。它是寄存器虚拟机，不过它也有栈。&lt;/p&gt;
    
    </summary>
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/categories/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.oschina.io/categories/BEAM/VM/"/>
    
    
      <category term="BEAM" scheme="http://szpzs.oschina.io/tags/BEAM/"/>
    
      <category term="VM" scheme="http://szpzs.oschina.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>我最喜欢的erlang程序</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-and-other-things/</id>
    <published>2016-09-20T15:17:15.000Z</published>
    <updated>2016-09-20T15:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。</p>
<p>他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。</p>
<a id="more"></a>
<h1 id="通用服务器"><a href="#通用服务器" class="headerlink" title="通用服务器"></a>通用服务器</h1><p>一般来说服务器都是做特定的事情的。一个HTTP服务器响应HTTP请求而一个FTP服务器响应FTP请求，等等。那么什么是通用服务器呢？我们肯定能归纳出一个服务器的概念，然后做出一个通用服务器，并且我们可以在晚些时候让它变成一个特定的服务器。</p>
<p>下面就是我的通用服务器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">universal_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;become, F&#125; -&gt;</div><div class="line">            F()</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个服务器相当简单。一旦我创建了一个通用服务器，它只是呆在那里等待一个 {become, F}消息，收到这样的消息后，他就变成了F服务器。</p>
<h1 id="阶乘服务器"><a href="#阶乘服务器" class="headerlink" title="阶乘服务器"></a>阶乘服务器</h1><p>一个阶乘服务器就是等待一个整数然后返回这个整数的阶乘。下面就是非常简单的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">factorial_server</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;From, N&#125; -&gt;</div><div class="line">            From ! factorial(N),</div><div class="line">            factorial_server()</div><div class="line">    <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span></div><div class="line">    <span class="number">1</span>;</div><div class="line"><span class="function"><span class="title">factorial</span><span class="params">(N)</span> -&gt;</span> N * factorial(N-<span class="number">1</span>).</div></pre></td></tr></table></figure>
<p>现在我们已经准备好high起来了。</p>
<h1 id="把它们集成起来"><a href="#把它们集成起来" class="headerlink" title="把它们集成起来"></a>把它们集成起来</h1><p>我将写一个小函数来创建一个通用服务器，然后给它发送“变成阶乘服务器”消息，接着我将发送一个整数给它，等它返回结果并打印出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></div><div class="line">    Pid = spawn(fun universal_server/0), Pid ! &#123;become, fun factorial_server/0&#125;,</div><div class="line">    Pid ! &#123;self(), <span class="number">50</span>&#125;,</div><div class="line">    <span class="keyword">receive</span></div><div class="line">        X -&gt;</div><div class="line">            X</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这些函数都属于这个模块  <a href="http://joearms.github.io/code/fav1.erl" target="_blank" rel="external">/code/fav1.erl</a>.</p>
<p>现在我们需要做的就是启动一个Erlang shell并运行这个测试程序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line"><span class="number">1</span> &gt; c(fav1).</div><div class="line">&#123;ok, fav1&#125;</div><div class="line"><span class="number">2</span> &gt; fav1:test().</div><div class="line"><span class="number">30414093201713378043612608166064768844377641568960512000000000000</span></div></pre></td></tr></table></figure>
<h1 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h1><p>多年前当我在SICS的时候，我接触到 <a href="http://www.planet-lab.org/" target="_blank" rel="external">Planet 实验室</a>。Planet 实验室是一个有9000台计算机的研究网络。加入Planet实验室很容易，你所要做的是买一台标准PC，将它连接到网络并捐献它的使用给Planet实验室组织。你捐献你的机器给这个网络，相应的你可以使用Planet实验室里的所有其他机器。</p>
<p>Planet实验室是一个为分布式应用的真实世界的测试环境，它当前有1171个节点在562个站上。</p>
<p>当时我要用Planet实验室来做什么呢？我也不知道。最终我做的是写一些脚本在所有Planet实验的机器上安装了空转的通用服务器（和本文的代码很相似）。然后我设计了一套goosip算法来给这个网络发送 <strong>become</strong> 消息。这样我就有了一个空转的网络，我可以在数秒内将它变成我想要的任何服务器。</p>
<p>大概一年后，我必须要写一篇论文。作为一个研究者，最不划算的一个事情就是为了挣钱养家你必须要写关于这样或那样的论文，这样的论文所写的从来不是你当时感兴趣的，但是却一定是关于资助你研究的项目所期望读到的。</p>
<p>我已经在Planet实验室上建立了我的gossip网络，我可以让它成为任何服务器，因此我让它成为一个内容分发网络并且用一个gossip算法来将一个同样的文件拷贝到这个网络上的所有机器上。最后我把这件事写成一篇论文然后大家都哈皮了。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html" target="_blank" rel="external">http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，我收到了来自罗文大学的Dean Galvin的邮件。迪安在做一个项目，他问我“什么样的Erlang样例程序最能体现Erlang的特点”。&lt;/p&gt;
&lt;p&gt;他想要一个小程序，可以适合在十分钟里最好地展示Erlang这门语言的特点。我思考了一阵子然后快速地写出了我最喜欢的程序，它叫做“通用服务器”。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>Erlang的事件驱动应用</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-event-driven-applications/</id>
    <published>2016-09-20T14:42:13.000Z</published>
    <updated>2016-09-20T15:16:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="http://en.wikipedia.org/wiki/Event_%28computing%29" target="_blank" rel="external">事件</a> 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门<a href="http://www.erlang.org/doc/design_principles/events.html" target="_blank" rel="external">一章</a>是关于事件的，还有一种 <a href="http://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="external">事件驱动架构</a> 可以让你的代码和架构更牛X：</p>
<ul>
<li>它更易于将你的代码真正地解耦。</li>
<li>它打开了一扇门，通往令人感兴趣的新的架构模式，比如 <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="external">CQRS</a>（命令查询职责分离模式），<a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="external">event sourcing</a>（事件源模式），和<br><a href="http://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="external">event collaboration</a>（事件合作模式）。</li>
<li>应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。</li>
<li>事件和命令能够被非常小的事件处理器来处理。</li>
<li>如果你真的要用事件来开发系统，那么就可能像<a href="http://www.rabbitmq.com/" target="_blank" rel="external">rabbitmq</a>，<a href="http://www.zeromq.org/" target="_blank" rel="external">0mq</a>一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：</li>
<li>系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。</li>
<li>为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。</li>
<li>一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。</li>
</ul>
<a id="more"></a>
<p>Erlang已经提供了一种方式来实现事件驱动架构：gen_event 行为。<a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event</a> 是 Erlang/OTP 自带的<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id59741" target="_blank" rel="external">默认行为</a>之一。对我来说，它也是Erlang/OTP最酷的特性之一，因为你在许多语言或环境里都无法得到这样开箱即用（并且免费）的特性，因此这真的是非常棒。</p>
<h1 id="它是如何运作的"><a href="#它是如何运作的" class="headerlink" title="它是如何运作的"></a>它是如何运作的</h1><p>Gen_event 有一个或多个事件管理器、事件处理器，来派发和处理事件：</p>
<p><strong>事件管理器</strong>：一个事件管理器是一个 gen_event 进程。<br><strong>事件处理器</strong>：事件处理器是正真处理事件的回调模块，并且被注册到一个或多个事件管理器。<br><strong>事件</strong>：一个事件是任何erlang term，比如一个元组，一个原子，一个列表，等等。</p>
<p>在某些方面，gen_event 用起来像<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>里的<a href="http://nodejs.org/api/events.html#events_class_events_eventemitter" target="_blank" rel="external">EventEmitter</a>类，在概念上说也像<a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>。这个概念是有某种事件总线（事件管理器）负责接收来自系统的事件并且将它们路由到相应的监听者。其基本的工作流如下：</p>
<ul>
<li>创建一个或者多个实现 <a href="http://www.erlang.org/doc/man/gen_event.html" target="_blank" rel="external">gen_event<br>行为</a><br>的回调模块。在本文末尾的<strong>附录B</strong>里有完整的例子。</li>
<li>启动一个事件管理器进程。</li>
<li>注册一个或者多个事件处理器到事件管理器上。</li>
<li>通过事件管理器派发事件。</li>
<li>在你的事件处理器里异步（同步）处理派发过来的事件。</li>
</ul>
<p>现在让我们按顺序研究上述每一步。</p>
<h1 id="启动一个事件管理器"><a href="#启动一个事件管理器" class="headerlink" title="启动一个事件管理器"></a>启动一个事件管理器</h1><p>这就是调用如下函数一样简单：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start().</div></pre></td></tr></table></figure>
<p>或者你计划把你的事件管理器包含在一个<a href="http://www.erlang.org/doc/design_principles/sup_princ.html" target="_blank" rel="external">监督树</a>里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link().</div></pre></td></tr></table></figure>
<h2 id="用一个给定的名字注册一个事件管理器"><a href="#用一个给定的名字注册一个事件管理器" class="headerlink" title="用一个给定的名字注册一个事件管理器"></a>用一个给定的名字注册一个事件管理器</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start(my_event_bus).</div></pre></td></tr></table></figure>
<p>或者也可以：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;ok, Pid&#125; = gen_event:start_link(my_event_bus).</div></pre></td></tr></table></figure>
<p>这些函数与start/0以及start_link/0的目的一样，只是它们允许你用一个指定的名字注册一个新的事件管理器。引述<a href="http://www.erlang.org/doc/man/gen_event.html#start_link-1" target="_blank" rel="external">官方文档</a>如下：</p>
<p>如果 EventMgrName={local, Name}，这个事件管理器被以Name为名字用 register/2 本地注册。</p>
<p>如果 EventMgrName={global, GlobalName}，这个事件管理器被以GlobalName为名字用 global:register_name/2 全局注册。</p>
<p>如果没有名字提供，则这个事件管理器不能被注册。</p>
<p>如果 EventManager={via, Module, ViaName}，这个事件管理器将被Module注册到系统。这个回调模块Module应该导出如下函数 register_name/2 ，unregister_name/1 ，whereis_name/1 and send/2，这些函数和global模块里的相应函数的行为一样。因此，{via, global, GlobalName} 是一个有效的引用。</p>
<h1 id="注册事件处理器"><a href="#注册事件处理器" class="headerlink" title="注册事件处理器"></a>注册事件处理器</h1><p>一旦你已经有了你的事件管理器并且把它运行起来了，就该通过用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_handler/3</a> 来添加一些事件处理器了。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>上述函数将添加一个新的事件处理器到指定的事件管理器（你传入的第一个入参所指的）。事件管理器可以用如下几种方式指定：</p>
<ul>
<li>进程PID。</li>
<li>Name，如果事件管理器是本地注册的。</li>
<li>{Name, Node}，如果事件管理器是在另一个节点本地注册的，或者 {global,<br>GlobalName}，如果事件管理器是全局注册的。</li>
<li>{via, Module, ViaName}，如果事件管理器的注册是通过一个替代进程注册的。</li>
</ul>
<p>第二个入参指定事件处理器的模块名，不过它也可以是{Module, Id}，Module是回调模块的名字，而当有多个事件处理器用同一个回调模块的时候，Id则用于识别指定的事件处理器。</p>
<p>紧接着my_event_handler里的回调函数 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:init-1" target="_blank" rel="external">init/1</a> 被调用，传给 add_handler/3 的第三个入参将原封不动地传给 init/1 做入参。init/1 可能返回：</p>
<p>如果成功，函数将返回{ok, State} 或 {ok, State, hibernate}，State是事件处理器内部初始状态。</p>
<p>如果返回{ok, State, hibernate}，事件管理器将通过调用 proc_lib:hibernate/3 进入冬眠状态，一直等到下一个事件发生。</p>
<h2 id="被监督的事件处理器"><a href="#被监督的事件处理器" class="headerlink" title="被监督的事件处理器"></a>被监督的事件处理器</h2><p>你可以用 <a href="http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3" target="_blank" rel="external">add_sup_handler/3</a> 在调用进程（也就是注册新事件处理器的进程）和事件处理器自己之间建立某种形式的监测（或监督）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add_sup_handler</span><span class="params">(my_event_bus, my_event_handler, [arg1, arg2])</span>.</span></div></pre></td></tr></table></figure>
<p>正如官方文档描述：</p>
<p>如果调用进程后续因为原因Reason而终止，事件管理器将通过用 {stop, Reason} 作为入参调用 Module:terminate/2 来删除事件处理器。</p>
<p>如果事件处理器后来被删除，事件管理器给调用进程发送一个消息 {gen_event_EXIT, Handler, Reason}。Reaseon是下列之一：</p>
<pre><code>normal，如果事件处理器因为 delete_handler/3 的调用而被删除，或者被一个回调函数（见下面段落）返回 remove_handler 。

shutdown，如果事件处理器因为事件管理器结束而被删除。

{swapped, NewHandler, Pid}，如果进程Pid已经调用 swap_handler/3 或 swap_sup_handler/3 来用另一个事件处理器 NewHandler 替换了当前事件处理器。一个term，如果事件处理器因为一个错误而被删除。term的值是依据错误而来的。
</code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>事件处理器是按顺序执行的，所以要尽量保持它的代码短小。如果你需要有上千个事件处理器，那么实现某种<a href="https://gist.github.com/1230182" target="_blank" rel="external">转发器</a>是更好的选择。转发器的思路是有好几个子gen_event订阅一个主gen_event。这样将负载分发给所有感兴趣的监听者。</p>
<p>另一方面，如果你必需要在一个事件处理器里做费时的操作，你应该尝试用一个 <a href="https://gist.github.com/4474770" target="_blank" rel="external">gen_event caster</a>，他将监听事件并派发独特的（普通的）erlang消息。</p>
<p>我们也要注意，当一个被监督的事件处理器退出的时候，gen_event讲给所有的事件处理器<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L319" target="_blank" rel="external">发送消息</a>，因此要准备好如何处理这些消息。</p>
<h1 id="派发事件"><a href="#派发事件" class="headerlink" title="派发事件"></a>派发事件</h1><p>通过事件管理器派发一个事件实际上是相当简单的，仅仅需要调用 <a href="http://www.erlang.org/doc/man/gen_event.html#notify-2" target="_blank" rel="external">gen_event:notify/2</a> 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>你可以在本文的<strong>附录A</strong>里看到gen_event如何派发一个事件的具体细节。</p>
<p>这个函数将异步地派发这个事件。这意味着这个函数调用将不会阻塞而是立即返回。也有同步派发事件的方式，就是使用函数 <a href="http://www.erlang.org/doc/man/gen_event.html#sync_notify-2" target="_blank" rel="external">gen_event:sync_notify/2</a>：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:sync_notify(my_event_handler, &#123;new_user_created, User&#125;).</div></pre></td></tr></table></figure>
<p>同步在这里的意思是这个函数的调用将阻塞并仅在所有事件处理器已经被调用并且处理了这个事件后才返回。</p>
<h2 id="用消息替代-Notify-2"><a href="#用消息替代-Notify-2" class="headerlink" title="用消息替代 Notify/2"></a>用消息替代 Notify/2</h2><p>另一种方式来调用事件处理器是通过派发普通消息给事件管理器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pid ! &#123;new_user_created&#125;</div></pre></td></tr></table></figure>
<p>这将调用<strong>所有</strong>注册的事件处理器的 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数，gen_event官方文档说明如下：</p>
<p>当一个事件管理器接收到不是事件或者一个同步请求（或者一个系统消息）的任何其他消息时，每一个已经安装在这个事件管理器上的事件处理器的这个函数被调用。</p>
<h1 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h1><p>为了处理由notify/2派发的事件，你的回调模块需要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_event-2" target="_blank" rel="external">handle_event/2</a> 函数，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div></pre></td></tr></table></figure>
<p>另外，为了处理消息，要实现 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2" target="_blank" rel="external">handle_info/2</a> 函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(Info, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"Got message: ~p"</span>, [Info]),</div><div class="line">  &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>上面两个例子里的State是由 init/1 返回的数据。</p>
<p>上述两个函数返回值如下所述（当然我们还是引用官方文档）：</p>
<p>如果这个函数返回 {ok, NewState} 或者 {ok, NewState, hibernate} ，这个事件处理器将留在事件管理器里并且带着可能被修改过的内部状态NewState。</p>
<p>如果{ok, NewState, hibernate} 返回，事件管理器也将进入冬眠状态（通过调用 proc_lib:hibernate/3），并等待下一个事件的发生。只要一个事件处理器返回{ok, NewState, hibernate} 则整个事件管理器进程进入冬眠状态。</p>
<p>如果函数返回 {swap_handler, Args1, NewState, Handler2, Args2}，这个事件处理器将被 Handler2 替代，替换过程首先是调用 Module:terminate(Args1, NewState)，然后再调用 Module2:init({Args2, Term}) ，这里的Term是 Module:terminate/2 的返回值。更多信息可以查看 gen_event:swap_handler/3 。</p>
<p>如果函数返回 remove_handler ，这个事件处理器将通过调用 Module:terminate(remove_handler, State)来被删除。</p>
<h1 id="额外事项"><a href="#额外事项" class="headerlink" title="额外事项"></a>额外事项</h1><h2 id="停止事件管理器"><a href="#停止事件管理器" class="headerlink" title="停止事件管理器"></a>停止事件管理器</h2><p>停止事件管理器有时候是必须的并且通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#stop-1" target="_blank" rel="external">stop/1</a> 很容易就做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:stop(my_event_bus).</div></pre></td></tr></table></figure>
<p>这也会引起在所有已经注册的事件处理器上调用 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 。</p>
<h2 id="在一个事件处理器上调用函数"><a href="#在一个事件处理器上调用函数" class="headerlink" title="在一个事件处理器上调用函数"></a>在一个事件处理器上调用函数</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-3" target="_blank" rel="external">call/3</a> 来确切地调用一个事件处理器上指定的函数，就像你在 gen_server上做的一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;).</div></pre></td></tr></table></figure>
<p>和gen_server一样，你可以在调用 <a href="http://www.erlang.org/doc/man/gen_event.html#call-4" target="_blank" rel="external">call/4</a> 到时候指定一个超时时间：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ok = gen_event:call(my_event_bus, my_event_handler, &#123;do_something&#125;, <span class="number">5000</span>).</div></pre></td></tr></table></figure>
<p>gen_event将调用事件处理器模块的 handle_call/2 回调函数。例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, this_is_my_reply, State&#125;.</div></pre></td></tr></table></figure>
<h2 id="删除事件处理器"><a href="#删除事件处理器" class="headerlink" title="删除事件处理器"></a>删除事件处理器</h2><p>你可以通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#delete_handler-3" target="_blank" rel="external">delete_handler/3</a> 来删除你的事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:delete_handler(my_event_bus, my_event_handler, [arg1, arg2]).</div></pre></td></tr></table></figure>
<p>这个函数将从事件管理器删除这个事件处理器，而且也会将第三个参数传给 <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2" target="_blank" rel="external">terminate/2</a> 并调用它并将将调用结果返回。</p>
<p>列出所有已经注册的事件处理器</p>
<p>为了列出一个事件管理器当前注册的所有事件处理器，可以调用 <a href="http://www.erlang.org/doc/man/gen_event.html#which_handlers-1" target="_blank" rel="external">which_handlers/1</a> ：</p>
<p>gen_event:which_handlers(my_event_bus).</p>
<h2 id="替换-交换-事件处理器"><a href="#替换-交换-事件处理器" class="headerlink" title="替换 (交换) 事件处理器"></a>替换 (交换) 事件处理器</h2><p>通过调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_handler-3" target="_blank" rel="external">swap_handler/3</a> 也可以在运行时更换事件处理器：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen_event:swap_handler(my_event_bus, &#123;my_event_handler, [arg1]&#125;, &#123;my_new_event_handler, [arg2]&#125;).</div></pre></td></tr></table></figure>
<p>整个过程是：首先调用 my_event_handler:terminate([arg1], State) 然后调用 my_new_event_handler:init([arg2])，用一个新的事件处理器替换一个久的事件处理器。</p>
<p>如果老的事件处理器是被监督的，则新的事件处理器也被监督。你当然可以直接用同样的参数调用 <a href="http://www.erlang.org/doc/man/gen_event.html#swap_sup_handler-3" target="_blank" rel="external">swap_sup_handler/3</a> 来做到。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>再一次我要感谢 <a href="https://github.com/elbrujohalcon" target="_blank" rel="external">Fernando “El Brujo” Benavides</a> 对本文的总体思考，关于gen_event缺陷的评论，以及他分享的gen_event转发器和caster。</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Marcelo Gornstein <a href="marcelo@inakanetworks.com">marcelo@inakanetworks.com</a></p>
<p>Github: <a href="https://github.com/marcelog" target="_blank" rel="external">marcelog</a></p>
<p>Homepage: <a href="http://marcelog.github.com/" target="_blank" rel="external">http://marcelog.github.com</a></p>
<h1 id="附录-A-gen-event实际上是如何派发一个事件的"><a href="#附录-A-gen-event实际上是如何派发一个事件的" class="headerlink" title="附录 A: gen_event实际上是如何派发一个事件的"></a>附录 A: gen_event实际上是如何派发一个事件的</h1><p>函数 notify/2 的实际调用最终在你的erlang/otp源码的 <a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl" target="_blank" rel="external">lib/stdlib/src/gen_event.erl</a> 文件的504行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="keyword">catch</span> Mod1:Func(Event, State) <span class="keyword">of</span></div></pre></td></tr></table></figure>
<p>Func是原子 handle_event 或 handle_info。所以如果你的事件处理器崩溃或不知何故失败了，事件管理器是不会崩溃的。</p>
<p>如果运行一个被监督的事件处理器（用add_sup_handler/3启动的），在同一个文件的<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L635" target="_blank" rel="external">635行</a>的 terminate/2 函数被调用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Res = (<span class="keyword">catch</span> Mod:terminate(Args, State)),</div></pre></td></tr></table></figure>
<p>另外，被监督的事件处理器，在<a href="https://github.com/erlang/otp/blob/maint/lib/stdlib/src/gen_event.erl#L648" target="_blank" rel="external">648行</a>一个消息被发送给这个事件处理器注册到的进程</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Handler#handler.supervised <span class="keyword">of</span></div><div class="line">  <span class="literal">false</span> -&gt;</div><div class="line">      ok;</div><div class="line">  Pid -&gt;</div><div class="line">      Pid ! &#123;gen_event_EXIT,handler(Handler),Reason&#125;,</div><div class="line">      ok</div><div class="line">  <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="附录-B-回调模块样例"><a href="#附录-B-回调模块样例" class="headerlink" title="附录 B: 回调模块样例"></a>附录 B: 回调模块样例</h1><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_event_handler)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([</span></div><div class="line">  init/<span class="number">1</span>, terminate/<span class="number">2</span>, handle_info/<span class="number">2</span>,</div><div class="line">  handle_call/<span class="number">2</span>, code_change/<span class="number">3</span>, handle_event/<span class="number">2</span></div><div class="line">]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  &#123;ok, []&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">  &#123;ok, not_implemented, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(bad_smell, State)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"That's an aweful smell..  go clean your kitty's litter~n~n"</span>),</div><div class="line">  &#123;ok, State&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(_Event, State)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">  &#123;ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Arg, _State)</span> -&gt;</span></div><div class="line">  ok.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://inaka.net/blog/2013/01/21/erlang-event-driven/" target="_blank" rel="external">http://inaka.net/blog/2013/01/21/erlang-event-driven/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Event_%28computing%29&quot;&gt;事件&lt;/a&gt; 是你个人工具箱里最好的工具之一。甚至在OTP设计原则有专门&lt;a href=&quot;http://www.erlang.org/doc/design_principles/events.html&quot;&gt;一章&lt;/a&gt;是关于事件的，还有一种 &lt;a href=&quot;http://en.wikipedia.org/wiki/Event-driven_architecture&quot;&gt;事件驱动架构&lt;/a&gt; 可以让你的代码和架构更牛X：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它更易于将你的代码真正地解耦。&lt;/li&gt;
&lt;li&gt;它打开了一扇门，通往令人感兴趣的新的架构模式，比如 &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;（命令查询职责分离模式），&lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;event sourcing&lt;/a&gt;（事件源模式），和&lt;br&gt;&lt;a href=&quot;http://martinfowler.com/eaaDev/EventCollaboration.html&quot;&gt;event collaboration&lt;/a&gt;（事件合作模式）。&lt;/li&gt;
&lt;li&gt;应用程序可以被扩展，扩展的方式是通过创建“自治的组件”来“插入”系统，而这些组件通过触发命令或者事件来做它们自己的事情。比如一些事件如下：user_logged_in，user_created，user_voted，incoming_tweet，user_tweeted，等等。&lt;/li&gt;
&lt;li&gt;事件和命令能够被非常小的事件处理器来处理。&lt;/li&gt;
&lt;li&gt;如果你真的要用事件来开发系统，那么就可能像&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;rabbitmq&lt;/a&gt;，&lt;a href=&quot;http://www.zeromq.org/&quot;&gt;0mq&lt;/a&gt;一样通过一个队列来派发事件和命令。这也将引入几个有趣的知识点：&lt;/li&gt;
&lt;li&gt;系统可以用任何你喜欢的语言（Erlang，Scala，Python，Ruby，js-node，等等）来构造。&lt;/li&gt;
&lt;li&gt;为了可扩展性，只要插入所需的足够多的同类型或不同类型的命令处理器或事件处理器。&lt;/li&gt;
&lt;li&gt;一些“疯狂特性”的实现和原型是非常有可能的而且可以很快地完成！它们将可能用非erlang语言实现（如果用队列的话）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="event-driven" scheme="http://szpzs.oschina.io/categories/Erlang/event-driven/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="event-driven" scheme="http://szpzs.oschina.io/tags/event-driven/"/>
    
      <category term="application" scheme="http://szpzs.oschina.io/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS的查询、分页和并发的数据插入</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</id>
    <published>2016-09-20T14:18:06.000Z</published>
    <updated>2016-09-20T14:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">上星期的Erlang Thursday</a>的结尾，我说我们将继续研究ets模块的select函数的特性。</p>
<p>所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">TestOrderedSetTable = ets:new(ordered_set_table, [public, ordered_set]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line"><span class="comment">% 20499</span></div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:give_away(TestOrderedSetTable, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>接着我们给我们的测试ETS表装载一些测试数据，在数据的序列中留出一些空隙，为了后面我们填补这些空隙。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>然后我们从表里查询所有数据，我们可以看到不同类型的表的数据排序是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;]</span></div></pre></td></tr></table></figure>
<p>ets模块也有一个函数 <a href="http://erlang.org/doc/man/ets.html#select_reverse-2" target="_blank" rel="external">ets:select_reverse</a> ，我们停下来看一看它能做些什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">ets:select_reverse(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;]</span></div><div class="line">ets:select_reverse(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;]).</div><div class="line"><span class="comment">% [&#123;29,29&#125;,</span></div><div class="line"><span class="comment">%  &#123;27,27&#125;,</span></div><div class="line"><span class="comment">%  &#123;25,25&#125;,</span></div><div class="line"><span class="comment">%  &#123;23,23&#125;,</span></div><div class="line"><span class="comment">%  &#123;21,21&#125;,</span></div><div class="line"><span class="comment">%  &#123;19,19&#125;,</span></div><div class="line"><span class="comment">%  &#123;17,17&#125;,</span></div><div class="line"><span class="comment">%  &#123;15,15&#125;,</span></div><div class="line"><span class="comment">%  &#123;13,13&#125;,</span></div><div class="line"><span class="comment">%  &#123;11,11&#125;,</span></div><div class="line"><span class="comment">%  &#123;9,9&#125;,</span></div><div class="line"><span class="comment">%  &#123;7,7&#125;,</span></div><div class="line"><span class="comment">%  &#123;5,5&#125;,</span></div><div class="line"><span class="comment">%  &#123;3,3&#125;,</span></div><div class="line"><span class="comment">%  &#123;1,1&#125;]</span></div></pre></td></tr></table></figure>
<p>我们比较 ets:select/2 和 ets:select_reverse/2 的结果，TestTable的结果是一样的，而TestOrderedSetTable的结果刚好是反序，这个结果和官方文档对 ets:select_reverse/2 描述一样。其实我们思考一下也就明白了。</p>
<p>结束了这个简单的小插曲，我们接着运行我们上面相同的匹配规则只是结果集限制在5个纪录，同时我们得到一个continuation。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;Result, Continuation&#125; = ets:select(TestTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;19,19&#125;,&#123;29,29&#125;,&#123;27,27&#125;,&#123;17,17&#125;,&#123;5,5&#125;],</span></div><div class="line"><span class="comment">% &#123;20499,214,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">&#123;OrdSetResult, OrdSetContinuation&#125; = ets:select(TestOrderedSetTable, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [], [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;&#125;]&#125;], <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;3,3&#125;,&#123;5,5&#125;,&#123;7,7&#125;,&#123;9,9&#125;],&#123;16402,9,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>有了这些continuation，我们看看我们取回来的下一个结果集是怎么样的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;1,1&#125;,&#123;23,23&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;9,9&#125;],&#123;20499,111,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;11,11&#125;,&#123;13,13&#125;,&#123;15,15&#125;,&#123;17,17&#125;,&#123;19,19&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,19,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>还记得我们用来创建元组的数字序列里留的那些间隙吗？</p>
<p>现在来看看我们填上那些序列间隙，同时我们用已经获取的continuation来查询数据会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestOrderedSetTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div><div class="line">[[ets:insert(TestTable, &#123;X, X&#125;) || X &lt;- lists:seq(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2</span>)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true]]</span></div></pre></td></tr></table></figure>
<p>现在我们用前面获取到的continuation重新运行 ets:select/1 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line"><span class="comment">% &#123;[&#123;12,12&#125;,&#123;7,7&#125;,&#123;3,3&#125;,&#123;10,10&#125;,&#123;9,9&#125;],</span></div><div class="line"><span class="comment">%  &#123;20499,224,5,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</span></div><div class="line">ets:select(OrdSetContinuation).</div><div class="line"><span class="comment">% &#123;[&#123;10,10&#125;,&#123;11,11&#125;,&#123;12,12&#125;,&#123;13,13&#125;,&#123;14,14&#125;],</span></div><div class="line"><span class="comment">%  &#123;16402,14,[],5,&lt;&lt;&gt;&gt;,[],0,0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们比较以前的结果，我们看到现在的结果里有了偶数元素在列表里。对于我们的 TestTable ，如果我们看上面的Continuation变量的值，它有一个continuation 的点，值是214，因为它是当前continuation和调用 ets:select(Countinuation) 后的结果continuation里唯一变化的值，所以通过这个值我们很难推断continuation的变化。</p>
<p>另一方面，OrdsetContinuation，它的第二个元素的值是9，也就是ETS表id 16402 后面的元素。而后面其它的continuation的这个值分别是19和14也碰巧和对应结果集的最后元素匹配上。因此在有序集合的情况下，我们能推断作为ordered_set类型的ETS表的continuation的一部分，这个continuation告诉我们返回结果集里最后纪录的键，我们可以不管任何同时插入动作发生而继续从这个纪录开始获取数据。</p>
<p>下次我们将看看 ets:is_compiled_ms/1 这个函数，并基于对官方文档的该函数的阅读，我们如何将匹配规则应用在continuation上。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-selects-continuations-and-concurrent-inserts/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;的结尾，我说我们将继续研究ets模块的select函数的特性。&lt;/p&gt;
&lt;p&gt;所以在开始我们的任何试验前，我们设置好我们的测试ETS表，这次我们将创建一个 ordered_set 类型的表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/select/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - 限制返回结果的ETS查询</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-using-ets-select-with-a-limit/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-using-ets-select-with-a-limit/</id>
    <published>2016-09-20T14:10:28.000Z</published>
    <updated>2016-09-20T14:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">上星期的Erlang Thursday</a>我们继续研究 ets:select/2 并且用 ets:fun2ms/1生成匹配规则来和它配合使用。</p>
<p>这个星期我们将看看ets模块提供的select函数的其它版本。</p>
<a id="more"></a>
<p>还是老样子，我们将设置好我们新的ETS表的环境，以便我们的shell崩溃了我们的表不会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = fun() -&gt; receive after infinity -&gt; ok end end.</div><div class="line">% #Fun&lt;erl_eval.20.54118792&gt;</div><div class="line">SomeProcess = spawn(Fun).</div><div class="line">% &lt;0.52.0&gt;</div><div class="line">TestTable = ets:new(ets_table, [public]).</div><div class="line">% 16402</div><div class="line">ets:give_away(TestTable, SomeProcess, []).</div><div class="line">% true</div></pre></td></tr></table></figure>
<p>接下来我们将装载我们的测试ETS表，它是一些测试“产品”。为了例子的简单，我们将仅用一个数字代表一个产品id，然后用一个100以内的随机整数加上0.99作为价格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[ets:insert(TestTable, &#123;ProductId, random:uniform(100) + 0.99&#125;)</div><div class="line">  || ProductId &lt;- lists:seq(1, 10000) ]].</div><div class="line">% [[true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true,true,true,true,true,true,true,true,</div><div class="line">%   true,true,true,true,true|...]]</div></pre></td></tr></table></figure>
<p>我们将创建一个匹配规则（价格在19.99至30之间）来查找数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ProductsInTheTwenties = ets:fun2ms(fun(&#123;Product, Price&#125;)</div><div class="line">                                     when Price &gt;= 19.99 andalso Price &lt; 30</div><div class="line">                                     -&gt; &#123;Product, Price&#125;</div><div class="line">                                   end).</div><div class="line">% [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;,</div><div class="line">%   [&#123;&apos;andalso&apos;,&#123;&apos;&gt;=&apos;,&apos;$2&apos;,19.99&#125;,&#123;&apos;&lt;&apos;,&apos;$2&apos;,30&#125;&#125;],</div><div class="line">%   [&#123;&#123;&apos;$1&apos;,&apos;$2&apos;&#125;&#125;]&#125;]</div></pre></td></tr></table></figure>
<p>如果我们用 ets:select/2 和上面这个匹配规则在我们的表上，我们在一个查询里得到所有结果就和前面我们看到的一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties).</div><div class="line">% [&#123;4351,29.99&#125;,</div><div class="line">%  &#123;635,19.99&#125;,</div><div class="line">%  &#123;6005,20.99&#125;,</div><div class="line">%  &#123;3742,27.99&#125;,</div><div class="line">%  &#123;5956,29.99&#125;,</div><div class="line">%  &#123;3753,28.99&#125;,</div><div class="line">%  &#123;6653,25.99&#125;,</div><div class="line">%  &#123;5151,28.99&#125;,</div><div class="line">%  &#123;2693,27.99&#125;,</div><div class="line">%  &#123;4253,21.99&#125;,</div><div class="line">%  &#123;7636,23.99&#125;,</div><div class="line">%  &#123;1935,19.99&#125;,</div><div class="line">%  &#123;9044,22.99&#125;,</div><div class="line">%  &#123;7797,22.99&#125;,</div><div class="line">%  &#123;2147,23.99&#125;,</div><div class="line">%  &#123;2574,26.99&#125;,</div><div class="line">%  &#123;7575,29.99&#125;,</div><div class="line">%  &#123;2130,28.99&#125;,</div><div class="line">%  &#123;4908,27.99&#125;,</div><div class="line">%  &#123;2218,22.99&#125;,</div><div class="line">%  &#123;9848,21.99&#125;,</div><div class="line">%  &#123;7632,26.99&#125;,</div><div class="line">%  &#123;3562,21.99&#125;,</div><div class="line">%  &#123;3130,27.99&#125;,</div><div class="line">%  &#123;575,26.99&#125;,</div><div class="line">%  &#123;4622,28.99&#125;,</div><div class="line">%  &#123;5678,25.99&#125;,</div><div class="line">%  &#123;4022,...&#125;,</div><div class="line">%  &#123;...&#125;|...]</div></pre></td></tr></table></figure>
<p>不过ets模块也给我们一个限制结果集的方式如果我们愿意的话，用 ets:select/3 并传入一个要一次返回结果数的限制。</p>
<p>那么我们来用 ets:select/3 并给它的限制是10，然后看看结果是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们的结果是一个元组而不是一个结果的列表。第一个元组元素是一个我们期望的10个结果组成的列表，第二个元素是一个奇怪的元组，我们查阅官方文档中 ets:select/3 的描述，这个奇怪的元组表示一个概念：continuation 。</p>
<p>所以我们再运行我们的查询，这次我们把结果绑定到变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;Results, Continuation&#125; = ets:select(TestTable, ProductsInTheTwenties, 10).</div><div class="line">% &#123;[&#123;9027,27.99&#125;,</div><div class="line">%   &#123;7347,29.99&#125;,</div><div class="line">%   &#123;7282,20.99&#125;,</div><div class="line">%   &#123;9386,24.99&#125;,</div><div class="line">%   &#123;5415,25.99&#125;,</div><div class="line">%   &#123;4032,29.99&#125;,</div><div class="line">%   &#123;8105,25.99&#125;,</div><div class="line">%   &#123;4634,24.99&#125;,</div><div class="line">%   &#123;1275,20.99&#125;,</div><div class="line">%   &#123;234,20.99&#125;],</div><div class="line">%  &#123;16402,576,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在我们有了这个continuation，不过它是什么？它对我们来说有什么用？</p>
<p>简而言之，它可以被认为是一个不可变的书签。它不仅表示我们在查询结果的哪一页，也表示我们正在读的内容（我们的查询）。</p>
<p>它允许我们把这个continuation传给 <a href="http://www.erlang.org/doc/man/ets.html#select-1" target="_blank" rel="external">ets:select/1</a> ，就能快速获取我们前面看过的结果内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>因为它是我们的特殊的不可变的书签，每次我们用这个书签它都带我们到这同样书的相同的地方，并且我们仅能读到我们原先设置的每页最大纪录数。</p>
<p>所以不管我们在我们同一个continuation上调用多少次 ets:select/1 ，每次我们都将获得相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div><div class="line">ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>而如果我们仔细看结果的元组，我们看到得到一个不同的下一个continuation的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;SecondResults, SecondContinuation&#125; = ets:select(Continuation).</div><div class="line">% &#123;[&#123;2533,24.99&#125;,</div><div class="line">%   &#123;1357,22.99&#125;,</div><div class="line">%   &#123;564,21.99&#125;,</div><div class="line">%   &#123;9086,22.99&#125;,</div><div class="line">%   &#123;5265,25.99&#125;,</div><div class="line">%   &#123;4030,22.99&#125;,</div><div class="line">%   &#123;2802,25.99&#125;,</div><div class="line">%   &#123;8254,27.99&#125;,</div><div class="line">%   &#123;7088,26.99&#125;,</div><div class="line">%   &#123;3062,27.99&#125;],</div><div class="line">%  &#123;16402,960,10,&lt;&lt;&gt;&gt;,[&#123;6792,29.99&#125;,&#123;9295,29.99&#125;],2&#125;&#125;</div></pre></td></tr></table></figure>
<p>我们可以用这个新的continuation用在我们下一次调用 ets:select/1 上，来得到下一个结果集和另一个continuation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ets:select(SecondContinuation).</div><div class="line">% &#123;[&#123;8569,19.99&#125;,</div><div class="line">%   &#123;1805,28.99&#125;,</div><div class="line">%   &#123;6819,23.99&#125;,</div><div class="line">%   &#123;9313,28.99&#125;,</div><div class="line">%   &#123;9527,27.99&#125;,</div><div class="line">%   &#123;1737,29.99&#125;,</div><div class="line">%   &#123;700,26.99&#125;,</div><div class="line">%   &#123;142,25.99&#125;,</div><div class="line">%   &#123;6792,29.99&#125;,</div><div class="line">%   &#123;9295,29.99&#125;],</div><div class="line">%  &#123;16402,513,10,&lt;&lt;&gt;&gt;,[],0&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果我们在获取完结果集后再执行一次查询，我们得到一个 ‘$end_of_table’ 原子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(TestTable, [&#123;&#123;&apos;$1&apos;, &apos;$2&apos;&#125;, [&#123;&apos;&lt;&apos;, &apos;$2&apos;, 0&#125;], [&apos;$$&apos;]&#125;], 10).</div><div class="line">% &apos;$end_of_table&apos;</div></pre></td></tr></table></figure>
<p>指定一个限制并有一个continuation的能力也可以用在 ets:match/3 和 ets:match/1 上，同时也可以用在 ets:match_object/3 和 ets:match_object/1 上。</p>
<p>下星期，我们将继续研究ets模块里的不同select函数，同时看看它们的行为方式和有序集合，将比较一下 select 函数和 select_reverse函数的不同，也研究一下如果我们当我们用一个continuation的时候在结果集里插入一些数据，continuation将会怎样。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-using-ets-select-with-a-limit/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;我们继续研究 ets:select/2 并且用 ets:fun2ms/1生成匹配规则来和它配合使用。&lt;/p&gt;
&lt;p&gt;这个星期我们将看看ets模块提供的select函数的其它版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/select/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS，匹配规则和函数</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-match-specs-and-functions/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-match-specs-and-functions/</id>
    <published>2016-09-20T14:03:29.000Z</published>
    <updated>2016-09-20T14:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">上星期的Erlang Thursday</a>我展示了怎样通过使用ets:select带来的好处而且使我们的查询更丰富的优势来结束文章。</p>
<p>首先我们将需要一个新的ETS表，那么我们以一个新的public类型的“产品”表开始，并且按我们的标准来创建一个进程然后将表的所有权转移给它。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.52.0&gt;</span></div><div class="line">Products = ets:new(products, [public]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">ets:give_away(Products, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>下一步我们将装载我们的“产品”进入表里。</p>
<p>在我们这个例子里，我们只是创建一个产品，用一个二进制数据当做产品的名字并用一个整数当做“共同世界货币里的价格”。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(Products, &#123;integer_to_binary(X), X&#125;) || X &lt;- lists:seq(<span class="number">1</span>, <span class="number">100</span>) ]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>和我们在上星期一样，我们可以手工创建一个元组列表到匹配规则里去运行我们的查询，说是获取小于10CWC的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"8"&gt;&gt;,&lt;&lt;"6"&gt;&gt;,&lt;&lt;"5"&gt;&gt;,&lt;&lt;"3"&gt;&gt;,&lt;&lt;"7"&gt;&gt;,&lt;&lt;"1"&gt;&gt;,&lt;&lt;"4"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"9"&gt;&gt;,&lt;&lt;"2"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>我们也可以查询到那些大于10CWC并且小于25CWC的产品名称。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&gt;', '$<span class="number">2</span>', <span class="number">10</span>&#125;, &#123;'&lt;', '$<span class="number">2</span>', <span class="number">25</span>&#125;], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% [&lt;&lt;"11"&gt;&gt;,&lt;&lt;"15"&gt;&gt;,&lt;&lt;"23"&gt;&gt;,&lt;&lt;"20"&gt;&gt;,&lt;&lt;"21"&gt;&gt;,&lt;&lt;"14"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"12"&gt;&gt;,&lt;&lt;"13"&gt;&gt;,&lt;&lt;"16"&gt;&gt;,&lt;&lt;"19"&gt;&gt;,&lt;&lt;"17"&gt;&gt;,&lt;&lt;"18"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"22"&gt;&gt;,&lt;&lt;"24"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>但是这样并不一定清晰明了，因为我们正在使用元组里的元素的数值以及在它们里面元组列表的元组列表。</p>
<p>这个时候 <a href="http://www.erlang.org/doc/man/ets.html#fun2ms-1" target="_blank" rel="external">ets:fun2ms/1</a> 来解救我们。</p>
<p>ets:fun2ms/1 的入参是一个函数并且将把这个函数转换成一个匹配规则。</p>
<p>这就允许我们写一个函数，这个函数入参是一个产品和价格组成的元组，然后它返回价格小于10的产品。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &lt; <span class="number">10</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&lt;','$2',10&#125;],['$1']&#125;]</span></div></pre></td></tr></table></figure>
<p>我们也能在传递给 ets:fun2ms/1 的这个函数的判断分支里用一个组合检查，相当于分支类型语句，</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Between_25_And_35_CWC = ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">25</span>, Cost &lt; <span class="number">35</span> -&gt; Product <span class="keyword">end</span>).</div><div class="line"><span class="comment">% [&#123;&#123;'$1','$2'&#125;,[&#123;'&gt;','$2',25&#125;,&#123;'&lt;','$2',35&#125;],['$1']&#125;]</span></div><div class="line">ets:select(Products, Between_25_And_35_CWC).</div><div class="line"><span class="comment">% [&lt;&lt;"30"&gt;&gt;,&lt;&lt;"33"&gt;&gt;,&lt;&lt;"32"&gt;&gt;,&lt;&lt;"29"&gt;&gt;,&lt;&lt;"28"&gt;&gt;,&lt;&lt;"26"&gt;&gt;,</span></div><div class="line"><span class="comment">%  &lt;&lt;"34"&gt;&gt;,&lt;&lt;"27"&gt;&gt;,&lt;&lt;"31"&gt;&gt;]</span></div></pre></td></tr></table></figure>
<p>或者也可以是类型分支语句。</p>
<p>虽然这个函数有用，但是它还是有它的限制，因为这是在函数上解析转换，所以你不能像在普通函数上一样用任何东西。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:fun2ms(<span class="keyword">fun</span>(&#123;Product, Cost&#125;) <span class="keyword">when</span> Cost &gt; <span class="number">90</span> -&gt; lists:reverse(binary:bin_to_list(Product)) <span class="keyword">end</span>).</div><div class="line"><span class="comment">% Error: Unknown error code &#123;122,lists,reverse&#125;</span></div><div class="line"><span class="comment">% &#123;error,transform_error&#125;</span></div></pre></td></tr></table></figure>
<p>但是，匹配规则的结果部分也是不支持任何高级函数功能的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:select(Products, [&#123;&#123;'$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', <span class="number">90</span>, '$<span class="number">2</span>'&#125;], [binary:bin_to_list('$<span class="number">1</span>')]&#125;]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  binary:bin_to_list/1</span></div><div class="line"><span class="comment">%         called as binary:bin_to_list('$1')</span></div></pre></td></tr></table></figure>
<p>即使有这些限制，ets:fun2ms/1 依然帮助我们做了更富表现力的ETS查询。我们不仅能用有意义的变量名替代那些 $X 变量来引用一个函数，也用判断分支语句来替代判断元组，而且我们也可以在我们的结果里用这些变量名同时做基本的格式化作为函数的一部分。</p>
<p>请确认在下周回来，因为我们将继续研究 ets:select 的不同版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-match_specs-and-functions/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/&quot;&gt;上星期的Erlang Thursday&lt;/a&gt;我展示了怎样通过使用ets:select带来的好处而且使我们的查询更丰富的优势来结束文章。&lt;/p&gt;
&lt;p&gt;首先我们将需要一个新的ETS表，那么我们以一个新的public类型的“产品”表开始，并且按我们的标准来创建一个进程然后将表的所有权转移给它。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/match/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="match-specs" scheme="http://szpzs.oschina.io/tags/match-specs/"/>
    
      <category term="match-functions" scheme="http://szpzs.oschina.io/tags/match-functions/"/>
    
      <category term="fun2ms" scheme="http://szpzs.oschina.io/tags/fun2ms/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – 更多的ETS数据匹配和查询</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-more-ets-data-matching-and-querying/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-more-ets-data-matching-and-querying/</id>
    <published>2016-09-20T13:54:22.000Z</published>
    <updated>2016-09-20T14:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续上周开始的从ETS获取数据研究。</p>
<p>我们已经有一个模块 markov_words ，本周我们将添加一个函数 markov_words:create_word_triples/1 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>,</span></div><div class="line">         create_word_triples/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_triples<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_triples(Words, []).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([_Word, _SecondWord | []], WordTriples)</span> -&gt;</span></div><div class="line">    WordTriples;</div><div class="line"><span class="function"><span class="title">create_word_triples</span><span class="params">([FirstWord | Words], WordTriples)</span> -&gt;</span></div><div class="line">    [SecondWord, Following | _] = Words,</div><div class="line">    UpdatedWordTriples = [&#123;FirstWord, SecondWord, Following&#125; | WordTriples],</div><div class="line">    create_word_triples(Words, UpdatedWordTriples).</div></pre></td></tr></table></figure>
<p>添加新函数的原因是它将允许我们得到更精确的马尔科夫链，这是通过能看到后续两个词的复合键的情形而提高获取下一个单词的概率。</p>
<p>修改和重新定义我们的模块后，我们回到Erlang shell，编译我们的模块并转载我们的介绍文本给一个变量，测试开始。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line"></div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>本周我们创建新的ETS表，创建一个新的进程并且把表转移给它（在例子中我们输入一些错误的东西来引起当前的shell进程崩溃）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MarkovWords = ets:new(markov_word_tuples, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 16402</span></div><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div><div class="line">ets:give_away(MarkovWords, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>这周，除了添加我们的词对元组到ETS，我们也将添加新的词三元组到ETS的同样的表里。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(MarkovWords, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"></div><div class="line">[[ ets:insert(MarkovWords, WordTriple) || WordTriple &lt;- markov_words:create_word_triples(ToTC)]].</div></pre></td></tr></table></figure>
<p>既然我们已经有词对和三词组在同一个ETS表中，我们可以用 ets:match_object/2 函数并指定一个匹配模式仅获得二元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者指定另一个匹配模式仅获得三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,","it"&#125;]</span></div></pre></td></tr></table></figure>
<p>而如果我们用 ets:lookup/2 函数并传入键，那么我们得到这个键的所有数据而不管它是二元组还是三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:lookup(MarkovWords, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","loaves","and"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France.","In"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;","there"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison","only."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its","noisiest"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,","we"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,","it"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>和 ets:lookup/2 不一样，ets:match_object/2 可以匹配元组中的任何元素而不仅是键。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ets:match_object(MarkovWords, &#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>和 ets:match_object/2 一样，ets:match/2 也可以如此匹配元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(MarkovWords, &#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>但有时候我们可能想要对如何返回结果给我们有更细粒度的控制能力，比如用一个元素单列表而不是一个字符串嵌套列表。或者我们甚至有一些标准是我们想要的真正作为我们选择的数据的一部分。</p>
<p>让我们开始研究 <a href="http://www.erlang.org/doc/man/ets.html#select-2" target="_blank" rel="external">ets:select/2</a> 。</p>
<p>ets:select/2 第一个入参是一个表，第二个入参是一个匹配规则。</p>
<p>这个匹配规则是一个三元组列表，元组的第一个元素是一个匹配模式，第二个元素是一个判断语句元组的列表，最后一个元素是一个表示每个匹配的结果。</p>
<p>如果我们想让调用 ets:select/2 结果和 ets:match/2 相似，就如像下面输出一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], [['$<span class="number">1</span>']]&#125;]).</div><div class="line"><span class="comment">% [["winter"],</span></div><div class="line"><span class="comment">%  ["spring"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["season"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["epoch"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["age"],</span></div><div class="line"><span class="comment">%  ["worst"],</span></div><div class="line"><span class="comment">%  ["best"]]</span></div></pre></td></tr></table></figure>
<p>第二个入参是一个匹配规则列表，它只有一个元素，这个元素的组成是：<br>1）一个{“was”, “the”, ‘$1’}样式的匹配模式，它和我们传给 ets:match/2 的一样<br>2）一个空的条件判断元组列表3）一个返回结果的term： [[‘$1’]]，它是我们想要的结果格式列表，在本例子里我们想要每个结果都在它自己的列表里。</p>
<p>如果我们只是想得到一个词组成的列表，我们可以修改匹配规则的返回结果的term为[‘$1’]。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$<span class="number">1</span>']&#125;]).</div><div class="line"><span class="comment">% ["winter","spring","season","season","epoch","epoch","age",</span></div><div class="line"><span class="comment">%  "age","worst","best"]</span></div></pre></td></tr></table></figure>
<p>如果我们想让返回结果看起来更像是一个 ets:match<em>object/2 返回的结果集，我们可以使用 ‘$</em>‘作为结果term，它表示整个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, <span class="string">"the"</span>, '$<span class="number">1</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","season"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","epoch"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","age"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","worst"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","best"&#125;]</span></div></pre></td></tr></table></figure>
<p>如果你想要只是匹配某些元素并且提取元组中其它元素，我们可以用 ‘$$’ 作为结果term，它将返回所有匹配变量到一个列表里，返回列表里元素的顺序是按匹配模式里匹配变量的数值排序。</p>
<p>用 ets:select/2 我们也可以有指定多个匹配规则的能力。这样就允许我们查找到所有中间的词是 of 或 the 的三元组数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;'$<span class="number">1</span>', <span class="string">"the"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;, &#123;&#123;'$<span class="number">1</span>', <span class="string">"of"</span>, '$<span class="number">2</span>'&#125;, [], ['$_']&#125;]).</div><div class="line"><span class="comment">% [&#123;"some","of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"on","the","throne"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"direct","the","other"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"preserves","of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"throne","of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"worst","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"short,","the","period"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"winter","of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"degree","of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"epoch","of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"spring","of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"like","the","present"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the","State"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"age","of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"best","of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"season","of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"to","the","lords"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"in","the","superlative"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","winter"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the","spring"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was","the",[...]&#125;,</span></div><div class="line"><span class="comment">%  &#123;"was",[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;[...],...&#125;,</span></div><div class="line"><span class="comment">%  &#123;...&#125;|...]</span></div></pre></td></tr></table></figure>
<p>使用判断分支，我们可以找到在三元组数据里第一个元素是 was ，而且第二个词在字典排序上小于第三个词这样的第三个词。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:select(MarkovWords, [&#123;&#123;<span class="string">"was"</span>, '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, [&#123;'&lt;', '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;], ['$<span class="number">2</span>']&#125;]).</div><div class="line"><span class="comment">% ["than","winter","worst"]</span></div></pre></td></tr></table></figure>
<p>本周的文章我们已经学到使用 ets:match/2 和 ets:match_object/2 函数的其它方式，以及他们能克服使用 ets:lookup/2 的时候只能指定一个键的弱点，也可以能够通过使用 ets:select/2 来获得更强的查询能力。</p>
<p>下周，我们将研究 ets:select/2 的更多使用方式，以及我们怎样用ets模块的其它函数来帮助创建查询来更容易地快速解构数据。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-more-ets-data-matching-and-querying/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续上周开始的从ETS获取数据研究。&lt;/p&gt;
&lt;p&gt;我们已经有一个模块 markov_words ，本周我们将添加一个函数 markov_words:create_word_triples/1 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/match/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/tags/match/"/>
    
      <category term="select" scheme="http://szpzs.oschina.io/tags/select/"/>
    
      <category term="query" scheme="http://szpzs.oschina.io/tags/query/"/>
    
      <category term="lookup" scheme="http://szpzs.oschina.io/tags/lookup/"/>
    
      <category term="match_object" scheme="http://szpzs.oschina.io/tags/match-object/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS 数据匹配</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-data-matching/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-data-matching/</id>
    <published>2016-09-20T13:45:12.000Z</published>
    <updated>2016-09-20T13:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday开始从介绍系列文章改为专门讲ETS，开始用ETS存储一些数据然后在ETS里做一些数据的检索。</p>
<p>首先我们需要在ETS有一些数据，所以我们回到马尔科夫链这个问题上。</p>
<a id="more"></a>
<p>马尔科夫链是一个状态机，它是基于概率而不是特定的输入来转换状态的。它的一个普通的例子就是人们熟悉的智能手机里的“日常使用”的预测输入功能，也就是下一个词或字母会被预测并提供给使用者，而被选择的预测单词是遵循预测它跟随当前单词的历史有关的可能性。</p>
<p>首先我们将创建一个模块，该模块有一个函数将接收一个文本字符串，它返回的是一个元组列表，而这个元组的元素是由一个词和该词的后续词组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(markov_words)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([create_word_pairs/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="keyword">-spec</span> create_word_pairs<span class="params">(string())</span> -&gt; list<span class="params">(&#123;string(), string()&#125;)</span>.</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(Text)</span> -&gt;</span></div><div class="line">  Words = string:tokens(Text, <span class="string">" \t\n"</span>),</div><div class="line">  create_word_pairs([], Words).</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [_Word|[]])</span> -&gt;</span></div><div class="line">    WordPairs;</div><div class="line"><span class="function"><span class="title">create_word_pairs</span><span class="params">(WordPairs, [Word|Words])</span> -&gt;</span></div><div class="line">    [Following|_] = Words,</div><div class="line">    UpdatedWordPairs = [&#123;Word, Following&#125; | WordPairs],</div><div class="line">    create_word_pairs(UpdatedWordPairs, Words).</div></pre></td></tr></table></figure>
<p>上述代码输入的是一个文本字符串，然后基于空格、tab和新行字符作为词的边界将文本分割成词列表。基于这个词列表，我们创建一个列表，该列表元素是由词和词的后续词组成的元组，而这些元组将被我们插入我们的ETS表中。</p>
<p>是时候打开Erlang shell开始我们的试验了。</p>
<p>首先我们需要编译我们的模块，然后我们将创建一个变量来持有我们的文本，这个文本是为我们的马尔科夫链准备的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">c(markov_words).</div><div class="line">% &#123;ok,markov_words&#125;</div><div class="line">ToTC = "It was the best of times, it was the worst of times,</div><div class="line">it was the age of wisdom, it was the age of foolishness,</div><div class="line">it was the epoch of belief, it was the epoch of incredulity,</div><div class="line">it was the season of Light, it was the season of Darkness,</div><div class="line">it was the spring of hope, it was the winter of despair,</div><div class="line">we had everything before us, we had nothing before us,</div><div class="line">we were all going direct to Heaven,</div><div class="line">we were all going direct the other way--in short,</div><div class="line">the period was so far like the present period,</div><div class="line">that some of its noisiest authorities insisted on its</div><div class="line">being received, for good or for evil, in the superlative</div><div class="line">degree of comparison only.</div><div class="line"></div><div class="line">There were a king with a large jaw and a queen with a</div><div class="line">plain face, on the throne of England; there were a king</div><div class="line">with a large jaw and a queen with a fair face,</div><div class="line">on the throne of France. In both countries it was</div><div class="line">clearer than crystal to the lords of the State preserves</div><div class="line">of loaves and fishes, that things in general were</div><div class="line">settled for ever.".</div></pre></td></tr></table></figure>
<p>我们将创建一个新进程并把我们的ETS表转移给它，以防万一我们的Erlang shell崩溃。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.60.0&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们创建一个ETS表，它将用来存储数据，这些数据为我们用来作为我们的马尔科夫链生成器的一部分。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WordPairs = ets:new(word_pairs, [public, duplicate_bag]).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:give_away(WordPairs, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>我们设置表为 public，因为我们想让不再是表的所有者的shell进程可以添加数据到表里，同时我们设置表的类型为 duplicate bag。</p>
<p>设为 duplicate_bag 是为了演示的原因。我们希望能有相同键的多个数据，因为我们很可能会看到任何词多次，而且有些词对的词的集合很常见，所以我们希望能捕获（以及保留）那些重复的词。</p>
<p>为了方便从shell里生成数据，我们将用列表解析把我们从文本创建的每一个词对元组通过调用 ets:insert/2 函数来插入到我们的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[ ets:insert(WordPairs, WordPair) || WordPair &lt;- markov_words:create_word_pairs(ToTC)]].</div><div class="line"><span class="comment">% [[true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true,true,true,true,true,true,true,true,</span></div><div class="line"><span class="comment">%   true,true,true,true,true|...]]</span></div></pre></td></tr></table></figure>
<p>现在我们已经有了一些数据在我们的ETS表里，是时候看看我们怎样才能访问我们的数据。为访问数据，我们开始介绍函数 ets:match/2 ，它的入参是一个要查询的表以及一个模式。</p>
<p>模式是由一个Erlang term组成用来匹配：_ ，匹配任意数据而且不做绑定；或者模式变量，它的格式是$N，N是任意正整数。ets:match/2 的返回结果是一个列表，这个是由模式变量的值组成的，它们按照模式变量名的序列排序。</p>
<p>所以有了这些知识，我们可以尝试查询这些词对来找到所有跟在 of 后的词。如果我们写一个模式匹配，它可能看起来像 {“of”, Following}，但是使用ETS，我们需要用一个模式变量按规范来写成：{“of”, ‘$1’}.</p>
<p>让我们在shell里运行。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["loaves"],</span></div><div class="line"><span class="comment">%  ["the"],</span></div><div class="line"><span class="comment">%  ["France."],</span></div><div class="line"><span class="comment">%  ["England;"],</span></div><div class="line"><span class="comment">%  ["comparison"],</span></div><div class="line"><span class="comment">%  ["its"],</span></div><div class="line"><span class="comment">%  ["despair,"],</span></div><div class="line"><span class="comment">%  ["hope,"],</span></div><div class="line"><span class="comment">%  ["Darkness,"],</span></div><div class="line"><span class="comment">%  ["Light,"],</span></div><div class="line"><span class="comment">%  ["incredulity,"],</span></div><div class="line"><span class="comment">%  ["belief,"],</span></div><div class="line"><span class="comment">%  ["foolishness,"],</span></div><div class="line"><span class="comment">%  ["wisdom,"],</span></div><div class="line"><span class="comment">%  ["times,"],</span></div><div class="line"><span class="comment">%  ["times,"]]</span></div></pre></td></tr></table></figure>
<p>我们看到结果是一个由变量匹配数据的列表组成的列表，在本例子中，就是 ‘$1’ 匹配的。</p>
<p>为了好玩和探索，让我们确认一下在我们的双城记介绍文本里跟在 it 后面的词都有什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"it"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"],</span></div><div class="line"><span class="comment">%  ["was"]]</span></div></pre></td></tr></table></figure>
<p>就是一堆 was ，这刚好是这本书的头两段里的情况。</p>
<p>然后我们仔细检查看看跟在 Scrooge 后的词是什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(WordPairs, &#123;<span class="string">"Scrooge"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% []</span></div></pre></td></tr></table></figure>
<p>如果我们想得到整个元组，我们应该用 ets:match_object/2 ，它将返回满足匹配的整个对象。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>或者，在这个例子里，我们可以用 ets:lookup/2 ，它将返回所有键匹配的元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line"><span class="comment">% [&#123;"of","loaves"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","the"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","France."&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","England;"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","comparison"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","its"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","despair,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","hope,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Darkness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","Light,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","incredulity,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","belief,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","foolishness,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","wisdom,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;,</span></div><div class="line"><span class="comment">%  &#123;"of","times,"&#125;]</span></div></pre></td></tr></table></figure>
<p>所以为了采取一个从马尔科夫链简短绕道的例子，为什么我们想要使用 ets:lookup/2 或 ets:match_object/2 而不是其它函数？为了回答这个问题我们用一个例子，让我们添加另一种数据到我们的马尔科夫链表里，它是一个三元素元组。</p>
<p>To start with, we will insert 100_000 items into our ETS tables and see what the resulting memory size becomes. We will insert a new tuple of {X, X}, for all numbers from 1 to 100_000.（译者注：这一段应该是作者手误，从另外一篇文章错误地拷贝粘贴过来的，这一段和本文无关。）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(WordPairs, &#123;<span class="string">"of"</span>, <span class="string">"times,"</span>, <span class="string">"it"</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>如果我们调用 ets:lookup/2 ，我们将得到指定键的所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ets:lookup(WordPairs, <span class="string">"of"</span>).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>,<span class="string">"it"</span>&#125;]</div></pre></td></tr></table></figure>
<p>但是如果我们用 ets:match_object/2 ，并且用了一个两元组，因为我们只是想得到词对，我们在结果里将不会得到那个三元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ets:match_object(WordPairs, &#123;<span class="string">"of"</span>, '_'&#125;).</div><div class="line">[&#123;<span class="string">"of"</span>,<span class="string">"loaves"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"the"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"France."</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"England;"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"comparison"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"its"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"despair,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"hope,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Darkness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"Light,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"incredulity,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"belief,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"foolishness,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"wisdom,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;,</div><div class="line"> &#123;<span class="string">"of"</span>,<span class="string">"times,"</span>&#125;]</div></pre></td></tr></table></figure>
<p>回到马尔科夫链的场景，我们可以开始看看我们是怎样遵循马尔科夫链规则能够获得一些文本。</p>
<p>我们从一个给定的词得到匹配的潜在的词，并且我们从后续词列表里均匀随机抓取一个结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PotentialChoices = ets:match(WordPairs, &#123;<span class="string">"of"</span>, '$<span class="number">1</span>'&#125;).</div><div class="line">[NextWord] = lists:nth(random:uniform(length(PotentialChoices)), PotentialChoices).</div></pre></td></tr></table></figure>
<p>我们可以写一个函数，让它重复上面的这些步骤，直到终结为止。一些终结状态的例子应该是一个词而且没有后续词；我们得到一定数量的词来拼装我们的文本；或者我们得到一定的总长度，使得它符合社交网络和Tweet的要求。</p>
<p>本文里，我们已经开始将一些“真实”的数据加入ETS里，并且为一些给定的模式来匹配数据。下个星期我们将继续看看在这个例子里用其它方式从我们ETS表取出数据放到一些地方，在那里这些数据可能被更好的消费。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-data-matching/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-data-matching/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday开始从介绍系列文章改为专门讲ETS，开始用ETS存储一些数据然后在ETS里做一些数据的检索。&lt;/p&gt;
&lt;p&gt;首先我们需要在ETS有一些数据，所以我们回到马尔科夫链这个问题上。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/match/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
      <category term="match" scheme="http://szpzs.oschina.io/tags/match/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第五篇：keypos，compressed，read_conncurrency 和 write_concurren</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-5-keypos-compressed-read-conncurrency-and-write-concurrency/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-5-keypos-compressed-read-conncurrency-and-write-concurrency/</id>
    <published>2016-09-20T13:37:31.000Z</published>
    <updated>2016-09-20T13:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且就<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">上星期我所预告的</a>，要研究ETS表的 keypos 设置以及其他一下设置。</p>
<p>首先我们来看看 keypos 设置。</p>
<a id="more"></a>
<p>keypos是被存储的元组的基于1的索引，并且将被作为表的数据项的键。如果你记得我们<a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">第三篇介绍ETS的关于不同表类型的文章</a>所描述，表用这个索引作为它们的键进行比较来决定数据是否唯一。</p>
<p>如果我们创建一个新表而不指定它的 keypos 选项，则 keypos 默认是1。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20498</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>为了显示keypos的作用，我们将创建一些数据插入到我们的ETS表，这样我们就能看到keypos的作用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div><div class="line">Item4 = &#123;a, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;a,"a"&#125;</span></div><div class="line">Item5 = &#123;<span class="string">"a"</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;"a",a&#125;</span></div></pre></td></tr></table></figure>
<p>上述数据，我们在二元素元组里既有第一元素重复的也有第二元素重复的。</p>
<p>我们将继续依次把所有元素插入表中，我们要记住这个表是set类型的，所以任何新数据插入都会覆盖与它有相同键的前面插入的数据值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ets:insert(Table, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(Table, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div><div class="line">ets:insert(Table, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(Table).</div><div class="line"><span class="comment">% [&#123;"a",a&#125;,&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>当我们如上例子插入Item3，它覆盖表中的Item1，因为它们的元组第一个元素都是1。</p>
<p>我们现在创建一个kepos是2的新表，然后看看按上述例子同样的步骤来插入数据会有什么样的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">KeyPosTwo = ets:new(key_pos_2, [&#123;keypos, <span class="number">2</span>&#125;]).</div><div class="line"><span class="comment">% 24595</span></div><div class="line">ets:insert(KeyPosTwo, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item4).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;1,a&#125;]</span></div><div class="line">ets:insert(KeyPosTwo, Item5).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(KeyPosTwo).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;a,"a"&#125;,&#123;"a",a&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，当插入Item4时，就发生了覆盖，因为Item2和Item4的第二个元素都是“a”。然后插入Item5时，会覆盖Item1，因为它们的第二个元素都是原子a。</p>
<p>如果我们设置的keypos是其他值，比如说3，然后我们尝试插入一个元素小于3的元组，我们会得到一个bag argument异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">KeyPosThree = ets:new(key_pos_3, [&#123;keypos, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% 28692</span></div><div class="line">ets:insert(KeyPosThree, Item1).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(28692,&#123;1,a&#125;)</span></div></pre></td></tr></table></figure>
<p>现在我们来看看创建表的时候用compressed选项。</p>
<p>当创建一个新表，默认是不压缩的，因为我们可以从下面例子里看到表信息显示{compressed, false}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UncompressedTable = ets:new(uc, []).</div><div class="line"><span class="comment">% 32786</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>我们创建一个新表，用了compressed选项，然后用ets:info/1查看表信息，我们看到{compressed, true}。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CompressedTable = ets:new(uc, [compressed]).</div><div class="line"><span class="comment">% 45074</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>至少根据官方文档的说法，compressed选项会使得数据以更压缩的格式存储而减少内存的消耗。文档也警告这也会造成获取元素元组的操作更慢，并且键是不压缩存储的，至少在当前的版本里是这样。</p>
<p>让我们来看看compressed对内存的消耗有什么样的不同。</p>
<p>我们将给两种表分别插入100000条记录，然后看它们的内存大小。插入纪录的格式是{X, X}，X从1到100000。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, X&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,714643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,814643&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>有意思！</p>
<p>压缩表的内存大小是814643，而非压缩表的内存大小却小一点，是714643。</p>
<p>可能是对整数值的压缩效果不好，所以我们再做一次，这次是用字符串替换元组的第二个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(UncompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">lists:foreach(<span class="keyword">fun</span>(X) -&gt; ets:insert(CompressedTable, &#123;X, integer_to_list(X)&#125;) <span class="keyword">end</span>,</div><div class="line">              lists:seq(<span class="number">1</span>, <span class="number">100000</span>)).</div><div class="line"><span class="comment">% ok</span></div><div class="line">ets:info(CompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,true&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,914644&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div><div class="line">ets:info(UncompressedTable).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,1692433&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.109.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,uc&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,100000&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>用字符串替换元素第二元素后，压缩表内存大小是914644，而非压缩表的内存大小是1692433。</p>
<p>所以当你要决定是否使用压缩表的时候除了要更仔细的考虑你将用何种方式如何匹配数据外，你还要考虑你将要放入ETS表的数据是什么样的类型。</p>
<p>最后两个要讨论的选项是 read_concurrency 和 write_concurrency。</p>
<p>read_concurrency 默认被设置为false，根据官方文档的说法这个选项在“读比写操作频繁很多，或者当并发读写的量非常巨大的时候”最适合设置为true。</p>
<p>因此如果你有一个表有大量的读操作，而写操作零零散散，这个时候你应该设置read_concurrency为true，因为官方文档的说法是在读和写之间切换是很昂贵的。</p>
<p>write_concurrency 默认被设置为false，这会使得当一个写操作正在进行的时候会造成其它并发的写操作阻塞。当把该选项设置为true，则同一个表的不同的元组可以通过并发进程写入，并且不影响任何ordered_set类型表。</p>
<p>ETS的一系列介绍文章到此告一段路。下星期我们将开始研究用ETS和ETS表进行不同的操作。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-5/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍ETS并且就&lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/&quot;&gt;上星期我所预告的&lt;/a&gt;，要研究ETS表的 keypos 设置以及其他一下设置。&lt;/p&gt;
&lt;p&gt;首先我们来看看 keypos 设置。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第四篇：ETS的访问保护</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-4-ets-access-protections/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-4-ets-access-protections/</id>
    <published>2016-09-20T13:20:20.000Z</published>
    <updated>2016-09-20T13:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并研究ETS支持的不同访问级别。</p>
<p>ETS支持的不同访问级别：public，protected和private。</p>
<a id="more"></a>
<p>在创建一个新ETS表的时候可以传入不同访问类型的任意一个，不过我们先看看当我们不指定访问级别的时候ETS表的访问级别是哪一个？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Table = ets:new(some_name, []).</div><div class="line"><span class="comment">% 20501</span></div><div class="line">ets:info(Table).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.81.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,some_name&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>从上面的输出可以看到不指定访问级别的话默认就是protected。</p>
<p>那么一个ETS表是被保护的意味着什么呢？官方文档说明被保护的表只可以被所有者进程写入，但是其他进程可以读取。</p>
<p>现在让我们一起看看它是如何工作的。</p>
<p>首先我们创建一个进程以便我们可以把ETS表转移给它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Fun = <span class="keyword">fun</span>() -&gt; <span class="keyword">receive</span> <span class="keyword">after</span> infinity -&gt; ok <span class="keyword">end</span> <span class="keyword">end</span>.</div><div class="line"><span class="comment">% #Fun&lt;erl_eval.20.54118792&gt;</span></div><div class="line">SomeProcess = spawn(Fun).</div><div class="line"><span class="comment">% &lt;0.58.0&gt;</span></div></pre></td></tr></table></figure>
<p>我们创建一个新的ETS表并指定它是被保护的，同时也指定它是有名字的以方便后续操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ProtectedNamedETS = ets:new(protected_named_ets, [protected, named_table]).</div><div class="line"><span class="comment">% protected_named_ets</span></div></pre></td></tr></table></figure>
<p>函数的输出是 protected_name_ets 而不是像前面调用 ets:new/2 那样输出的是数字，这样一来我们能够用表的名字替代表标识码访问这个表。</p>
<p>我们将插入一条数据到这个ETS表里，并且我们将用这个ETS表的名字作为它的引用因为我们创建表的时候指定了 named_table 选项。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;foobar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>ets:insert/2 返回true，那么现在我们应该有一些数据在表里。让我们用ets:match/2把数据取出来，而且通过用一个$1的模式匹配出所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>那么作为这个ETS表的所有者进程，因为这个表是由这个进程创建的，所有我们能读写这个表。</p>
<p>现在我们把这个表转移给另外的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(protected_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>既然官方文档说表是可读的，我们在刚刚转移所有权后做同样的match操作。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:match(protected_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foobar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>我们读取到我们的数据。<br>那么尝试写会发生什么？因为官方文档说只有所有者进程才能有写的权限，并且在调用 ets:insert/2 的时候总是返回true。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(protected_named_ets, &#123;barbaz, foo&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(protected_named_ets,&#123;barbaz,foo&#125;)</span></div></pre></td></tr></table></figure>
<p>上面的例子返回了一个异常，异常的类型是 bag argument，也就是说它不允许非所有者进程写数据入表，但是这个异常没有确切地说明到底发生了什么。</p>
<p>如果我们尝试调用 ets:insert/2 往不存在的表插入数据将会发生什么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(no_such_table, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(no_such_table,&#123;foo,bar&#125;)</span></div></pre></td></tr></table></figure>
<p>一样的异常和一样的错误提示格式，仅仅是表名和元组不同。</p>
<p>仔细想想这些现象，这两种不同的情况有一样的错误是有意义的。当一个进程尝试去做一个插入而如果没有表存在或者如果表被设置为 protected，则就是要让正在调用插入动作的这个进程知道这样的表不存在。总之，就是调用者将一个错的ETS表的引用传给ets:insert/2 。</p>
<p>所以我们现在已经知道 protected 的行为，它是默认的访问级别，那么下面让我们看看 public 。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PublicNamedETS = ets:new(public_named_ets, [public, named_table]).</div><div class="line"><span class="comment">% public_named_ets</span></div></pre></td></tr></table></figure>
<p>我们将从我们当前的进程，也就是表的所有者插入一条数据并且获取所有数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;foo, bar&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;]]</span></div></pre></td></tr></table></figure>
<p>一切正常。</p>
<p>官方文档说public的表允许任何进程读和写，所以让我们把这个public表转给进程 SomeProcess 并且尝试去读和写。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(public_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在我们已经将表转移出去，是时候来尝试添加一条新的数据到表里，同时来看看我们能否将写入的内容读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(public_named_ets, &#123;bar, baz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(public_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;foo,bar&#125;],[&#123;bar,baz&#125;]]</span></div></pre></td></tr></table></figure>
<p>完全没问题。我们已经插入新数据到那个表里，并且当我们调用 ets:match/2 获取所有数据的时候，我们看到新数据在结果集里。</p>
<p>现在让我们创建一个 private 表。官方文档说对于 private 的ETS表，只有表的所有者才被允许读写这个ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PrivateNamedETS = ets:new(private_named_ets, [private, named_table]).</div><div class="line">private_named_ets</div></pre></td></tr></table></figure>
<p>当进程还拥有这个表的时候，我们添加一条数据并读取出来。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;fizz, buzz&#125;).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% [[&#123;fizz,buzz&#125;]]</span></div></pre></td></tr></table></figure>
<p>然后我们又把表转移给进程 SomeProcess。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ets:give_away(private_named_ets, SomeProcess, []).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在这个ETS表属于另一个进程了，我们再来尝试读取它的数据。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:match(private_named_ets, '$<span class="number">1</span>').</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:match/2</span></div><div class="line"><span class="comment">%         called as ets:match(private_named_ets,'$1')</span></div></pre></td></tr></table></figure>
<p>又是 bad argument 异常，就像前面例子我们尝试在一个 protected ETS表上用 ets:insert/2 函数，而当时那个表属于另外一个进程。<br>再来看看写的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(private_named_ets, &#123;buzz, fizz&#125;).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  ets:insert/2</span></div><div class="line"><span class="comment">%         called as ets:insert(private_named_ets,&#123;buzz,fizz&#125;)</span></div></pre></td></tr></table></figure>
<p>也是 bad argument 异常，现在这样的情况不会让人奇怪了，因为 protected 表的写以及这个 private 表的读都造成一样的异常。</p>
<p>总之，在所有到目前为止的ETS的介绍文章里，我们已经见过了ETS表的类型、访问级别、表命名、继承人和所有者这些属性的设置以及它们之间的关系。</p>
<p>下星期，我们将通过介绍ETS表的键位置的设置和其他一些设置来结束ETS介绍系列文章。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-4-ets-access-protections/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍ETS并研究ETS支持的不同访问级别。&lt;/p&gt;
&lt;p&gt;ETS支持的不同访问级别：public，protected和private。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday - ETS介绍第三篇：ETS表类型</title>
    <link href="http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-3-ets-table-types/"/>
    <id>http://szpzs.oschina.io/2016/09/20/erlang-thursday-ets-introduction-part-3-ets-table-types/</id>
    <published>2016-09-20T13:14:05.000Z</published>
    <updated>2016-09-20T13:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续介绍ETS并且研究一下ETS支持的不同存储策略类型。</p>
<p>ETS支持的不同存储类型是：set，ordered_set，bag，和duplicate bag。</p>
<a id="more"></a>
<p>每种类型都可以在创建一个新ETS表的时候传给创建函数，不过我们来看看创建ETS表的时候不指定任何类型的话ETS表是什么类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ETS_Empty = ets:new(ets_empty, []).</div><div class="line"><span class="comment">% 36886</span></div><div class="line">ets:info(ETS_Empty).</div><div class="line"><span class="comment">% [&#123;read_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;write_concurrency,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;compressed,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;memory,305&#125;,</span></div><div class="line"><span class="comment">%  &#123;owner,&lt;0.50.0&gt;&#125;,</span></div><div class="line"><span class="comment">%  &#123;heir,none&#125;,</span></div><div class="line"><span class="comment">%  &#123;name,ets_empty&#125;,</span></div><div class="line"><span class="comment">%  &#123;size,0&#125;,</span></div><div class="line"><span class="comment">%  &#123;node,nonode@nohost&#125;,</span></div><div class="line"><span class="comment">%  &#123;named_table,false&#125;,</span></div><div class="line"><span class="comment">%  &#123;type,set&#125;,</span></div><div class="line"><span class="comment">%  &#123;keypos,1&#125;,</span></div><div class="line"><span class="comment">%  &#123;protection,protected&#125;]</span></div></pre></td></tr></table></figure>
<p>上面的输出中，type 标签元组显示类型是 set。</p>
<p>为了研究不同类型的ETS表如何工作的，我们将创建三个元组加入不同ETS表里来看看它们是如何存储的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Item1 = &#123;<span class="number">1</span>, a&#125;.</div><div class="line"><span class="comment">% &#123;1,a&#125;</span></div><div class="line">Item2 = &#123;<span class="number">1.0</span>, <span class="string">"a"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1.0,"a"&#125;</span></div><div class="line">Item3 = &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;.</div><div class="line"><span class="comment">% &#123;1,"one"&#125;</span></div></pre></td></tr></table></figure>
<p>我们有两个第一元素都是1的元组，还有一个第一元素是1.0的元组，这是为了看看在相同的键情况下不同类型ETS表如何处理。</p>
<p>为什么有1和1.0两个键？因为根据使用的比较操作符的不同，它们可以被看作相同的也可以被看作不相同的，所以把它们当作一种相同键的情况。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> == <span class="number">1.0</span>.</div><div class="line"><span class="comment">% true</span></div><div class="line"><span class="number">1</span> =:= <span class="number">1.0</span>.</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>首先我们看看一个set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Set = ets:new(ets_set, [set]).</div><div class="line"><span class="number">40978</span></div></pre></td></tr></table></figure>
<p>我们插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Set, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>set类型的ETS表把1和1.0当作不同的键。那么我们插入Item3也就是插入一个已经存在的键会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Set, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Set).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>原先1为键的元组已经被我们刚刚插入的Item3元组替换了。</p>
<p>我们再来看看ordered_set类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_OrdSet = ets:new(ets_ordset, [ordered_set]).</div><div class="line"><span class="comment">% 45075</span></div></pre></td></tr></table></figure>
<p>我们还是插入Item1再插入Item2，然后用 ets:tab2list/1 来输出这个ETS表里存储了什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_OrdSet, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>这个例子里，1.0被认为和先插入的1是相等的，所以它覆盖了第一个插入的元素。</p>
<p>我们再插入Iterm3，结果是它也覆盖了1.0那个元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_OrdSet, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_OrdSet).</div><div class="line"><span class="comment">% [&#123;1,"one"&#125;]</span></div></pre></td></tr></table></figure>
<p>现在我们来看看bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_Bag = ets:new(ets_bag, [bag]).</div><div class="line"><span class="comment">% 49172</span></div></pre></td></tr></table></figure>
<p>我们还是给表里加入Item1和Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_Bag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>从 ets:tab2list/1 的输出我们看到bag类型的ETS表把Item1和Item2当作两个不同的元素。</p>
<p>再将Item3加入表里看看会有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>在这个bag类型的ETS表中，我们有了Item2以及Item1和Item3三个元素，甚至Item1和Item3有相同当键。</p>
<p>最后我们来看看duplicate_bag类型的ETS表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ETS_DupBag = ets:new(ets_dupbag, [duplicate_bag]).</div><div class="line"><span class="comment">% 53269</span></div></pre></td></tr></table></figure>
<p>像前面几种类型的ETS表一样，我们插入Item1再插入Item2。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:insert(ETS_DupBag, Item2).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>也和前面的例子一样，我们接着插入Item3。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item3).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是我们在这个duplicate_bag表中有所有三个元素。</p>
<p>如果我们比较bag和duplicate_bag两种表，我们发现它们似乎有一样的行为。</p>
<p>那么它们两者之间有什么不同呢？</p>
<p>如果你深入挖掘官方文档，仔细阅读 ets:new/2 函数中关于表类型的描述，它说明一个bag表允许有重复键，但是只不允许两个一样的一个元素存在，而duplicate_bag允许相同元素存在即时它们的键值都相同。</p>
<p>为验证这个结论，我们往bag表和duplicate_bag表都加入Item1，看看结果是什么。</p>
<p>首先是bag表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_Bag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_Bag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果和原来没有不同，所以往bag里添加已经存在的元素不会改变表的内容。</p>
<p>那么duplicate_bag表呢？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ets:insert(ETS_DupBag, Item1).</div><div class="line"><span class="comment">% true</span></div><div class="line">ets:tab2list(ETS_DupBag).</div><div class="line"><span class="comment">% [&#123;1,a&#125;,&#123;1,"one"&#125;,&#123;1,a&#125;,&#123;1.0,"a"&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是元组{1, a}有两份，因为我们调用 ets:insert/2 将这个元素插入了两次。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ets-introduction-part-3-ets-table-types/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续介绍ETS并且研究一下ETS支持的不同存储策略类型。&lt;/p&gt;
&lt;p&gt;ETS支持的不同存储类型是：set，ordered_set，bag，和duplicate bag。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/categories/Erlang/ETS/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://szpzs.oschina.io/tags/ETS/"/>
    
      <category term="ets" scheme="http://szpzs.oschina.io/tags/ets/"/>
    
  </entry>
  
</feed>
