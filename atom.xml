<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.oschina.io/"/>
  <updated>2017-01-05T14:40:09.000Z</updated>
  <id>http://szpzs.oschina.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gen_tcp 和 active_once</title>
    <link href="http://szpzs.oschina.io/2017/01/05/active-once/"/>
    <id>http://szpzs.oschina.io/2017/01/05/active-once/</id>
    <published>2017-01-05T14:19:10.000Z</published>
    <updated>2017-01-05T14:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>我想理解和测试gen_tcp模块使用的active_once选项。整个过程我写了一些代码，包括三个监督者，一个gen_fsm和一个gen_server。</p>
<p>这是一篇gen_tcp和active_onece选项的概念证明文章。正如我一直说的，这只是我的学习笔记并且我可能是错的。所以查阅OTP文档和其他一些不错的书籍，可以发现关于这一主题的相关内容。</p>
<a id="more"></a>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>目标很简单，就是看看active_once选项如何控制数据流。也许这一次这个博客的简单概念证明的规则被打破了。本文的这个例子并不像以前那么简单，但我认为最终它是值得的。</p>
<h1 id="主动和非主动套接字"><a href="#主动和非主动套接字" class="headerlink" title="主动和非主动套接字"></a>主动和非主动套接字</h1><p>gen_tcp模块提供两种方式来读取套接字流，主动和非主动套接字。后者是传统的方式。通过使用recv/2和recv/3函数，进程决定什么时候从输入流读取数据。这种方式下，进程负责控制输入数据流。</p>
<p>另一方面，主动套接字允许按Erlang消息方式来接收数据。这种方式的问题是，对端进程可以无节制地发送数据来淹没我们进程的接收数据队列，因为我们的进程没有相应的流控策略。</p>
<p>不过现在有办法解决这个问题。通过设置active_once选项为true，进程按Erlang消息方式从套接字接收一次数据。一旦消息被接收到，套接字又转换为非主动方式，如果缓冲区满了，则阻止发送进程发送数据。进程可以再设置active_once选项来从套接字接收下一个Erlang消息来重复这个过程。</p>
<h1 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h1><p>控制进程就是当套接字被设置成主动或active_once的时候从套接字流接收到Erlang消息的那个进程。默认情况下，控制进程就是接收套接字的进程。</p>
<p>正如我们将看到的，可以用controlling_process/2函数来改变谁是控制进程。</p>
<h1 id="概念证明的结构"><a href="#概念证明的结构" class="headerlink" title="概念证明的结构"></a>概念证明的结构</h1><p>实际上，就如下图这么简单。</p>
<p><img src="/images/structure-poc.png" style="border:0;"></p>
<p><strong>main_sup: 主监督者。</strong></p>
<p><strong>listener_sup: 接收链接进程的监督者。</strong></p>
<p><strong>worker_sup: 读取工作者的监督者。</strong></p>
<p><strong>accept_fsm: 接收链接进程。</strong></p>
<p><strong>worker_gen: 套接字读取工作者。</strong></p>
<hr>
<p><strong>main_sup - 主监督者</strong></p>
<p>它使用permanent和one_on_one 重启策略。它有两个也是监督者的子进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(main_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"main_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    RestartStrategy = one_for_one,</div><div class="line">    MaxRestarts = <span class="number">10</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = permanent,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = supervisor,</div><div class="line"></div><div class="line">    ListenerSup = &#123;'listener_sup',</div><div class="line">		   &#123;'listener_sup', start_link, []&#125;,</div><div class="line">		   Restart, Shutdown, Type, ['listener_sup']&#125;,</div><div class="line"></div><div class="line">    WorkerSup = &#123;'worker_sup',</div><div class="line">		   &#123;'worker_sup', start_link, []&#125;,</div><div class="line">		   Restart, Shutdown, Type, ['worker_sup']&#125;,</div><div class="line"></div><div class="line">    ChildList = [ListenerSup, WorkerSup],</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, ChildList&#125;&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>listener_sup: 接收链接进程的监督者。</strong></p>
<p>它使用permanent和one_on_one 重启策略。它的子进程是accept_fsm进程。三个子进程被启动起来是为了准备大量链接的冲击。监听套接字在init函数里被创建，并且它的active属性设置为false，我们想使用默认的流控方式。</p>
<p>需要注意的是，三个子进程是用一个列表解析来创建的，在这里每一个id由build_label函数创建，结果id的格式是 accept_fsm_n，n是进程的顺序。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(listener_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    &#123;ok, LSocket&#125; = gen_tcp:listen(<span class="number">2000</span>, [&#123;active, false&#125;]),</div><div class="line"></div><div class="line">    NumberOfWorkers = <span class="number">3</span>,</div><div class="line">    RestartStrategy = one_for_one,</div><div class="line">    MaxRestarts = <span class="number">100</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = permanent,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = worker,</div><div class="line"></div><div class="line">    ChildList = [&#123;build_label(<span class="string">"accept_fsm_"</span>, C),</div><div class="line">		  &#123;'accept_fsm', start_link, [LSocket]&#125;,</div><div class="line">		  Restart, Shutdown, Type, ['accept_fsm']&#125;</div><div class="line">		 || C &lt;- lists:seq(<span class="number">1</span>, NumberOfWorkers)],</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, ChildList&#125;&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">build_label</span><span class="params">(Name, C)</span> -&gt;</span></div><div class="line">    io_lib:format(<span class="string">"~s~w"</span>, [Name, C]).</div></pre></td></tr></table></figure>
<hr>
<p><strong>worker_sup: 读取工作者的监督者。</strong></p>
<p>它使用temporary和simple_on_on_one重启策略按需求来启动进程。它的子进程是worker_gen进程。它导出start_child/1函数，通过传递新的接收的套接字给此函数来启动一个worker_gen子进程。另外它设置新的子进程作为套接字的控制进程，这样该子进程就可以接收到Erlang消息流。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(worker_sup)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, start_child/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:start_link...~n"</span>),</div><div class="line">    supervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_child</span><span class="params">(ASocket)</span> -&gt;</span></div><div class="line">    &#123;ok, Pid&#125; = supervisor:start_child(?MODULE, [ASocket]),</div><div class="line">    gen_tcp:controlling_process(ASocket, Pid),</div><div class="line">    &#123;ok, Pid&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"listener_sup:init...~n"</span>),</div><div class="line"></div><div class="line">    RestartStrategy = simple_one_for_one,</div><div class="line">    MaxRestarts = <span class="number">100</span>,</div><div class="line">    MaxSecondsBetweenRestarts = <span class="number">3600</span>,</div><div class="line"></div><div class="line">    SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,</div><div class="line"></div><div class="line">    Restart = temporary,</div><div class="line">    Shutdown = <span class="number">2000</span>,</div><div class="line">    Type = worker,</div><div class="line"></div><div class="line">    AChild = &#123;'worker_gen', &#123;'worker_gen', start_link, []&#125;,</div><div class="line">	      Restart, Shutdown, Type, ['worker_gen']&#125;,</div><div class="line"></div><div class="line">    &#123;ok, &#123;SupFlags, [AChild]&#125;&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>accept_fsm: 接收链接进程。</strong></p>
<p>这个进程被实现为一个FSM（有限状态机），而且只有一个状态，即accept状态。它接收一个侦听套接字并且在其上接收链接。当一个新的链接到来，这个进程设置套接收的套接字为active_once并且传递新的接收套接字给worker_sup请求其创建一个新子进程。然后这个进程再回到accept状态。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(accept_fsm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_fsm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_event/<span class="number">3</span>,</span></div><div class="line">	 handle_sync_event/<span class="number">4</span>, handle_info/<span class="number">3</span>, terminate/<span class="number">3</span>, code_change/<span class="number">4</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([accept/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">(LSocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:start_link...~n"</span>),</div><div class="line">    gen_fsm:start_link(?MODULE, [LSocket], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([LSocket])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:init...~n"</span>),</div><div class="line">    gen_fsm:send_event(self(), accept),</div><div class="line">    &#123;ok, accept, LSocket&#125;.</div><div class="line"></div><div class="line"><span class="comment">% Events.</span></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(accept, LSocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"accept_fsm:accept...~n"</span>),</div><div class="line">    &#123;ok, ASocket&#125; = gen_tcp:accept(LSocket),</div><div class="line">    inet:setopts(ASocket, [&#123;active, once&#125;, &#123;packet, line&#125;]),</div><div class="line">    worker_sup:start_child(ASocket),</div><div class="line">    gen_fsm:send_event(self(), accept),</div><div class="line">    &#123;next_state, accept, LSocket&#125;.</div><div class="line"></div><div class="line"><span class="comment">% All events.</span></div><div class="line"><span class="function"><span class="title">handle_event</span><span class="params">(accept, _StateName, State)</span> -&gt;</span></div><div class="line">    &#123;next_state, accept, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_sync_event</span><span class="params">(_Any, _From, _StateName, State)</span> -&gt;</span></div><div class="line">    &#123;reply, ok, accept, State&#125;.</div><div class="line"></div><div class="line"><span class="comment">% OTP messeges.</span></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, StateName, State)</span> -&gt;</span></div><div class="line">    &#123;next_state, StateName, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _StateName, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, StateName, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, StateName, State&#125;.</div></pre></td></tr></table></figure>
<hr>
<p><strong>worker_gen: 套接字读取工作者。</strong></p>
<p>本文的概念证明就在这个进程里。它只是打印收到的数据到标准输出上。</p>
<p>为了观察流控的作用，在每次读取数据之间引入了一个延迟。在这种方式下，读取速度将比写的速度慢很多。当写缓冲满的时候会强制写进程停止写数据。</p>
<p>注意：每次读取数据后如何设置active_once选项以及如何设置packet类型。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(worker_gen)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_call/<span class="number">3</span>, handle_cast/<span class="number">2</span>, handle_info/<span class="number">2</span>,</span></div><div class="line">	 terminate/<span class="number">2</span>, code_change/<span class="number">3</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">(ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"worker_gen:start_link...~n"</span>),</div><div class="line">    gen_server:start_link(?MODULE, [ASocket], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([ASocket])</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"worker_gen:init...~n"</span>),</div><div class="line">    &#123;ok, ASocket&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, ok, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Request, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(&#123;tcp, _S, Data&#125;, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"~p~n"</span>, [Data]),</div><div class="line">    inet:setopts(ASocket, [&#123;active, once&#125;, &#123;packet, line&#125;]),</div><div class="line">    timer:sleep(<span class="number">100</span>),</div><div class="line">    &#123;noreply, ASocket&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(&#123;tcp_closed, _S&#125;, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Closed...~n"</span>),</div><div class="line">    &#123;stop, normal, ASocket&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(timeout, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Closed...~n"</span>),</div><div class="line">    &#123;stop, normal, ASocket&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, ASocket)</span> -&gt;</span></div><div class="line">    io:format(<span class="string">"Terminated...~n"</span>),</div><div class="line">    gen_tcp:close(ASocket),</div><div class="line">    ok.</div><div class="line"></div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<h1 id="代码的运行"><a href="#代码的运行" class="headerlink" title="代码的运行"></a>代码的运行</h1><p>让我们看看代码如何运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 17 [erts-6.1] [<span class="built_in">source</span>] [64-bit] [smp:4:4] [async-threads:10] [hipe]</div><div class="line">[kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V6.1  (abort with ^G)</div><div class="line">1&gt; l(main_sup).</div><div class="line">&#123;module,main_sup&#125;</div><div class="line">2&gt; main_sup:start_link().</div><div class="line">main_sup:init...</div><div class="line">listener_sup:init...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">accept_fsm:start_link...</div><div class="line">accept_fsm:init...</div><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;0.35.0&gt;&#125;</div><div class="line">3&gt;</div></pre></td></tr></table></figure>
<p>我们链接上一个客户端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;0.35.0&gt;&#125;</div><div class="line">worker_gen:start_link...</div><div class="line">worker_gen:init...</div><div class="line">accept_fsm:accept...</div><div class="line">3&gt;</div></pre></td></tr></table></figure>
<p>然后从客户端写一些文本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">accept_fsm:accept...</div><div class="line">listener_sup:start_link...</div><div class="line">listener_sup:init...</div><div class="line">&#123;ok,&lt;<span class="number">0.35</span>.<span class="number">0</span>&gt;&#125;</div><div class="line">worker_gen:start_link...</div><div class="line">worker_gen:init...</div><div class="line">accept_fsm:accept...</div><div class="line"><span class="string">"Hello World!!!\r\n"</span></div><div class="line"><span class="number">3</span>&gt;</div></pre></td></tr></table></figure>
<p>我们来写一大块数据并统计它的用时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time man ls|nc -c localhost 2000</div><div class="line"></div><div class="line">real	0m39.517s</div><div class="line">user	0m0.083s</div><div class="line">sys	0m0.019s</div><div class="line">$</div></pre></td></tr></table></figure>
<p>然后我们再做一次，不过这次我们去掉在每次读取数据之间的延迟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time man ls|nc -c localhost 2000</div><div class="line"></div><div class="line">real	0m0.100s</div><div class="line">user	0m0.085s</div><div class="line">sys	0m0.020s</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这两个测试让我们明白写进程是如何停下来等待缓冲区释放空间的。</p>
<p>在压力测试后，我们检查到没有进程泄露。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">3&gt; supervisor:count_children(main_sup).</div><div class="line">[&#123;specs,2&#125;,&#123;active,2&#125;,&#123;supervisors,2&#125;,&#123;workers,0&#125;]</div><div class="line">4&gt; supervisor:count_children(listener_sup).</div><div class="line">[&#123;specs,3&#125;,&#123;active,3&#125;,&#123;supervisors,0&#125;,&#123;workers,3&#125;]</div><div class="line">5&gt; supervisor:count_children(worker_sup).</div><div class="line">[&#123;specs,1&#125;,&#123;active,0&#125;,&#123;supervisors,0&#125;,&#123;workers,0&#125;]</div><div class="line">6&gt;</div></pre></td></tr></table></figure>
<p>我不太清楚这个解决方案有没有什么我不知道的问题。我尝试遵循我读过的Erlang和Elixir相关书籍中关于这个主题里学到模式。我可能有一些错误的地方，所以请阅读那些相关的书籍来获得关于这一主题的准确解释。</p>
<p>有任何更正、评论和建议请联系我，我很乐意听到你的反馈。</p>
<p>本文到此结束。</p>
<p>祝大家玩得开心。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://jmilet.github.io/erlang/2015/02/15/active_once.html" target="_blank" rel="external">http://jmilet.github.io/erlang/2015/02/15/active_once.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想理解和测试gen_tcp模块使用的active_once选项。整个过程我写了一些代码，包括三个监督者，一个gen_fsm和一个gen_server。&lt;/p&gt;
&lt;p&gt;这是一篇gen_tcp和active_onece选项的概念证明文章。正如我一直说的，这只是我的学习笔记并且我可能是错的。所以查阅OTP文档和其他一些不错的书籍，可以发现关于这一主题的相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="gen_tcp" scheme="http://szpzs.oschina.io/categories/Erlang/gen-tcp/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="gen_tcp" scheme="http://szpzs.oschina.io/tags/gen-tcp/"/>
    
      <category term="active" scheme="http://szpzs.oschina.io/tags/active/"/>
    
      <category term="active-once" scheme="http://szpzs.oschina.io/tags/active-once/"/>
    
      <category term="controlling process" scheme="http://szpzs.oschina.io/tags/controlling-process/"/>
    
      <category term="control flow" scheme="http://szpzs.oschina.io/tags/control-flow/"/>
    
  </entry>
  
  <entry>
    <title>总结2016，展望2017</title>
    <link href="http://szpzs.oschina.io/2016/12/31/2016-Summary/"/>
    <id>http://szpzs.oschina.io/2016/12/31/2016-Summary/</id>
    <published>2016-12-31T13:41:47.000Z</published>
    <updated>2016-12-31T13:59:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/my-road.jpg" style="border:0;"></p>
<h1 align="center">2016年：在路上</h1><br><h1 align="center">2017年：往前走</h1><br><h1 align="center">做时间的朋友</h1>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/my-road.jpg&quot; style=&quot;border:0;&quot;&gt;&lt;/p&gt;
&lt;h1 align=&quot;center&quot;&gt;2016年：在路上&lt;/h1&gt;&lt;br&gt;&lt;h1 align=&quot;center&quot;&gt;2017年：往前走&lt;/h1&gt;&lt;br&gt;&lt;h1 align
    
    </summary>
    
    
      <category term="2016" scheme="http://szpzs.oschina.io/tags/2016/"/>
    
      <category term="2017" scheme="http://szpzs.oschina.io/tags/2017/"/>
    
      <category term="Time" scheme="http://szpzs.oschina.io/tags/Time/"/>
    
      <category term="时间" scheme="http://szpzs.oschina.io/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>纯粹且简单的事务性内存</title>
    <link href="http://szpzs.oschina.io/2016/12/29/pure-and-simple-transaction-memories/"/>
    <id>http://szpzs.oschina.io/2016/12/29/pure-and-simple-transaction-memories/</id>
    <published>2016-12-29T05:22:47.000Z</published>
    <updated>2016-12-29T14:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇纯技术文章。</p>
<p>几个并行的程序如何维护一个状态的一致性视图？我的意思是，两个程序，可能处于不同的国家，如何用一致性方式来操作共同的状态变量？他们如何用一种不需要任何锁的方式来做到这点？</p>
<a id="more"></a>
<p>答案是令人吃惊的简单和不可思议的优美，那就是使用叫做事务性内存的方法。</p>
<h1 id="事务性内存是如何运作的？"><a href="#事务性内存是如何运作的？" class="headerlink" title="事务性内存是如何运作的？"></a>事务性内存是如何运作的？</h1><p>首先我必须解释为什么并发地更新数据会是一个问题。</p>
<p><img src="/images/tm1_problem.0.jpg" style="border:0;"></p>
<p>想像有一个服务器<strong>S</strong>有状态变量<strong>X</strong>和两个客户端<strong>C1</strong>和<strong>C2</strong>。客户端从服务器获取数据（图1）。现在两个客户端都认为<strong>X=20</strong>。<strong>C1</strong>给<strong>X</strong>增加<strong>20</strong>同时<strong>C2</strong>给<strong>X</strong>增加<strong>30</strong>。它们修改它们本地的副本（图2），并且将数据写回服务器（图3和图4）。如果这些操作是一个接一个地进行，那么最后服务器上的X的值应该是70而不是50，很明显现在有问题出现了。</p>
<p>解决此问题的常规方法是在独立的事务发生时锁定服务器，但这种方法正如<a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-dont-like-shared-memory.html" target="_blank" rel="external">我前面一篇文章</a>中指出的一样，它会有问题。</p>
<p>为了允许这些更新并行地执行而且不锁资源，我们可以使用叫做<a href="http://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="external">事务性内存</a>的方法。</p>
<h1 id="事务性内存"><a href="#事务性内存" class="headerlink" title="事务性内存"></a>事务性内存</h1><p><img src="/images/tm2_solution.0.jpg" style="border:0;"></p>
<p>一个事务性内存是一个元组（<strong>Var</strong>,<strong>Version</strong>,<strong>Value</strong>）的集合。如上图，X的版本是1而值是20，Y的版本是6而值是true。</p>
<p>版本数字表示这个变量被修改的次数。</p>
<p>现在我们来尝试做一个事务操作。假设我们想修改<strong>X</strong>和<strong>Y</strong>。首先我们给服务器发送消息：<strong>{get,X,Y}</strong>，服务器返回两个变量的值和它们各自的版本数字。</p>
<p>修改变量后，我们向服务器发送消息：{put,(X,1,30),(Y,6,false)}。仅当所有变量的版本数字与服务器中的变量的版本数字匹配，服务器将接收这个消息。然后服务器接受变量的修改并回复消息：<strong>yes</strong>。如果任何变量的版本数字不匹配，则服务器回复消息：<strong>no</strong>。</p>
<p>很明显，如果第二个进程在第一个进程回答之前更新内存，那么版本号将不一致，更新将失败。</p>
<p>请注意，该算法不锁定数据而且在一个分布式的环境中工作得很好，客户端和服务器处于物理上不同的机器上，这些机器之间的传输延迟是未知的。</p>
<p><strong>这不正是很好而且很老的基于set操作之上归纳出来的test-and-set操作吗？</strong></p>
<p>是的，当然是。如果你想想他们如何用信号量实现互斥的就明白了。信号量用一个原子的<strong>test-and-set</strong>指令来实现。一个信号量的值只能为0或1。test-and-set操作就是说，如果这个变量的值是0那么就把它的值改为1，这个操作是原子性的。要保留一个关键区域，它由一个标志保护。如果标志为0，那么它可以被保留，如果标志为1，那么它可以被使用。为了避免两个进程同时保留这个关键区域，test-and-set操作必须是原子性的。事务性内存只是概括了这个方法。</p>
<p>现在让我们用Erlang来实现它。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(tm)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, addVar/<span class="number">2</span>, getVars/<span class="number">2</span>, putVars/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% new() -&gt; Pid</span></div><div class="line"><span class="comment">%%   创建一个新的事务性内存 (TM)</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% addVar(Pid, Var) -&gt; ok</span></div><div class="line"><span class="comment">%%   增加一个变量到事务性内存</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% getVars([V1,...]) -&gt; [&#123;Vsn,Data&#125;,....]</span></div><div class="line"><span class="comment">%%   在事务性内存里查询变量V1，V2，...</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% putVars([&#123;Var,Vsn,Data&#125;]) -&gt; Bool</span></div><div class="line"><span class="comment">%%   修改事务性内存里的变量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">%% 下面是一个运行的例子</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% 1&gt; c(tm).</span></div><div class="line"><span class="comment">%% &#123;ok,tm&#125;</span></div><div class="line"><span class="comment">%% 2&gt; P=tm:new().</span></div><div class="line"><span class="comment">%% &lt;0.47.0&gt;</span></div><div class="line"><span class="comment">%% 3&gt; tm:addVar(x).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 4&gt; tm:addVar(P,x).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 5&gt; tm:addVar(P,y).</span></div><div class="line"><span class="comment">%% ok</span></div><div class="line"><span class="comment">%% 6&gt; tm:getVars(P, [x,y]).</span></div><div class="line"><span class="comment">%% [&#123;ok,&#123;0,void&#125;&#125;,&#123;ok,&#123;0,void&#125;&#125;]</span></div><div class="line"><span class="comment">%% 7&gt; tm:putVars(P, [&#123;x,0,12&#125;,&#123;y,0,true&#125;]).</span></div><div class="line"><span class="comment">%% yes</span></div><div class="line"><span class="comment">%% 8&gt; tm:putVars(P, [&#123;x,1,25&#125;]).</span></div><div class="line"><span class="comment">%% yes</span></div><div class="line"><span class="comment">%% 9&gt; tm:getVars(P, [x,y]).</span></div><div class="line"><span class="comment">%% [&#123;ok,&#123;2,25&#125;&#125;,&#123;ok,&#123;1,true&#125;&#125;]</span></div><div class="line"><span class="comment">%% 10&gt; tm:putVars(P, [&#123;x,1,15&#125;]).</span></div><div class="line"><span class="comment">%% no</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span> spawn(<span class="keyword">fun</span>() -&gt; loop(dict:new()) <span class="keyword">end</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">addVar</span><span class="params">(Pid, Var)</span> -&gt;</span> rpc(Pid, &#123;create, Var&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">getVars</span><span class="params">(Pid, Vgs)</span> -&gt;</span> rpc(Pid, &#123;get, Vgs&#125;).</div><div class="line"></div><div class="line"><span class="function"><span class="title">putVars</span><span class="params">(Pid, New)</span> -&gt;</span> rpc(Pid, &#123;put, New&#125;).</div><div class="line"></div><div class="line"><span class="comment">%% 内部函数</span></div><div class="line"><span class="comment">%%</span></div><div class="line"><span class="comment">%% 远程过程调用（RPC）</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Q)</span> -&gt;</span></div><div class="line">   Pid ! &#123;self(), Q&#125;,</div><div class="line">   <span class="keyword">receive</span></div><div class="line">       &#123;Pid, Reply&#125; -&gt; Reply</div><div class="line">   <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(Dict)</span> -&gt;</span></div><div class="line">   <span class="keyword">receive</span></div><div class="line">     &#123;From, &#123;get, Vars&#125;&#125; -&gt;</div><div class="line">        Vgs = lists:map(<span class="keyword">fun</span>(I) -&gt;</div><div class="line">                 dict:find(I, Dict) <span class="keyword">end</span>, Vars),</div><div class="line">        From ! &#123;self(), Vgs&#125;,</div><div class="line">        loop(Dict);</div><div class="line">     &#123;From, &#123;put, Vgs&#125;&#125; -&gt;</div><div class="line">        <span class="keyword">case</span> update(Vgs, Dict) <span class="keyword">of</span></div><div class="line">        no -&gt;</div><div class="line">                From ! &#123;self(), no&#125;,</div><div class="line">                  loop(Dict);</div><div class="line">        &#123;yes, Dict1&#125; -&gt;</div><div class="line">                From ! &#123;self(), yes&#125;,</div><div class="line">                loop(Dict1)</div><div class="line">        <span class="keyword">end</span>;</div><div class="line">    &#123;From, &#123;create, Var&#125;&#125; -&gt;</div><div class="line">       From ! &#123;self(), ok&#125;,</div><div class="line">       loop(create_var(Var, Dict))</div><div class="line">   <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">update</span><span class="params">([&#123;Var,Generation,Val&#125;|T], D)</span> -&gt;</span></div><div class="line">    &#123;G, _&#125; = dict:fetch(Var, D),</div><div class="line">    <span class="keyword">case</span> Generation <span class="keyword">of</span></div><div class="line">     G -&gt; update(T, dict:store(Var, &#123;G+<span class="number">1</span>, Val&#125;, D));</div><div class="line">     _  -&gt; no</div><div class="line">    <span class="keyword">end</span>;</div><div class="line"><span class="function"><span class="title">update</span><span class="params">([], D)</span> -&gt;</span></div><div class="line">    &#123;yes, D&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">create_var</span><span class="params">(Var, Dict)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> dict:find(Var, Dict) <span class="keyword">of</span></div><div class="line">   &#123;ok, _&#125; -&gt; Dict;</div><div class="line">   error -&gt; dict:store(Var, &#123;<span class="number">0</span>,void&#125;, Dict)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/09/pure-and-simple-transaction-memories.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/09/pure-and-simple-transaction-memories.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是一篇纯技术文章。&lt;/p&gt;
&lt;p&gt;几个并行的程序如何维护一个状态的一致性视图？我的意思是，两个程序，可能处于不同的国家，如何用一致性方式来操作共同的状态变量？他们如何用一种不需要任何锁的方式来做到这点？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="transaction memories" scheme="http://szpzs.oschina.io/categories/Erlang/transaction-memories/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="transaction memories" scheme="http://szpzs.oschina.io/tags/transaction-memories/"/>
    
  </entry>
  
  <entry>
    <title>为什么我不喜欢共享内存</title>
    <link href="http://szpzs.oschina.io/2016/12/26/why-i-dont-like-shared-memory/"/>
    <id>http://szpzs.oschina.io/2016/12/26/why-i-dont-like-shared-memory/</id>
    <published>2016-12-26T13:07:19.000Z</published>
    <updated>2016-12-26T13:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我上一篇博文《<a href="http://armstrongonsoftware.blogspot.com/2006/08/concurrency-is-easy.html" target="_blank" rel="external">并发是容易的</a>》里，我写了关于编写并发系统的一个简单模型。当你写博客的时候，你必须考虑目标受众和你想把博客定位在哪个级别上。它应该是技术先进的，还是应该普及你想谈论的观点？</p>
<a id="more"></a>
<p>我选择了用一个明显的非技术性的方式来谈论并发，我用人们互相交谈来类比并发这个概念。在我的博文里，我认为进程应该表现得很像人。人有私有的记忆并通过消息传递来改变自己的私有记忆。</p>
<p>现在对此文的反应超出了我的预料。首先很多人读我写的东西，这是一个惊喜。几乎没有宣传的情况下，这篇文章达到programming.reddit.com所有文章的第三位。事实上，上个星期三，排名reddit.com编程文章前五位的文章有三篇是关于Erlang的。其次，在reddit.com上有一个关于我这篇博文的讨论开始了。</p>
<p>在这里，我将回答在讨论里提出的第一个问题：</p>
<blockquote>
<p>Dogger说：</p>
<blockquote>
<p>我不太清楚为什么没有共享的内存会如此厉害。他抛出的简单的一问一答消息的例子并不是许多程序的工作机制。我认为发送消息有其地位，共享内存也一样。选择哪一个是最合适的。</p>
</blockquote>
</blockquote>
<p>很棒的评论！我们认为理所当然的事情是我们觉得最不需要解释的事情。现在我认为共享内存是错误的。在过去的二十年里，我一直这样认为，我认为这是不证自明的，而且从来没有真正解释为什么我认为共享内存是一个坏主意。所以在下面我将给出一些为什么我不喜欢共享内存的原因。</p>
<p>Dogger的第二个评论是：“他的例子…并不真正是很多程序的工作机制”，他这个评论当然是正确的。许多程序并不以我建议的方式来运行。关键点是这些程序可以用不同的编程风格编写，完全避免了共享内存和锁，并且利用了细粒度并发和纯消息传递。我也相信这样的程序更容易写和理解，因为我下面列出的所有与共享内存有关的问题都被避免了。请注意，我没有表明我有一个解决任何如下问题的方案。但我会说，这样的问题可以使用不同的编程风格来完全避免。</p>
<p>现在我将开始讲讲为什么我不喜欢共享内存：</p>
<h1 id="问题1：在关键区域崩溃的程序"><a href="#问题1：在关键区域崩溃的程序" class="headerlink" title="问题1：在关键区域崩溃的程序"></a>问题1：在关键区域崩溃的程序</h1><p>当两个或更多程序想要共享内存的时候下面的方法通常被用到。任何程序想操作共享内存必须如下列出的步骤来做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.操作共享内存</div><div class="line">3.释放这个锁</div></pre></td></tr></table></figure>
<p>获取锁之后和释放锁之前程序运行的代码被成为<em>关键区域</em>。在关键区域里的程序在运行期间不应该崩溃，而且在关键区域内不应该花太多时间。</p>
<p>如果程序在关键区域内崩溃的话会发生什么？</p>
<p>如果出现这种情况，则事情会变得很复杂。在理想的世界里，我们想要有这样的事务语义，即程序运行的净效应将是关键区域内的所有内存的改变都成功了，或者没有一个内存的改变成功并且内存的状态和程序进入关键区域前相同。</p>
<p>假设A尝试修改10个内存区域，这些区域叫做M1、M2…M10，那么程序假设如下所列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.修改 M1</div><div class="line">3.修改 M2</div><div class="line">4....</div><div class="line">5.修改 M10</div><div class="line">6.释放这个锁</div></pre></td></tr></table></figure>
<p>但是实际上可能是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.获取一个锁</div><div class="line">2.修改 M1</div><div class="line">3.修改 M2</div><div class="line">4.崩溃</div></pre></td></tr></table></figure>
<p>我们运行A想要的结果是，要么M1到M10的修改都成功，要么M1到M10的修改都不成功。因此，在上述第4步崩溃时，我们希望撤消前两个内存修改的结果。</p>
<p>要做到这点非常复杂，要假设有一些监督者程序在崩溃事件里能侦测到线程的崩溃并且恢复内存到原始状态。</p>
<h1 id="问题2：程序在关键区域花费太多时间"><a href="#问题2：程序在关键区域花费太多时间" class="headerlink" title="问题2：程序在关键区域花费太多时间"></a>问题2：程序在关键区域花费太多时间</h1><p>当一个程序位于一个关键区域内时，会发生很多事情，它可以操纵内存，这就是为什么它必须首先处于关键区域；并且它可以执行计算。问题是，这些计算发生时，该程序是在关键区域内。因此，如果这些计算需要很长的时间，那么等待访问共享内存的所有其他程序都将被排队，直到当前程序离开关键区域为止。</p>
<p>写在关键区域内执行的代码是非常困难的，因为我们要避免非常耗时的计算并将它们移到关键区域之外。我们还必须删除关键区域中的远程过程调用之类的东西，以防它们突然占用太长时间。所有这一切都是非常不自然的编程方式，很难难得到正确的结果。</p>
<h1 id="问题3：锁得太多"><a href="#问题3：锁得太多" class="headerlink" title="问题3：锁得太多"></a>问题3：锁得太多</h1><p>非常不幸地是我们经常锁的内存比我们想要的多得多，程序通常都是锁住所有共享内存，却只操作其中的一小段。在允许指针直接修改内存的语言中，可以保护的最小内存大小由页面表的粒度决定。一个典型的页面大小可能在8k到64k字节范围。8k字节的页面，你可能只想保护一个单字节，但你不得不保护最少8k字节。</p>
<p>您的程序可能只需要保护1字节，而系统中的其他程序可能希望修改在同一页的其他部分的内存，但它们必须等待，直到你的程序离开这个关键区域，它们才可以操纵他们相关的内存部分。</p>
<p>现在这一点在一个单CPU上可能并不重要，不同的线程都运行在同一个CPU，CPU总是忙，至少它在做一些事情。但在多核处理器上，这一点确实很重要。在多核CPU上，许多进程会等待获取锁，尽管逻辑上所有这些CPU可以并行运行。</p>
<p>当然，我们可以将共享内存划分成不同的分区，并让程序锁定到他们感兴趣的内存部分，但这样编程变得更加困难。</p>
<h1 id="问题4：分布式共享内存"><a href="#问题4：分布式共享内存" class="headerlink" title="问题4：分布式共享内存"></a>问题4：分布式共享内存</h1><p>现在事情变得真正复杂了。在单个主板上真正只有一个内存可以被不同的CPU访问，但在一个集群或在网络分布式系统，这是不可行的。真正发生的是，系统中的每个节点都有自己的内存，并且读写和锁被应用到本地内存。在任何一个系统中，其中一个内存必须承担某种主导角色，系统中的其他内存承担次要角色，并表现为高速缓存。然后在不同的内存之间运行某种缓存一致性协议，以确保访问该存储器的所有进程具有一致的世界观。</p>
<p>现在所有这一切是非常难以实现的。所以在这一点上，大多数程序员只有放弃并且使用容错分布式数据库。这种数据库通常是相当缓慢的，因为它必须在后台做很多复杂的东西。</p>
<h1 id="问题5：共享限制可扩展性"><a href="#问题5：共享限制可扩展性" class="headerlink" title="问题5：共享限制可扩展性"></a>问题5：共享限制可扩展性</h1><p>共享数据的线程不能独立地和并行地运行。在一个单核CPU上无所谓，但是在一个多核CPU上就有问题了。在线程共享数据的地方执行，它们的执行变成串行而不是并行。线程中的关键区域引入了限制可扩展性的串行瓶颈。</p>
<p>如果我们真的想要高性能，我们必须确保我们的应用程序不共享任何数据，这样我们就可以在许多独立的CPU上复制我们的解决方案。</p>
<h1 id="问题6：共享可以引入死锁"><a href="#问题6：共享可以引入死锁" class="headerlink" title="问题6：共享可以引入死锁"></a>问题6：共享可以引入死锁</h1><p>有时我们试图通过某种形式的细粒度共享来增加并发性。我们的想法是，不是锁定我们所有的内存，而是把内存分成更小的区域，只锁定那些我们感兴趣的内存。现在想象两个线程P和Q想要访问内存区域A和B。假设P锁定内存区域A，然后等待内存区域B，而Q刚好相反，即它先锁定B然后等待A。这导致死锁，P和Q现在无限期暂停。</p>
<h1 id="问题7：共享使得系统容易出错和调试困难"><a href="#问题7：共享使得系统容易出错和调试困难" class="headerlink" title="问题7：共享使得系统容易出错和调试困难"></a>问题7：共享使得系统容易出错和调试困难</h1><p>假设两个线程A和B共享数据。在A里的一个错误能够覆盖B使用的数据。即使B的代码都是正确的，它可能也会崩溃，因为它操作的数据结构被A破坏了。那么所有的系统应该完美地服从 <strong>我的程序不应该能够搞崩溃你的程序</strong>  这样的规则，但是当程序可以共享数据的情况下，这样的规则显然不成立。</p>
<p>调试变得可怕。线程B已经崩溃了，所以假定线程B的代码是不正确的似乎是合理的。这个假设是错误的，因为线程A的代码可能是祸因。这种因果分离使得调试非常困难。</p>
<p>最后，一个更普遍的评论是：</p>
<p><strong>共享不存在于现实世界中</strong></p>
<p>我以前是一个物理学家。在经典物理学中同时忽略量子效应情况下，现实世界中的两个物体不能同时存在于同一地点。</p>
<p>如果我们有两个物体，它们必须在不同的地方。现在，一个对象可以与另一个对象交互的唯一方式就是发送一条消息（比如说用光线）。如果光线编码一些关于状态变化的信息，那么就关心状态变化的接收对象而言，状态的变化只有在它消息收到后它才知道。</p>
<p>在简单的相对论里，同时发生的概念是不存在的。</p>
<p>关键点是现实中的对象不共享状态，我相信在软件中建模现实中不存在的东西不是一个好主意。</p>
<p>事实上您需要共享和锁来实现并行软件的想法是错误的。一切可以用共享和锁实现的，也可以用纯消息传递和无锁来实现。这就是<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>的方式。</p>
<p>在未来的博文中，我将告诉你如何做一个事务内存，它提供了一个无锁的方法在并行进程集里实现细粒度的状态一致性。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/09/why-i-dont-like-shared-memory.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/09/why-i-dont-like-shared-memory.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我上一篇博文《&lt;a href=&quot;http://armstrongonsoftware.blogspot.com/2006/08/concurrency-is-easy.html&quot;&gt;并发是容易的&lt;/a&gt;》里，我写了关于编写并发系统的一个简单模型。当你写博客的时候，你必须考虑目标受众和你想把博客定位在哪个级别上。它应该是技术先进的，还是应该普及你想谈论的观点？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="shared-memory" scheme="http://szpzs.oschina.io/categories/Erlang/shared-memory/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="shared-memory" scheme="http://szpzs.oschina.io/tags/shared-memory/"/>
    
  </entry>
  
  <entry>
    <title>并发是容易的</title>
    <link href="http://szpzs.oschina.io/2016/12/25/concurrency-is-easy/"/>
    <id>http://szpzs.oschina.io/2016/12/25/concurrency-is-easy/</id>
    <published>2016-12-25T10:28:54.000Z</published>
    <updated>2016-12-25T10:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们了解并发。</p>
<p>对并发的深入理解已经深植于我们的大脑。我们对刺激的反应非常迅速，这由大脑的被称为杏仁核的一部分负责，没有这个反应系统我们可能会死掉。有意识的想法太慢了，当“刹车”的想法形成的时候，我们已经那么做完了。</p>
<a id="more"></a>
<p><img src="/images/many_cars.0.jpg" style="border:0;"></p>
<p>在高速公路，我潜意识地判断几十或数百辆汽车的位置，这样做是没有经过有意识的思考的。如果我不能这样做，我可能会死掉。</p>
<h1 id="世界是并行的"><a href="#世界是并行的" class="headerlink" title="世界是并行的"></a>世界是并行的</h1><p>如果我们想写的程序的行为和真实世界里事物的行为一样，那么这些程序将有一个并发的结构。</p>
<h1 id="这就是为什么我们应该用并发的编程语言编程"><a href="#这就是为什么我们应该用并发的编程语言编程" class="headerlink" title="这就是为什么我们应该用并发的编程语言编程"></a>这就是为什么我们应该用并发的编程语言编程</h1><p>然而，大多数情况下，我们用顺序的编程语言编程现实世界的应用程序。这肯定很困难。</p>
<p>用被设计为编写并发应用程序的语言（比如<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>）来编程，那么并发编程会变得容易很多。</p>
<h1 id="Erlang程序模型，我们如何思考和交互"><a href="#Erlang程序模型，我们如何思考和交互" class="headerlink" title="Erlang程序模型，我们如何思考和交互"></a>Erlang程序模型，我们如何思考和交互</h1><p>我们没有共享记忆。我有我的记忆，你有你的记忆，我们俩一共有两个大脑，彼此独立，它们不连在一起。为了要改变你的记忆，通过说话或挥动我的手臂的方式我发一个消息给你。你听到或看到，然后你的记忆改变了。但是如果我不问你或者不观察你的反应，我就不知道你是否收到了我发给你的消息。</p>
<p>Erlang进程也是如此。Erlang进程没有共享内存。每个进程有它自己的内存。为了改变其他进程的内存，你必须发送消息给它们并希望它们收到而且理解你发的消息的意思。</p>
<p>为了确认其他进程收到你的消息并改变了它的内存，你必须问它们（通过发送一条消息）。这正是我们人类如何彼此交互的方式。</p>
<p>苏：“嗨，比尔，我的电话号码是45 67 89 12”。</p>
<p>苏：“你听见了吗？”。</p>
<p>比尔：“收到，你的电话号码是45 67 89 12”。</p>
<p>这些互动模式对于我们来说非常熟悉，从出生开始，我们通过观察外部世界，并且通过发送信息给外部世界同时通过观察外部世界的反馈来学习与外部世界交互。</p>
<h1 id="人们作为独立实体通过发送消息进行交互"><a href="#人们作为独立实体通过发送消息进行交互" class="headerlink" title="人们作为独立实体通过发送消息进行交互"></a>人们作为独立实体通过发送消息进行交互</h1><p>这就是Erlang进程的工作方式，也是我们的工作方式，所以我们可以非常容易理解Erlang程序。</p>
<p>Erlang程序由许多小进程组成，这些进程之间总在喋喋不休的交流，就像我们人类。</p>
<p>一个Erlang程序由数十，可能数千，甚至数十万小进程组成。所有这些进程独立地运行。它们彼此通过发送消息来交流。每个进程有自己的私有内存。它们的行为就像一座大房子里的人们一样彼此通过聊天来交流。</p>
<p>这使得Erlang程序天生就容易管理和扩展。假设我们有十个人（进程），他们有太多的工作要做，我们该如何处理？答案就是让更多的人来做。我们怎么管理这些人？简单地朝他们喊指令就行（广播）。</p>
<p>Erlang进程没有共享内存，所以当一块内存被使用的时候就没必要给它上锁。有锁就需要钥匙，只要有锁，就有可能某天会丢失钥匙。当你丢了钥匙，会怎么样？你会惊慌失措。</p>
<p>有锁和钥匙的分布式软件系统总是出错。</p>
<h1 id="如果有人死了，其他人会注意到"><a href="#如果有人死了，其他人会注意到" class="headerlink" title="如果有人死了，其他人会注意到"></a>如果有人死了，其他人会注意到</h1><p>我在一个房间里，突然倒下死了，别人可能会注意到，至少我希望是如此。Erlang进程和我们人是一样的，他们有时也会死。不像人们死去时那样，Erlang进程在它们最后一口气的时候会大声喊出他们到底死于什么。</p>
<p>想象一个有很多人的房间，突然一个人倒下并死掉。就在他死亡的一刻，他说，“我死于心脏病”，或者，“我死于胃出血”。这就是Erlang进程的做法。一个进程死的时候可能会说：“我死于被要求被零除”，另一个进程死的时候可能会说：“我死于被要求查询空列表的最后一个元素是什么”。</p>
<p>现在在我们这个很多人的房间里，我们可以想象有一些人被特别地赋予清理尸体的特殊工作。假设有两个人，简和约翰。如果简死了，约翰会处理简的后事。如果约翰死了，简会处理约翰的后事。简和约翰被一个看不见的约定联系在一起，只要他们中的一个死亡，另一个就会处理后事。</p>
<p>这就是Erlang的错误发现机制，进程可以被链接在一起。如果其中一个进程死掉，其他进程会获得一个错误消息，这个消息告诉他们死亡进程的死亡原因。</p>
<p>基本上就是这样的。</p>
<p>这就是Erlang程序的工作机制。</p>
<h1 id="到目前为止我们学到了什么"><a href="#到目前为止我们学到了什么" class="headerlink" title="到目前为止我们学到了什么"></a>到目前为止我们学到了什么</h1><p>Erlang程序由许多进程组成。这些进程彼此之间可以发送消息。这些消息可能会或可能不会被接收和理解。如果你想知道消息是否被接收和理解，你必须给进程发送一条消息并等待回复。</p>
<p>进程可以被链接在一起。如果链接中的一个进程死掉，其他的进程会被发送一条包含这个进程为什么死掉的消息。</p>
<p>这个简单的编程模型是被我称为面向并发编程模型的一部分。你可以在<a href="http://www.sics.se/~joe/thesis" target="_blank" rel="external">这里</a>参阅更多信息。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2006/08/concurrency-is-easy.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2006/08/concurrency-is-easy.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们了解并发。&lt;/p&gt;
&lt;p&gt;对并发的深入理解已经深植于我们的大脑。我们对刺激的反应非常迅速，这由大脑的被称为杏仁核的一部分负责，没有这个反应系统我们可能会死掉。有意识的想法太慢了，当“刹车”的想法形成的时候，我们已经那么做完了。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="concurrency" scheme="http://szpzs.oschina.io/categories/Erlang/concurrency/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="concurrency" scheme="http://szpzs.oschina.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>我们没有走过的路</title>
    <link href="http://szpzs.oschina.io/2016/12/24/road-we-didnt-go-down/"/>
    <id>http://szpzs.oschina.io/2016/12/24/road-we-didnt-go-down/</id>
    <published>2016-12-24T04:58:03.000Z</published>
    <updated>2016-12-24T05:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直在关注Erlang邮件列表里的一个有趣的讨论，在这个讨论里，Steve Vinoski和朋友们告诉我们RPC的问题是什么。</p>
<p>讨论开始在5月22日，共同话题是facebook宣布已部署了一个用Erlang写的聊天服务器。</p>
<p>在其中的一个帖子里Steve写道：</p>
<a id="more"></a>
<blockquote>
<p>“所有那些年的 CORBA 经验教给我的，也就是那个RPC，因为一些原因，总的来说它是一个<strong>真正的坏主意</strong>。它是一个来之不易的教训。Erlang 的 RPC 是很棒的，因为整个 Erlang 系统从根本上设计并将其内置到语言中，但对于普通的语言，RPC 带来的问题比它解决的问题多。”<br><a href="http://www.erlang.org/pipermail/erlang-questions/2008-May/035191.html" target="_blank" rel="external">更多…</a><br>– Steve Vinoski</p>
</blockquote>
<p>后续的帖子要求Steve详细阐述这点。</p>
<p>Steve在Erlang邮件列表里发了一篇很长并且精彩的关于RPC问题总结的帖子：</p>
<blockquote>
<p>“但是如果你没有时间或精力，最根本的问题是，RPC试图使得一个分布式调用看起来像一个本地调用。这是行不通的，因为在分布式系统中的错误模式完全不同于本地系统中的错误模式，……”<br><a href="http://www.erlang.org/pipermail/erlang-questions/2008-May/035207.html" target="_blank" rel="external">更多…</a><br>– Steve Vinoski</p>
</blockquote>
<p>精辟！是的，是的，是的。当我读到这个，我的大脑大叫：是的，是的，是的 - 谢谢你，史提夫。史提夫在《<a href="http://steve.vinoski.net/pdf/IEEE-RPC_Under_Fire.pdf" target="_blank" rel="external">RPC Under Fire</a>》里关于这点写了更多。</p>
<h1 id="这是一条我们没走过的路"><a href="#这是一条我们没走过的路" class="headerlink" title="这是一条我们没走过的路"></a>这是一条我们没走过的路</h1><p>Steve沿着这条路走，看见一些事情，也看到它非常糟糕的地方，但他活着回来，可以告诉我们他所看见的事情。</p>
<p>调用一个远程操作并且包装它看起来像一个本地操作的根本问题是本地的错误模式和远程操作的错误模式是完全不同的。</p>
<p>如果这还不够糟糕，性能方面也完全不同。本地的操作需要几微秒，当通过一个RPC执行的时候，可能忽然就花掉几毫秒。</p>
<p>如果程序员不能判断本地和远程调用之间的不同，那么要写出高效的代码基本不可能。随意放置RPC在一些乱七八糟的软件中可以（必定）破坏性能。</p>
<blockquote>
<p>我亲眼见证了几个大型项目的失败，正是因为本地和远程过程调用之间的区别还不清楚。</p>
</blockquote>
<p>注意：这个因素在有几十个程序员参与的大项目里变得更糟糕。如果是一个小团队，则还有机会挽救，这需要参与者清楚哪些是本地调用，哪些是是远程调用。</p>
<h1 id="在Erlang的世界我们是如何做的？"><a href="#在Erlang的世界我们是如何做的？" class="headerlink" title="在Erlang的世界我们是如何做的？"></a>在Erlang的世界我们是如何做的？</h1><p>所有Erlang程序是由并行进程集合组成的，这些进程可以创建其他进程并且发送和接收消息。这么做非常简单而且是一个轻量操作。</p>
<p>为了错误处理的目的，进程可以彼此链接在一起。如果A链接到B并且A崩溃了，那么B会被发送一个错误信号，反之亦然。链接机制与消息发送/接收机制完全正交。</p>
<p>当我们编写分布式系统，各种形式的RPC通常是非常有用的编程抽象，但RPC的确切形式因问题不同而不同，也因系统架构不同而不同。</p>
<p>RPC的确切形式凝固成一个刚性框架，不顾错误场景是场灾难。</p>
<p>用发送、 接收和链接，Erlang 程序员可以很容易把自定义错误处理“揉进他们自己的RPC”。</p>
<p>在Erlang里没有“标准PRC存根生成器”，Erlang也没有聪明到有一个如此的生成器。</p>
<p>在很多应用里，RPC尽可能最简单的形式就够了，我们可以定义它如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">     &#123;Pid, Response&#125; -&gt;</div><div class="line">        Response</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这一点都不复杂。这段代码只是发送一条消息然后等待回复。</p>
<p>在这个主题上有很多的变化。最简单的RPC将永远等待下去，所以如果回复一直不来的话，客户端就会挂起。我们可以用增加超时来修复这个问题：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request, Time)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    &#123;Pid, Response&#125; -&gt;</div><div class="line">        &#123;ok, Response&#125;</div><div class="line">    <span class="keyword">after</span> Time -&gt;</div><div class="line">        &#123;error, timeout&#125;</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>假设我们希望在一个PRC调用中远程机器死掉的时候一个异常在客户端被抛出，那么我们可以写如下代码：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></div><div class="line"> link(Pid),</div><div class="line"> Pid ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    Response -&gt;</div><div class="line">        Response</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>如果在RPC里有任何差错的话，附加的链接将确保客户端终止。</p>
<p>假设我们想要“并行化两个RPC”，则代码如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid1, Pid2, Request)</span> -&gt;</span></div><div class="line"> Pid1 ! Pid2 ! &#123;self(), Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">    &#123;Pid1, Response1&#125; -&gt;</div><div class="line">        <span class="keyword">receive</span></div><div class="line">            &#123;Pid2, Response2&#125; -&gt;</div><div class="line">                &#123;Response1, Response2&#125;</div><div class="line">        <span class="keyword">end</span></div><div class="line">     <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>（不用担心这段代码的执行，消息的回复顺序是无关紧要的。）</p>
<p>我想通过一些小例子来说明的观点是，RPC的粒度级别和错误特性是在编程人员的精确控制下的。</p>
<p>如果事实证明这些RPC的抽象不是我们真正想要的，然后我们可以很容易地用原始的进程和消息方式来写我们的解决方案。</p>
<p>所以，例如，从一个消息序列图得到Erlang代码是一个简单的编程工作。</p>
<p>“标准”的RPC也做以下的疯狂的假设”，回复应该一定返回到客户”。</p>
<p>互相合作的形式，比如告诉X做Y然后发送结果到Z，这种形式是不可能用一个标准的 RPC 框架（如 SOAP)来表达的，但在Erlang中表达却很简单︰</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(tell,X,toDo,Y,replyTo,Z)</span> -&gt;</span></div><div class="line"> X ! &#123;Z, Y&#125;.</div></pre></td></tr></table></figure>
<p>（这里假设约定我前面一直用发送两个元素的元组当作消息，其中有进程的Id，它被期待当作回复消息的元组的第一元素（在前面的例子例我们用self()，这样就强制要求回复消息返回给原请求者））</p>
<p>假设我们要加版本信息到我们的协议，这也很容易做到：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request, Vsn)</span> -&gt;</span></div><div class="line"> Pid ! &#123;self(), vsn, Vsn, Request&#125;,</div><div class="line"> <span class="keyword">receive</span></div><div class="line">     ...</div><div class="line"> <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>关键点是，这里展示的事情，比如像版本信息、错误处理平行化等等都是容易添加的，只要我们暴露消息和函数调用之间的接口并允许用户定制构建他们自己和远程代码的交互形式。</p>
<p>当然，组件间交互的一定通用模式将浮现，它们被加入OTP库。</p>
<h1 id="什么是OTP？"><a href="#什么是OTP？" class="headerlink" title="什么是OTP？"></a>什么是OTP？</h1><p>OTP是在相当常见的场景下像RPC一样做事的一套久经测试验证的方法。OTP方法没有覆盖所有错误场景，不过它们覆盖了通常的场景。我们经常需要跨出OTP框架外设计我们自己特定的错误和恢复策略，不过做这些都很简单，因为OTP它自己是一个消息驱动的框架，所有我们必须要做的是去掉那些存根函数，用我们自己定制的函数来替换它们来发送和接收消息。</p>
<p>OTP应该重新命名为“OTP on rails”，它真的只是一个构建容错系统的框架。</p>
<p>这种没有过度依赖一个特别的RPC方式来构建软件的方法可行吗？</p>
<p>我的回答是可行的，而且肯定可行。</p>
<p>我们用这种方式构建实时服务器软件在爱立信已经有几十年了。我们已经用PLEX, EriPascal, Erlang 和 C++ with Rose-RT好多年了。所有这些的共同点就是不依赖RPC。我们指定协议，然后我们用一些不同的技术实现它们。</p>
<p>这些协议比指定使用的RPC是更复杂的方式，但是通过暴露协议和错误模式，我们可以使得系统高可用。</p>
<p>我一直认为如果我们用RPC来做事情，我们会遇到麻烦。</p>
<p>Steve这么做过也遇到了这些问题，而我们走的是不同的路。</p>
<p>真正有趣的是，史提夫的世界和我们的世界开始碰撞-我们有很多东西要互相学习。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://armstrongonsoftware.blogspot.com.ar/2008/05/road-we-didnt-go-down.html" target="_blank" rel="external">http://armstrongonsoftware.blogspot.com.ar/2008/05/road-we-didnt-go-down.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直在关注Erlang邮件列表里的一个有趣的讨论，在这个讨论里，Steve Vinoski和朋友们告诉我们RPC的问题是什么。&lt;/p&gt;
&lt;p&gt;讨论开始在5月22日，共同话题是facebook宣布已部署了一个用Erlang写的聊天服务器。&lt;/p&gt;
&lt;p&gt;在其中的一个帖子里Steve写道：&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="RPC" scheme="http://szpzs.oschina.io/categories/Erlang/RPC/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="RPC" scheme="http://szpzs.oschina.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>在Erlang里用进程保存状态</title>
    <link href="http://szpzs.oschina.io/2016/12/19/storing-state-in-erlang-with-processes/"/>
    <id>http://szpzs.oschina.io/2016/12/19/storing-state-in-erlang-with-processes/</id>
    <published>2016-12-19T08:57:00.000Z</published>
    <updated>2016-12-19T09:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>状态是我们如何使程序做不平凡的事情。如果我们正在写一个电子游戏，它的一个状态可能是一个被打败的坏人的数字。在大多数编程语言中，我们将通过将计数分配给变量，然后在每次新的坏人被击败时更新这个值来实现这一点。然而，一旦变量已经被赋值（单次赋值），Erlang不允许我们修改这个变量的值。那么如果我们不能够改变一个变量的值，我们如何在Erlang里跟踪状态？答案是：用进程。</p>
<a id="more"></a>
<h1 id="单次赋值"><a href="#单次赋值" class="headerlink" title="单次赋值"></a>单次赋值</h1><p>Erlang从单次赋值中获得很多的能力。单次赋值意味着，一旦一个值被赋予一个变量，则没有其他值可以被赋予这同一个变量。在许多Erlang的教程里你可以看到像如下一样的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; X = <span class="number">1</span>.</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span>&gt; X = <span class="number">2</span>.</div><div class="line">** exception error: no match <span class="keyword">of</span> right hand side value <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在第一步，Erlang尝试用值1<a href="http://learnyousomeerlang.com/syntax-in-functions" target="_blank" rel="external">模式匹配</a>X。因为X没有被绑定，所以它被绑定到值1。从现在开始，当X在模式匹配操作符的左手边的时候，普通的模式匹配就会发生。这就是为什么我们在第二步得到一个错误 - Erlang尝试用值2去和已经有值为1的X匹配，因此引起一个无法匹配的错误。我们依然可以匹配X只要右手边相应的值是1，如下例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>&gt; X = <span class="number">1</span>.</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; &#123;X, <span class="number">2</span>&#125; = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;.</div><div class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>单次赋值是Erlang的一个非常棒的的优点，因为它减少了有<a href="http://en.wikipedia.org/wiki/Side_effect_computer_science" target="_blank" rel="external">副作用</a>的函数调用的可能。副作用使得写高并发的代码非常困难。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>在本文剩下的部分我们将使用一个计数器的例子。我的意思是通过一个计数器也就是一段简单的代码，它能够保持计数值，并提供一个API增值和（或）访问计数的值。这是一个关于状态的非常简单的例子；计数器的状态就是计数的值。</p>
<p>面向对象语言做这个例子非常简单，它很自然地存储状态到类实例的变量里。例如，用Ruby来实现一个简单的计数器，我们可能会像下面这样做：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ruby里一个简单面向对象计数器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @count = <span class="number">0</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">click</span></span></div><div class="line">    @count += <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">c = Counter.new</div><div class="line">c.click <span class="comment"># =&gt; <span class="doctag">@count</span> is now 1</span></div><div class="line">c.click <span class="comment"># =&gt; <span class="doctag">@count</span> is now 2</span></div></pre></td></tr></table></figure>
<p>@count是Counter类的一个实例变量。当我们通过调用Counter.new来创建Counter类的一个新实例的时候，在构造器（函数initialize）里@count被初始化为0。每次我们调用click方法，@count的值被增加一。@count持有计数器的状态。我们可以很容易地创建多个计数器，它们都有自己私有的状态。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c1 = Counter.new</div><div class="line">c2 = Counter.new</div><div class="line">c1.click <span class="comment"># =&gt; 1</span></div><div class="line">c1.click <span class="comment"># =&gt; 2</span></div><div class="line">c2.click <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<h1 id="递归和状态"><a href="#递归和状态" class="headerlink" title="递归和状态"></a>递归和状态</h1><p>那么我们如何在Erlang里保持状态呢？我们可以用递归来做到，通过从初始函数调用到下一个函数调用和后续的函数调用之间传递状态。如下有一个Erlang的计数器例子，每次递归函数调用的时候打印出递增的计数器值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% loop_counter.erl</span></div><div class="line"><span class="comment">% 一个递归循环计数器</span></div><div class="line"><span class="comment">% 基于当前进程，并且没有访问计数器的值</span></div><div class="line"><span class="keyword">-module</span><span class="params">(loop_counter)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([go/<span class="number">0</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">go</span><span class="params">()</span> -&gt;</span></div><div class="line">  go(<span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">go</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  io:format(<span class="string">"N is ~p~n"</span>, [N]),</div><div class="line">  <span class="comment">% 只是为了不让我们的终端忙疯了。</span></div><div class="line">  timer:sleep(<span class="number">1000</span>),</div><div class="line">  go(N + <span class="number">1</span>).</div><div class="line"></div><div class="line"><span class="comment">%%% Erlang shell</span></div><div class="line"><span class="number">1</span>&gt; c(loop_counter).</div><div class="line">&#123;ok,loop_counter&#125;</div><div class="line"><span class="number">2</span>&gt; loop_counter:go().</div><div class="line">N is <span class="number">0</span></div><div class="line">N is <span class="number">1</span></div><div class="line">N is <span class="number">2</span></div><div class="line">N is <span class="number">3</span></div><div class="line"></div><div class="line">(hit Ctrl-c)</div><div class="line">BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded</div><div class="line">       (v)ersion (k)ill (D)b-tables (d)istribution</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用go/1函数的输入参数N来跟踪我们的状态，我们用N+1作为下一个调用的参数递归地调用相同函数来增加计数器值。事实上，我们能够增加这个值意味着我们正在跟踪计数器的状态。但是这个例子没有太多用处，因为递归调用循环完全占据当前的Erlang进程。</p>
<p>我们可以用 <a href="http://www.erlang.org/doc/man/erlang.html#spawn-1" target="_blank" rel="external">erlang:spawn/1</a> 将我们的计数器循环从主进程（我们的Erlang shell）分开。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(loop_counter).</div><div class="line">&#123;ok,loop_counter&#125;</div><div class="line"><span class="number">2</span>&gt; Pid = spawn(<span class="keyword">fun</span> loop_counter:go/<span class="number">0</span>).</div><div class="line">N is <span class="number">0</span></div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line">N is <span class="number">1</span></div><div class="line">N is <span class="number">2</span></div><div class="line">N is <span class="number">3</span></div><div class="line">N is <span class="number">4</span></div><div class="line"><span class="number">3</span>&gt; q().</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>这样我们重新获取我们Erlang shell的控制权，但是现在我们无法控制计数器或者以编程方式获取它当前的值。</p>
<h1 id="用消息控制和查询状态"><a href="#用消息控制和查询状态" class="headerlink" title="用消息控制和查询状态"></a>用消息控制和查询状态</h1><p>在前面一节，我们创建了一个计数器，通过递归地调用自己来增加自己的值，但是我们无法控制计数器或者从外部代码访问它的状态。我们可以用消息来做到这点。如下的例子，增加一个click消息给我们的计数器。我们可以用click消息增加计数器的值，并且将修改后的值作为消息返回给调用的进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% counter.erl</span></div><div class="line"><span class="comment">% 创建一个计数器循环来侦听click消息。</span></div><div class="line"><span class="keyword">-module</span><span class="params">(counter)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, click/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">% 创建一个计数器，返回pid</span></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></div><div class="line">  spawn(<span class="keyword">fun</span>() -&gt; loop(<span class="number">0</span>) <span class="keyword">end</span>).</div><div class="line"></div><div class="line"><span class="comment">% 递归循环，函数中用receive块接收消息。</span></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  <span class="keyword">receive</span></div><div class="line">    &#123;click, From&#125; -&gt;</div><div class="line">      From ! N + <span class="number">1</span>,</div><div class="line">      loop(N + <span class="number">1</span>)</div><div class="line">  <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% API函数。增值计数器，计数器的pid是入参给定的。</span></div><div class="line"><span class="function"><span class="title">click</span><span class="params">(Pid)</span> -&gt;</span></div><div class="line">  Pid ! &#123;click, self()&#125;,</div><div class="line">  <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">%%% in Erlang shell</span></div><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; counter:click(C).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; counter:click(C).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">5</span>&gt; counter:click(C).</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>当我们调用counter:new/0，这个函数创建一个新的递归循环，并用0初始化计数器的值，然后返回被创建进程的pid。循环函数立即进入receive块，在这里它无限期等待从任何其他进程发来的消息。我们设置它只监听一个消息：{click, From}，并要求From是调用进程的pid。</p>
<p>如下例子是从终端创建一个计数器进程并直接发送一个消息给它然后等待接收一个消息返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; C ! &#123;click, self()&#125;.</div><div class="line">&#123;click,&lt;<span class="number">0.32</span>.<span class="number">0</span>&gt;&#125;</div><div class="line"><span class="number">4</span>&gt; <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>上述这个例子显得有点笨拙。我们不想每次要增值计数器的时候都必须写消息调用和receive块；而且这样也不安全，因为这样做留下了很多犯错的空间。因此我们引入API函数counter:click/1（参阅上面的代码例子），它的入参是一个计数器的pid，它知道以正确的方式发送和接收一个click消息。</p>
<p>注意：我们在counter:click/1里用self/0来自动获取调用进程的pid。这种用法可以正常工作，因为counter:click/1是被调用进程调用的。如果我们在counter:loop/1函数里调用self/0，它将返回被创建进程的pid，而这个被创建的进程正在执行循环。</p>
<p>使用这个范例，通过创建多个进程来创建和控制多个计数器是很容易的。此外，API隐藏了大部分的底层实现细节，我们可以与计数器实例一起工作，而不必知道它们的值实际上是一个进程标识符。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&gt; c(counter).</div><div class="line">&#123;ok,counter&#125;</div><div class="line"><span class="number">2</span>&gt; C1 = counter:new().</div><div class="line">&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">3</span>&gt; C2 = counter:new().</div><div class="line">&lt;<span class="number">0.41</span>.<span class="number">0</span>&gt;</div><div class="line"><span class="number">4</span>&gt; counter:click(C1).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">5</span>&gt; counter:click(C1).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">6</span>&gt; counter:click(C2).</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们也可以修改循环函数来侦听一个set消息来允许我们手工设置计数器的值。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% 增加一个消息处理器来设置计数器的值。</span></div><div class="line"><span class="function"><span class="title">loop</span><span class="params">(N)</span> -&gt;</span></div><div class="line">  <span class="keyword">receive</span></div><div class="line">    &#123;click, From&#125; -&gt;</div><div class="line">      From ! N + <span class="number">1</span>,</div><div class="line">      loop(N + <span class="number">1</span>);</div><div class="line">    &#123;set, Value, From&#125; -&gt;</div><div class="line">      From ! ok,</div><div class="line">      loop(Value)</div><div class="line">  <span class="keyword">end</span>.</div><div class="line"></div><div class="line"><span class="comment">% API函数。依据给定的pid来设置计数器的值。</span></div><div class="line"><span class="function"><span class="title">set</span><span class="params">(Pid, Value)</span> -&gt;</span></div><div class="line">  Pid ! &#123;set, self(), Value&#125;,</div><div class="line">  <span class="keyword">receive</span> V -&gt; V <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<h1 id="用于生产环境的gen-server"><a href="#用于生产环境的gen-server" class="headerlink" title="用于生产环境的gen_server"></a>用于生产环境的gen_server</h1><p>我们上述例子的计数器有许多潜在问题。当一个计数器进程收到一个意料之外的消息会发生什么？当系统很忙并且无法以及时的方式响应一个click消息的时候会发生什么？我们如何停止计数器并释放它正在使用的任何系统资源？当我们增加越来越多的消息的时候，代码也很快变得不可管理。</p>
<p>Erlang有一套<a href="http://www.erlang.org/doc/design_principles/des_princ.html#id60128" target="_blank" rel="external">行为</a>接口用来解决当试图使用Erlang解决问题时普遍遇到的各种问题。这套模块被称为<a href="http://www.erlang.org/doc/design_principles/des_princ.html" target="_blank" rel="external">OTP</a>（正式称谓是“开放电信平台”，现在只是简单地叫做“OTP”）。</p>
<p>OTP的 <a href="http://www.erlang.org/doc/design_principles/gen_server_concepts.html" target="_blank" rel="external">gen_server</a> 行为被设计和实现出来就是为了用来实现一种设计模式，这种设计模式解决我们在本文已经遇到的问题。它以一种健壮和完整的方式实现一个有状态的被创建的进程行为，并且解决很多我们还没有考虑到的问题。</p>
<p>我不打算在这里深入研究OTP行为，因为本文的目的不是教你各种OTP行为或者正确的OTP设计。如果你想学习更多的细节，请看Erlang官方的 <a href="http://www.erlang.org/doc/man/gen_server.html" target="_blank" rel="external">gen_server 文档</a>以及《Learn You Some Erlang》的 <a href="http://learnyousomeerlang.com/clients-and-servers" target="_blank" rel="external">客户端和服务端</a> 章节。然而下面的例子将给你一个不错的主意，就是gen_server如何解决在Erlang里保持状态的问题。</p>
<p>如下就是一个用gen_server实现一个简单的计数器的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% counter_server.erl</span></div><div class="line"><span class="comment">% 简单计数器实现为一个gen_server</span></div><div class="line"><span class="keyword">-module</span><span class="params">(counter_server)</span>.</div><div class="line"><span class="keyword">-behavior</span><span class="params">(gen_server)</span>.</div><div class="line"></div><div class="line"><span class="comment">% API</span></div><div class="line"><span class="keyword">-export</span><span class="params">([new/<span class="number">0</span>, click/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">% gen_server需要的</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_call/<span class="number">3</span>, handle_cast/<span class="number">2</span>, handle_info/<span class="number">2</span>, terminate/<span class="number">2</span>, code_change/<span class="number">3</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%%% API 方法</span></div><div class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></div><div class="line">  gen_server:start(?MODULE, [], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">click</span><span class="params">(Pid)</span> -&gt;</span></div><div class="line">  gen_server:call(Pid, click).</div><div class="line"></div><div class="line"><span class="comment">%%% gen_server 回调</span></div><div class="line"><span class="comment">%%%   这些是实现gen_server行为所需要的</span></div><div class="line"><span class="comment">%%%   我们只是使用了 init 和 handle_call</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">  <span class="comment">% 第二个值是初始化计数器的状态</span></div><div class="line">  &#123;ok, <span class="number">0</span>&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(click, _From, N)</span> -&gt;</span></div><div class="line">  <span class="comment">% 第二个值是消息回复的调用者</span></div><div class="line">  <span class="comment">% 第三个值是新状态</span></div><div class="line">  &#123;reply, N + <span class="number">1</span>, N + <span class="number">1</span>&#125;.</div><div class="line"></div><div class="line"><span class="comment">% 基本上，我们忽略这些函数，不过我们保持同样的计数器状态</span></div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, N)</span> -&gt;</span></div><div class="line">  &#123;noreply, N&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Msg, N)</span> -&gt;</span></div><div class="line">  &#123;noreply, N&#125;.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, N, _Other)</span> -&gt;</span></div><div class="line">  &#123;ok, N&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _N)</span> -&gt;</span></div><div class="line">  ok.</div><div class="line"></div><div class="line"><span class="comment">%%% Erlang console</span></div><div class="line"><span class="number">1</span>&gt; c(counter_server).</div><div class="line">&#123;ok,counter_server&#125;</div><div class="line"><span class="number">2</span>&gt; &#123;ok, C&#125; = counter_server:new().</div><div class="line">&#123;ok,&lt;<span class="number">0.39</span>.<span class="number">0</span>&gt;&#125;</div><div class="line"><span class="number">3</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">5</span>&gt; counter_server:click(C).</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>这个例子可能看起来像是解决一个简单问题用了很多代码，但是我们只是在这个框架里实现功能让我们获得非常大的灵活性。另外也有大量可用模版为你创建代码框架（在Emacs里，你可以从Erlang包里用 M-x tempo-template-erlang-generic-server 创建代码框架）。</p>
<p>作为一个例子，和上述例子一样增加一个set/2功能只是增加一个API函数和一个handle_call回调函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%%% API</span></div><div class="line"><span class="function"><span class="title">set</span><span class="params">(Value, Pid)</span> -&gt;</span></div><div class="line">  gen_server:call(Pid, &#123;set, Value&#125;).</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(&#123;set, Value&#125;, _From, _N)</span> -&gt;</span></div><div class="line">  &#123;reply, ok, Value&#125;;</div><div class="line"></div><div class="line"><span class="comment">% 来自上面的现有回调，供参考</span></div><div class="line"><span class="comment">%  (这两个函数分支在一起是为了模式匹配)</span></div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(click, _From, N)</span> -&gt;</span></div><div class="line">  &#123;reply, N + <span class="number">1</span>, N + <span class="number">1</span>&#125;.</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这就是你从本文学到的。我们在Erlang里用进程保持状态跟踪，并且我们用消息访问和控制状态。在很多方面，Erlang的进程类似于其他语言中的类的实例。在许多其他方面，它们是非常不同的。在Erlang里解决问题要用不同的思考方式：用进程的概念来思考。一开始这可能很难理解，但是一旦你理解它了，许多问题以这种方式更容易解决。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://dantswain.herokuapp.com/blog/2014/09/27/storing-state-in-erlang-with-processes/" target="_blank" rel="external">http://dantswain.herokuapp.com/blog/2014/09/27/storing-state-in-erlang-with-processes/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态是我们如何使程序做不平凡的事情。如果我们正在写一个电子游戏，它的一个状态可能是一个被打败的坏人的数字。在大多数编程语言中，我们将通过将计数分配给变量，然后在每次新的坏人被击败时更新这个值来实现这一点。然而，一旦变量已经被赋值（单次赋值），Erlang不允许我们修改这个变量的值。那么如果我们不能够改变一个变量的值，我们如何在Erlang里跟踪状态？答案是：用进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Erlang/process/"/>
    
      <category term="state" scheme="http://szpzs.oschina.io/categories/Erlang/process/state/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
      <category term="state" scheme="http://szpzs.oschina.io/tags/state/"/>
    
      <category term="gen_server" scheme="http://szpzs.oschina.io/tags/gen-server/"/>
    
      <category term="behavior" scheme="http://szpzs.oschina.io/tags/behavior/"/>
    
  </entry>
  
  <entry>
    <title>BIF和NIF函数之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/18/eli5-bif-nif/"/>
    <id>http://szpzs.oschina.io/2016/12/18/eli5-bif-nif/</id>
    <published>2016-12-18T10:46:43.000Z</published>
    <updated>2016-12-18T10:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIF函数"><a href="#BIF函数" class="headerlink" title="BIF函数"></a>BIF函数</h1><p>除非你在Erlang/OTP的C源码上工作，你永远不需要创建自己的BIF函数。如果你想为你的项目实现自己的原生函数，请看下一节关于NIF的内容。</p>
<a id="more"></a>
<p>在Erlang的标准库里大多数的函数是用Erlang实现的。不过许多虚拟机的特性以及内部函数是不可能用纯Erlang语言来做到的。所以它们被用C语言来写并被导出为BIF，即内部构建函数。BIF被用作标准Erlang库，并且在编译的时候被静态地构建进Erlang虚拟机模拟器。</p>
<p>当阅读Erlang标准库的时候，你经常会看到一些函数会有一个调用是：erlang:nif_error(…)。这些是BIF的桩。BEAM装载器找到原生库并且使用对C语言的原生实现的引用来替换这些桩。你也可以用其他语言比如C++或Rust来创建BIF或NIF函数。你也可以在一个叫做bif.tab的特殊文件里注册一个新的BIF，当你构建Erlang虚拟机的模拟器的时候，这个文件串联起module:function名字和BIF的对应关系。</p>
<p>如果你好奇，你可以在Erlang/OTP的C源码中搜索一些函数，比如：erl_bif_lists.c里的lists_reverse_2。一个BIF函数接受进程指针和一个指向寄存器的指针，它可以访问它所需的许多<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">Term</a>（Eterm C 类型）寄存器。一个BIF必须返回一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">Term</a>值或者一个THE_NON_VALUE来针对特殊的执行控制功能，如trap，yield和异常。</p>
<h1 id="NIF函数"><a href="#NIF函数" class="headerlink" title="NIF函数"></a>NIF函数</h1><p>NIF是一种制作原生函数的不同方式，它更适合于分开编译和被用户模块装载。NIF接口和类型系统也是简化的，他们抽象并隐藏了Erlang虚拟机模拟器的许多内部类型、位和字段。</p>
<p>在官方标准文档里有很好的<a href="http://erlang.org/doc/tutorial/nif.html" target="_blank" rel="external">NIF教程</a>，并且大约有一百万个有用户写的以及在许多GitHub项目里可用的NIF函数。</p>
<p>就算它简化了，我们还是一定要小心 ！写得很糟糕的 NIF 是能够搞垮整个虚拟机或抢占资源和减慢执行速度。</p>
<blockquote>
<p>参见：<br>BEAM智慧：<a href="http://beam-wisdoms.clau.se/en/latest/interfacing.html" target="_blank" rel="external">Erlang与外部世界的接口</a>，针对一些NIF、交互库以及为不同语言提供的端口驱动器。</p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-bif-nif.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-bif-nif.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BIF函数&quot;&gt;&lt;a href=&quot;#BIF函数&quot; class=&quot;headerlink&quot; title=&quot;BIF函数&quot;&gt;&lt;/a&gt;BIF函数&lt;/h1&gt;&lt;p&gt;除非你在Erlang/OTP的C源码上工作，你永远不需要创建自己的BIF函数。如果你想为你的项目实现自己的原生函数，请看下一节关于NIF的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="BIF" scheme="http://szpzs.oschina.io/categories/Erlang/BIF/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/categories/Erlang/BIF/NIF/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="BIF" scheme="http://szpzs.oschina.io/tags/BIF/"/>
    
      <category term="NIF" scheme="http://szpzs.oschina.io/tags/NIF/"/>
    
  </entry>
  
  <entry>
    <title>跟踪之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/18/eli5-tracing/"/>
    <id>http://szpzs.oschina.io/2016/12/18/eli5-tracing/</id>
    <published>2016-12-18T01:12:29.000Z</published>
    <updated>2016-12-18T01:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang VM 如何跟踪函数调用、消息传递、进程的创建和结束？</p>
<a id="more"></a>
<p>跟踪是一种Erlang虚拟机模式，可以被打开和关闭。打开该模式会开始产生一个事件流。调用dbg:tracer()启动一个将接收这个事件流的进程。你可以创建你自己的跟踪器，它有自己的状态，然后给它输送事件。</p>
<p>跟踪能够产生大量不相关的数据。要限制这些不相关的数据，可以调用dbg:tp/4 （这一类函数）来产生一个跟踪过滤器。</p>
<p>当所有事情准备好了：一个跟踪器和一个过滤器，就可以开始打开开关接收事件了。一个对dbg:p/2（这一类函数）的调用设置跟踪目标（一个进程、一个端口、创建和退出事件、所有相关事件，诸如此类）。它将开始发送所有匹配跟踪目标和你给跟踪器进程设置的过滤器的事件。</p>
<h1 id="跟踪的内部运作"><a href="#跟踪的内部运作" class="headerlink" title="跟踪的内部运作"></a>跟踪的内部运作</h1><p>像进程生命周期事件或消息这样简单的事情在虚拟机的C代码中到处都有跟踪器检查。如果跟踪被开启，那么一条消息会发送给当前的跟踪器。</p>
<p>对BIF函数的调用和返回进行跟踪会更复杂。因为BIF不是真正的Erlang代码，它们必须以某种方式被包裹在跟踪代码里。这是通过用BIF的入口函数地址与另一个表替换BIF表来做到的。这个新表中的每个条目是一个简单的使用函数名称和参数来对erts_bif_trace函数的调用。这个函数执行真正的调用并且发送跟踪消息。</p>
<p>在某些时刻使用另一个技巧。在BIF结束前，特定的BEAM操作码被推送到栈上，它将发送跟踪事件。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-tracing.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-tracing.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang VM 如何跟踪函数调用、消息传递、进程的创建和结束？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="tracer" scheme="http://szpzs.oschina.io/categories/Erlang/tracer/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="tracer" scheme="http://szpzs.oschina.io/tags/tracer/"/>
    
  </entry>
  
  <entry>
    <title>输入/输出和端口之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/17/eli5-io/"/>
    <id>http://szpzs.oschina.io/2016/12/17/eli5-io/</id>
    <published>2016-12-17T14:38:54.000Z</published>
    <updated>2016-12-17T14:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>人们运行电脑程序的主要原因是因为有副作用。一个没有副作用的纯粹程序将消耗电力，温暖你的房间，除此之外别无他用。为了将程序连接到外部世界，每一种语言都有输入和输出的功能。例如：读写文件、访问硬件端口、或者与操作系统驱动器交互、在屏幕上描绘等等。</p>
<a id="more"></a>
<p>Erlang用端口来做到上述事情，端口是被叫做端口驱动器的小的C语言模块驱动。一些驱动是Erlang自带的，另一些则需要你自己创建或者请别人帮你创建。许多端口问题在GitHub上都有了解决方案（比如Unix管道）。</p>
<p>当你连接到一个资源开始使用它的时候，你收到的值是一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-port" target="_blank" rel="external">端口</a>。它的行为和进程相似：它消耗CPU时间来处理你的数据，你可以发消息给它，它也可以发消息给你。你可以连接或者监测一个端口（监测功能是从Erlang/OTP 19开始增加的）。</p>
<h1 id="端口任务"><a href="#端口任务" class="headerlink" title="端口任务"></a>端口任务</h1><p>每个端口和进程一样都是赋给一个调度器。每个CPU核上的调度器将会定期地检查赋予它的端口并且执行轮询和维护（这叫做运行端口任务）。这样就给端口驱动器分配CPU时间来执行实际的IO并且传递结果给正在等待的进程。</p>
<p>为了提高这个过程的效率并且为了从调度器分离出来端口任务，以便使得它们不影响主程序，异步线程被发明出来。虚拟机创建额外的线程，它们只有一个主要目标，就是服务IO任务。</p>
<p>异步线程的个数可以通过命令行标志 +A 正整数 来控制。默认是10个异步线程。</p>
<h1 id="端口驱动器"><a href="#端口驱动器" class="headerlink" title="端口驱动器"></a>端口驱动器</h1><p>一个C模块可以用名字的方式被注册成一个端口驱动器。你可以指定，当打开一个端口的时候，哪一个驱动器被调用。端口驱动器执行几个基本命令来打开端口、关闭端口、发送数据给端口或者从端口读取数据。例如，套接字接口、操作系统进程的创建，它们都是作为端口驱动器来实现的。</p>
<blockquote>
<p>参见：<br>技术细节：<a href="http://beam-wisdoms.clau.se/en/latest/indepth-io.html" target="_blank" rel="external">Erlang的IO</a></p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-io.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-io.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人们运行电脑程序的主要原因是因为有副作用。一个没有副作用的纯粹程序将消耗电力，温暖你的房间，除此之外别无他用。为了将程序连接到外部世界，每一种语言都有输入和输出的功能。例如：读写文件、访问硬件端口、或者与操作系统驱动器交互、在屏幕上描绘等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="port" scheme="http://szpzs.oschina.io/categories/Erlang/port/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="input" scheme="http://szpzs.oschina.io/tags/input/"/>
    
      <category term="output" scheme="http://szpzs.oschina.io/tags/output/"/>
    
      <category term="port" scheme="http://szpzs.oschina.io/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>进程堆之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/16/eli5-process-heap/"/>
    <id>http://szpzs.oschina.io/2016/12/16/eli5-process-heap/</id>
    <published>2016-12-16T09:02:13.000Z</published>
    <updated>2016-12-16T13:13:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang里的每一个事物都是一个term。一个term是Erlang里的任何值。在Erlang内部，一个term是一个保留一些最少有效位（根据值的不同有效位从2到6不等）的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-word" target="_blank" rel="external">字</a>，这些有效位定义了它的类型。剩下的位包含它自己的值（比如<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed" target="_blank" rel="external">立即数</a>的值）或包含一个指向堆上数据（<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box" target="_blank" rel="external">box</a> 值）的指针。</p>
<a id="more"></a>
<p>一个进程的堆是一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。而进程的栈则是另一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。栈被分配在堆的里面。<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-registers" target="_blank" rel="external">寄存器</a>也是一个由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组。堆上的数据大多数都是由<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">term</a>组成的数组，除了用<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-header" target="_blank" rel="external">头部标签</a>（详情参阅 <a href="http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html" target="_blank" rel="external">数据类型内存布局</a>）标记的数据。</p>
<h1 id="堆载体"><a href="#堆载体" class="headerlink" title="堆载体"></a>堆载体</h1><p>Erlang内的内存分配发生在所谓的“载体”内。它们看起来像游戏里使用的“区域内存”–事先分配的一大块系统堆。在载体内部，真正的内存分配在这里发生。至于它们是如何运作的，为简单起见你可以想象成简单的malloc/realloc。</p>
<p>克服内存碎片的复杂事情都被封装好了，并且不是我们要理解的重点。你可以看源码 erts/emulator/beam/erl_*alloc.c （有许多文件，每一个分配策略一个文件）。模拟器有命令行标志来控制分配策略（参阅 <a href="http://erlang.org/doc/man/erts_alloc.html" target="_blank" rel="external">http://erlang.org/doc/man/erts_alloc.html</a> 标志部分）。</p>
<h1 id="堆内的内存分配"><a href="#堆内的内存分配" class="headerlink" title="堆内的内存分配"></a>堆内的内存分配</h1><p>当一个进程需要一些内存，它的 heap_top 增大，堆顶下面的内存就准备好被使用。一些活动想在其他进程的堆上分配内存，例如发送一个消息将把一个消息的拷贝给接收进程。</p>
<p>在进程堆内部是没有记账本的。就是没有跟踪那一个字属于哪里，但是我们可能通过查看标签位是可以知道每一个内存单元存储了什么。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>垃圾回收跟踪从寄存器和栈知道的活数据并保存它们，然后将其他的数据都卸掉。</p>
<p>当一个堆达到它的容量阀值（比如75%），进程就触发垃圾回收。一个新的更大的堆可能被分配出来。扫描分代的垃圾回收算法运行在堆上。这个算法获取“<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-roots" target="_blank" rel="external">roots</a>”（垃圾回收期间，根是所有已知的活数据）并把它们移到新堆。然后扫描源堆的剩余部分，提取更多的值，由根引用。扫描后，源堆只剩下死数据接着算法把它们卸掉。</p>
<p>“扫描”的意思是，垃圾回收器将数据从头到尾过一遍，分析所有它遇到的数据。“分代的”的意思是，算法将数据分为新生代和老生代，并假设新数据经常是死掉的，老数据是不太可能被释放的。另外算法记住老的位置（成熟的），也就是上一次扫描结束的地方。这个位置下面的任何数据被保证自上次扫描以来有没有更新。这一招会减少扫描的量，并加速算法。</p>
<p>在现实中比较复杂一点。可能有一个或两个堆有不同的逻辑应用于它们。每一个进程都有自己的垃圾回收器这样就使得Erlang的垃圾回收延时低。另外它不会暂停或影响其他调度器上的其他进程。这不是一个简单的话题，不过原理都在这：<a href="http://gchandbook.org/" target="_blank" rel="external">http://gchandbook.org/</a></p>
<blockquote>
<p>另外请参阅<br>BEAM 智慧: 深层次知识: <a href="http://beam-wisdoms.clau.se/en/latest/indepth-heap-layout.html" target="_blank" rel="external">进程堆布局</a>。<br>BEAM Wisdoms: 深层次知识: <a href="http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html" target="_blank" rel="external">数据类型内存布局</a>。<br><a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html" target="_blank" rel="external">Erlang里的垃圾回收器</a></p>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-process-heap.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-process-heap.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang里的每一个事物都是一个term。一个term是Erlang里的任何值。在Erlang内部，一个term是一个保留一些最少有效位（根据值的不同有效位从2到6不等）的&lt;a href=&quot;http://beam-wisdoms.clau.se/en/latest/definitions.html#def-word&quot;&gt;字&lt;/a&gt;，这些有效位定义了它的类型。剩下的位包含它自己的值（比如&lt;a href=&quot;http://beam-wisdoms.clau.se/en/latest/definitions.html#def-immed&quot;&gt;立即数&lt;/a&gt;的值）或包含一个指向堆上数据（&lt;a href=&quot;http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box&quot;&gt;box&lt;/a&gt; 值）的指针。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Erlang/process/"/>
    
      <category term="heap" scheme="http://szpzs.oschina.io/categories/Erlang/process/heap/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
      <category term="heap" scheme="http://szpzs.oschina.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>进程之浅显易懂</title>
    <link href="http://szpzs.oschina.io/2016/12/15/eli5-processes/"/>
    <id>http://szpzs.oschina.io/2016/12/15/eli5-processes/</id>
    <published>2016-12-15T15:07:17.000Z</published>
    <updated>2016-12-15T15:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是进程如何组成的以及如何工作的高层次概述。</p>
<a id="more"></a>
<h1 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h1><p>一个进程就是一个简单的C语言结构，这个结构包含了一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-heap" target="_blank" rel="external">堆</a>，一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack" target="_blank" rel="external">栈</a>，一些<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-registers" target="_blank" rel="external">寄存器</a>，还有一个指令指针。也有一些异常处理、跟踪等额外字段。一个新的进程是以这个C语言结构创建的，创建的时候有一个最小尺寸的堆。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img src="/images/eli5-process-stack.png" style="border:0;"></p>
<p><a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack" target="_blank" rel="external">栈</a>是在新生代堆上一个内存数组，它被用来当作返回栈和变量的临时存储。栈从堆的尾部开始，向堆的首部增长。栈上的数据按<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-stack-frame" target="_blank" rel="external">栈帧</a>来组织。</p>
<p>当一个函数需要一些临时的内存，它在栈上分配几个字的空间，并在第0个字上设置一个特定的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cp" target="_blank" rel="external">CP</a>值。后续这个内存地址可以被当作返回地址，并且从这个内存内找到下一个栈帧从哪里开始。这个临时内存也可以被用来在递归调用的时候保存寄存器（这样会造成栈的增长）。</p>
<p>尾递归避免保存这些临时数据或者在递归前释放这些临时数据。它用更聪明的办法传递参数，这样就不需要在栈上保存参数从而不会使得栈增长。</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>每一个新进程都被赋予一个<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-scheduler" target="_blank" rel="external">调度器</a>。调度器从队列里取出一个进程并拿到该进程的指令指针。然后调度器执行一个指令接着进入重复执行指令的循环。在完成一定数量的工作（<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-reduction" target="_blank" rel="external">规约数</a>）后，调度器将把当前的进程放回队列然后从队列里选择另一个进程。这种机制使得一些类型的公平调度成为可能：每一个进程都可以得到CPU时间而不管队列中其他进程如何繁忙。</p>
<h1 id="杀死和退出"><a href="#杀死和退出" class="headerlink" title="杀死和退出"></a>杀死和退出</h1><p>杀死一个进程就像给它发送一个退出异常。进程从睡眠中醒来，获得CPU时间，然后发现一个异常。那么它将终止自己或者捕获这个异常并且像一个正常的消息一样进行处理。无条件杀死信号和异常很像，这是Erlang代码无法捕获它。</p>
<h1 id="调度和负载均衡"><a href="#调度和负载均衡" class="headerlink" title="调度和负载均衡"></a>调度和负载均衡</h1><p><img src="/images/eli5-process-sched.png" style="border:0;"></p>
<p>默认情况下BEAM虚拟机每个CPU核启动一个调度器。进程以某种方式（简单来说你可以认为是随机地）赋给调度器。你可以用标志 +S 和 +SP 来配置调度器。调度器可以用不同的方式（+sbt 标志）被绑定到CPU核。</p>
<p>有3种进程优先级：low、normal、high和max。处在max优先级的进程总是首先运行而其他进程一直等待。high优先级进程比normal优先级进程大约多8倍时间运行（这个倍数依赖于实现）。当没有其他工作可做的时候low优先级进程才运行。</p>
<p>在运行时，调度器和其他调度器（即在调度器数组中比它前一位的调度器）比较它们之间的进程队列。如果其他调度器的队列比它的长，调度器将从其他调度器的队列里偷一个或多个进程给自己的队列。这种默认行为是可以被改变的。负载均衡策略可以用虚拟机标志 +S 和 +scl 来配置。你可能想使用尽可能少的CPU核来让其他CPU核睡眠和节能。或者你更喜欢将进程平摊给各个CPU核从而减少时延。</p>
<p>偷进程就如将指针从一个数组移到另一个数组一样容易。当一个活动进程在CPU核间跳动的话，可能影响<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-cache-locality" target="_blank" rel="external">缓存区</a>。</p>
<h1 id="进程注册"><a href="#进程注册" class="headerlink" title="进程注册"></a>进程注册</h1><p>一个全局进程表映射进程标识符（pid）到进程结构。要了解一个进程的pid，可以参阅它的Process.common.id字段。进程通过它本地的pid唯一标识。远程pid包含更多信息：一个节点名和内部节点id。远程pid必须在拥有它的节点上解析。</p>
<p>另一个全局表（进程注册）映射名字到pid。你可以用erlang:register、erlang:unregister和erlang:whereis 这些BIF来使用它。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><img src="/images/eli5-process-mqueue.png" style="border:0;"></p>
<p>消息被存储在堆上或者在堆段里，并且被用单链表串起来。消息队列是一个属于进程结构的C结构并且它包含了发给进程的<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-term" target="_blank" rel="external">数据项</a>。对于更大的或嵌套的数据则使用<a href="http://beam-wisdoms.clau.se/en/latest/definitions.html#def-box" target="_blank" rel="external">Boxed data</a>，它被分配在堆上。存在一个队列位置的指针，它是先进的BEAM操作码，它用来扫描邮箱。当扫描指针到达邮箱的底部，进程将被置为接收消息状态。仅当一个消息被匹配了，指针才被复位到队列的首部。这就是为什么在一个大的邮箱队列中进行选择接收是缓慢的。</p>
<h1 id="发送一个消息"><a href="#发送一个消息" class="headerlink" title="发送一个消息"></a>发送一个消息</h1><p>发送一个消息给一个进程很简单。下面就是虚拟机的做法：</p>
<ol>
<li>锁上一个进程邮箱（如果运行在一个单核上就不需要）。</li>
<li>拷贝消息到目的进程的堆。</li>
<li>添加结果数据到进程邮箱。</li>
<li>解锁进程邮箱。</li>
<li>如果进程处在接收消息状态，它将回到调度队列并随时醒来处理消息。</li>
</ol>
<p>一个进程等待一个消息（用接收操作），直到消息到达它都不会被放入调度器运行队列等待执行。这就是为什么百万个空闲进程可以毫不费劲地同时存在于一个单机上。</p>
<h1 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h1><p>Traps是虚拟机循环的一个特性，它允许临时暂停长时间运行的BIF。状态被保存在临时内存区并且控制权回到调度器。进程设置它的指令指针到特定的trap指令并且BIF返回。</p>
<p>在trap期间，当前进程被放回进程队列，这就允许其他进程运行。当时机到来，虚拟机循环遇到trap指令，并且跳回到长时间运行BIF。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://beam-wisdoms.clau.se/en/latest/eli5-processes.html" target="_blank" rel="external">http://beam-wisdoms.clau.se/en/latest/eli5-processes.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是进程如何组成的以及如何工作的高层次概述。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/categories/Erlang/process/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="process" scheme="http://szpzs.oschina.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>Erlang垃圾回收细节以及它为何重要</title>
    <link href="http://szpzs.oschina.io/2016/12/13/erlang-garbage-collection-details-and-why-it-matters/"/>
    <id>http://szpzs.oschina.io/2016/12/13/erlang-garbage-collection-details-and-why-it-matters/</id>
    <published>2016-12-13T13:27:00.000Z</published>
    <updated>2016-12-13T13:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang尝试解决的一个主要问题就是为实现高水平响应的<a href="https://en.wikipedia.org/wiki/Real-time_computing" target="_blank" rel="external">软实时系统</a>创建一个平台。这样的系统需要快速的<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="external">垃圾回</a>收策略，这样就不会阻止系统以及时的方式进行响应。另外当我们认为Erlang是一门无破坏性修改特性的<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="external">不可改变</a>语言的时候，垃圾回收变得更重要，因为这样的语言有更高产生垃圾的几率。</p>
<a id="more"></a>
<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>在我们深入垃圾回收之前，了解Erlang进程的内存布局是很有必要的。Erlang进程的内存布局可以分为三个主要部分：进程控制块，栈和堆。这和Unix的进程布局非常像。</p>
<p><img src="/images/erlang-memory-layout.png" style="border:0;"></p>
<ul>
<li><strong>进程控制块</strong>：进程控制块持有进程的一些信息，诸如：它在进程表里的标识符（PID），当前状态（运行、等待），它的注册名字，初始化调用和当前调用；另外进程控制块还持有指向到达消息的指针，这些消息是<em>链接列表</em>的成员，它们存储在进程私有堆里。</li>
<li><strong>栈</strong>：它是一个向下增长的内存区域，它持有函数的进出参数，返回地址，本地变量以及计算表达式的临时空间。</li>
<li><strong>堆</strong>：它是一个向上增长的内存区域，它持有进程邮箱的实际消息，像<a href="http://www.erlang.org/doc/man/lists.html" target="_blank" rel="external">列表</a>和<a href="http://www.erlang.org/documentation/doc-5.8/doc/reference_manual/data_types.html" target="_blank" rel="external">元组</a>这样的复合数据，<a href="http://www.erlang.org/doc/man/binary.html" target="_blank" rel="external">二进制数据</a>，大于一个机器字的诸如浮点数对象。大于64字节的二进制数据不保存在进程私有堆里，这样的二进制数据叫做<em>Refc Binary</em>（引用计数二进制），它们存储在一个大<em>共享堆</em>，被那些有指向引用计数二进制数据指针的进程访问。那些指针叫做<em>ProcBin</em>并且存储在进程的私有堆里。</li>
</ul>
<h1 id="垃圾回收细节"><a href="#垃圾回收细节" class="headerlink" title="垃圾回收细节"></a>垃圾回收细节</h1><p>为了解释当前默认的Erlang垃圾回收机制，我们可以简单地说，一种是独立运行在每个Erlang进程私有堆内的分代复制垃圾回收，另一种是发生在全局共享堆的引用计数垃圾回收。</p>
<h2 id="私有堆垃圾回收"><a href="#私有堆垃圾回收" class="headerlink" title="私有堆垃圾回收"></a>私有堆垃圾回收</h2><p>私有堆的垃圾回收是分代的。分代垃圾回收将堆分成两个段：年轻代和老生代。分代的原理是：如果一个对象在一个垃圾回收周期存活下来，那么它短时间成为垃圾的机会就降低了。所以年轻代给新分配的数据使用，老生代给那些已经执行了指定次数的垃圾回收后还依然幸存下来的数据使用。这种分割为两个段的方式有助于垃圾回收减少在还没有变成垃圾的数据上进行不必要的垃圾回收过程。Erlang的垃圾回有两种策略：<em>分代的</em>（轻量级的）和<em>全扫描</em>（重量级的）。分代的垃圾回收只是回收年轻代堆，而全扫描垃圾回收则回收年轻代和老生的堆。现在让我们仔细看看一个新启动的Erlang进程在私有堆里的垃圾回收步骤：</p>
<p><strong>场景1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; No GC &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个短时存活的进程没有垃圾回收发生，它用的堆没有超过<em>min_heap_size</em>设置的值然后就终止了。在这个场景下，被进程使用的所有内存都被回收。</p>
<p><strong>场景2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Terminate</div></pre></td></tr></table></figure>
<p>一个新创建的进程，它的数据增长超过<em>min_heap_size</em>设置的值，所以发生了一次全扫描垃圾回收，很明显因为在此之前从来没有发生过垃圾回收，所以就不存在年轻代和老生代两个段。在第一次全扫描垃圾回收后，堆被分割成年轻代和老生代，并且此后垃圾回收策略切换到分代的垃圾回收并且一直维持这种策略直到进程终止。</p>
<p><strong>场景3:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Generational &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在进程的生命周期里当垃圾回收策略从分代的垃圾回收再次切换到全扫描的垃圾回收的时候，这会有几种不同的情况。第一种情况是在一定数量的分代的垃圾回收发生后。这个一定的数量可以全局设置或者每个进程用<em>fullsweep_after</em>标志设置。每个进程的分代的垃圾回收次数统计和它切换到全扫描到垃圾回收前的分代的垃圾回收次数上限分别是进程的<em>minor_gcs</em>和<em>fullsweep_after</em>属性，同时这两个值可用<em>process_info(PID, garbage_collection)</em>的返回值来获得。第二种情况是分代的垃圾回收不能回收足够的内存的时候。最后一种情况是当<em>garbage_collection(PID)</em>函数被手工调用的时候。在这几种情况后，垃圾回收策略再次从全扫描的垃圾回收切换回分代的垃圾回收并且保持直到上述的情况发生。</p>
<p><strong>场景4:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Increase Heap &gt; Fullsweep &gt; ... &gt; Terminate</div></pre></td></tr></table></figure>
<p>在场景3里，如果第二次全扫描垃圾回收不能回收足够的内存，那么堆被增大，而垃圾回收策略再切换回全扫描垃圾回收，像一个新创建的进程一样。所有这四种场景可以反复发生。</p>
<p>那么现在的问题是，像Erlang这样的自动垃圾回收语言，上述这些知识为什么重要？首先这些知识能帮助你通过调优全局的或某个进程的垃圾回收的发生和策略来使得你的系统更快。其次从它的垃圾回收角度来开，我们可以理解使得Erlang成为一个软实时平台的主要原因之一。这是因为每一个进程都有它自己的私有堆和它自己的垃圾回收，因此每次在一个进程里垃圾回收发生只是让这个正在进行垃圾回收的进程停顿而不会停顿其他任何进程，这是一个软实时系统所需要的。</p>
<h2 id="共享堆垃圾回收"><a href="#共享堆垃圾回收" class="headerlink" title="共享堆垃圾回收"></a>共享堆垃圾回收</h2><p>共享堆垃圾回收是引用计数垃圾回收。每一个共享堆里的对象（Refc）都有一个引用它的计数器，这个计数器被其他对象（ProcBin）持有，而这个ProcBin对象存储在Erlang进程的私有堆里。如果一个对象的引用计数器的值变为0，这个对象变成不可访问，并且将被销毁。引用计数器方式的垃圾回收是如此的廉价而且帮助系统避免出现意外的长时间暂停同时促进了系统的响应。但是由于在设计你的参与者模式系统时不太熟悉的一些知名反模式可能会造成内存泄漏的麻烦。</p>
<ul>
<li>首先是当一个引用计数二进制数据被分割为子二进制数据。为了节省资源，子二进制数据并不是原二进制数据分割部分的新拷贝，而只是对这个分割部分的引用。然而除了原始二进制数据，这个子二进制数据的引用计数是一个新的引用，正如你能理解的，这将导致一个问题，原始二进制数据必须等它的子二进制数据被回收后才能回收。</li>
<li>另一个众所周知的问题是当有一类长期生存的中间件进程，它作为一个请求控制器或消息路由器来控制和传输大的引用计数二进制消息。因为这个进程和所有这些引用计数二进制数据关联，所以它们的计数器值就增加了。所以回收这些引用计数二进制数据依赖于回收所有的ProcBin对象，甚至包括这个中间件进程里的ProcBin对象。非常不幸的是，因为ProcBin只是一个指针，它非常廉价，以至于在这个中间件进程里要花很长时间才能遇到一次回收这个ProcBin对象。造成的结果就是，即使除了中间件进程外其他所有进程里的ProcBin对象都被回收了，引用计数二进制数据还是继续留存在共享堆里。</li>
</ul>
<p>共享堆很重要，因为它减少了进程间传递大二进制消息的IO开销。另外子二进制数据只是某个二进制数据的指针，所以它的创建是如此快速。但是按一般规律来说，为了更快而使用快捷方式是有代价的，代价就是要以某种方式好好设计你的系统不至于让你陷入到麻烦当中。另外针对引用计数二进制数据泄漏问题有一些著名的架构模式，这些在<a href="http://ferd.ca/" target="_blank" rel="external">Fred Hebert</a>的免费电子书 <a href="http://www.erlang-in-anger.com/" target="_blank" rel="external">Erlang in Anger</a> 里有详细的解释，我想我是没办法解释的比他更好。所以我强烈建议你读一下这本书。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>即使我们现在正在使用的语言，它像Erlang这样自己管理内存，但是也不能阻止我们去理解它是如何分配和回收内存的。不像<a href="https://golang.org/ref/mem" target="_blank" rel="external">Go语言内存模型文档</a>所建议的：“如果你必须读本文档剩下部分来理解你自己程序的行为，你就是太聪明了。不过别自作聪明。”，我相信我们必须足够聪明才能够使我们的系统更快更安全，有时候它不会发生除非我们更深地钻研挖进去理解它的本质。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/faq/academic.html" target="_blank" rel="external">Erlang的学时和历史疑问</a></li>
<li><a href="http://lampwww.epfl.ch/resources/lamp/teaching/advancedCompiler/2004/slides/ImplementationOfConcurrency_slides.pdf" target="_blank" rel="external">FPL和并发执行</a></li>
<li><a href="http://user.it.uu.se/~jesperw/publications/Wilhelmsson_lic.pdf" target="_blank" rel="external">消息传递并发的有效内存管理</a></li>
<li><a href="http://labouseur.com/courses/erlang/programming-parallel-with-erlang.pdf" target="_blank" rel="external">用Erlang编程并行世界</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Erlang尝试解决的一个主要问题就是为实现高水平响应的&lt;a href=&quot;https://en.wikipedia.org/wiki/Real-time_computing&quot;&gt;软实时系统&lt;/a&gt;创建一个平台。这样的系统需要快速的&lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;垃圾回&lt;/a&gt;收策略，这样就不会阻止系统以及时的方式进行响应。另外当我们认为Erlang是一门无破坏性修改特性的&lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;不可改变&lt;/a&gt;语言的时候，垃圾回收变得更重要，因为这样的语言有更高产生垃圾的几率。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/categories/Erlang/GC/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="GC" scheme="http://szpzs.oschina.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Erlang调度器的细节以及它为何重要</title>
    <link href="http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/"/>
    <id>http://szpzs.oschina.io/2016/12/11/erlang-scheduler-details/</id>
    <published>2016-12-10T16:50:08.000Z</published>
    <updated>2016-12-10T16:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《<a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html" target="_blank" rel="external">Erlang垃圾回收细节以及它为何重要</a>》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。</p>
<a id="more"></a>
<h1 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度"></a>什么是调度</h1><p>通常来说，调度就是一种分派工作给工作者的机制。所谓的工作可能是一个算数运算、字符串处理或者数据抽取，而工作者是一些资源，比如像<a href="https://en.wikipedia.org/wiki/Green_threads" target="_blank" rel="external">Green Thread</a>这样虚拟的资源或者像<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Native Thread</a>这样的物理资源。调度器以一种方式执行调度活度，最大限度地提高吞吐量和公平性，最大限度地降低响应时间和延时。调度是像操作系统和虚拟机这样的多任务系统的重要组成部分，它被分为两种类型：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29" target="_blank" rel="external">抢占式</a>：一个抢占式调度器在执行的任务间进行上下文切换，它有权力抢占（中断）任务并且在不需要被抢占任务的配合下的稍后恢复执行它们。实现这样的功能是基于如下几个因素，比如：任务的优先级，时间切片或者规约数。</li>
<li><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="external">协作式</a>：一个协作式调度器需要任务协作来进行上下文切换。在这种方式下，调度器简单地让任务周期性地或者空闲地时候自愿地释放控制权，然后启动一个新的任务并且再一次等待它自愿地归还控制权。</li>
</ul>
<p>现在的问题是，哪一种调度机制适合软实时系统，也就是这个系统必须在指定的时间内响应。协作式调度系统不能满足软实时系统的要求，因为其运行的任务可能永远也不会返还控制权或者在规定时限后返还控制权。所以软实时系统通常采用抢占式调度。</p>
<h1 id="Erlang的调度"><a href="#Erlang的调度" class="headerlink" title="Erlang的调度"></a>Erlang的调度</h1><p>Erlang作为一个多任务软实时平台采用的就是抢占式调度。Erlang调度器的职责就是选择一个进程并执行它的代码。它也处理垃圾回收和内存管理。如何选择一个进程来执行是基于每个进程可配置的优先级，并且同一优先级的进程是轮询地被调度的。另外，执行中的进程被抢占的因素是基于自上次该进程被选中执行后一定数量的<strong>规约数</strong>而不管它的优先级如何。规约数是每个进程的一个计数器，一般每调用一次函数，它就加一。当一个进程的计数器达到最大规约数时，就会抢占进程和进行上下文切换。例如，在Erlang/OTP R12B 计数器的最大值是2000规约数。</p>
<p>Erlang的任务调度有很长的发展历史。它随着时间而改变。这些改变受Erlang的SMP（对称多处理器）特性的改变而被影响。</p>
<h2 id="R11B之前的调度"><a href="#R11B之前的调度" class="headerlink" title="R11B之前的调度"></a>R11B之前的调度</h2><p>在R11B之前，Eralng还不支持SMP，因此它只有一个调度器运行在操作系统主进程的线程里，并且相应的只有一个<strong>运行队列</strong>。调度器从运行队列选择可运行的Erlang进程和IO任务来执行。</p>
<p><img src="/images/scheduling-before-r11b.png" style="border:0;"></p>
<p>这种方式不需要锁数据结构，但是这么写的应用无法利用并行的好处。</p>
<h2 id="R11B和R12B的调度"><a href="#R11B和R12B的调度" class="headerlink" title="R11B和R12B的调度"></a>R11B和R12B的调度</h2><p>SMP支持被加入Erlang虚拟机里，所以它可以有1到1024个运行在操作系统进程的线程里的调度器。然而，这个版本的调度器只能从一个共用运行队列里选取可执行任务。</p>
<p><img src="/images/scheduling-in-r11b-and-r12b.png" style="border:0;"></p>
<p>由于这种方式造成并行，使得所有共享数据结构都要用锁保护起来。例如运行队列本身就是一个必须被保护起来的共享数据结构。虽热锁会造成一些性能损失，但是新的调度器在多核处理器上带来的性能提升还是很可观的。</p>
<p>在这个版本里的一些瓶颈如下：</p>
<ul>
<li>当调度器增加后，共用运行队列成为瓶颈。</li>
<li>增加ETS表相关的锁，同时也影响到Mnesia。</li>
<li>当许多进程同时给一个进程发送消息的时候增加锁的冲突。</li>
<li>一个进程等待获取一个锁的时候会阻塞它的调度器。</li>
</ul>
<p>然而，每一个调度器分配一个运行队列的方案在下一个版本被选择来解决这些瓶颈。</p>
<h2 id="R13B后的调度"><a href="#R13B后的调度" class="headerlink" title="R13B后的调度"></a>R13B后的调度</h2><p>在这个版本，每个调度器有它自己的运行队列。在多核多调度器的系统里，这将减少锁冲突数量并且提升系统整体性能。</p>
<p><img src="/images/scheduling-after-r13b.png" style="border:0;"></p>
<p>这种方式在访问运行队列时锁冲突解决了，不过却引入了一些新问题：</p>
<ul>
<li>如何在运行队列中分配任务做到公平？</li>
<li>如果一个调度器被分配了过多的任务而另外的调度器却很清闲，这个问题如何解决？</li>
<li>基于什么样的命令一个调度器可以从一个过载的调度器偷任务？</li>
<li>要是我们启动了很多调度器，但是却很少任务，如何处理？</li>
</ul>
<p>这些问题使得Erlang开发团队引入一个概念使得调度公平和高效，这个概念就是<strong>迁移逻辑</strong>。它尝试在基于从系统收集来的统计数据上控制和平衡运行队列。</p>
<p>然而我们不应该让我们的调度一直维持现状，因为它很可能在将来的版本变得更好。</p>
<h1 id="控制和监督API"><a href="#控制和监督API" class="headerlink" title="控制和监督API"></a>控制和监督API</h1><p>有一些Erlang模拟器启动标志和一些内部控制和监督函数与调度器行为有关。</p>
<h2 id="调度线程"><a href="#调度线程" class="headerlink" title="调度线程"></a>调度线程</h2><p>当用erl启动脚本启动Erlang模拟器的时候，可以通过给+S标志传递两个用冒号分割的数字来指定最大可用调度线程数和在线调度线程数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S MaxAvailableSchedulers:OnlineSchedulers</div></pre></td></tr></table></figure>
<p>最大可用调度线程数只能在启动的时候指定而且在运行时是固定不变的，但是在线调度线程数可以在启动和运行时被指定和修改。例如我们可以在启动一个模拟器的时候指定16个最大调度线程和8个在线调度线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ erl +S 16:8</div></pre></td></tr></table></figure>
<p>然后在shell里在线调度线程可以被修改，如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; erlang:system_info(schedulers). <span class="comment">%% =&gt; returns 16</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_flag(schedulers_online, <span class="number">16</span>). <span class="comment">%% =&gt; returns 8</span></div><div class="line">&gt; erlang:system_info(schedulers_online). <span class="comment">%% =&gt; returns 16</span></div></pre></td></tr></table></figure>
<p>另外，使用+SP标志可以用百分比的方式设置这两个值。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>如前所述调度器基于进程的优先级来选择它们来执行。优先级可以在进程内通过调用erlang:process_flag/2函数来设置。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PID = spawn(<span class="keyword">fun</span>() -&gt;</div><div class="line">   <span class="comment">%% ...</span></div><div class="line">   <span class="keyword">end</span>).</div></pre></td></tr></table></figure>
<p>优先级可以是 low、normal、high、max 这些原子中的任何一个。默认优先级是normal，max优先级是保留给Erlang运行时内部使用不应被一般进程使用。</p>
<h2 id="运行队列统计"><a href="#运行队列统计" class="headerlink" title="运行队列统计"></a>运行队列统计</h2><p>如前所述运行队列持有准备好执行但未被调度器选中执行的进程。可以通过调用erlang:statistics(run_queue)获取在所有可用运行队列已经准备好可运行的进程数。作为一个真实例子，让我启动Erlang模拟器，给它4个在线调度器，并且给它们10个非常消耗CPU的并发进程。这些进程<a href="https://gist.github.com/hamidreza-s/9e3ed289f65759048875" target="_blank" rel="external">计算一个很大数字的素数</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%% 就绪</span></div><div class="line">&gt; erlang:statistics(online_schedulers). <span class="comment">%% =&gt; 4</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div><div class="line"></div><div class="line"><span class="comment">%% 并发创建10个重型进程</span></div><div class="line">&gt; [spawn(<span class="keyword">fun</span>() -&gt; calc:prime_numbers(<span class="number">10000000</span>) <span class="keyword">end</span>) || _ &lt;- lists:seq(<span class="number">1</span>, <span class="number">10</span>)].</div><div class="line"></div><div class="line"><span class="comment">%% 运行队列中还有任务要做</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 8</span></div><div class="line"></div><div class="line"><span class="comment">%% Erlang shell依然可以响应，非常棒！</span></div><div class="line">&gt; calc:prime_numbers(<span class="number">10</span>). <span class="comment">%% =&gt; [2, 3, 5, 7]</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 4</span></div><div class="line"></div><div class="line"><span class="comment">%% 等一会儿</span></div><div class="line">&gt; erlang:statistics(run_queue). <span class="comment">%% =&gt; 0</span></div></pre></td></tr></table></figure>
<p>因为并发进程数大于在线调度器，这将花些时间让调度器执行运行队列里的进程并最终清空运行队列。有趣的是，创建了这些重型进程后，Erlang模拟器任然因为它的抢占式调度可以响应其他请求。Erlang的抢占式调度不会让这些重型进程消耗掉所有运行时，其他轻量并且重要的进程也可以被执行，这个特性在实现一个软实时系统的时候是非常棒的。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>虽然实现一个抢占式调度系统可能很复杂，但是在Erlang里这些不是开发者的责任，因为抢占式调度特性已经在Erlang虚拟机里。另一方面，当在一个软实时系统里系统以高水平的公平性和即时的响应需要扩展到所有处理资源的时候，跟踪、平衡、执行、迁移和抢占进程这些额外的处理成本是完全可负担的。顺便值得一提的是，完全抢占式调度是几乎所有操作系统都支持的特性，但在高层次的平台，语言或库里，Erlang虚拟机几乎是唯一完全抢占式调度的，因为JVM依赖于操作系统的调度器，CAF这个C++ actor库用协作式调度，Go也不是完全抢占式调度，还有诸如Python的Twisted，Ruby的Event Machine和Nodejs也不是完全抢占式调度的。这并不意味着对于所有的挑战这都是最好的选择，而是说我们如果要实现一个低延时的软实时系统，Erlang是一个好的选择。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="http://www.erlang.org/doc/man/erl.html" target="_blank" rel="external">erl脚本官方文档</a></li>
<li><a href="http://erlang.org/doc/man/erlang.html" target="_blank" rel="external">erlang模块官方文档</a></li>
<li><a href="http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html" target="_blank" rel="external">Erlang如何调度</a></li>
<li><a href="http://www.erlang.org/euc/08/euc_smp.pdf" target="_blank" rel="external">深入Erlang虚拟机</a></li>
<li><a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html" target="_blank" rel="external">Erlang调度器：它是如何工作的</a></li>
</ul>
<blockquote>
<p><em>原文链接：</em>  <a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank" rel="external">https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些基本的特性使得Erlang成为一个软实时平台。其中之一是它的垃圾回收机制，我已经在我上一篇文章《&lt;a href=&quot;https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html&quot;&gt;Erlang垃圾回收细节以及它为何重要&lt;/a&gt;》里谈到了这点。另一个特性就是它的调度机制，这个特性值得我们好好研究一下。本文我将解释它的历史、现状，以及控制和监督API。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Scheduler" scheme="http://szpzs.oschina.io/categories/Erlang/Scheduler/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Scheduler" scheme="http://szpzs.oschina.io/tags/Scheduler/"/>
    
  </entry>
  
  <entry>
    <title>用Rebar3热更新Erlang代码</title>
    <link href="http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/"/>
    <id>http://szpzs.oschina.io/2016/12/09/hot-code-loading-with-erlang-and-rebar3/</id>
    <published>2016-12-09T13:16:16.000Z</published>
    <updated>2016-12-09T13:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：</p>
<blockquote>
<p>代码热更新就是一门给正在飞奔的汽车换引擎的艺术。</p>
</blockquote>
<p>简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。</p>
<a id="more"></a>
<p>我们将创建一个样例项目，然后学习如何来做代码热更新。这个项目的代码我已经放在<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">这里</a>。让我们用rebar3来创建一个模版项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new release nine9s</div></pre></td></tr></table></figure>
<p>现在我们在我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config" target="_blank" rel="external">rebar.config</a>文件里增加cowboy和lager为依赖。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [</div><div class="line">	&#123;lager, &#123;git, <span class="string">"git://github.com/basho/lager.git"</span>, &#123;tag, <span class="string">"2.1.1"</span>&#125;&#125;&#125;,</div><div class="line">	&#123;cowboy, &#123;git, <span class="string">"https://github.com/ninenines/cowboy.git"</span>, &#123;tag, <span class="string">"2.0.0-pre.1"</span>&#125;&#125;&#125;</div><div class="line">]&#125;.</div></pre></td></tr></table></figure>
<p>为了更加真实的体验，请按如下修改我们的<a href="https://github.com/kansi/nine9s/blob/0.1.0/rebar.config#L14-L15" target="_blank" rel="external">rebar.config</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;relx, [</div><div class="line">		&#123;release, &#123;'nine9s', <span class="string">"0.1.0"</span>&#125;, ['nine9s', sasl]&#125;,</div><div class="line">		&#123;sys_config, <span class="string">"./config/sys.config"</span>&#125;,</div><div class="line">		&#123;vm_args, <span class="string">"./config/vm.args"</span>&#125;,</div><div class="line">		&#123;dev_mode, false&#125;,</div><div class="line">		&#123;include_erts, true&#125;,</div><div class="line">		&#123;extended_start_script, true&#125;</div><div class="line">	]</div><div class="line">&#125;.</div></pre></td></tr></table></figure>
<p>你可能想知道这个“nine9s”应用将会做些什么？我的想法是先让这个应用做成一个hello world的web服务，然后再热更新它的代码。修改你的nine9s_app.erl文件以便让start/2看起来像下面一样：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line"> Dispatch = cowboy_router:compile(</div><div class="line">                                  [&#123;‘_’, [</div><div class="line">                                          &#123;“/”, default_handler, []&#125;</div><div class="line">                                         ]&#125;</div><div class="line">                                  ]),</div><div class="line"> &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line"> [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line"> ‘nine9s_sup’:start_link().</div></pre></td></tr></table></figure>
<p>现在我们创建一个模块，它叫做default_handler.erl。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-module(default_handler).</div><div class="line">-export([init/2]).</div><div class="line">init(Req, Opts) -&gt;</div><div class="line">    Req2 = cowboy_req:reply(200, [ &#123;&lt;&lt;”content-type"&gt;&gt;,</div><div class="line">                                    &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                            &lt;&lt;”Hello world!”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>接下来，我们编译并运行这个应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile &amp;&amp; rebar3 release</div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 console</div></pre></td></tr></table></figure>
<p>现在你已经运行了你的应用，你可以浏览<a href="http://localhost:9090" target="_blank" rel="external">http://localhost:9090</a>来验证一下。请保持这个应用一直运行，因为我们将创建这个应用的一个新版本并且尝试在线进行代码热更新。</p>
<p>上述代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0分支</a>里。</p>
<p>我们开始添加一些新的特性到我们的项目里，这样将形成我们项目的0.2.0版本，然后我们将尝试在运行着的0.1.0版本上在线进行代码热更新。版本0.2.0的代码在<a href="https://github.com/kansi/nine9s/tree/master" target="_blank" rel="external">项目</a>的<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0分支</a>。</p>
<p>我们想统计我们的default_handler已经响应的请求数。这个很好解决，我们创建一个模块<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/state_handler.erl" target="_blank" rel="external">state_handler.erl</a>，它是一个gen_server，它将存储default_handler.erl被调用的次数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(state_handler)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</div><div class="line"><span class="comment">%% API functions</span></div><div class="line"><span class="keyword">-export</span><span class="params">([hello_world/<span class="number">0</span>,</span></div><div class="line">         get_hello_world_count/<span class="number">0</span>,</div><div class="line">         start_link/<span class="number">0</span>]).</div><div class="line"><span class="comment">%% gen_server callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>,</span></div><div class="line">         handle_call/<span class="number">3</span>,</div><div class="line">         handle_cast/<span class="number">2</span>,</div><div class="line">         handle_info/<span class="number">2</span>,</div><div class="line">         terminate/<span class="number">2</span>,</div><div class="line">         code_change/<span class="number">3</span>]).</div><div class="line"><span class="keyword">-record</span><span class="params">(state, &#123;count = <span class="number">0</span>&#125;)</span>.</div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="comment">%%% API functions</span></div><div class="line"><span class="comment">%%%==========================================================</span></div><div class="line"><span class="function"><span class="title">hello_world</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:cast(?MODULE, hello_world).</div><div class="line"><span class="function"><span class="title">get_hello_world_count</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:call(?MODULE, hello_world_count).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    gen_server:start_link(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="comment">%%% callback functions</span></div><div class="line"><span class="comment">%%%===========================================================</span></div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    &#123;ok, #state&#123;&#125;&#125;.</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(hello_world_count, _From, State)</span> -&gt;</span></div><div class="line">    &#123;reply, State#state.count, State&#125;;</div><div class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, _From, State)</span> -&gt;</span></div><div class="line">    Reply = ok,</div><div class="line">    &#123;reply, Reply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(hello_world, State)</span> -&gt;</span></div><div class="line">    Count = State#state.count,</div><div class="line">    &#123;noreply, State#state&#123;count = Count + <span class="number">1</span>&#125;&#125;;</div><div class="line"><span class="function"><span class="title">handle_cast</span><span class="params">(_Msg, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, State)</span> -&gt;</span></div><div class="line">    &#123;noreply, State&#125;.</div><div class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State)</span> -&gt;</span></div><div class="line">    ok.</div><div class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></div><div class="line">    &#123;ok, State&#125;.</div></pre></td></tr></table></figure>
<p>我们修改我们的<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/default_handler.erl" target="_blank" rel="external">default_handler.erl</a>，以便每次它接收到请求的时候就通知state_handler。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(default_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    state_handler:hello_world(),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         &lt;&lt;”Hello world <span class="number">2</span> !”&gt;&gt;, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>我们的state_handler将是<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_sup.erl" target="_blank" rel="external">nine9s_sup</a>监督者下的一个工作进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_sup’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</div><div class="line"><span class="keyword">-define</span><span class="params">(CHILD(Id, Mod, Args, Restart, Type)</span>, &#123;Id, &#123;Mod, start_link, Args&#125;, Restart, 60000, Type, [Mod]&#125;).</div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    supervisor:start_link(&#123;local, ?SERVER&#125;, ?MODULE, []).</div><div class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></div><div class="line">    State_Handler = ?CHILD(state_handler, state_handler, [], transient, worker),</div><div class="line">    &#123;ok, &#123; &#123;one_for_all, <span class="number">0</span>, <span class="number">1</span>&#125;, [State_Handler]&#125; &#125;.</div></pre></td></tr></table></figure>
<p>既然我们已经记录了default_handler的访问次数，我们就想有一个cowboy的路由来给出当前的访问次数，所以我们修改<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s_app.erl" target="_blank" rel="external">nine9s_sup.erl</a>。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(‘nine9s_app’)</span>.</div><div class="line"><span class="keyword">-behaviour</span><span class="params">(application)</span>.</div><div class="line"><span class="comment">%% Application callbacks</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">2</span></span></div><div class="line">         ,stop/<span class="number">1</span>]).</div><div class="line"><span class="keyword">-export</span><span class="params">([set_routes_new/<span class="number">0</span></span></div><div class="line">        ,set_routes_old/<span class="number">0</span> ]).</div><div class="line"><span class="function"><span class="title">start</span><span class="params">(_StartType, _StartArgs)</span> -&gt;</span></div><div class="line">    Dispatch = cowboy_router:compile([&#123;‘_’, get_new_routes()&#125;]),</div><div class="line">    &#123;ok, _&#125; = cowboy:start_http(http, <span class="number">10</span>, [&#123;port, <span class="number">9090</span>&#125;],</div><div class="line">    [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]),</div><div class="line">    ‘nine9s_sup’:start_link().</div><div class="line"><span class="function"><span class="title">stop</span><span class="params">(_State)</span> -&gt;</span> ok.</div><div class="line"><span class="function"><span class="title">get_new_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/count”, count_handler, []&#125;] ++ get_old_routes().</div><div class="line"><span class="function"><span class="title">get_old_routes</span><span class="params">()</span> -&gt;</span></div><div class="line">    [&#123;“/”, default_handler, []&#125;].</div><div class="line"><span class="function"><span class="title">set_routes_new</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_new_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div><div class="line"><span class="function"><span class="title">set_routes_old</span><span class="params">()</span> -&gt;</span></div><div class="line">    CompileRoutes = cowboy_router:compile([&#123;‘_’, get_old_routes() &#125;]),</div><div class="line">    cowboy:set_env(http, dispatch, CompileRoutes).</div></pre></td></tr></table></figure>
<p>请注意，我们把路由分成两部分，一部分是版本0.1.0里就有的，也就是老路由，还有一部分就是新路由。函数set_routes_new/0和set_routes_old/0我们将在后面解释。</p>
<p>下述代码是count_handler模块，就是处理路由 “/count”的模块。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(count_handler)</span>.</div><div class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">2</span>])</span>.</div><div class="line"><span class="function"><span class="title">init</span><span class="params">(Req, Opts)</span> -&gt;</span></div><div class="line">    Count = state_handler:get_hello_world_count(),</div><div class="line">    BCount = integer_to_binary(Count),</div><div class="line">    Req2 = cowboy_req:reply(<span class="number">200</span>, [ &#123;&lt;&lt;”content-type”&gt;&gt;,</div><div class="line">                                 &lt;&lt;”text/plain”&gt;&gt;&#125; ],</div><div class="line">                         BCount, Req),</div><div class="line">    &#123;ok, Req2, Opts&#125;.</div></pre></td></tr></table></figure>
<p>最后，我们将修改在<a href="https://github.com/kansi/nine9s/blob/0.2.0/apps/nine9s/src/nine9s.app.src#L3" target="_blank" rel="external">nine9s.app.src</a>和<a href="https://github.com/kansi/nine9s/blob/0.2.0/rebar.config#L7" target="_blank" rel="external">rebar.config</a>里的版本数字。版本0.2.0的特性就完成了。现在我们将尝试将正在运行的0.1.0版本升级到版本0.2.0。</p>
<p>为了升级到新的版本，我们需要创建一个appup文件，也就是nine9s.app.src文件，它描述了如何从版本0.1.0升级到0.2.0。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"vsn in app.src"</span>,</div><div class="line">    [ &#123;<span class="string">"upgrade from vsn"</span>, Instructions1&#125;],</div><div class="line">    [ &#123;<span class="string">"downgrade to vsn"</span>, Instructions2&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>appup文件是一个三元素组成的元组文件。第一个元素是和.app.src文件里一样的版本号（也就是当前版本）。第二个元素是一个元组列表，它的第一个元素是将要被升级的版本号，它的第二个元素是一些指令组成的列表，这些指令指示该如何从这个版本升级到新的版本。第三个元素也是一个元组列表，它的第一个元素是将要降级到的版本号，它的第二个元素是也是一些指令组成的列表，这些指令指示该如何降级到这个版本。</p>
<p>下面是应用nine9s的appup文件内容：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;“<span class="number">0.2</span>.<span class="number">0</span>”,</div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;add_module, state_handler&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, restart_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;add_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_new, [] &#125;&#125; ] &#125;],</div><div class="line"></div><div class="line">  [&#123;“<span class="number">0.1</span>.<span class="number">0</span>”, [</div><div class="line">              &#123;load_module, default_handler&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, terminate_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;apply, &#123;supervisor, delete_child, [nine9s_sup, state_handler]&#125;&#125;</div><div class="line">             ,&#123;update, nine9s_sup, supervisor&#125;</div><div class="line">             ,&#123;delete_module, state_handler&#125;</div><div class="line">             ,&#123;apply, &#123;nine9s_app, set_routes_old, [] &#125;&#125;</div><div class="line">             ,&#123;delete_module, count_handler&#125;</div><div class="line">             ,&#123;load_module, nine9s_app&#125;</div><div class="line">             ]</div><div class="line">&#125;]&#125;.</div></pre></td></tr></table></figure></p>
<p>现在我们先来解释一下升级指令。注意：这些指令是按它们在文件中的先后顺序来执行的。</p>
<ul>
<li>{add_module, state_handler} : 指示增加state_handler模块到运行环境里。</li>
<li>{update, nine9s, supervisor} : 这条指令将修改监督者的内部状态，也就是改变重启策略和最大重启频率，同时也改变子进程规格说明。最终将增加state_handler这个模块到监督者的子进程规格说明里。</li>
<li>{apply, {supervisor, restart_child, [nine9s, state_handler]}} : “apply”指令接收{M,F,A}做为参数，然后执行 M:F(A1, … An)。所以我们实际上是执行supervisor:restart_child(nine9s, state_handler)，这将在nine9s_sup监督者下启动state_handler做为工作进程。请注意：上述三条指令的顺序。首先我们增加state_handler模块，然后改变监督者的状态，最后创建state_handler进程。</li>
<li>{load_module, default_handler} : 这条指令将重新装载default_handler模块，替换它的老版本代码。</li>
<li>{add_module, count_handler} : 增加count_handler模块。</li>
<li>{load_module, nine9s_app} : 我们重新装载nine9s_app，从而我们新增加的函数被装载进虚拟机。</li>
<li>{apply, {nine9s_app, set_routes_new, [ ] }} ] } ] : 既然我们装载了新的函数，我就执行 nine9s_app:set_routes_new() 增加新的路由到我们的服务器。</li>
</ul>
<p>接下来的元素是如何降级的指令，它的工作模式和前一个元素相似，但是是用老模块替换新模块。</p>
<ul>
<li>{load_module, default_handler} : 这个指令将装载老的default_handler模块。</li>
<li>{apply, {supervisor, terminate_child, [nine9s_sup, state_handler]}} : 终止state_handler进程。</li>
<li>{apply, {supervisor, delete_child, [nine9s_sup, state_handler]}} : 从nine9s_sup里删除state_handler这个子进程规格。</li>
<li>{update, nine9s_sup, supervisor} : 修改监督者nine9s_sup的内部状态。</li>
<li>{delete_module, state_handler} : 删除state_handler模块。</li>
<li>{apply, {nine9s_app, set_routes_old, [ ] }} : 设置路由为老版本路由。</li>
<li>{delete_module, count_handler} : 删除count_handler模块。</li>
<li>{load_module, nine9s_app} : 装载老的nine9s_app模块。</li>
</ul>
<p>既然我们的appup文件准备好了，我们就开始升级到最新的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先我们拷贝appup文件到lib目录下nine9s/ebin下</span></div><div class="line">$ cp apps/nine9s/src/nine9s.appup.src _build/default/lib/nine9s/ebin/nine9s.appup</div><div class="line"><span class="comment"># 接着我们编译和发布应用</span></div><div class="line">$ rebar3 compile</div><div class="line">$ rebar3 release</div><div class="line"><span class="comment"># 生成relup到前一个版本</span></div><div class="line">$ rebar3 relup -n nine9s -v <span class="string">"0.2.0"</span> -u <span class="string">"0.1.0"</span></div><div class="line"><span class="comment"># 生成新版本的tar文件</span></div><div class="line">$ rebar3 tar -n nine9s -v <span class="string">"0.2.0"</span></div><div class="line">$ mv _build/default/rel/nine9s/nine9s-0.2.0.tar.gz _build/default/rel/nine9s/releases/0.2.0/nine9s.tar.gz</div><div class="line"><span class="comment"># 升级到新的版本</span></div><div class="line">$ _build/default/rel/nine9s/bin/nine9s-0.1.0 upgrade <span class="string">"0.2.0"</span></div></pre></td></tr></table></figure>
<p>搞定！如果所有执行都成功，那么我们就升级到0.2.0版本了。你可以浏览 <a href="http://localhost:9090和http://localhost:9090/count来验证一下。" target="_blank" rel="external">http://localhost:9090和http://localhost:9090/count来验证一下。</a></p>
<p>项目有两个分支<a href="https://github.com/kansi/nine9s/tree/0.1.0" target="_blank" rel="external">0.1.0</a>和<a href="https://github.com/kansi/nine9s/tree/0.2.0" target="_blank" rel="external">0.2.0</a>。你可以先编译和运行分支0.1.0，然后切换到0.2.0分支，使用python脚本<a href="https://github.com/kansi/nine9s/blob/0.2.0/upgrade.py" target="_blank" rel="external">upgrade.py</a>来升级到0.2.0版本。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4" target="_blank" rel="external">https://medium.com/@kansi/hot-code-loading-with-erlang-and-rebar3-8252af16605b#.zu5b3bzk4</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中我将探讨为了在生产环境里获得高可用性的关键特性：代码热更新。下面是我给不熟悉代码热更新的同学关于这个概念的正式定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码热更新就是一门给正在飞奔的汽车换引擎的艺术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，它的目的就是不停止服务的情况下用新的代码替换正在运行的代码。现在我们明白了代码热更新是什么了，那么让我们尝试着看看在Erlang里如何做到代码热更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/tags/Rebar3/"/>
    
      <category term="热更新" scheme="http://szpzs.oschina.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Rebar3 Shell</title>
    <link href="http://szpzs.oschina.io/2016/12/07/rebar3-shell/"/>
    <id>http://szpzs.oschina.io/2016/12/07/rebar3-shell/</id>
    <published>2016-12-07T13:39:29.000Z</published>
    <updated>2016-12-23T12:15:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。</p>
<a id="more"></a>
<p>它有很多好的特性，不过在我的观点来看，这些是一个Erlang shell工具最少要支持的。因此，尝试展示这些特性听起来好像是吹嘘你该做的本分事情一样；多说无益，下面就进入正题。</p>
<p>不过，一些Erlang的东西的可用性一直很糟糕，我们（贡献者）已经在rebar3上做了很多工作来尝试解决这些糟糕的体验。我不得不说，很多社区已经有大量的非常好的工具，但是它们都是独立的，如何用好它们必须要读者自己去逐个尝试。这个时候，rebar3横空出世了。</p>
<p>当使用rebar3 shell命令的时候首先吸引人的是，它会自动编译项目（如果项目还没有被编译）并且将编译后的项目加入你的代码搜索路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; vegur:module_info().</div><div class="line">[&#123;module,vegur&#125;,</div><div class="line">&#123;exports,[&#123;start_http,3&#125;,</div><div class="line">&#123;start_proxy,3&#125;,</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个功能作用于所有项目。这至少摆脱很多需要你自己手写默认设置的许多烦恼。现在这些都由rebar3 shell来做。</p>
<p>对于一个编程语言来说，一个好的shell环境就是关于它的互动性。期望能够快速地重编译代码或者运行测试，并且重新装载代码而不需要任何中断或丢失状态。rebar3 shell有一个代理，隐藏在r3模块背后，它准备着所有需要重新编译代码或者运行任务的状态的管理。所以，例如任何存在的项目，我可以要求重新编译或者任何其他任务运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&gt; r3:do(compile).</div><div class="line">===&gt; This feature is experimental <span class="keyword">and</span> may be modified or removed at any time.</div><div class="line">Verifying dependencies...</div><div class="line">Compiling vegur</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(ct).</div><div class="line">Verifying dependencies...</div><div class="line">Fetching websocket_client (&#123;git,<span class="string">"git@github.com:jeremyong/websocket_client.git"</span>,</div><div class="line">&#123;tag,<span class="string">"v0.7"</span>&#125;&#125;)</div><div class="line">Linking _build/default/lib/cowboyku to _build/test/lib/cowboyku</div><div class="line">Linking _build/default/lib/cowlib to _build/test/lib/cowlib</div><div class="line">Linking _build/default/lib/erequest_id to _build/test/lib/erequest_id</div><div class="line">...</div><div class="line">Running Common Test suites...</div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_callback: OK</span></div><div class="line"><span class="comment">%%% vegur_bytepipe_SUITE ==&gt; pipe_proc_timeout: OK</span></div><div class="line">...</div><div class="line">All <span class="number">140</span> tests passed.</div><div class="line">ok</div><div class="line"><span class="number">3</span>&gt; r3:do(dialyzer).</div><div class="line">Verifying dependencies...</div><div class="line">...</div><div class="line">Analyzing <span class="number">19</span> files with <span class="string">"/home/ferd/code/self/vegur/_build/default/rebar3_18.1.5_plt"</span>...</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>如上述例子等等。所有这些任务都会用你的最新版本的rebar.config文件来运行它的任务和切换路径重装载模块等等。</p>
<p>rebar3的代理还有一个名字使得可以在外部调用它。你可以用一个名字来启动一个shell（rebar3 shell –name my_shell 或 rebar3 shell –sname my_shell）然后远程向它发送消息或者直接RPC调用当作指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --sname=my_shell</div><div class="line">erl -sname remote -eval <span class="string">'rpc:call(my_shell@localhost, r3, do, [ct]), halt(0).'</span> -noshell</div></pre></td></tr></table></figure>
<p>当作人们的工具的目的应该是可以被用来从你的IDE或编辑器里增加钩子到Erlang shell里。</p>
<p>被写出来的和rebar3代理一起工作的插件也是一种选择。例如，通过监控硬盘，<a href="https://www.rebar3.org/docs/using-available-plugins#auto-compile-and-load" target="_blank" rel="external">rebar3_atuo 能够被用来自动重新编译修改过的文件</a>，这样也省了这个的功能要和IDE或编辑器合成的需求。</p>
<p>这提供了一个非常好的改进，例如，在运行调试周期，在测试，代码分析和交互式调试都可以在同一个环境进行。</p>
<p>为了使得开发周期更加与你的项目成长无缝对接，rebar3 shell将在构建工具里自动侦测<a href="https://www.rebar3.org/docs/releases" target="_blank" rel="external">release配置</a>，并且以你的release遵循的的<a href="https://www.rebar3.org/docs/releases#section-application-configuration" target="_blank" rel="external">应用配置</a>【1】启动你的系统。</p>
<p>这意味着只要你的代码库配置成装配为一个可执行版本，你可以在它里面访问shell的代码重装载特性，使用的是同样的工具，而这些工具你可能以别的方式使用。</p>
<p>如果你不使用release呢？应用可以在你的rebar.config文件里被指定为{shell, [{apps, [myapp]}]}  或者在命令行里的参数里指定（–apps app1,app2）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --apps vegur</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">...</div><div class="line">===&gt; Booted midjan</div><div class="line">===&gt; Booted quickrand</div><div class="line">===&gt; Booted uuid</div><div class="line">===&gt; Booted erequest_id</div><div class="line">===&gt; Booted vegur</div></pre></td></tr></table></figure>
<p>万一你的开发环境和生产环境不匹配，任意的代码可以被运行来设置shell并且通过escript来设置它。这些设置指定的动态环境变量或启动外部依赖的模拟模块是特别有用的。为了进一步解释，下面的例子将展示我们如何不让shell启动，除非所有需要设置的环境变量都设置好了：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env escript</div><div class="line"></div><div class="line"><span class="function"><span class="title">main</span><span class="params">(_)</span> -&gt;</span></div><div class="line">	OSVars = [<span class="string">"USER"</span>, <span class="string">"PASS"</span>],</div><div class="line">	[check_is_set(Var) || Var &lt;- OSVars].</div><div class="line"></div><div class="line"><span class="function"><span class="title">check_is_set</span><span class="params">(Var)</span> -&gt;</span></div><div class="line">	<span class="keyword">case</span> os:getenv(Var) <span class="keyword">of</span></div><div class="line">		<span class="literal">false</span> -&gt;</div><div class="line">			rebar_api:error(<span class="string">"Missing var ~s"</span>, [Var]),</div><div class="line">			halt(<span class="number">1</span>);</div><div class="line">		_ -&gt;</div><div class="line">			ok</div><div class="line">	<span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>这个escript文件可以通过增加{shell, [{script_file, “path/to/file”}]}到你的rebar.config文件配置成总是执行，或者通过在命令行被直接调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rebar3 shell --script_file <span class="built_in">test</span>/check_env.escript</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling vegur</div><div class="line">Erlang/OTP 18 [erts-7.1] [<span class="built_in">source</span>] [64-bit] [smp:8:4] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.1  (abort with ^G)</div><div class="line">1&gt; ===&gt; Missing var PASS</div></pre></td></tr></table></figure>
<p>希望这些工具比那些开箱即用的更可以让Erlang开发者的生活轻松些。</p>
<p>【1】这里有些警告：因为rebar3 shell是一个开发工具，诸如Erlang虚拟机配置的选项（例如，调度器的数量）已经在运行时里有了而且不能被修改。它不能复制所有release的配置，因此，你应该在生产环境保持使用release。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">http://ferd.ca/rebar3-shell.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我花了好长时间来写。关于rebar3 shell的其中一件事就是它会怎么做你期望它处理不论大或小的项目：它装载代码路径，启动应用（如果指定的话），允许一个分布式节点运行，让你定义定制的脚本来设置它的状态，并且让你在它里面运行rebar3的任务，同时好好地更新状态使得工作正常运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3 Shell" scheme="http://szpzs.oschina.io/tags/Rebar3-Shell/"/>
    
  </entry>
  
  <entry>
    <title>用Rebar3构建你的第一个Erlang应用</title>
    <link href="http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/"/>
    <id>http://szpzs.oschina.io/2016/12/05/building-your-first-erlang-app-using-rebar3/</id>
    <published>2016-12-05T03:17:42.000Z</published>
    <updated>2016-12-05T11:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rebar3是Erlang的构建工具和包管理工具。归功于<a href="http://www.rebar3.org/" target="_blank" rel="external">Rebar3</a>以及它的插件<a href="https://hex.pm/" target="_blank" rel="external">Hex</a>，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。</p>
<a id="more"></a>
<h1 id="下载Rebar3"><a href="#下载Rebar3" class="headerlink" title="下载Rebar3"></a>下载Rebar3</h1><p>从Rebar3官方网站下载最新版本的Rebar3，网址：<a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -O https://s3.amazonaws.com/rebar3/rebar3</div></pre></td></tr></table></figure>
<p>用chmod赋予其可执行权限，并将它加入你的环境变量PATH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x rebar3</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:rebar3所在目录</div></pre></td></tr></table></figure>
<h1 id="你的第一个Erlang应用"><a href="#你的第一个Erlang应用" class="headerlink" title="你的第一个Erlang应用"></a>你的第一个Erlang应用</h1><p>使用rebar3 new命令采用内建模块app可以创建一个新的项目。在本例子里我们创建一个叫做myapp的项目。其他可用内建模版是：release、lib、plugin、escript、cmake。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rebar3 new app myapp</div><div class="line">===&gt; Writing myapp/src/myapp_app.erl</div><div class="line">===&gt; Writing myapp/src/myapp_sup.erl</div><div class="line">===&gt; Writing myapp/src/myapp.app.src</div><div class="line">===&gt; Writing myapp/rebar.config</div><div class="line">===&gt; Writing myapp/.gitignore</div><div class="line">===&gt; Writing myapp/LICENSE</div><div class="line">===&gt; Writing myapp/README.md</div></pre></td></tr></table></figure>
<p>代码在src目录里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> myapp</div><div class="line">$ tree</div><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── rebar.config</div><div class="line">└── src</div><div class="line">    ├── myapp.app.src</div><div class="line">    ├── myapp_app.erl</div><div class="line">    └── myapp_sup.erl</div></pre></td></tr></table></figure>
<p>因为Rebar3只处理 <a href="http://www.erlang.org/doc/design_principles/applications.html" target="_blank" rel="external">OTP结构的项目</a> ，所以约定成俗用一个 .app.src 文件定义你的应用是一个OTP应用。看起来是不是很熟悉？这个文件也是Erlang文件。你可以阅读 <a href="http://www.erlang.org/doc/design_principles/applications.html#id73836" target="_blank" rel="external">详细的指引</a> 来看看它都能包括些什么元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp.app.src</div><div class="line">&#123;application, <span class="string">'myapp'</span>,</div><div class="line"> [&#123;description, <span class="string">"An OTP application"</span>&#125;,</div><div class="line">  &#123;vsn, <span class="string">"0.1.0"</span>&#125;,</div><div class="line">  &#123;registered, []&#125;,</div><div class="line">  &#123;mod, &#123;<span class="string">'myapp_app'</span>, []&#125;&#125;,</div><div class="line">  &#123;applications,</div><div class="line">   [kernel,</div><div class="line">    stdlib</div><div class="line">   ]&#125;,</div><div class="line">  &#123;env,[]&#125;,</div><div class="line">  &#123;modules, []&#125;</div><div class="line"> ]&#125;.</div></pre></td></tr></table></figure>
<p>src/myapp_app.erl是一个非常简单的代码框架。它只是让你可以启动和停止你的Erlang应用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat src/myapp_app.erl</div><div class="line">-module(<span class="string">'myapp_app'</span>).</div><div class="line">-behaviour(application).</div><div class="line">-export([start/2, stop/1]).</div><div class="line">start(_StartType, _StartArgs) -&gt;</div><div class="line">    <span class="string">'myapp_sup'</span>:start_link().</div><div class="line">stop(_State) -&gt;</div><div class="line">    ok.</div></pre></td></tr></table></figure>
<p>Rebar3用rebar.config来指定一些额外的元数据，比如<a href="https://github.com/rebar/rebar/wiki/Dependency-management" target="_blank" rel="external">依赖</a>。rebar.config还可以包含很多配置项。你可以参考 <a href="https://github.com/rebar/rebar/blob/master/rebar.config.sample" target="_blank" rel="external">详细例子</a> 来学习各种配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat rebar.config</div><div class="line">&#123;erl_opts, [debug_info]&#125;.</div><div class="line">&#123;deps, []&#125;.</div></pre></td></tr></table></figure>
<p>现在我们用Rebar3启动一个Erlang shell，它包含了你的应用及依赖的路径。然后运行 application:start(myapp). 来确认你的应用被正确地装载了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ rebar3 shell</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Compiling myapp</div><div class="line">Erlang R16B03-1 (erts-5.10.4) [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line">Eshell V5.10.4  (abort with ^G)</div><div class="line">1&gt; application:start(myapp).</div><div class="line">ok</div><div class="line">2&gt; application:stop(myapp).</div><div class="line">ok</div><div class="line">3&gt;</div><div class="line">=INFO REPORT==== 29-Jun-2015::16:14:10 ===</div><div class="line">    application: myapp</div><div class="line">    exited: stopped</div><div class="line">    <span class="built_in">type</span>: temporary</div></pre></td></tr></table></figure>
<p><a href="https://github.com/ferd" target="_blank" rel="external">Fred Hebert</a> （<a href="http://learnyousomeerlang.com/" target="_blank" rel="external">Learn You Some Erlang</a> 的作者）写了一篇很好的<a href="http://ferd.ca/rebar3-shell.html" target="_blank" rel="external">文章</a>介绍rebar3 shell的命令。</p>
<h1 id="Erlang的包"><a href="#Erlang的包" class="headerlink" title="Erlang的包"></a>Erlang的包</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要安装一个叫做<a href="https://github.com/hexpm/rebar3_hex" target="_blank" rel="external">rebar3_hex</a>的插件来从<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>（Erlang和Elixir的包管理者）获取和安装Erlang包。简单地把如下一行加入到rebar.config文件中（你需要Erlang/OTP17.4或以上版本）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;plugins, [rebar3_hex]&#125;.</div></pre></td></tr></table></figure>
<p>然后运行命令：rebar3 update 来启用这个插件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rebar3 update</div><div class="line">===&gt; Fetching jsx (&#123;pkg,&lt;&lt;<span class="string">"jsx"</span>&gt;&gt;,&lt;&lt;<span class="string">"2.6.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching ssl_verify_hostname (&#123;pkg,&lt;&lt;<span class="string">"ssl_verify_hostname"</span>&gt;&gt;,</div><div class="line">                                           &lt;&lt;<span class="string">"1.0.5"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching rebar3_hex (&#123;pkg,&lt;&lt;<span class="string">"rebar3_hex"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.6.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling ssl_verify_hostname</div><div class="line">===&gt; Compiling jsx</div><div class="line">===&gt; Compiling rebar3_hex</div><div class="line">===&gt; Updating package index…</div></pre></td></tr></table></figure>
<p>如果你想避免每次创建一个新Erlang应用都要做这个步骤，则将上述配置添加到全局的配置文件rebar.config中，并把这个配置文件放置在如下目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/.config/rebar3/rebar.config</div></pre></td></tr></table></figure>
<h2 id="查找Erlang包"><a href="#查找Erlang包" class="headerlink" title="查找Erlang包"></a>查找Erlang包</h2><p>搜索命令让你远程查找在<a href="https://hex.pm/" target="_blank" rel="external">Hex.pm</a>上发布的Erlang包。你可以在查询语句里用正则表达式字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 hex search cowboy</div><div class="line">cloudi_service_http_cowboy</div><div class="line">cowboy</div></pre></td></tr></table></figure>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>Rebar3能下载和安装Erlang包以及任何必要的依赖。在你的rebar.config文件里增加应用名字到deps配置项，然后运行命令：rebar3 compile。下面的例子，我们尝试使用两个Erlang包，cowboy和meck。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [cowboy, meck]&#125;.</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rebar3 compile</div><div class="line">===&gt; Verifying dependencies...</div><div class="line">===&gt; Fetching ranch (&#123;pkg,&lt;&lt;<span class="string">"ranch"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching meck (&#123;pkg,&lt;&lt;<span class="string">"meck"</span>&gt;&gt;,&lt;&lt;<span class="string">"0.8.2"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowlib (&#123;pkg,&lt;&lt;<span class="string">"cowlib"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.1"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Fetching cowboy (&#123;pkg,&lt;&lt;<span class="string">"cowboy"</span>&gt;&gt;,&lt;&lt;<span class="string">"1.0.0"</span>&gt;&gt;&#125;)</div><div class="line">===&gt; Compiling cowlib</div><div class="line">===&gt; Compiling ranch</div><div class="line">===&gt; Compiling meck</div><div class="line">===&gt; Compiling cowboy</div><div class="line">===&gt; Compiling myapp</div></pre></td></tr></table></figure>
<p>想要安装一个Erlang包的指定版本？在配置中把应用名字和版本写在一个元组中。你可以在<a href="https://hex.pm/" target="_blank" rel="external">Hex主页</a>上查询Erlang包的可用版本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;deps, [&#123;cowboy, “<span class="number">1.0</span>.<span class="number">2</span>”&#125;, &#123;meck, <span class="string">"0.8.3"</span>&#125;]&#125;.</div></pre></td></tr></table></figure>
<h2 id="列出已安装的包"><a href="#列出已安装的包" class="headerlink" title="列出已安装的包"></a>列出已安装的包</h2><p>rebar3 deps 命令列出你本地已经安装的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div><div class="line">meck (locked package 0.8.2)</div></pre></td></tr></table></figure>
<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>要卸载一个包，你首先要在rebar.config文件中将它删除，然后使用命令：rebar unlock。现在我们卸载meck包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rebar3 unlock</div><div class="line">$ rebar3 deps</div><div class="line">cowboy (locked package 1.0.0)</div></pre></td></tr></table></figure>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="http://www.rebar3.org/" target="_blank" rel="external">http://www.rebar3.org/</a></p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz" target="_blank" rel="external">https://medium.com/erlang-central/building-your-first-erlang-app-using-rebar3-25f40b109aad#.mmyp4pfgz</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rebar3是Erlang的构建工具和包管理工具。归功于&lt;a href=&quot;http://www.rebar3.org/&quot;&gt;Rebar3&lt;/a&gt;以及它的插件&lt;a href=&quot;https://hex.pm/&quot;&gt;Hex&lt;/a&gt;，创建和发布你的Erlang包非常简单。让我们做一个简单的“hello world”式的包来演练一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/categories/Erlang/Rebar3/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Rebar3" scheme="http://szpzs.oschina.io/tags/Rebar3/"/>
    
  </entry>
  
  <entry>
    <title>红回调和绿回调</title>
    <link href="http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/"/>
    <id>http://szpzs.oschina.io/2016/12/01/Red-and-Green-Callbacks/</id>
    <published>2016-12-01T07:11:46.000Z</published>
    <updated>2016-12-01T07:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。</p>
<p>为了解释这个问题，我必须先回过头来讲讲I/O。</p>
<a id="more"></a>
<h1 id="Erlang的并发I-O"><a href="#Erlang的并发I-O" class="headerlink" title="Erlang的并发I/O"></a>Erlang的并发I/O</h1><p>Erlang是如何处理并发I/O的？相当简单！假设我们有三个进程A、B和C，它们在并行执行。我用如下的方式描述这个场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A || B || C</div></pre></td></tr></table></figure>
<p>上述描述假设三个进程A、B、C正在进行I/O操作。</p>
<p>进程A如下所描述做一些事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A: --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>进程B则如下描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B: ---- write --- write --- <span class="built_in">read</span> --- <span class="built_in">read</span> --- write ---</div></pre></td></tr></table></figure>
<p>C进程也大致如此。虚线表示一些顺序的计算。进程A的Erlang代码框架如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">a</span><span class="params">()</span> -&gt;</span></div><div class="line">    ...</div><div class="line">    X = read(),</div><div class="line">    ...</div><div class="line">    Y = read(),</div><div class="line">    ...</div><div class="line">    write(...),</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>进程B和进程C的代码也和这个差不多。</p>
<p>Erlang里实际上是没有read()这个函数的。Erlang有  <a href="http://www.erlang.org/course/concurrent_programming.html#select" target="_blank" rel="external">select receive</a>  模式来处理消息，所以我们实际上定义的read()函数像如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">()</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        Pattern1 -&gt;</div><div class="line">           ...</div><div class="line">        Pattern2 -&gt;</div><div class="line">           ...</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>select receive 模式如何工作的细节不是本次讨论的重点，因此本文我将忽略这些细节。</p>
<p>重点是我在进程A的代码里如下所写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">X = read()</div><div class="line">...</div></pre></td></tr></table></figure>
<p>那么，我们的进程将在read函数处被挂起（或者叫做阻塞）直到read函数执行完毕。因此我们的代码“看起来像”是正在做一个同步阻塞的读动作。</p>
<p>看起来像是用双引号括起来的，因为它不是一个真正的阻塞读，而是一个真正的异步读，这个读操作不阻塞其他任何Erlang进程。</p>
<p>这真是棒极了，因为从一开始，程序就等待读请求完成，然后获得读取到的数据，程序继续运行。</p>
<h1 id="理解并发"><a href="#理解并发" class="headerlink" title="理解并发"></a>理解并发</h1><p>Erlang的I/O非常特别。当我们有两个并行的进程A和B，A进程里的一个读请求将明显地阻塞A进程，但是不会对其他任何并行的进程（这里指B）有影响。</p>
<p>所以A和B可以都同时执行写入操作就好像它们是连续的进程。</p>
<p>现在假设我们没有一个合适的基础并发模型。假设所有我们要做的事情都放入一个单独线程来执行。假设我们做一个读操作（它是阻塞的）而其他事情都在等待。啊！亲！我们的编程模型是更加清晰简单了，但是我们却浪费了CPU的宝贵资源。</p>
<p>现在在一些语言（正是我在研究的Javascript）没有多进程和多线程。不确切地说，它有一个线程，所有的事情都揉进这个线程里。在Javascript里要写与读相关操作的代码，你不得不用红回调，并且发明你自己的并发概念。</p>
<h1 id="红回调"><a href="#红回调" class="headerlink" title="红回调"></a>红回调</h1><p>在Javascript里你肯定不想在主线程里做一个阻塞同步读操作（记住它只有一个线程），那么你必需设置一个回调，当读操作完成的时候触发这个回调。我叫这样的回调为红回调。你写的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; ... do something <span class="keyword">with</span> x ..&#125;;</div><div class="line"><span class="keyword">var</span> error = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; .... x …&#125;</div><div class="line">read(Something, &#123;onSuccess:done, onError:error&#125;);</div><div class="line">... ... more code ...</div></pre></td></tr></table></figure>
<p>这样的代码搞得我脑袋一团浆糊。</p>
<p>当程序正在上述代码 more code 的某个地方执行的时候，读操作完成了，则必需立即回到done这个函数来执行，然后再回到前面 more code 中断的地方。我发现这个方式非常难以理解。</p>
<p>这的确很糟糕，每一个要解决并发问题的Javascript程序员必需要发明他自己的并发模型。问题就在于他们不知道他们正在做的是什么。每次一个Javascript程序员写下一行代码，说是“此处就该这么做”的时候，他实际上是在发明一个新的并发模型，并且在这些代码执行的时候他是没有任何线索知道这些代码是怎样交织在一起的。</p>
<p>（其实我对Javascript又爱又恨，它的大部分我都喜欢，但是就是恨它的并发模型。不过好笑的是，Javascript是没有并发模型的，所以对它也无从可恨了。:-）</p>
<p>更加难以理解的是错误。在共享内存的多线程回调代码里的错误更加是令我极度头痛！</p>
<h1 id="绿回调"><a href="#绿回调" class="headerlink" title="绿回调"></a>绿回调</h1><p>只是为了使得生活更加困惑，在Erlang里我们大量使用了回调。我把这些回调称为“绿回调”。因此回调并不一定是不好的。在Erlang里，我们可以在一个进程的上下文里更清晰地看到回调的执行，所以我们没有如何查看回调执行过程的问题。</p>
<p>如下是Erlang里一个绿回调的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">loop</span><span class="params">(F)</span> -&gt;</span></div><div class="line">    <span class="keyword">receive</span></div><div class="line">        &#123;new_callback, F1&#125; -&gt;</div><div class="line">            loop(F1);</div><div class="line">        Msg -&gt;</div><div class="line">            F(Msg),</div><div class="line">            loop(F)</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>当一个进程运行这段代码的时候收到一个消息Msg，它就执行函数F(Msg)。这里没有任何不确定的，当回调被触发的时候我们确切地知道。在收到消息Msg后，这个回调被立即触发。</p>
<p>这一小段代码却非常漂亮。如果你给进程发送一个消息{new_callbak, F1}，那么它将改变它的行为，在下一次调用的时候，它将执行新的回调。</p>
<p>我不知道你在Javascript里如何写出这样的代码。我写过大量的JQurey代码并且明白如何设置和删除回调。但是在删除一个事件处理并新增一个事件处理这期间里，这个事件被触发了，这会发生什么？我不知道。生命如此短暂如何花的起那么多时间来找这个答案。</p>
<h1 id="Erlang的I-O是如何工作的"><a href="#Erlang的I-O是如何工作的" class="headerlink" title="Erlang的I/O是如何工作的"></a>Erlang的I/O是如何工作的</h1><p>我们实际上并没有给进程发送消息。我们给进程的邮箱发送消息。每一个进程有一个邮箱，当我们给一个进程发送消息，这个消息被放入这个进程的邮箱（如果快递小子能找到这个进程的话）。</p>
<p>想像一下，Erlang的进程是有邮箱的房子。发送消息就好比你把你的消息给快递小子。快递小子的工作就是做两件事：把邮件放入目的邮箱并敲门说：“有新信到了”。</p>
<p>进程可能在忙着也可能在睡觉，就如一个房东一个样，他可能在干这活或者在睡觉。如果他在睡觉，那么当邮递员来了并敲响了房门，房东就会走到邮箱那里检查是否有令人感兴趣的邮件。</p>
<p>如果房东此时把手头的活干完后，正在做其他事情的时候，房东可能会走到邮箱那里检查是否有新的邮件到了，</p>
<p>这就是Erlang的消息工作机制。每一个房子（进程）有它自己的生命周期。邮递员投递邮件，房东根据自己的意愿决定什么时候去检查邮箱。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html" target="_blank" rel="external">http://joearms.github.io/2013/04/02/Red-and-Green-Callbacks.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种回调，我把他们分别叫做“红回调”和“绿回调”。红回调令人讨厌而且它打断你程序的控制流程。绿回调令人愉悦而且它不会打断你程序的控制流程。Javascript的回调是红回调而Erlang的回调是绿回调。&lt;/p&gt;
&lt;p&gt;为了解释这个问题，我必须先回过头来讲讲I/O。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="callback" scheme="http://szpzs.oschina.io/categories/Erlang/callback/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="callback" scheme="http://szpzs.oschina.io/tags/callback/"/>
    
  </entry>
  
  <entry>
    <title>Erlang(和Elixir)无epmd之分布式</title>
    <link href="http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/"/>
    <id>http://szpzs.oschina.io/2016/11/22/erlang-and-elixir-distribution-without-epmd/</id>
    <published>2016-11-22T02:50:54.000Z</published>
    <updated>2016-11-22T03:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：</p>
<ul>
<li>epmd（Erlang端口映射守护进程）端口4369，</li>
<li>Erlang节点自己的端口，一个不可预知的大数字端口。</li>
</ul>
<p>这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的<a href="http://erlang.org/doc/man/kernel_app.html" target="_blank" rel="external">kernel文档</a>里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。</p>
<a id="more"></a>
<p>但是如果我们限制了Erlang节点在一个单独的端口，那么我们还真的需要一个端口映射吗？运行epmd有以下几个潜在的缺点：</p>
<ul>
<li>我们可能想要以运行Erlang节点的用户来运行epmd，但是正如我们将见到的，这个很难得到保证。</li>
<li>我们可能想要配置epmd监听一个特定的端口，但是这依赖于在本机上我们如何第一次运行epmd。</li>
<li>任何人无需身份验证可以连接epmd并且可以列出本地的所有Erlang节点。</li>
<li>与epmd的连接都没有加密，即使你按 <a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">Erlang distribution over TLS</a> 这篇文章的方法去做，与epmd的连接也是不受保护的，并且有被中间人攻击的潜在风险。</li>
<li>虽然epmd很稳定，它也有发生崩溃的可能。一旦它崩溃了，任何已经存在的分布式Erlang节点将继续运行，即使epmd恢复了，这些节点也不会重新连接empd。这意味着存在的分布式连接继续工作着，但是与这些节点的新的连接将不起作用。阅读俄文博客 <a href="https://habrahabr.ru/post/49535/" target="_blank" rel="external">Экстренная реанимация epmd</a> 可能可以在不重启epmd的情况下解决这个问题。</li>
</ul>
<p>那么我们来研究一下epmd是如何工作的，然后我们如何做就可以在不用epmd的情况下运行一个Erlang集群。</p>
<h1 id="epmd是如何第一次启动的？"><a href="#epmd是如何第一次启动的？" class="headerlink" title="epmd是如何第一次启动的？"></a>epmd是如何第一次启动的？</h1><p>让我们来读读源码！epmd是在<a href="https://github.com/erlang/otp/blob/OTP-19.1.1/erts/etc/common/erlexec.c#L1234-L1279" target="_blank" rel="external">erlexec.c文件的start_epmd函数</a>里被启动的。实际上，每一次一个Erlang分布式节点启动epmd都无条件地被启动。如果一个epmd实例已经在运行，新的epmd在侦听端口4369的时候将失败，它将因此悄无声息地结束运行。</p>
<p>事实上，这就是即使由另一个用户启动的epmd实例存在系统将发生的事情。任何epmd实例都非常乐意为由任何用户启动的Erlang节点服务，因此这个通常不会引起任何问题。</p>
<h1 id="那么谁可以连接epmd？"><a href="#那么谁可以连接epmd？" class="headerlink" title="那么谁可以连接epmd？"></a>那么谁可以连接epmd？</h1><p>任何人都可以！默认情况下，epmd侦听在所有有效的接口上，并且响应关于当前有哪些节点以及这些节点所侦听的端口的查询。一听到这个场景，系统管理员应该有点紧张。</p>
<p>你可以在epmd启动前通过手工指定 -address 选项或设定ERL_EPMD_ADDRESS 环境变量启动epmd来改变上述情况。这个方法在<a href="http://erlang.org/doc/man/epmd.html" target="_blank" rel="external">官方文档</a>里有描述。这个方法需要在你第一次启动epmd的时候来做，否则，已经存在的epmd实例将不受影响地继续运行。</p>
<h1 id="为什么我们需要一个端口映射守护进程？"><a href="#为什么我们需要一个端口映射守护进程？" class="headerlink" title="为什么我们需要一个端口映射守护进程？"></a>为什么我们需要一个端口映射守护进程？</h1><p>很明显，epmd就是一个中间人。我们可以绕过这个中间人吗？</p>
<p>我们可以让每个Erlang节点侦听在一个大家熟知的端口–如果我们打算去除掉epmd的话，我们可以用empd默认保留的端口，4369。但是这就意味着我们只能够在每个主机上运行一个Erlang节点（当然，在某些场景下这就足够了）。</p>
<p>那么让我们指定一些其他端口。前面我们提到变量 inet_dist_listen_min 和 inet_dist_listen_max 。这两个变量定义一个端口范围，不过如果我们设置它们为相同的值，我们就把范围缩小到一个端口：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">erl -sname foo \</div><div class="line">    -kernel inet_dist_listen_min <span class="number">4370</span> \</div><div class="line">            inet_dist_listen_max <span class="number">4370</span></div></pre></td></tr></table></figure>
<p>这个方法不错，不过我们也需要告诉其他节点不要再去询问epmd来获取端口号，而是只用这个端口号来代替。如果我们在同一个主机上有几个节点，我们需要为这些节点配置不同的端口号。</p>
<h1 id="用别的方法"><a href="#用别的方法" class="headerlink" title="用别的方法"></a>用别的方法</h1><p>在Erlang/OTP 19.0里，有两个新的命令行选项：</p>
<ul>
<li>当我们指定 -start_epmd false，Erlang将不会在启动一个分布式节点的时候尝试去启动epmd；</li>
<li>选项 -epmd_module foo 让你指定一个不同的模块替代默认的模块erl_epmd，用来节点名字注册和查询。</li>
</ul>
<p>接下来我们来构建一些代码！</p>
<p>我想用一个无状态的方式来实现这个方法：既然发起连接的节点知道了它要连接的节点的名字，那么我就用这个名字作为资源来得到相应的端口号。我选择4370这个端口作为基准端口，它比epmd的端口大一。接着我从节点名称的“节点”部分抽取出数字，比如节点名称为 myapp3@foo.example.com 抽取的数字是3。最后我把这个数字和基准端口相加。由此得知，节点 myapp3@foo.example.com 侦听在端口4373。如果节点名字最后不是数字，我这种情况将处理为0。这意味着节点 myapp3 和 myotherapp3 不能运行在同一个主机上，但是我准备好了处理对这种场景。（感谢 Luca Favatella 的完美建议）</p>
<p>为此我们来写一个小模块：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([dist_port/<span class="number">1</span>])</span>.</div><div class="line"></div><div class="line"><span class="comment">%% 返回被一个指定节点使用的端口号。</span></div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_atom</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    dist_port(atom_to_list(Name));</div><div class="line"><span class="function"><span class="title">dist_port</span><span class="params">(Name)</span> <span class="title">when</span> <span class="title">is_list</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 获取基端口号。如果没有在 kernel 的环境变量</span></div><div class="line">    <span class="comment">%% inet_dist_base_port 里指定, 则默认为</span></div><div class="line">    <span class="comment">%% 4370, 比epmd端口大1。</span></div><div class="line">    BasePort = application:get_env(kernel, inet_dist_base_port, <span class="number">4370</span>),</div><div class="line"></div><div class="line">    <span class="comment">%% 现在，算出我们相对于基端口号的偏移值。</span></div><div class="line">    <span class="comment">%% 这个偏移值就是我们节点名的@符号左边的数字。</span></div><div class="line">    <span class="comment">%% 如果这个数字不存在，则偏移量设置为0。</span></div><div class="line">    <span class="comment">%%</span></div><div class="line">    <span class="comment">%% 同时我们也处理主机名没有指定的情况。</span></div><div class="line">    NodeName = re:replace(Name, <span class="string">"@.*$"</span>, <span class="string">""</span>),</div><div class="line">    Offset =</div><div class="line">        <span class="keyword">case</span> re:run(NodeName, <span class="string">"[0-9]+$"</span>, [&#123;capture, first, list&#125;]) <span class="keyword">of</span></div><div class="line">            nomatch -&gt;</div><div class="line">                <span class="number">0</span>;</div><div class="line">            &#123;match, [OffsetAsString]&#125; -&gt;</div><div class="line">                list_to_integer(OffsetAsString)</div><div class="line">        <span class="keyword">end</span>,</div><div class="line"></div><div class="line">    BasePort + Offset.</div></pre></td></tr></table></figure>
<p>同时我们还要写一个模块用作 -epmd_module。有一点小复杂就是因为OTP19.0期望这个模块导出 register_node/2 函数，而从OTP19.1开始则是期望导出 register_node/3 函数。我们把这两个函数都包含进去。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_epmd_client)</span>.</div><div class="line"></div><div class="line"><span class="comment">%% epmd_module 回调函数</span></div><div class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>,</span></div><div class="line">         register_node/<span class="number">2</span>,</div><div class="line">         register_node/<span class="number">3</span>,</div><div class="line">         port_please/<span class="number">2</span>,</div><div class="line">         names/<span class="number">1</span>]).</div><div class="line"></div><div class="line"><span class="comment">%% 监督者模块 erl_distribution 尝试着把我们当做一个被监督的子进程。</span></div><div class="line"><span class="comment">%% 我们不需要子进程，所以返回 ignore 。</span></div><div class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></div><div class="line">    ignore.</div><div class="line"></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(_Name, _Port)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 本函数是我们连接epmd并告诉它我们监听哪个端口，</span></div><div class="line">    <span class="comment">%% 不过因为我们是无epmd的，所以我们不需要做这些。</span></div><div class="line"></div><div class="line">    <span class="comment">%% 需要返回一个1到3的 ”creation” 数字。</span></div><div class="line">    Creation = rand:uniform(<span class="number">3</span>),</div><div class="line">    &#123;ok, Creation&#125;.</div><div class="line"></div><div class="line"><span class="comment">%% 从Erlang/OTP19.1开始，register_node/3函数替代register_node/2函数，</span></div><div class="line"><span class="comment">%% 该函数多了一个地址族的入参，取值为 ‘inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line"><span class="comment">%% 这一点对我们来说没有多大的改动。</span></div><div class="line"><span class="function"><span class="title">register_node</span><span class="params">(Name, Port, _Family)</span> -&gt;</span></div><div class="line">    register_node(Name, Port).</div><div class="line"></div><div class="line"><span class="function"><span class="title">port_please</span><span class="params">(Name, _IP)</span> -&gt;</span></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line">    <span class="comment">%% 分布式协议版本从Erlang/OTP16开始就是5。</span></div><div class="line">    Version = <span class="number">5</span>,</div><div class="line">    &#123;port, Port, Version&#125;.</div><div class="line"></div><div class="line"><span class="function"><span class="title">names</span><span class="params">(_Hostname)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 因为我们没有epmd，所以我们真的不知道此处是否有其他节点。</span></div><div class="line">    &#123;error, address&#125;.</div></pre></td></tr></table></figure>
<p>正如你所见，大多数事情基本完成了。</p>
<p>当这个模块被加为 erl_distribution 监督者的子进程的时候，start_link/0 将被调用。我们并不需要在这个启动一个进程，因此我们只是返回 ignore。</p>
<p>register_node函数通常会连接epmd并告诉它我们使用哪一个端口。epmd将返回一个“creation”数字。“creation”数字上一个介于1和3的整数。epmd跟踪每一个节点名字的“creation”数字并且当一个确定名字的节点重连的时候增加这个数字。这意味着它可以区分先前某一个节点“存活期间”的进程id。</p>
<p>既然我们没有epmd，那么我们就没有获得它跟踪节点生命周期的好处。在这里我们返回一个随机数，它有三分之二的机会不同于前面的“creation”数字。</p>
<p>port_please/2 获取远程主机的IP地址以便连接它的epmd，但是我们不关心这些；我们用我们自己的算法来算出我们的端口号。</p>
<p>我们也需要返回一个分布式协议版本号。从Erlang/OTP 6开始它就是5（参阅 <a href="http://erlang.org/doc/apps/erts/erl_dist_protocol.html" target="_blank" rel="external">分布式协议官方文档</a> ），就这么简单。</p>
<p>最后，names/1 函数被调用来返回某个主机上的Erlang节点列表。我们没有办法知道这些信息，所以让我们假装我们连接不上这个主机。</p>
<p>目前为止，一起都顺利。但是我们需要一个方法来确认我们正侦听在合适的端口上。我认为最好的方法是写一个新的分布式协议模块，该模块仅是设置端口号而让真正的协议模块做它自己的事情：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(epmdless_dist)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([listen/<span class="number">1</span>,</span></div><div class="line">         select/<span class="number">1</span>,</div><div class="line">         accept/<span class="number">1</span>,</div><div class="line">         accept_connection/<span class="number">5</span>,</div><div class="line">         setup/<span class="number">5</span>,</div><div class="line">         close/<span class="number">1</span>,</div><div class="line">         childspecs/<span class="number">0</span>]).</div><div class="line"></div><div class="line"><span class="function"><span class="title">listen</span><span class="params">(Name)</span> -&gt;</span></div><div class="line">    <span class="comment">%% 在此处我们算出我们想要侦听在什么端口。</span></div><div class="line"></div><div class="line">    Port = epmdless:dist_port(Name),</div><div class="line"></div><div class="line">    <span class="comment">%% 设置 “最小” 和 “最大” 两个变量，强制侦听端口为一个值。</span></div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_min, Port),</div><div class="line">    ok = application:set_env(kernel, inet_dist_listen_max, Port),</div><div class="line"></div><div class="line">    <span class="comment">%% 最后运行真正的函数！</span></div><div class="line">    inet_tcp_dist:listen(Name).</div><div class="line"></div><div class="line"><span class="function"><span class="title">select</span><span class="params">(Node)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:select(Node).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">accept_connection</span><span class="params">(AcceptPid, Socket, MyNode, Allowed, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">setup</span><span class="params">(Node, Type, MyNode, LongOrShortNames, SetupTime)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:setup(Node, Type, MyNode, LongOrShortNames, SetupTime).</div><div class="line"></div><div class="line"><span class="function"><span class="title">close</span><span class="params">(Listen)</span> -&gt;</span></div><div class="line">    inet_tcp_dist:close(Listen).</div><div class="line"></div><div class="line"><span class="function"><span class="title">childspecs</span><span class="params">()</span> -&gt;</span></div><div class="line">    inet_tcp_dist:childspecs().</div></pre></td></tr></table></figure>
<p>几乎所有的代码都在这。listen/1函数在将控制权交给真正的处理模块inet_tcp_dist前，根据我们的节点名来设置inet_dist_listen_min和inet_dist_listen_max两个变量。</p>
<p>（请注意：虽然inet_tcp_dist是默认的处理模块，但是它仅提供基于IPv4上的未加密连接。如果你想用IPv6，你应该用inet6_tcp_dist，而如果你想用<a href="https://www.erlang-solutions.com/blog/erlang-distribution-over-tls.html" target="_blank" rel="external">基于TLS上的Erlang分布式功能</a>，那就应该选择inet_tsl_dist或inet6_tsl_dist。增加这些弹性的尝试留给读者自己练习。）</p>
<p>我们准备好了！现在我们启动两个节点，foo1和foo2，并且使它们彼此互连：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo1</div><div class="line">erl -proto_dist epmdless -start_epmd <span class="literal">false</span> -epmd_module epmdless_epmd_client -sname foo2</div></pre></td></tr></table></figure>
<p>系统能正常运行吗？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(foo2@poki-sona-sin)<span class="number">1</span>&gt; net_adm:ping('foo1@poki-sona-sin').</div><div class="line">pong</div></pre></td></tr></table></figure>
<p>看起来没问题！</p>
<h1 id="接着在Elixir下尝试"><a href="#接着在Elixir下尝试" class="headerlink" title="接着在Elixir下尝试"></a>接着在Elixir下尝试</h1><p>当然，因为Erlang和Elixir都运行在同样的虚拟机上，那么就没有什么可以阻止我们在Elixir里实现上述功能了。</p>
<p>在Elixir里，我们可以将所有代码放在一个单独文件里，编译器会将它编译成我们需要的不同的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一个包含根据一个节点名来决定端口号的函数的模块。</span></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless</span></span> <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_atom(name) <span class="keyword">do</span></div><div class="line">    dist_port Atom.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_list(name) <span class="keyword">do</span></div><div class="line">    dist_port List.to_string name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dist_port</span></span>(name) <span class="keyword">when</span> is_binary(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 算出基端口。如果没有指定则用</span></div><div class="line">    <span class="comment"># inet_dist_base_port 这个kernel的环境变量,</span></div><div class="line">    <span class="comment"># 默认值是4370, 比epmd的端口大1。</span></div><div class="line">    base_port = <span class="symbol">:application</span>.get_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_base_port</span>, <span class="number">4370</span></div><div class="line"></div><div class="line">    <span class="comment"># 现在，基于基端口算出我们的“偏移量”。</span></div><div class="line">    <span class="comment"># 偏移量就是一个我们节点名@符号左边的整数。</span></div><div class="line">    <span class="comment"># 如果这个整数不存在，则偏移量是0。</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># 也处理主机名没有指定的情况。</span></div><div class="line">    node_name = Regex.replace ~r/@.*<span class="variable">$/</span>, name, <span class="string">""</span></div><div class="line">    offset =</div><div class="line">      <span class="keyword">case</span> Regex.run ~r/[<span class="number">0</span>-<span class="number">9</span>]+<span class="variable">$/</span>, node_name <span class="keyword">do</span></div><div class="line">    <span class="keyword">nil</span> -&gt;</div><div class="line">      <span class="number">0</span></div><div class="line">    [offset_as_string] -&gt;</div><div class="line">      String.to_integer offset_as_string</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">    base_port + offset</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_dist</span></span> <span class="keyword">do</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(name) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 此处我们算出我们想要侦听的端口。</span></div><div class="line"></div><div class="line">    port = Epmdless.dist_port name</div><div class="line"></div><div class="line">    <span class="comment"># 设置“min”和“max”变量，强制两个端口为一个值。</span></div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_min</span>, port</div><div class="line">    <span class="symbol">:ok</span> = <span class="symbol">:application</span>.set_env <span class="symbol">:kernel</span>, <span class="symbol">:inet_dist_listen_max</span>, port</div><div class="line"></div><div class="line">    <span class="comment"># 最后运行真正的函数！</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.listen name</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(node) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.select node</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accept_connection</span></span>(accept_pid, socket, my_node, allowed, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.accept_connection accept_pid, socket, my_node, allowed, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>(node, type, my_node, long_or_short_names, setup_time) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.setup node, type, my_node, long_or_short_names, setup_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(listen) <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.close listen</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">childspecs</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:inet_tcp_dist</span>.childspecs</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Epmdless_epmd_client</span></span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># erl_distribution想要我们启动一个工作进程，然而我们并不需要。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start_link</span></span> <span class="keyword">do</span></div><div class="line">    <span class="symbol">:ignore</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="comment"># 因为Erlang/OTP 19.1用register_node/3来替换register_node/2，</span></div><div class="line">  <span class="comment"># 只是多传了一个参数：地址族，’inet_tcp’ 或 ‘inet6_tcp’。</span></div><div class="line">  <span class="comment"># 这对于我们来说没什么问题。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(name, port, _family) <span class="keyword">do</span></div><div class="line">    register_node(name, port)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register_node</span></span>(_name, _port) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 在此处我们应该连接epmd并告诉它哪个是我们侦听的端口，</span></div><div class="line">    <span class="comment"># 但是因为我们是无epmd的，所以我们不需要这么做。</span></div><div class="line"></div><div class="line">    <span class="comment"># 需要返回一个介于1和3的"creation”数字。</span></div><div class="line">    creation = <span class="symbol">:rand</span>.uniform <span class="number">3</span></div><div class="line">    &#123;<span class="symbol">:ok</span>, creation&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">port_please</span></span>(name, _ip) <span class="keyword">do</span></div><div class="line">    port = Epmdless.dist_port name</div><div class="line">    <span class="comment"># 分布式协议版本数字从Erlang/OTP R6开始就是5。</span></div><div class="line">    version = <span class="number">5</span></div><div class="line">    &#123;<span class="symbol">:port</span>, port, version&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">names</span></span>(_hostname) <span class="keyword">do</span></div><div class="line">    <span class="comment"># 既然我们没有epmd，那么我们就不真正需要知道其他节点。</span></div><div class="line">    &#123;<span class="symbol">:error</span>, <span class="symbol">:address</span>&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>当我们启动Elixir，我们需要用 - -erl 来传递一些参数来使得功能启用：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --erl <span class="string">"-proto_dist Elixir.Epmdless -start_epmd false -epmd_module Elixir.Epmdless_epmd_client"</span> --sname foo3</div></pre></td></tr></table></figure>
<p>让我们ping我们前面已经启动的两个节点：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">1</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo1@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div><div class="line">iex(foo3<span class="variable">@poki</span>-sona-sin)<span class="number">2</span>&gt; Node.ping <span class="symbol">:<span class="string">"foo2@poki-sona-sin"</span></span></div><div class="line"><span class="symbol">:pong</span></div></pre></td></tr></table></figure>
<p>它们都连通了并且没有epmd参与！</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文描述的只是其中一种不需要epmd的Erlang分布式方式；我相信你可以用别的办法来更好地符合你的需求。我希望上述的示例代码是有用的指南！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html" target="_blank" rel="external">https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你部署一个分布式Erlang应用的时候，你最可能必须要回答的问题是：“哪些端口需要在防火墙里打开？”。除非进行配置，否则答案就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epmd（Erlang端口映射守护进程）端口4369，&lt;/li&gt;
&lt;li&gt;Erlang节点自己的端口，一个不可预知的大数字端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个答案通常都不能简单地应用到防火墙的规则。通常的解决方法是用环境变量 inet_dist_listen_min 和 inet_dist_listen_max （官方的&lt;a href=&quot;http://erlang.org/doc/man/kernel_app.html&quot;&gt;kernel文档&lt;/a&gt;里有描述）来限制分布式端口在一个小范围或者甚至是一个单独的端口。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="distribution" scheme="http://szpzs.oschina.io/categories/Erlang/distribution/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="Elixir" scheme="http://szpzs.oschina.io/tags/Elixir/"/>
    
      <category term="epmd" scheme="http://szpzs.oschina.io/tags/epmd/"/>
    
  </entry>
  
  <entry>
    <title>Erlang快速安装</title>
    <link href="http://szpzs.oschina.io/2016/09/28/erlang-quick-install/"/>
    <id>http://szpzs.oschina.io/2016/09/28/erlang-quick-install/</id>
    <published>2016-09-28T14:01:48.000Z</published>
    <updated>2016-10-13T12:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/erlang-logo.png" style="border:0;"><br>在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的<a href="http://www.erlang.org/doc/installation_guide/INSTALL.html" target="_blank" rel="external">完全安装指引</a>。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。</p>
<ul>
<li><a href="#part1">在Mac OS X上安装Erlang</a></li>
<li><a href="#part2">在Linux上安装Erlang</a></li>
<li><a href="#part3">在Windows上安装Erlang</a></li>
<li><a href="#part4">用最新版本预编译包安装Erlang</a></li>
<li><a href="#part5">从源码编译安装Erlang</a></li>
</ul>
<a id="more"></a>
<h2 id="在Mac-OS-X上安装Erlang"><a href="#在Mac-OS-X上安装Erlang" class="headerlink" title="在Mac OS X上安装Erlang"></a><span id="part1">在Mac OS X上安装Erlang</span></h2><p><strong>使用HomeBrew来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install erlang</div></pre></td></tr></table></figure>
<p><strong>用MacPorts来安装Erlang：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port install erlang</div></pre></td></tr></table></figure>
<h2 id="在Linux上安装Erlang"><a href="#在Linux上安装Erlang" class="headerlink" title="在Linux上安装Erlang"></a><span id="part2">在Linux上安装Erlang</span></h2><p>大多数操作系统在它们的包管理系统里有预构建的Erlang发行版本。</p>
<p><strong>在Ubuntu和Debian下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install erlang</div></pre></td></tr></table></figure>
<p><strong>在Fedora下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<p><strong>在FreeBSD下，安装指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo pkg update</div><div class="line">sudo pkg install erlang</div></pre></td></tr></table></figure>
<h2 id="在Windows上安装Erlang"><a href="#在Windows上安装Erlang" class="headerlink" title="在Windows上安装Erlang"></a><span id="part3">在Windows上安装Erlang</span></h2><p><a href="http://www.erlang.org/download.html" target="_blank" rel="external">直接下载安装程序来安装</a></p>
<h2 id="用最新版本预编译包安装Erlang"><a href="#用最新版本预编译包安装Erlang" class="headerlink" title="用最新版本预编译包安装Erlang"></a><span id="part4">用最新版本预编译包安装Erlang</span></h2><p>你在寻找最新的稳定Erlang版本或者前一个Erlang版本吗？<a href="https://www.erlang-solutions.com/" target="_blank" rel="external">Erlang Solutions</a> 给OS X，Windows，Ubuntu，Debian，Fedora，CentOS，Raspbian 以及其他平台都提供了一个<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp" target="_blank" rel="external">预编译安装包</a>。它们也提供了一个企业级Erlang发行版。</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="external">从Erlang Solutions下载</a></p>
<h2 id="从源码编译安装Erlang"><a href="#从源码编译安装Erlang" class="headerlink" title="从源码编译安装Erlang"></a><span id="part5">从源码编译安装Erlang</span></h2><p>你可以用Kerl脚本在你自己的机器上从源码来构建Erlang。Kerl是一个脚本，它使得你用几个命令就轻松地构建不同版本的Erlang。</p>
<p><strong>下载Kerl指令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O https://raw.githubusercontent.com/spawngrid/kerl/master/kerl</div><div class="line">chmod +x kerl</div></pre></td></tr></table></figure>
<p>选择一个可用的Erlang源码发行版本并且像如下指令一样来构建它（在这个例子里，我们选择18.0版本并且命名它为mybuild-18.0）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list releases</div><div class="line">./kerl build 18.0 mybuild-18.0</div></pre></td></tr></table></figure>
<p>选择一个目录来安装，例如 ~/erlang-r16b03</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./kerl list builds</div><div class="line">./kerl install mybuild-18.0 ~/erlang-18.0</div></pre></td></tr></table></figure>
<p>最后，把目录 ~/erlang-18.0/bin 加到你的环境变量 $PATH 里。</p>
<p><strong>搞定！</strong></p>
<p>在你的终端运行erl来启动一个Erlang shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ erl</div><div class="line">Erlang/OTP 18 [erts-7.0] [<span class="built_in">source</span>] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:<span class="literal">false</span>]</div><div class="line"></div><div class="line">Eshell V7.0  (abort with ^G)</div><div class="line">1&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634" target="_blank" rel="external">https://medium.com/erlang-central/erlang-quick-install-9c5dcaa5b634</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/erlang-logo.png&quot; style=&quot;border:0;&quot;/&gt;&lt;br&gt;在你开始玩Erlang之前，你应该要将它安装好。这里有覆盖所有相关配置的&lt;a href=&quot;http://www.erlang.org/doc/installation_guide/INSTALL.html&quot;&gt;完全安装指引&lt;/a&gt;。本文将给你一个简单的最小安装指引，立即让你的第一个Erlang shell跑起来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#part1&quot;&gt;在Mac OS X上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part2&quot;&gt;在Linux上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part3&quot;&gt;在Windows上安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part4&quot;&gt;用最新版本预编译包安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#part5&quot;&gt;从源码编译安装Erlang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/categories/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/categories/Erlang/install/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.oschina.io/tags/Erlang/"/>
    
      <category term="install" scheme="http://szpzs.oschina.io/tags/install/"/>
    
      <category term="HomeBrew" scheme="http://szpzs.oschina.io/tags/HomeBrew/"/>
    
      <category term="MacPorts" scheme="http://szpzs.oschina.io/tags/MacPorts/"/>
    
      <category term="Kerl" scheme="http://szpzs.oschina.io/tags/Kerl/"/>
    
  </entry>
  
</feed>
