<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.github.io/"/>
  <updated>2016-09-15T12:53:08.000Z</updated>
  <id>http://szpzs.github.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>erlang-thursday-lists-foldl-3-and-lists-foldr-3</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-lists-foldl-3-and-lists-foldr-3/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-lists-foldl-3-and-lists-foldr-3/</id>
    <published>2016-09-15T12:38:40.000Z</published>
    <updated>2016-09-15T12:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/</a></p>
</blockquote>
<p>今天Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#foldl-3" target="_blank" rel="external">lists:foldl/3</a> 和 <a href="http://www.erlang.org/doc/man/lists.html#foldr-3" target="_blank" rel="external">lists:foldr/3</a> 。</p>
<p>lists:foldl/3 是Erlang版的 reduce 函数。 lists:foldl/3 接收三个入参：一个函数，一个初始的累加器，一个列表，输出一个单一的值。</p>
<a id="more"></a>
<p>foldl的第一个入参是一个接收两个参数的函数，一个是当前循环到的列表元素，另一个是积累的值。这个函数的输出值作为循环到下一个列表元素的时候的累加器，或者当循环结束的时候作为foldl函数的输出值。</p>
<p>foldl的第二个入参是一个累加器的初始值。与其他一些语言不同，在其他语言里这个累加器的初始值是可选的，而且常常是使用循环列表的第一个元素作为默认值，但是在Erlang里，累加器的初始值必需作为lists:foldl/3和lists:foldr/3两个函数的入参。</p>
<p>第三个入参，也就是最后一个入参是将被循环遍历的列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Sum) -&gt; Sum + X <span class="keyword">end</span>, <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 15</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Product) -&gt; Product * X <span class="keyword">end</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 120</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]) <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 1 2 3 4 5 ok</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]), Accum <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 1 2 3 4 5 void</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Accum) -&gt; Accum + X <span class="keyword">end</span>, <span class="number">1</span>, []).</div><div class="line"><span class="comment">% 1</span></div><div class="line">lists:foldl(<span class="keyword">fun</span>(X, Result) -&gt; lists:umerge(Result, X) <span class="keyword">end</span>, [], [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>], [<span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>]]).</div><div class="line"><span class="comment">% [1,2,3,5,8,11,13,17]</span></div></pre></td></tr></table></figure>
<p>在Erlang的lists模块里也包含foldr/3函数，它是从左到右（译者注：应该是从右到左，可能是作者手误）遍历列表或者说是从最后一个元素到第一个元素遍历列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:foldr(<span class="keyword">fun</span>(X, Accum) -&gt; io:format(<span class="string">"~p "</span>, [X]), Accum <span class="keyword">end</span>, void, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% 5 4 3 2 1 void</span></div><div class="line">lists:foldr(<span class="keyword">fun</span>(X, Accum) -&gt; Accum + X <span class="keyword">end</span>, <span class="number">1</span>, []).</div><div class="line"><span class="comment">% 1</span></div></pre></td></tr></table></figure>
<p>Erlang文档里指出foldl/3通常比foldr/3更好，因为foldl/3是尾递归，而foldr/3不是。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文链接：&lt;/em&gt;  &lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/&quot;&gt;https://www.proctor-it.com/erlang-thursday-lists-foldl-3-and-lists-foldr-3/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt; 和 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#foldr-3&quot;&gt;lists:foldr/3&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;lists:foldl/3 是Erlang版的 reduce 函数。 lists:foldl/3 接收三个入参：一个函数，一个初始的累加器，一个列表，输出一个单一的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="foldl" scheme="http://szpzs.github.io/tags/foldl/"/>
    
      <category term="foldr" scheme="http://szpzs.github.io/tags/foldr/"/>
    
  </entry>
  
  <entry>
    <title>erlang-thursday-lists-map-2</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-lists-map-2/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-lists-map-2/</id>
    <published>2016-09-15T11:53:09.000Z</published>
    <updated>2016-09-15T12:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-map-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-map-2/</a></p>
</blockquote>
<p>今天的Erlang Thursday讲的是函数 <a href="http://www.erlang.org/doc/man/lists.html#map-2" target="_blank" rel="external">lists:map/2</a> 。</p>
<p>lists:map/2 接收两个入参，一个是接收一个入参的函数，我们称它为“mapping”函数，另一个是一个Erlang term组成的列表。lists:map/2 的结果是一个列表，这个列表是由入参的列表的每个元素应用于“mapping”函数得到结果组成的。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X + <span class="number">1</span> <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X * X <span class="keyword">end</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% [1,4,9,16]</span></div></pre></td></tr></table></figure>
<p>因为字符串在Erlang里就是整数列表，所以你也可以将map函数应用在字符串上。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) -&gt; X - <span class="number">1</span> <span class="keyword">end</span>, <span class="string">"IBM"</span>).</div><div class="line"><span class="comment">% "HAL"</span></div></pre></td></tr></table></figure>
<p>###Erlang里的函数</p>
<p>如果你仔细观察上面第一个例子，你会发现第一个入参我们传递的是一个 fun(X) -&gt; X + 1 end. 这是Erlang的匿名函数的语法。 一个匿名函数的格式如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">fun</span><span class="params">(Args1)</span> O<span class="title">ptionalGuardClause1</span> -&gt;</span></div><div class="line">        Expression1, Expression2;</div><div class="line">   (Args2) OptionalGuardClause2 -&gt;</div><div class="line">        Expression3, Expression4;</div><div class="line">   (Args3) OptionalGuardClause3 -&gt;</div><div class="line">        Expression5, Expression6;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为我们可以像普通函数一样使用匿名函数，除了在17.0以前的版本不能递归调用一个匿名函数外，所以我们可以将一个有多个子句的匿名函数传给lists:map/2 函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span>(X) <span class="keyword">when</span> is_atom(X) -&gt; atom; (X) -&gt; nil <span class="keyword">end</span>, [<span class="number">1</span>, x, &#123;x&#125;, [], 'B']).</div><div class="line">[nil,atom,nil,nil,atom]</div></pre></td></tr></table></figure>
<p>###传递命名函数给lists:map/2</p>
<p>虽然一些场合我们用匿名函数，但是更多时候为了清晰明了，我们还是想用命名函数。我们可以通过函数的限定名称方式来传递一个命名函数给lists:map/2，采用的格式是，在module:function_name/arity 前面加上 fun 。下面的例子用math:log10/1和erlang:is_atom/1两个函数来演示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> math:log10/<span class="number">1</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>]).</div><div class="line">[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>]</div><div class="line">lists:map(<span class="keyword">fun</span> erlang:is_atom/<span class="number">1</span>, [<span class="number">1</span>, x, &#123;x&#125;, [], 'B']).</div><div class="line">[<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文链接：&lt;/em&gt;  &lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-lists-map-2/&quot;&gt;https://www.proctor-it.com/erlang-thursday-lists-map-2/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天的Erlang Thursday讲的是函数 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#map-2&quot;&gt;lists:map/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;lists:map/2 接收两个入参，一个是接收一个入参的函数，我们称它为“mapping”函数，另一个是一个Erlang term组成的列表。lists:map/2 的结果是一个列表，这个列表是由入参的列表的每个元素应用于“mapping”函数得到结果组成的。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="map" scheme="http://szpzs.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:flatten/1</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-lists-flatten-1/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-lists-flatten-1/</id>
    <published>2016-09-15T11:44:42.000Z</published>
    <updated>2016-09-15T12:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-flatten-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-flatten-1/</a></p>
</blockquote>
<p>Erlang Thursday今天要讲的函数是 lists:flatten/1。</p>
<p>lists:flatten/1 函数将一个任意深度的由Erlang的term组成的列表展平为一个“扁平”的列表。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lists:flatten([]).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:flatten([a, b, c]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:flatten([a, b, [<span class="number">1</span>, [x, y], <span class="number">3</span>], c]).</div><div class="line"><span class="comment">% [a,b,1,x,y,3,c]</span></div><div class="line">lists:flatten([a, b, [<span class="number">1</span>, [x, &#123;some, tuple&#125;], <span class="number">3</span>], c]).</div><div class="line"><span class="comment">% [a,b,1,x,&#123;some,tuple&#125;,3,c]</span></div></pre></td></tr></table></figure>
<p>注意！它会把所有的列表都展平，比如下面的例子：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, <span class="string">"foo"</span>, b]).</div><div class="line"><span class="comment">% [a,102,111,111,b]</span></div></pre></td></tr></table></figure>
<p>上面的例子，你得到的结果有整数在列表里，因为字符串实际上在底层就是一个整数列表，所以你得到的是字符串“foo”里f和o的ASCII字符码。</p>
<p>如果你要保留字符串的格式，你必须使用二进制格式的字符串，如下所示：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, &lt;&lt;<span class="string">"foo"</span>&gt;&gt;, b]).</div><div class="line"><span class="comment">% [a,&lt;&lt;"foo"&gt;&gt;,b]</span></div></pre></td></tr></table></figure>
<p>作为一个奖励，还有一个lists:flatten/2 函数，它将一个列表展平，并且接收另外一个入参 Tail，这个入参将附加在展平列表的后面从而形成一个新的列表，例子如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:flatten([a, [<span class="number">1</span>, [b, [<span class="number">2</span>]]]], [x, y, z]).</div><div class="line"><span class="comment">% [a,1,b,2,x,y,z]</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文链接：&lt;/em&gt;  &lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-lists-flatten-1/&quot;&gt;https://www.proctor-it.com/erlang-thursday-lists-flatten-1/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Erlang Thursday今天要讲的函数是 lists:flatten/1。&lt;/p&gt;
&lt;p&gt;lists:flatten/1 函数将一个任意深度的由Erlang的term组成的列表展平为一个“扁平”的列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="flatten" scheme="http://szpzs.github.io/tags/flatten/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:max/1</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-lists-max-1/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-lists-max-1/</id>
    <published>2016-09-15T08:43:49.000Z</published>
    <updated>2016-09-15T12:51:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-max-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-max-1/</a></p>
</blockquote>
<p>今天我们来学习 lists:max/1。</p>
<p>lists:max/1 接收一个入参，这个入参是一个最少有一个元素的列表，并且它返回这个列表里最大值的元素。这个列表可以由任何Erlang term组成：</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="number">1</span>, <span class="number">39</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">27</span>, <span class="number">52</span>, <span class="number">16</span>]).</div><div class="line"><span class="comment">% 63</span></div><div class="line">lists:max([q, w, a, r, c, f, m, b]).</div><div class="line"><span class="comment">% w</span></div><div class="line">lists:max([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]]).</div><div class="line"><span class="comment">% [1,2,4]</span></div></pre></td></tr></table></figure>
<p>Erlang在不同类型的term之间有着截然不同的大小顺序，</p>
<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string<br>传给lists:max/1函数的列表可以由任意类型的term组成。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, a]).</div><div class="line"><span class="comment">% a</span></div><div class="line">lists:max([<span class="number">1</span>, a, [foo, bar], &#123;baz&#125;]).</div><div class="line"><span class="comment">% [foo,bar]</span></div></pre></td></tr></table></figure>
<p>因为在Erlang中字符串实际上是数字列表，所以我们甚至可以比较字符串。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:max([<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"snafu"</span>]).</div><div class="line"><span class="string">"snafu"</span></div></pre></td></tr></table></figure>
<p>如果你传入一个空列表给lists:max/1函数，一个 “no function clause matching”的错误将产生，因为该函数需要一个至少有一个元素的列表作为入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:max([]).</div><div class="line">** exception error: no function clause matching lists:max([]) (lists.erl, line <span class="number">326</span>)</div></pre></td></tr></table></figure>
<p>请您告诉我在以后的Erlang Thursday系列文章里，哪些是您喜欢的Erlang函数，甚至只是你想看到的函数？</p>
<p>如果您想比较Erlang的max函数和Ruby的max方法，别忘了看看上周的Ruby Tuesday系列文章： <a href="http://www.proctor-it.com/ruby-tuesday-enumerable-max/" target="_blank" rel="external">Ruby Tuesday on Enumerable#max</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文链接：&lt;/em&gt;  &lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-lists-max-1/&quot;&gt;https://www.proctor-it.com/erlang-thursday-lists-max-1/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 lists:max/1。&lt;/p&gt;
&lt;p&gt;lists:max/1 接收一个入参，这个入参是一个最少有一个元素的列表，并且它返回这个列表里最大值的元素。这个列表可以由任何Erlang term组成：&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="max" scheme="http://szpzs.github.io/tags/max/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:seq</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-lists-seq/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-lists-seq/</id>
    <published>2016-09-15T08:02:18.000Z</published>
    <updated>2016-09-15T12:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-seq/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-seq/</a></p>
</blockquote>
<p>Erlang Thursday系列文章的下一个目标是详细描述那些与Ruby Tuesday系列文章里着重阐述的方法所相对应的Erlang函数。我希望通过每个星期与Ruby Tuesday配合的Erlang Thursday系列文章能使得读者渐渐不再对Erlang陌生；我也希望通过这种方式建立一个共同讨论的渠道来使得读者不再认为Erlang是令人生畏的一门语言。我很想知道您对我这个目标如何才能更好地让读者接受和理解的一些想法。<br><a id="more"></a><br>因为这周我在<a href="https://www.proctor-it.com/ruby-tuesday-ranges/" target="_blank" rel="external">Ruby Tuesday</a>里谈到了Ruby的Range方法，那么今天我要讲的Erlang函数就是lists:seq/2和lists:seq/3。</p>
<p>如果你还记得上周<a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">Erlang Thursday</a>里的Erlang扫盲小知识里讲到的，在函数名字后面的数字表示是这个函数的arity，也就是入参的个数。</p>
<p>函数 lists:seq/2 接受两个整数入参，一个表示起始整数，一个表示结束整数，它产生一个包括这两个入参的整数列表。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% [1]</span></div></pre></td></tr></table></figure>
<p>有三个入参的lists:seq函数引入一个增量作为第三个参数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).</div><div class="line"><span class="comment">% [1,4,7,10]</span></div></pre></td></tr></table></figure>
<p>这个增量值可以是负数，这样就允许从一个整数减少低至另一个整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">20</span>, <span class="number">10</span>, -<span class="number">1</span>).</div><div class="line"><span class="comment">% [20,19,18,17,16,15,14,13,12,11,10]</span></div><div class="line">lists:seq(<span class="number">20</span>, <span class="number">10</span>, -<span class="number">5</span>).</div><div class="line"><span class="comment">% [20,15,10]</span></div></pre></td></tr></table></figure>
<p>如果给了不合适的起始和结束入参，lists:seq 函数不像Rang Range那样返回一个空集合，它会抛出一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lists:seq(<span class="number">10</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching lists:seq(10,1) (lists.erl, line 241)</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div><div class="line">lists:seq(<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div><div class="line">lists:seq(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  lists:seq/3 (lists.erl, line 262)</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文链接：&lt;/em&gt;  &lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-lists-seq/&quot;&gt;https://www.proctor-it.com/erlang-thursday-lists-seq/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Erlang Thursday系列文章的下一个目标是详细描述那些与Ruby Tuesday系列文章里着重阐述的方法所相对应的Erlang函数。我希望通过每个星期与Ruby Tuesday配合的Erlang Thursday系列文章能使得读者渐渐不再对Erlang陌生；我也希望通过这种方式建立一个共同讨论的渠道来使得读者不再认为Erlang是令人生畏的一门语言。我很想知道您对我这个目标如何才能更好地让读者接受和理解的一些想法。&lt;br&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="seq" scheme="http://szpzs.github.io/tags/seq/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – lists:member/2</title>
    <link href="http://szpzs.github.io/2016/09/15/erlang-thursday-lists-member-2/"/>
    <id>http://szpzs.github.io/2016/09/15/erlang-thursday-lists-member-2/</id>
    <published>2016-09-15T06:09:19.000Z</published>
    <updated>2016-09-15T12:50:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-member/</a></p>
</blockquote>
<p>为了和每周的 <a href="http://www.proctor-it.com/ruby-tuesday-enumerableinclude/" target="_blank" rel="external">Ruby Tuesday</a> 系列文章中关于Enumerable#include?函数来个跨界对比，我决定着重介绍 Erlang 中相同类型的函数，lists:member/2。</p>
<a id="more"></a>
<p>首先给不熟悉Erlang的同学们补充一下知识：lists:member/2 表达的意思是在lists模块里有个名字叫member的函数，它有两个参数。Arity这个词的意思表示这个函数接受的入参的个数。在Erlang中，模块很重要，因为它是所有函数赖以生存的容器－－另外也是因为模块在Erlang里是代码重新装载的单元－－为了重新载入某个方法的新版本，必需指定具体模块。</p>
<p>总而言之，模块lists的函数member接受两个入参：一个是被查找的元素，它是Erlang的一种由任意数据类型组成的数据，另一个是被检索的由Erlang的各种类型数据组成的列表；如果被查找的元素在列表里被找到，则返回true。一个Erlang的term是任意Erlang数据类型组成的数据。</p>
<p>为了方便大家运行，下面的表达式是通用的写法，返回值则加上了%符号，这个符号是Erlang注释符号，这样就方便大家直接拷贝下面的表达式然后复制到Erlang的shell上运行。</p>
<p>这个函数能够很方便地判断一个数字是否在一个由数字组成的列表里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:member(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]).</div><div class="line"><span class="comment">% false</span></div><div class="line">lists:member(<span class="number">13</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>或者判断一个原子是否在一个由原子组成的列表里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lists:member(c, [a, b, c, d]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(q, [a, b, c, d]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>或者由更复杂的term组成的列表，比如元组，或者包含列表的元组：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:member(&#123;d, <span class="number">4</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;, &#123;d, <span class="number">4</span>&#125;]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(&#123;'Foo', [bar, baz]&#125;, [a, <span class="number">1</span>, &#123;'Foo', [bar, baz]&#125;]).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(&#123;fu, [bar, baz]&#125;, [a, <span class="number">1</span>, &#123;'Foo', [bar, baz]&#125;]).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>甚至是判断一个整数或字符是否在一个字符串里：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lists:member($a, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member(<span class="number">97</span>, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">lists:member($A, <span class="string">"banana"</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>如果你仔细观察，你会发现，在Erlang里字符串实际上是由整数组成的列表。</p>
<p>希望这是一个有趣的Ruby和Erlang的比较；同时如果你对它不熟悉的话，能让你更了解Erlang。</p>
<p>原文链接：<a href="https://www.proctor-it.com/erlang-thursday-lists-member/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-lists-member/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;原文链接：&lt;/em&gt;  &lt;a href=&quot;https://www.proctor-it.com/erlang-thursday-lists-member/&quot;&gt;https://www.proctor-it.com/erlang-thursday-lists-member/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了和每周的 &lt;a href=&quot;http://www.proctor-it.com/ruby-tuesday-enumerableinclude/&quot;&gt;Ruby Tuesday&lt;/a&gt; 系列文章中关于Enumerable#include?函数来个跨界对比，我决定着重介绍 Erlang 中相同类型的函数，lists:member/2。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="member" scheme="http://szpzs.github.io/tags/member/"/>
    
  </entry>
  
</feed>
