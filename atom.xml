<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time is all</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://szpzs.github.io/"/>
  <updated>2016-09-18T12:29:25.000Z</updated>
  <id>http://szpzs.github.io/</id>
  
  <author>
    <name>彭政生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang Thursday – c:xm/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-c-xm-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-c-xm-1/</id>
    <published>2016-09-18T12:26:16.000Z</published>
    <updated>2016-09-18T12:29:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 <a href="http://erlang.org/doc/man/c.html#xm-1" target="_blank" rel="external">c:xm/1</a>.</p>
<p>c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。</p>
<a id="more"></a>
<p>首先让我们检查一下erlang模块，看看它是否有废弃的函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c:xm(erlang).</div><div class="line"><span class="comment">% [&#123;deprecated,[]&#125;,&#123;undefined,[]&#125;,&#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>结果是没有调用废弃的函数，没有未定义的函数，也没有未被使用的函数在erlang模块里。注：上述结果我是在Erlang 17.3.4 下得到的，根据你使用不同的erlang版本，你可能得到不一样的结果，因为 erlang:now/0 在18.0版本里已经是废弃的函数。（译者注：这句话有点费解，官网对 c:xm/1 对解析是：This function finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1. ）</p>
<p>为了找到符合这样标准的现存模块，我查看 Erlang 17.0 的 <a href="http://erlang.org/download/otp_src_17.0.readme" target="_blank" rel="external">README</a> 来搜索 deprecated 这个词。 找到如下这句：</p>
<p>pg 模块已经废弃，它将在Erlang/OTP 18中被删除。</p>
<p>那么让我们把这个模块名传给 c:xm/1 看看有什么结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c:xm(pg).</div><div class="line"><span class="comment">% [&#123;deprecated,[&#123;&#123;pg,create,1&#125;,&#123;pg,master,1&#125;&#125;,</span></div><div class="line"><span class="comment">%               &#123;&#123;pg,create,2&#125;,&#123;pg,master,1&#125;&#125;]&#125;,</span></div><div class="line"><span class="comment">%  &#123;undefined,[]&#125;,</span></div><div class="line"><span class="comment">%  &#123;unused,[]&#125;]</span></div></pre></td></tr></table></figure>
<p>我们可以看到我们得到了pg模块里有关废弃的函数信息。</p>
<p>虽然你在日常工作中需要使用这个函数的几率很低，因为erlang相关的工具通常都非常注意这些方面，这足够引起人们的好奇，看起来调用这个函数似乎很值得，尤其如果那个时间Erlang代码的编译是Erlang内部完成的。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-c-xm-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-c-xm-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们换一个方向，我们来看看 c 模块的 &lt;a href=&quot;http://erlang.org/doc/man/c.html#xm-1&quot;&gt;c:xm/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;c:xm/1 有一个入参，这个入参是表示一个模块名字的原子，或者这个入参是表示一个文件名单字符串，该函数检查模块没有使用和没有定义的函数以及废弃的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/categories/Erlang/c/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="c" scheme="http://szpzs.github.io/tags/c/"/>
    
      <category term="xm" scheme="http://szpzs.github.io/tags/xm/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:is_subset/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-is-subset-2/</id>
    <published>2016-09-18T12:22:01.000Z</published>
    <updated>2016-09-18T12:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#is_subset-2" target="_blank" rel="external">ordsets:is_subset/2</a>.</p>
<p>ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">10</span>)).</div><div class="line"><span class="comment">% [1,2,3,4,5,6,7,8,9,10]</span></div><div class="line">SetB = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>)).</div><div class="line"><span class="comment">% [2,4,6,8,10]</span></div><div class="line">SetC = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">15</span>, <span class="number">3</span>)).</div><div class="line"><span class="comment">% [1,4,7,10,13]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:is_subset(SetB, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetB).</div><div class="line"><span class="comment">% false</span></div><div class="line">ordsets:is_subset(SetC, SetA).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>有几个事实要跟不熟悉集合理论的同学讲讲。首先，空集合是所有集合的子集；其次，一个集合是它自己的子集；最后，如果集合B是集合A的超集，则集合A是集合B的子集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ordsets:is_subset(EmptySet, SetA).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetB).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, SetC).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(EmptySet, EmptySet).</div><div class="line"><span class="comment">% true</span></div><div class="line">ordsets:is_subset(SetA, SetA).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-is_subset-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#is_subset-2&quot;&gt;ordsets:is_subset/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ordsets:is_subset/2 有两个有序集合的入参，函数会检测第一个入参是否是第二入参的子集。例如一个集合A，它是另一个集合B的子集，则集合A的每一个元素必须是集合B的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="is_subset" scheme="http://szpzs.github.io/tags/is-subset/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:subtract/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-subtract-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-subtract-2/</id>
    <published>2016-09-18T12:18:09.000Z</published>
    <updated>2016-09-18T12:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#subtract-2" target="_blank" rel="external">ordsets:subtract/2</a>.</p>
<p>ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">OrderedSetA = ordsets:from_list([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">OrderedSetB = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">OrderedSetC = ordsets:from_list([<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">16</span>, -<span class="number">16</span>]).</div><div class="line"><span class="comment">% [-16,-4,-2,2,4,16]</span></div><div class="line">EmptySet = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetA, OrderedSetB).</div><div class="line"><span class="comment">% [4]</span></div><div class="line">ordsets:subtract(OrderedSetA, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,4,5]</span></div><div class="line">ordsets:subtract(OrderedSetB, EmptySet).</div><div class="line"><span class="comment">% [1,2,3,5,8,13]</span></div><div class="line">ordsets:subtract(EmptySet, OrderedSetA).</div><div class="line"><span class="comment">% []</span></div><div class="line">ordsets:subtract(OrderedSetB, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5,8,13]</span></div></pre></td></tr></table></figure>
<p>请注意，ordsets:subtract/2 的入参顺序是不可换的，这一点和 ordsets:union/2 或者 ordsets:intersection/2 不一样。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ordsets:subtract(OrderedSetA, OrderedSetC).</div><div class="line"><span class="comment">% [1,3,5]</span></div><div class="line">ordsets:subtract(OrderedSetC, OrderedSetA).</div><div class="line"><span class="comment">% [-16,-4,-2,16]</span></div></pre></td></tr></table></figure>
<p>如果你不是一直跟读Erlang Thursday的话，我再次友情提醒你，虽然Erlang用列表来表示有序集合，但是并不意味着列表是有序集合。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-subtract-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ordsets:substract/2 有两个入参，它们都是有序集合，返回值是一个由只在第一个有序集合入参而不在第二个有序集合入参的元素组成的有序集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="subtract" scheme="http://szpzs.github.io/tags/subtract/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday Bonus! Performace of erlang:length/1 on a list</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</id>
    <published>2016-09-18T12:12:46.000Z</published>
    <updated>2016-09-18T12:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家一个Erlang Thursday福利。</p>
<p>上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：</p>
<p>有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？</p>
<a id="more"></a>
<p>我可以百分之九九确定Erlang必须每次都要遍历列表来计算其长度，因为它用链接列表类的数据结构来构造它的列表，但是我不确定是否有一些聪明的实现方法是我没有意识到，这些方法能提高获取列表长度到速度。</p>
<p>在写今天的Erlang Thursday的时候，我意识到，我应该用 timer:tc 函数，通过它来展示需要多长时间来获取不同列表的长度来证明 erlang:length/1 函数的执行情况。</p>
<p>为了纪念这个问题，也为了在下一次会议的时候能回忆其它，我在这里记录相关内容。我们要明白，timer:tc 函数返回的结果里第一个元素是被测量函数执行的微秒时间。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10</span>)]).</div><div class="line">&#123;<span class="number">2</span>,<span class="number">10</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000</span>)]).</div><div class="line">&#123;<span class="number">5</span>,<span class="number">1000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000</span>)]).</div><div class="line">&#123;<span class="number">41</span>,<span class="number">10000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000</span>)]).</div><div class="line">&#123;<span class="number">134</span>,<span class="number">100000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">1000000</span>)]).</div><div class="line">&#123;<span class="number">1918</span>,<span class="number">1000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">10000000</span>)]).</div><div class="line">&#123;<span class="number">25139</span>,<span class="number">10000000</span>&#125;</div><div class="line">timer:tc(erlang, length, [lists:seq(<span class="number">1</span>, <span class="number">100000000</span>)]).</div><div class="line">&#123;<span class="number">1368691</span>,<span class="number">100000000</span>&#125;</div></pre></td></tr></table></figure>
<p>在链接列表有大概1000元素以后，我们可以看到计算其长度的时间线性增长，尽管不是真正对所有节点做遍历，但是在算法复杂度（大O）上看是相同复杂度级别。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-bonus-performace-of-erlang-length-1-on-a-list/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家一个Erlang Thursday福利。&lt;/p&gt;
&lt;p&gt;上星期在达拉斯－沃斯堡的Erlang User group 演讲上，有一些Erlang新人参加我们的会议，有人提到了如下问题：&lt;/p&gt;
&lt;p&gt;有没有聪明的方法来获得列表的长度，或者还是必须要遍历列表的所有元素来计算它的长度呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/categories/Erlang/erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/tags/erlang/"/>
    
      <category term="length" scheme="http://szpzs.github.io/tags/length/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:intersection/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-intersection-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-intersection-2/</id>
    <published>2016-09-18T12:08:06.000Z</published>
    <updated>2016-09-18T12:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday继续看ordsets模块并且讲讲 <a href="http://erlang.org/doc/man/ordsets.html#intersection-2" target="_blank" rel="external">ordsets:intersection/2</a> 。</p>
<p>ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OrderedSet1 = ordsets:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>]</div><div class="line">OrderedSet2 = ordsets:from_list([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet1, OrderedSet2).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection(OrderedSet2, OrderedSet1).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>因为 ordsets:intersection/2 在集合中找共同的元素，就向上面的例子一样，入参的顺序是可以交换的，不管两个入参的有序集合的参数顺序如何，我们得到的结果是一样的。</p>
<p>如果没有共同的元素，则结果是一个空的有序集合（其实就是一个空列表，上周的文章 <a href="http://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">ordsets:union/2</a> 里强调了用一个列表来当做一个有序集合是危险的）。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Evens = ordsets:from_list(lists:seq(<span class="number">2</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</div><div class="line">Odds = ordsets:from_list(lists:seq(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>]</div><div class="line">ordsets:intersection(OrderedSet2, ordsets:new()).</div><div class="line">[]</div><div class="line">ordsets:intersection(Evens, Odds).</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>Erlang也提供了 <a href="http://erlang.org/doc/man/ordsets.html#intersection-1" target="_blank" rel="external">ordsets:intersection/1</a> 函数，它的入参是一个由多个有序集合为元素组成的列表，它返回的结果是列表里所有的有序集合的交集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">OrderedSet3 = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</div><div class="line">ordsets:intersection([Evens, Odds, OrderedSet1]).</div><div class="line">[]</div><div class="line">ordsets:intersection([Odds, OrderedSet2, OrderedSet1]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>]</div><div class="line">ordsets:intersection([Evens, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">2</span>]</div><div class="line">ordsets:intersection([Odds, OrderedSet1, OrderedSet3]).</div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-intersection-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday继续看ordsets模块并且讲讲 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#intersection-2&quot;&gt;ordsets:intersection/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ordsets:intersection/2 有两个有序集合的入参，它返回的结果是两个有序集合的交集形成的新的有序集合。对于那些没有集合理论背景的人，通俗的解释就是一个集合交集就是所有相交的集合的共同元素组成的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="intersection" scheme="http://szpzs.github.io/tags/intersection/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – ordsets:union/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-union-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-ordsets-union-2/</id>
    <published>2016-09-18T11:55:20.000Z</published>
    <updated>2016-09-18T12:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://erlang.org/doc/man/ordsets.html#union-2" target="_blank" rel="external">ordsets:union/2</a> 。</p>
<p>ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SetA = ordsets:from_list([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">SetB = ordsets:new().</div><div class="line"><span class="comment">% []</span></div><div class="line">SetC = ordsets:from_list([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]).</div><div class="line"><span class="comment">% [1,3,4,5,9]</span></div><div class="line">SetD = ordsets:from_list([a, b, c, d, e]).</div><div class="line"><span class="comment">% [a,b,c,d,e]</span></div><div class="line">UnionAB = ordsets:union(SetA, SetB).</div><div class="line"><span class="comment">% [1,2,3,5]</span></div><div class="line">UnionAC = ordsets:union(SetA, SetC).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div></pre></td></tr></table></figure>
<p>因为Erlang里的字符串实际上是字符列表，我们可以从字符串产生有序集合，然后通过这个函数得到两个字符串里不重复的字符并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:from_list(<span class="string">"Kermit"</span>).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list([<span class="number">75</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">116</span>]).</div><div class="line"><span class="comment">% "Keimrt"</span></div><div class="line">ordsets:from_list(<span class="string">"Mississippi"</span>).</div><div class="line"><span class="comment">% "Mips"</span></div><div class="line">ordsets:union(ordsets:from_list(<span class="string">"Kermit"</span>), ordsets:from_list(<span class="string">"Mississippi"</span>)).</div><div class="line"><span class="comment">% "KMeimprst"</span></div></pre></td></tr></table></figure>
<p>ordsets模块也包含 <a href="http://erlang.org/doc/man/ordsets.html#union-1" target="_blank" rel="external">ordsets:union/1</a> ，它的入参是一个由有序集合组成的列表，它返回的是列表里所有有序集合的并集。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UnionAC = ordsets:union([SetA, SetC]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABC = ordsets:union([SetB, SetC, SetA]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9]</span></div><div class="line">UnionABCD = ordsets:union([SetB, SetC, SetA, SetD]).</div><div class="line"><span class="comment">% [1,2,3,4,5,9,a,b,c,d,e]</span></div><div class="line">UnionCD = ordsets:union([SetC, SetD]).</div><div class="line"><span class="comment">% [1,3,4,5,9,a,b,c,d,e]</span></div></pre></td></tr></table></figure>
<p>警告：有序集合的表现形式虽然只是一个列表，但是如果你传递一个普通列表给 ordsets:union/2 ，你将得不到你预期的结果，因为这个函数要求每个有序集合里的元素是真正的有序并且是一个集合。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,2,3,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c]</span></div><div class="line">ordsets:union([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, a, b, c, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,1,2,a,b,c,1]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-ordsets-union-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-ordsets-union-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://erlang.org/doc/man/ordsets.html#union-2&quot;&gt;ordsets:union/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ordsets:union/2 有两个有序集合类型的入参，它的输出是这两个入参合并得到的有序集合 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/categories/Erlang/ordsets/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="ordsets" scheme="http://szpzs.github.io/tags/ordsets/"/>
    
      <category term="union" scheme="http://szpzs.github.io/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thrusday – queue:out/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thrusday-queue-out-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thrusday-queue-out-1/</id>
    <published>2016-09-18T11:49:21.000Z</published>
    <updated>2016-09-18T11:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的的是queue模块原生API中的  <a href="http://erlang.org/doc/man/queue.html#out-1" target="_blank" rel="external">queue:out/1</a> 函数。</p>
<p>queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。</p>
<a id="more"></a>
<p>“是什么让这个函数这么厉害？”，你可能会这么问我。</p>
<p>这应该是这个函数由元组、标签元组组成，它的不可变性，它的宽容性，以及我们最终看到它返回结果的事实，所有这些使得我希望更多的队列实现都有像这样的一个API。</p>
<p>首先应该由很多次我自己或别人的过往经历中，在尝试弹出队列第一个元素的时候忘了检查这个队列是否是空的，从而造成一个很不友好的运行时错误。</p>
<p>queue:out/1 恰恰相反，当你给它的入参是一个空队列的时候，它并不触发一个错误，而是返回一个标签元组来告诉你，你传入的队列是空的，另外它还返回一个空队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:out(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们的入参是一个非空队列，queue:out/1 返回一个两元素元组。第一个元素是一个标签元组，它告诉我们，我们得到了一个值以及入参队列的头部元素，第二个元素，我们得到了入参队列移除头部元素后剩下的元素组成的队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([a, b, c, d]).</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">&#123;&#123;value, Head&#125;, NewQueue&#125; = queue:out(Queue).</div><div class="line"><span class="comment">% &#123;&#123;value,a&#125;,&#123;[d],[b,c]&#125;&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[d],[a,b,c]&#125;</span></div><div class="line">Head.</div><div class="line"><span class="comment">% a</span></div><div class="line">NewQueue.</div><div class="line"><span class="comment">% &#123;[d],[b,c]&#125;</span></div><div class="line">queue:head(NewQueue).</div><div class="line"><span class="comment">% b</span></div></pre></td></tr></table></figure>
<p>当我们在跨语言条件下谈论队列的理论上的概念时，“pop”这个概念做了两个事情，返回队列的头部元素，同时修改队列将其头部元素删除。</p>
<p>由于Erlang的队列是不可改变的，那么你仔细想想几分钟，你就会感觉到 queue:out/1 这个函数的妙处了，它也做了“pop”概念中的两件事情，就是返回队列头部，同时返回一个删除了头部元素的新的队列。</p>
<p>Erlang的queue模块也提供了函数 <a href="http://erlang.org/doc/man/queue.html#out_r-1" target="_blank" rel="external">queue:out_r/1</a> ，它的行为和 queue:out/1 基本一样，不一样的是它操作的是队列的尾部元素而不是队列的头部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:out_r(queue:from_list([a, b, c, d])).</div><div class="line"><span class="comment">% &#123;&#123;value,d&#125;,&#123;,[a,b]&#125;&#125;</span></div><div class="line">queue:out_r(queue:new()).</div><div class="line"><span class="comment">% &#123;empty,&#123;[],[]&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>我希望你和我一样发现 queue:out/1 方便好用。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thrusday-queue-out-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thrusday-queue-out-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的的是queue模块原生API中的  &lt;a href=&quot;http://erlang.org/doc/man/queue.html#out-1&quot;&gt;queue:out/1&lt;/a&gt; 函数。&lt;/p&gt;
&lt;p&gt;queue:out/1 是我见过的出镜率最高的队列函数或者说是队列方法。而且它在我所用到的各种语言或应用库中都存在。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="out" scheme="http://szpzs.github.io/tags/out/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:split/2</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-split-2/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-split-2/</id>
    <published>2016-09-18T11:45:36.000Z</published>
    <updated>2016-09-18T12:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲queue模块的原生API：<a href="http://erlang.org/doc/man/queue.html#split-2" target="_blank" rel="external">queue:split/2</a> 。</p>
<p>queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([a, <span class="number">1</span>, b, <span class="number">2</span>, c, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:split(<span class="number">4</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[2],[a,1,b]&#125;,&#123;[4,3],&#125;&#125;</span></div><div class="line">queue:split(<span class="number">0</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[]&#125;,&#123;[4,3,c],[a,1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">1</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[],[a]&#125;,&#123;[4,3,c],[1,b,2]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">7</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[4,3,c],[a,1,b,2]&#125;,&#123;[],[]&#125;&#125;</span></div><div class="line">queue:split(<span class="number">15</span>, QueueOne).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:split/2</span></div><div class="line"><span class="comment">%         called as queue:split(15,&#123;[4,3,c],[a,1,b,2]&#125;)</span></div><div class="line">&#123;SplitFirst, SplitSecond&#125; = queue:split(<span class="number">3</span>, QueueOne).</div><div class="line"><span class="comment">% &#123;&#123;[b,1],[a]&#125;,&#123;[4,3,c],[2]&#125;&#125;</span></div><div class="line">SplitFirst.</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">SplitSecond.</div><div class="line"><span class="comment">% &#123;[4,3,c],[2]&#125;</span></div><div class="line">queue:peek(SplitFirst).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(SplitSecond).</div><div class="line"><span class="comment">% &#123;value,2&#125;</span></div></pre></td></tr></table></figure>
<p>Erlang也提供一个 <a href="http://erlang.org/doc/man/queue.html#join-2" target="_blank" rel="external">queue:join/2</a> 函数，它有两个入参，入参类型都是队列，函数返回值是一个新的队列，新队列是由第二个入参队列添加到第一个入参队列后面形成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:join(SplitFirst, SplitSecond).</div><div class="line"><span class="comment">% &#123;[4,3,c],[a,1,b,2]&#125;</span></div><div class="line">queue:join(SplitSecond, SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[2,c,3,4,a]&#125;</span></div><div class="line">queue:join(queue:new(), SplitFirst).</div><div class="line"><span class="comment">% &#123;[b,1],[a]&#125;</span></div><div class="line">queue:join(queue:new(), queue:new()).</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-split-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-split-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲queue模块的原生API：&lt;a href=&quot;http://erlang.org/doc/man/queue.html#split-2&quot;&gt;queue:split/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;queue:split/2 有两个入参。第一个入参是一个从零到X的整数N，X是一个队列的元素个数，这个队列就是第二个入参，也就是我们想分隔的队列。函数的返回值是一个两元素元组，第一个元素是被分割队列的前N个元素组成的队列，第二个元素是被分割队列剩下的元素组成的队列。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="split" scheme="http://szpzs.github.io/tags/split/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:peek/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-peek-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-peek-1/</id>
    <published>2016-09-18T11:39:35.000Z</published>
    <updated>2016-09-18T11:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 <a href="http://erlang.org/doc/man/queue.html#peek-1" target="_blank" rel="external">queue:peek/1</a> 。</p>
<p>queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueOne = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:peek(QueueOne).</div><div class="line"><span class="comment">% &#123;value,1&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>queue:peek/1 绝对不会修改入参队列，所以我们可以再一次调用上述例子，或者像下面例子一样多次调用，而我们的入参队列不会被修改。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">QueueTwo = queue:from_list([a, b, c, d, e, f]).</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">queue:peek(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,a&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div></pre></td></tr></table></figure>
<p>不像上一篇文章里我们看到的 <a href="http://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">queue:head/1</a> ，我们可以安全地在入参队列为空的情况下调用 queue:peek/1 函数，而不是获得一个异常。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:head/1</span></div><div class="line"><span class="comment">%         called as queue:head(&#123;[],[]&#125;)</span></div><div class="line">queue:peek(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div></pre></td></tr></table></figure>
<p>Erlang的 queue 模块也包含函数 <a href="http://erlang.org/doc/man/queue.html#peek_r-1" target="_blank" rel="external">queue:peek_r/1</a> ，它返回入参队列的尾部元素。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">queue:peek_r(EmptyQueue).</div><div class="line"><span class="comment">% empty</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueOne).</div><div class="line"><span class="comment">% &#123;value,5&#125;</span></div><div class="line">queue:peek_r(QueueTwo).</div><div class="line"><span class="comment">% &#123;value,f&#125;</span></div><div class="line">QueueTwo.</div><div class="line"><span class="comment">% &#123;[f,e],[a,b,c,d]&#125;</span></div><div class="line">QueueOne.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">EmptyQueue.</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-peek-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-peek-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续研究queue模块来看看扩展API里的 &lt;a href=&quot;http://erlang.org/doc/man/queue.html#peek-1&quot;&gt;queue:peek/1&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;queue:peek/1 接收一个队列为入参，如果这个队列是空的，它返回原子 empty ，否则它返回 {value, Item} 元组，其中 Item 是队列的头部元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="peek" scheme="http://szpzs.github.io/tags/peek/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:tail/1</title>
    <link href="http://szpzs.github.io/2016/09/18/erlang-thursday-queue-tail-1/"/>
    <id>http://szpzs.github.io/2016/09/18/erlang-thursday-queue-tail-1/</id>
    <published>2016-09-18T11:31:31.000Z</published>
    <updated>2016-09-18T11:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 <a href="http://erlang.org/doc/man/queue.html#tail-1" target="_blank" rel="external">queue:tail/1</a>.</p>
<p>queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">Tail = queue:tail(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Tail).</div><div class="line"><span class="comment">% 2</span></div><div class="line">queue:to_list(Tail).</div><div class="line"><span class="comment">% [2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>我们可以看到上述调用 queue:tail/1 的例子不像其它语言一样是一个破坏性操作，它完全保留了原始的入参队列的完整性。</p>
<p>做为将一个队列做为双端来处理的Okasaki API的一部分，queue:tail/1 有一个对应的函数 <a href="http://erlang.org/doc/man/queue.html#liat-1" target="_blank" rel="external">queue:liat/1</a> ，这个函数返回移除入参队列的最后一个元素后形成的新队列。queue:liat/1 也有一个别名函数，就是Okasaki API的 <a href="http://erlang.org/doc/man/queue.html#init-1" target="_blank" rel="external">queue:init/1</a>.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue:liat(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">queue:init(Queue).</div><div class="line"><span class="comment">% &#123;[4],[1,2,3]&#125;</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>注意：Erlang官方文档也指出有一个别名函数 queue:lait/1 ，大家最好不要用它，因为它的拼写是错误的。</p>
<p>因为我们是要深入细节然后看看我们能学到什么，那么让我们一起来到目前为止我们接触到的不同的tail函数在接收一个空队列为入参会发生什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:tail(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop/1</span></div><div class="line"><span class="comment">%         called as queue:drop(&#123;[],[]&#125;)</span></div><div class="line">queue:liat(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div><div class="line">queue:init(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:drop_r/1</span></div><div class="line"><span class="comment">%         called as queue:drop_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>当我们分别调用 <a href="http://erlang.org/doc/man/queue.html#drop-1" target="_blank" rel="external">queue:tail/1</a> 和 <a href="http://erlang.org/doc/man/queue.html#drop_r-1" target="_blank" rel="external">queue:liat/1</a> 的时候，看起来像我们在调用 queue:drop/1 和 queue:drop_r/1 得到的异常错误一样。</p>
<p>当我们用一个有若干元素的队列做为入参来调用 queue:drop/1 和 queue:drop_r/1 ，然后看看的执行情况，看起来 queue:tail/1 就是 queue:drop/1 的别名函数，而 queue:list/1 和 queue:init/1 就是 queue:drop_r/1 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:drop(Queue).</div><div class="line"><span class="comment">% &#123;[5,4],[2,3]&#125;</span></div><div class="line">queue:drop_r(Queue).</div><div class="line">&#123;[<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-tail-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-tail-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续queue模块的Okazaki API，来讲讲 &lt;a href=&quot;http://erlang.org/doc/man/queue.html#tail-1&quot;&gt;queue:tail/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;queue:tail/1 接收一个非空队列入参，返回移除了第一个元素的新队列。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="tail" scheme="http://szpzs.github.io/tags/tail/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:head/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-queue-head-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-queue-head-1/</id>
    <published>2016-09-17T08:44:16.000Z</published>
    <updated>2016-09-17T08:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看<a href="http://erlang.org/doc/man/queue.html#head-1" target="_blank" rel="external">queue:head/1</a>.</p>
<p>queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Queue = queue:from_list([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div><div class="line">queue:head(Queue).</div><div class="line"><span class="comment">% 1</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<p>上述例子显示，queue:head/1 函数没有修改原来的队列，而仅是返回它的第一个元素。</p>
<p>因为 queue:head/1 仅仅是返回队列头部能找到的值，而且不是一个标签元组，如果我们尝试从一个空的队列获取它的头部元素则会抛出一个错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EmptyQueue = queue:new().</div><div class="line"><span class="comment">% &#123;[],[]&#125;</span></div><div class="line">queue:head(EmptyQueue).</div><div class="line"><span class="comment">%** exception error: empty</span></div><div class="line"><span class="comment">%     in function  queue:head/1</span></div><div class="line"><span class="comment">%        called as queue:head(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>为了安全起见，让我们不在一个空队列上运行该函数而造成抛出异常，queue模块也定义了一个函数 queue:is_empty/1 ，你可以用它来检查一个队列是否为空。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue:is_empty(EmptyQueue).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>像 queue:cons/2 和Okazaki API的其它函数一样，模块里也有一个函数<a href="http://erlang.org/doc/man/queue.html#daeh-1" target="_blank" rel="external">queue:dash</a> （head单词倒过来写），它从队列获取最后一个元素，它也是 <a href="http://erlang.org/doc/man/queue.html#last-1" target="_blank" rel="external">queue:last/1</a> 的别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:daeh(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:last(Queue).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>如果你调用 queue:dash/1 和 queue:last/1 的时候用空队列做入参也会引起错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:daeh(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:last(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div></pre></td></tr></table></figure>
<p>如果我们仔细看 queue:dash/1 和 queue:last/1 引起的错误，我们看到这个错误来自扩展API的 queue:get_r/1 。如果我们仔细看 queue:get_r/1 的执行情况，他看起来像 queue:tail/1 和 queue:dash/1 ，而这两个函数真的仅是 <a href="http://erlang.org/doc/man/queue.html#get_r-1" target="_blank" rel="external">queue:get_r/1</a> 别名函数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">queue:get_r(EmptyQueue).</div><div class="line"><span class="comment">% ** exception error: empty</span></div><div class="line"><span class="comment">%      in function  queue:get_r/1</span></div><div class="line"><span class="comment">%         called as queue:get_r(&#123;[],[]&#125;)</span></div><div class="line">queue:get_r(Queue).</div><div class="line"><span class="comment">% 5</span></div><div class="line">Queue.</div><div class="line"><span class="comment">% &#123;[5,4],[1,2,3]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-head-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-head-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们继续挖掘Erlang的queue模块的Okazaki API，这次来看看&lt;a href=&quot;http://erlang.org/doc/man/queue.html#head-1&quot;&gt;queue:head/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;queue:head/1 入参是一个队列，它的输出是这个队列的第一个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="head" scheme="http://szpzs.github.io/tags/head/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – queue:cons/2</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-queue-cons-2/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-queue-cons-2/</id>
    <published>2016-09-17T08:39:51.000Z</published>
    <updated>2016-09-17T08:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday我们稍微深入一下queue模块，我们讲讲来自Okazaki的API：<a href="http://www.erlang.org/doc/man/queue.html#cons-2" target="_blank" rel="external">queue:cons/2</a> 。</p>
<p>queue:cons/2 有两个入参，一个是元素，一个是队列，它执行后返回一个元素加在队列头部形成的新队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">7</span>, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[7]&#125;</span></div><div class="line">queue:cons(<span class="number">3</span>, queue:cons(<span class="number">7</span>, queue:new())).</div><div class="line"><span class="comment">% &#123;[7],[3]&#125;</span></div><div class="line">queue:cons(nil, queue:new()).</div><div class="line"><span class="comment">% &#123;[],[nil]&#125;</span></div><div class="line">queue:cons(<span class="number">5</span>, queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>])).</div><div class="line"><span class="comment">% &#123;[21],[5,7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<p>如果我们传入一个列表给 queue:cons/2 ，我们看到它出错，表明它想要一个队列，而不会隐式地将一个列表转成一个队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue:cons(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).</div><div class="line"><span class="comment">% ** exception error: bad argument</span></div><div class="line"><span class="comment">%      in function  queue:in_r/2</span></div><div class="line"><span class="comment">%         called as queue:in_r(5,[1,2,3,4])</span></div></pre></td></tr></table></figure>
<p>因为队列被设置成一个双端队列，Okasaki API 也提供了一个对应的函数 <a href="http://www.erlang.org/doc/man/queue.html#snoc-2" target="_blank" rel="external">queque:snoc/2</a> ，它将元素加在传入的队列的尾部。注意，queue:snoc/2 和 queue:cons/2 两个函数的两个入参的顺序也是相反的；queue:snoc/2 的第一个入参上一个队列，而要加在它尾部的元素做为第二个入参。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">queue:snoc(queue:new(), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:snoc(queue:new(), <span class="number">7</span>), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5],[7]&#125;</span></div><div class="line">queue:snoc(queue:from_list([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">21</span>]), <span class="number">5</span>).</div><div class="line"><span class="comment">% &#123;[5,21],[7,9,13]&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-queue-cons-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-queue-cons-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday我们稍微深入一下queue模块，我们讲讲来自Okazaki的API：&lt;a href=&quot;http://www.erlang.org/doc/man/queue.html#cons-2&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/categories/Erlang/queue/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="queue" scheme="http://szpzs.github.io/tags/queue/"/>
    
      <category term="cons" scheme="http://szpzs.github.io/tags/cons/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – filelib:is_file/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-filelib-is-file-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-filelib-is-file-1/</id>
    <published>2016-09-17T08:35:45.000Z</published>
    <updated>2016-09-17T08:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/filelib.html#is_file-1" target="_blank" rel="external">filelib:is_file/1</a>.</p>
<p>filelib:is_file/1 入参是一个表示文件名的字符串，它根据这个文件名所指的是否是文件或目录而返回true或者false。</p>
<p>这个函数在你正在需要从一个配置文件读取内容并且在尝试处理前确认这个文件或目录是否存在的时候有用，以便你可以在退出前得到一个友好的错误信息而不仅是引起一个系统错误。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(<span class="string">"foo"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"junk"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tmp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"tempmp"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"temp"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/bin"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/var"</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">"/usr/local/vars"</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(<span class="string">"."</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file(<span class="string">".."</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>filelib:is_file/1 的入参也可以是一个原子，或者甚至也可以是一个嵌套的列表来表示一个文件名。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">filelib:is_file(foo).</div><div class="line"><span class="comment">% false</span></div><div class="line">filelib:is_file(junk).</div><div class="line"><span class="comment">% true</span></div><div class="line">filelib:is_file([<span class="string">"/usr"</span>, ['/local', '/bin']]).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-filelib-is_file-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/filelib.html#is_file-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;filelib:is_file/1&lt;/a&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="filelib" scheme="http://szpzs.github.io/categories/Erlang/filelib/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="filelib" scheme="http://szpzs.github.io/tags/filelib/"/>
    
      <category term="is_file" scheme="http://szpzs.github.io/tags/is-file/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:iso_week_number/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-iso-week-number-1/</id>
    <published>2016-09-17T07:49:18.000Z</published>
    <updated>2016-09-17T07:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#iso_week_number-1" target="_blank" rel="external">calendar:iso_week_number/1</a>.</p>
<p>calendar:iso_week_number/1 接收一个日期元组做为入参，然后返回一个由年份和周数字组成的元组。年份是入参里的年份，而周数字是一个1到53的整数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">04</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">19</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">05</span>, <span class="number">03</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">18</span>&#125;</div></pre></td></tr></table></figure>
<p>如果我们拿本周做为一个例子，我们可以看到本周是从星期一（五月四日）开始，而前一个星期天（五月三日）是属于上一个星期的。</p>
<p>我们看到一月一日是这一年的第一周，这没什么奇怪，而2015年的十二月三十一日是这一年的第53周。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">1</span>&#125;</div><div class="line">calendar:iso_week_number(&#123;<span class="number">2015</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line">&#123;<span class="number">2015</span>,<span class="number">53</span>&#125;</div></pre></td></tr></table></figure>
<p>一开始听到一年有53周我们会很惊讶，因为几乎每个人都认为一年只有52周，直到你意识到有些十二月三十一日有时候是处于一周的开始，所以造成了它处在第53周，而它仅仅是这周的一部分。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-iso_week_number-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#iso_week_number-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calendar:iso
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="iso_week_number" scheme="http://szpzs.github.io/tags/iso-week-number/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:is_leap_year/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-is-leap-year-1/</id>
    <published>2016-09-17T07:43:16.000Z</published>
    <updated>2016-09-17T07:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#is_leap_year-1" target="_blank" rel="external">calendar:is_leap_year/1</a>.</p>
<p>calendar:is_leap_year/1 接收一个非负整数表示的年份，如果这个年份是闰年，则返回true，否则返回false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(<span class="number">2015</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2012</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">2017</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">2000</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:is_leap_year(<span class="number">1900</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:is_leap_year(<span class="number">0</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>有了这个Erlang核心库的内置函数，意味着你不需要编写代码或者甚至不需要查找规则来记住如何判断某个年份到底是不是闰年。</p>
<p>如果你传递一个负数来表示年份，Erlang将抛出一个异常，因为没有一个函数分支能匹配用负数来表示的年份。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:is_leap_year(-<span class="number">1</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-1) (calendar.erl, line 183)</span></div><div class="line">calendar:is_leap_year(-<span class="number">4</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:is_leap_year(-4) (calendar.erl, line 183)</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-is_leap_year-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#is_leap_year-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calendar:is_lea
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="is_leap_year" scheme="http://szpzs.github.io/tags/is-leap-year/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:valid_date/3</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-valid-date-3/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-valid-date-3/</id>
    <published>2016-09-17T07:38:52.000Z</published>
    <updated>2016-09-17T07:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#valid_date-3" target="_blank" rel="external">calendar:valid_date/3</a>.</p>
<p>本来这次我是想讲函数 calendar:time_difference/3 ，但是当我详细看了 <a href="http://www.erlang.org/doc/man/calendar.html" target="_blank" rel="external">calendar</a> 模块的官方文档后，发现文档里已经说这个函数被淘汰了，所以今天我讲 calendar:valid_date/3 。</p>
<a id="more"></a>
<p>calendar:valid_date/3 的入参分别是一个表示年份的整数、一个表示月份的整数以及一个表示日的整数。如果传入的日期是有效的，则 calendar:valid_date/3 返回原子true，如果传入的日期是无效的，则 calendar:valid_date/3 返回原子false。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">30</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2012</span>, <span class="number">02</span>, <span class="number">29</span>).</div><div class="line"><span class="comment">% true</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">17</span>, <span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>我们也可以快速地检查一下本篇文章发布的日期也是有效日期。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<p>现在让我们看看入参中有0或负整数情况会怎么样？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(-<span class="number">1</span>, <span class="number">04</span>, <span class="number">23</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, -<span class="number">7</span>, <span class="number">21</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">2015</span>, <span class="number">7</span>, -<span class="number">13</span>).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% false</span></div></pre></td></tr></table></figure>
<p>正如人们所希望的，除非你要经常处理公元前的日期，不然的话有一个负数的日期是无效的。</p>
<p>Erlang也提供了函数 calendar:valid_date/1 ，它的入参是由年、月、日三个整数组成的元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">11</span>, <span class="number">76</span>&#125;).</div><div class="line"><span class="comment">% false</span></div><div class="line">calendar:valid_date(&#123;<span class="number">2015</span>, <span class="number">04</span>, <span class="number">23</span>&#125;).</div><div class="line"><span class="comment">% true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-valid_date-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#valid_date-3&quot;&gt;calendar:valid_date/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本来这次我是想讲函数 calendar:time_difference/3 ，但是当我详细看了 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html&quot;&gt;calendar&lt;/a&gt; 模块的官方文档后，发现文档里已经说这个函数被淘汰了，所以今天我讲 calendar:valid_date/3 。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="valid_date" scheme="http://szpzs.github.io/tags/valid-date/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:date_to_gregorian_days/3</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-date-to-gregorian-days-3/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-date-to-gregorian-days-3/</id>
    <published>2016-09-17T07:33:21.000Z</published>
    <updated>2016-09-17T07:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#date_to_gregorian_days-3" target="_blank" rel="external">calendar:date_to_gregorian_days/3</a>.</p>
<p>正如我们上星期在 <a href="http://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">Erlang Thursday calendar:day_of_the_week/3</a> 中讲到的，当我们看到一些错误消息的时候，我们看到错误来自于 calendar:date_to_gregorian_days/3。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>在上星期那篇文章里我保证我们下次将深入了解 calendar:date_to_gregorian_days/3 ，所以现在让我们来完成这个任务。</p>
<p>calendar:date_to_gregorian_days/3 有三个入参，一个代表年份的非负整数，一个代表月份的从1到12的整数，一个代表某月第几日的从1到31的整数，该函数返回的值是从公元元年1月1日截止到入参日期的天数。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 366</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 719528</span></div><div class="line">calendar:date_to_gregorian_days(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 730484</span></div></pre></td></tr></table></figure>
<p>还有一个只接收一个入参的版本 calendar:date_to_gregorian_days/1，它的入参是由年、月、日三个整数组成元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">16</span>&#125;).</div><div class="line"><span class="comment">% 736069</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 0</span></div><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 366</span></div></pre></td></tr></table></figure>
<p>如果我们传给 calendar:date_to_gregorian_days/1 无效的日期，我们就会在错误消息里看到它正在调用 calendar:date_to_gregorian_days/3 。所以它是一个不错的辅助函数，不破坏我们的模式匹配。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:date_to_gregorian_days(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;).</div><div class="line">** exception error: no function clause matching calendar:date_to_gregorian_days(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>) (calendar.erl, line <span class="number">114</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-date_to_gregorian_days-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#date_to_gregorian_days-3&quot;&gt;calendar:date_to_gregorian_days/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;正如我们上星期在 &lt;a href=&quot;http://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/&quot;&gt;Erlang Thursday calendar:day_of_the_week/3&lt;/a&gt; 中讲到的，当我们看到一些错误消息的时候，我们看到错误来自于 calendar:date_to_gregorian_days/3。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – calendar:day_of_the_week/3</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-day-of-the-week-3/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-calendar-day-of-the-week-3/</id>
    <published>2016-09-17T07:27:44.000Z</published>
    <updated>2016-09-17T07:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/calendar.html#day_of_the_week-3" target="_blank" rel="external">calendar:day_of_the_week/3</a>.</p>
<p>calendar:day_of_the_week/3 允许你传入年、月、日然后得到这个日子在一个星期里是第几天。</p>
<a id="more"></a>
<p>第一个入参表示年份而且必须是非负整数。第二个入参是月份而且必须是1到12的整数（包括1和12），它表示公历的12个月份，1表示1月份。最后一个入参是第几日，必须是1到31（包括1和31）的整数。</p>
<p>calendar:day_of_the_week/3 返回一个1到7（包括1和7）的整数值，1表示星期一，7表示星期日。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 1</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% 5</span></div><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).</div><div class="line"><span class="comment">% 6</span></div></pre></td></tr></table></figure>
<p>本篇文章的发布日期是2015年4月9日，把它传给 calendar:day_of_the_week/3 ，得到返回值是4，正好表示星期四，也就是本系列文章发布的日子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>).</div><div class="line"><span class="comment">% 4</span></div></pre></td></tr></table></figure>
<p>还有一个 calendar:day_of_the_week/1 函数，它和上面的函数功能和参数要求基本一样，只是它只接收一个入参，这个入参是由年、月、日组成的三元素元组。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(&#123;<span class="number">2015</span>, <span class="number">4</span>, <span class="number">9</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>&#125;).</div><div class="line"><span class="comment">% 4</span></div><div class="line">calendar:day_of_the_week(&#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;).</div><div class="line"><span class="comment">% 5</span></div></pre></td></tr></table></figure>
<p>为了帮助大家认识 calendar:day_of_the_week/3 函数返回的错误消息，让我们看看，当我们给该函数传递无效日期，我们会得到什么。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">calendar:day_of_the_week(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:date_to_gregorian_days(0,0,0) (calendar.erl, line 114)</span></div><div class="line"><span class="comment">%      in function  calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">2</span>, <span class="number">31</span>).</div><div class="line"><span class="comment">% ** exception error: no true branch found when evaluating an if expression</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 116)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div><div class="line">calendar:day_of_the_week(<span class="number">1970</span>, <span class="number">13</span>, <span class="number">2</span>).</div><div class="line"><span class="comment">% ** exception error: no function clause matching calendar:last_day_of_the_month1(1970,13) (calendar.erl, line 243)</span></div><div class="line"><span class="comment">%      in function  calendar:date_to_gregorian_days/3 (calendar.erl, line 115)</span></div><div class="line"><span class="comment">%      in call from calendar:day_of_the_week/3 (calendar.erl, line 151)</span></div></pre></td></tr></table></figure>
<p>如果你仔细看这些错误消息，你会看到 calendar:day_of_the_week/3 调用了 calendar:date_to_gregorian_days/3 ，我们将在下个星期的Erlang Thursday来介绍它。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-calendar-day_of_the_week-3/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/calendar.html#day_of_the_week-3&quot;&gt;calendar:day_of_the_week/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;calendar:day_of_the_week/3 允许你传入年、月、日然后得到这个日子在一个星期里是第几天。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/categories/Erlang/calendar/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="calendar" scheme="http://szpzs.github.io/tags/calendar/"/>
    
      <category term="day_of_the_week" scheme="http://szpzs.github.io/tags/day-of-the-week/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thurday – lists:delete/2</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thurday-lists-delete-2/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thurday-lists-delete-2/</id>
    <published>2016-09-17T07:21:28.000Z</published>
    <updated>2016-09-17T07:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/lists.html#delete-2" target="_blank" rel="external">lists:delete/2</a> 。</p>
<p>lists:delete/2 接收一个Erlang term作为它的第一个入参，它将把该term从第二个入参－－一个列表里删除掉。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).</div><div class="line"><span class="comment">% [8,7,6,5,4,3,2]</span></div><div class="line">lists:delete(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,1,2,3,5,8]</span></div><div class="line">lists:delete(<span class="number">72</span>, <span class="string">"Hello World!"</span>).</div><div class="line"><span class="comment">% "ello World!"</span></div><div class="line">lists:delete(d, [a, b, c, d]).</div><div class="line"><span class="comment">% [a,b,c]</span></div><div class="line">lists:delete(<span class="number">4</span>, []).</div><div class="line"><span class="comment">% []</span></div><div class="line">lists:delete(&#123;b, <span class="number">2</span>&#125;, [&#123;a, <span class="number">1</span>&#125;, &#123;b, <span class="number">2</span>&#125;, &#123;c, <span class="number">3</span>&#125;]).</div><div class="line"><span class="comment">% [&#123;a,1&#125;,&#123;c,3&#125;]</span></div><div class="line">lists:delete([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]).</div><div class="line"><span class="comment">% [[4,5,6],[7,8,9]]</span></div></pre></td></tr></table></figure>
<p>注意：lists:delete/2 仅仅是将第一个在列表里发现的term删掉，而其他任何在列表里同样的term它不会删除。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:delete(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]).</div><div class="line"><span class="comment">% [1,2,3,5,8]</span></div></pre></td></tr></table></figure>
<p>因为 lists:delete/2 是一个非常简单就能讲清楚用法的函数，这样这篇文章将可能非常短，所以我想在下面我们展示一下如何自己来写一个非常简单(1) 的 lists:delete/2 实现是非常值得的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>让我们一起看看我们的delete函数在被调用的时候是如何执行的？</p>
<p>my_lists:delete/2 是一个友好的API函数，它仅仅是调用一个“私有”函数（没有导出的函数）－－ delete/3，所以调用者不需要担心那个我们传递的已经检查了的一个空列表作为初始值的累加器。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-module</span><span class="params">(my_lists)</span>.</div><div class="line"></div><div class="line"><span class="keyword">-export</span><span class="params">([delete/<span class="number">2</span>])</span>.</div><div class="line"></div><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, List)</span> -&gt;</span></div><div class="line">    delete(Item, [], List).</div></pre></td></tr></table></figure>
<p>delete/3函数的第一个分支用模式匹配来检查我们想要删除掉元素是否也是需要检查的列表的第一个元素。如果模式匹配成果，我们会看到第一个元素被删除！接着我们就能停止处理列表并返回的结果，而这个结果是由我们已经检查过的元素组成列表的反转列表和那些剩下的我们还没有检查的元素组成的列表一起构成的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Item|Rest])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked) ++ Rest;</div></pre></td></tr></table></figure>
<p>第二个分支“知道”我们想删除掉元素和剩下的列表的第一个元素不匹配。它是怎么“知道”的？因为如果它们匹配，第一个分支将模式匹配成功而第二个分支将得不到执行的机会。因为我们找不到元素需要被删除，我们通过将元素加到被检查过的元素组成的列表头部，并且继续调用 delete/3 。我们通过在被检查过的元素组成的列表头部加上元素形成新的被检查过元素组成的列表的做法就是为什么我们在第一分支和第三分支需要反转被检查元素组成的列表的原因。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(Item, Checked, [Head|Rest])</span> -&gt;</span></div><div class="line">    delete(Item, [Head | Checked], Rest);</div></pre></td></tr></table></figure>
<p>第三个也是最后一个 delete/3 函数的分支已经搜索到列表的结尾并且没有发现相同的元素，所以我们只是将被检查过的元素组成的列表反转后返回。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">(_Item, Checked, [])</span> -&gt;</span></div><div class="line">    lists:reverse(Checked).</div></pre></td></tr></table></figure>
<p>这就是你自己的简单(1)版 lists:delete/2 的实现。</p>
<p>1、简单的意思是因为这个版本没有进行性能优化，或者没有做彻底的是否完全符合 lists:delete/2 规范的测试。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thurday-lists-delete-2/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thurday-lists-delete-2/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/lists.html#delete-2&quot;&gt;lists:delete/2&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;lists:delete/2 接收一个Erlang term作为它的第一个入参，它将把该term从第二个入参－－一个列表里删除掉。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/categories/Erlang/lists/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="lists" scheme="http://szpzs.github.io/tags/lists/"/>
    
      <category term="delete" scheme="http://szpzs.github.io/tags/delete/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Thursday – erlang:list_to_atom/1</title>
    <link href="http://szpzs.github.io/2016/09/17/erlang-thursday-erlang-list-to-atom-1/"/>
    <id>http://szpzs.github.io/2016/09/17/erlang-thursday-erlang-list-to-atom-1/</id>
    <published>2016-09-17T07:15:31.000Z</published>
    <updated>2016-09-17T07:20:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Erlang Thursday讲的是 <a href="http://www.erlang.org/doc/man/erlang.html#list_to_atom-1" target="_blank" rel="external">erlang:list_to_atom/1</a>.</p>
<p>erlang:list_to_atom/1 的入参是一个字符串，返回的是一个Erlang的原子。</p>
<a id="more"></a>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>)</span>.</span></div><div class="line">% <span class="title">foo</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo"</span>)</span>.</div><div class="line">% <span class="title">'Foo'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Foo_bar"</span>)</span>.</div><div class="line">% <span class="title">'Foo_bar'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo_bar"</span>)</span>.</div><div class="line">% <span class="title">foo_bar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"foo"</span>++<span class="string">"bar"</span>)</span>.</div><div class="line">% <span class="title">foobar</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Erlang"</span>)</span>.</div><div class="line">% <span class="title">'Erlang'</span></div><div class="line"><span class="title">list_to_atom</span><span class="params">(<span class="string">"Elixir"</span>)</span>.</div><div class="line">% <span class="title">'Elixir'</span></div></pre></td></tr></table></figure>
<p>这个函数在你必须要基于从外部系统读到的字符串，比如解析一个CSV类型的头部，生成键或标识符的时候有用。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lists:map(<span class="keyword">fun</span> erlang:list_to_atom/<span class="number">1</span>,      	     string:tokens(<span class="string">"firstName,lastName,age,gender,preferredName,dateOfBirth"</span>, <span class="string">","</span>)).</div><div class="line"><span class="comment">% [firstName,lastName,age,gender,preferredName,dateOfBirth]</span></div></pre></td></tr></table></figure>
<p>当你用 erlang:list_to_atom/1 将从外部系统获取的字符串转换成原子的时候一定要小心，因为它只能处理值为256以下的字符。任何字符值在256（注1）以下的字符串都能正常地用该函数转成一个原子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">list_to_atom("Joe, Mike, and Robert").</div><div class="line">% 'Joe, Mike, and Robert'</div><div class="line">list_to_atom("it's").</div><div class="line">% 'it's'</div><div class="line">list_to_atom("heyn").</div><div class="line">% 'heyn'</div><div class="line">list_to_atom("with_supported_char"++[255]).</div><div class="line">% with_supported_charÿ</div><div class="line">list_to_atom("with_non_supported_char"++[256]).</div><div class="line">% ** exception error: bad argument</div><div class="line">%      in function  list_to_atom/1</div><div class="line">%         called as list_to_atom([119,105,116,104,95,110,111,110,95,115,117,112,112,111,114,</div><div class="line">%                                 116,101,100,95,99,104,97,114,256])</div></pre></td></tr></table></figure>
<p>1、字符值必须是非负整数，范围是0到255。</p>
<blockquote>
<p><em>原文链接：</em>  <a href="https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/" target="_blank" rel="external">https://www.proctor-it.com/erlang-thursday-erlang-list_to_atom-1/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Erlang Thursday讲的是 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#list_to_atom-1&quot;&gt;erlang:list_to_atom/1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;erlang:list_to_atom/1 的入参是一个字符串，返回的是一个Erlang的原子。&lt;/p&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://szpzs.github.io/categories/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/categories/Erlang/erlang/"/>
    
    
      <category term="Erlang" scheme="http://szpzs.github.io/tags/Erlang/"/>
    
      <category term="erlang" scheme="http://szpzs.github.io/tags/erlang/"/>
    
      <category term="list_to_atom" scheme="http://szpzs.github.io/tags/list-to-atom/"/>
    
  </entry>
  
</feed>
