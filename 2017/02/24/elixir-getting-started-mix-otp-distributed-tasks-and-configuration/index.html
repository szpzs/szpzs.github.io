<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Elixir,distributed-task,configuration," />





  <link rel="alternate" href="/atom.xml" title="Time is all" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="我们第一个分布式代码
异步/等待
分布式任务
路由层
测试过滤器和标签
应用环境和配置
总结

本章是Mix和OTP教程的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的第一章，或者查看本教程的章节索引。">
<meta property="og:type" content="article">
<meta property="og:title" content="Mix 和 OTP－分布式任务和配置">
<meta property="og:url" content="http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/index.html">
<meta property="og:site_name" content="Time is all">
<meta property="og:description" content="我们第一个分布式代码
异步/等待
分布式任务
路由层
测试过滤器和标签
应用环境和配置
总结

本章是Mix和OTP教程的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的第一章，或者查看本教程的章节索引。">
<meta property="og:updated_time" content="2017-02-24T04:26:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mix 和 OTP－分布式任务和配置">
<meta name="twitter:description" content="我们第一个分布式代码
异步/等待
分布式任务
路由层
测试过滤器和标签
应用环境和配置
总结

本章是Mix和OTP教程的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的第一章，或者查看本教程的章节索引。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://szpzs.oschina.io/2017/02/24/elixir-getting-started-mix-otp-distributed-tasks-and-configuration/"/>

  <title> Mix 和 OTP－分布式任务和配置 | Time is all </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?773cb20e4f6e199d6371a6a8df8640bd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Time is all</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Mix 和 OTP－分布式任务和配置
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-24T12:23:14+08:00" content="2017-02-24">
              2017-02-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Elixir/" itemprop="url" rel="index">
                    <span itemprop="name">Elixir</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Elixir/distributed-task-configuration/" itemprop="url" rel="index">
                    <span itemprop="name">distributed-task configuration</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li><a href="#part-one">我们第一个分布式代码</a></li>
<li><a href="#part-two">异步/等待</a></li>
<li><a href="#part-three">分布式任务</a></li>
<li><a href="#part-four">路由层</a></li>
<li><a href="#part-five">测试过滤器和标签</a></li>
<li><a href="#part-six">应用环境和配置</a></li>
<li><a href="#part-seven">总结</a></li>
</ol>
<p>本章是<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">Mix和OTP教程</a>的一部分，它依赖这个教程的前面章节。要获得更多信息，请阅读本教程的<a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" target="_blank" rel="external">第一章</a>，或者查看本教程的章节索引。</p>
<a id="more"></a>
<p>在这最后一章，我们将回到 :kv 应用并增加一个路由层，这个路由层将允许我们基于bucket名字在节点间分布请求。</p>
<p>路由层将接收如下格式的一张路由表：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line"> &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>路由器将根据表检查bucket名字的第一个字节然后据此来派发到合适的节点。例如，以字母“a”开头的一个bucket（?a表示字母“a”的Unicode代码点）将被派发到节点 foo@computer-name 。</p>
<p>如果匹配的条目指向处理请求的节点，那么我们就已经完成了路由，并且这个节点将执行请求的操作。如果匹配的条目指向一个不同的节点，我们将传递请求给这个节点，它将查询自己的路由表（可能与第一个节点的不同）并且做响应的动作。如果没有条目匹配，则一个错误将抛出。</p>
<p>你可能想知道为什么我们不告诉我们在我们的路由表找到的节点直接执行被请求的操作，而是传递路由请求给那个节点处理。尽管路由表和上面的那样简单，但在所有节点之间都可以合理地共享，这样当我们的应用程序增长时用这种方式传递路由请求使路由表变得更小。也许在某个时候，foo@computer-name 只是负责路由bucket的请求，而bucket被派发给不同的节点。用这种方式，bar@computer-name 不需要知道任何这些改变。</p>
<blockquote>
<p>注意：我们将在本章在同一个机器上使用两个节点。你可以自由地使用两台（或更多）不同的机器在同一网络，但你需要做一些准备工作。首先，你需要确认所有机器有一个有完全相同值的 ~/.erlang.cookie 文件。其次，你需要保证 <a href="http://www.erlang.org/doc/man/epmd.html" target="_blank" rel="external">epmd</a> 正运行在一个没有阻塞的端口（你可以运行 epmd -d 来输出调试信息）。最后，如果你想大体上学习更多分布式的知识，我们建议看 <a href="http://learnyousomeerlang.com/distribunomicon" target="_blank" rel="external">Learn You Some Erlang 里很棒的分布式章节</a>。</p>
</blockquote>
<h1 id="我们第一个分布式代码"><a href="#我们第一个分布式代码" class="headerlink" title="我们第一个分布式代码"></a><span id="part-one">我们第一个分布式代码</span></h1><p>Elixir自带了工具来链接节点以及在它们之间交换信息。实际上，当在一个分布式环境工作的时候，我们用进程、消息传递和接收消息相同的概念，因为Elixir进程是<em>位置透明的</em>。这就是说当发送一个消息的时候，不用关心接收进程是在同一个节点还是在另一个节点，虚拟机将能够在这两种情况下传递消息。</p>
<p>要运行分布式代码，我们需要用一个名字来启动虚拟机。名字可以是短的（当在同一个网络里）或长的（需要完整的计算机地址）。让我们启动一个新的IEx会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo</div></pre></td></tr></table></figure>
<p>你现在可以看到提示符有一点不同，显示了节点名字和计算机名字：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Interactive Elixir - press Ctrl+C to exit (type h() ENTER <span class="keyword">for</span> help)</div><div class="line">iex(foo<span class="variable">@jv</span>)<span class="number">1</span>&gt;</div></pre></td></tr></table></figure>
<p>我的机器名是 jv ，所以在上面的例子里我看到 foo@jv ，不过你将得到一个不同的结果。在后续的例子里我们将使用 foo@computer-name，当使用这些代码的时候，你应该相应地修改它们。</p>
<p>让我们在shell里定义一个叫Hello的模块：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; <span class="class"><span class="keyword">defmodule</span> <span class="title">Hello</span></span> <span class="keyword">do</span></div><div class="line">...&gt;   <span class="function"><span class="keyword">def</span> <span class="title">world</span></span>, <span class="symbol">do:</span> IO.puts <span class="string">"hello world"</span></div><div class="line">...&gt; <span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果你在同一个网络里的其他机器上已经装好了Erlang和Elixir，你可以在它上面启动另外一个IEx会话。否则，你可以在另一个终端启动另一个IEx会话。在这两种情况，给它一个短名叫做bar：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar</div></pre></td></tr></table></figure>
<p>注意，在这个新的IEx会话里，我们无法访问 Hello.world/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Hello.world</div><div class="line">** (UndefinedFunctionError) undefined <span class="symbol">function:</span> Hello.world/<span class="number">0</span></div><div class="line">    Hello.world()</div></pre></td></tr></table></figure>
<p>但是我们可以从 bar@computer-name 在 foo@computer-name 上创建一个新进程！让我们来试一试（@computer-name 是依据你自己的机器名字来写的）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iex&gt; Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt; Hello.world <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>Elixir在其他节点上启动一个进程并返回它的pid。代码在 Hello.world/0 函数所在的节点上被执行。注意：结果“hello world”打印在节点bar上而不是节点foo上。也就是说，被打印的消息从foo节点传回给bar节点。这是因为创建在其他节点（foo）上的进程仍然是有节点bar的组领导。我们已经简单地在<a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html#processes-and-group-leaders" target="_blank" rel="external">IO那一章</a>介绍了组领导的概念。</p>
<p>我们和往常一样可以与Node.spawn_link/2返回的pid进行消息的发送和接收操作。让我们尝试一个快速ping-pong例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iex&gt; pid = Node.spawn_link <span class="symbol">:<span class="string">"foo@computer-name"</span></span>, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   receive <span class="keyword">do</span></div><div class="line">...&gt;     &#123;<span class="symbol">:ping</span>, client&#125; -&gt; send client, <span class="symbol">:pong</span></div><div class="line">...&gt;   <span class="keyword">end</span></div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line"><span class="comment">#PID&lt;9014.59.0&gt;</span></div><div class="line">iex&gt; send pid, &#123;<span class="symbol">:ping</span>, <span class="keyword">self</span>()&#125;</div><div class="line">&#123;<span class="symbol">:ping</span>, <span class="comment">#PID&lt;0.73.0&gt;&#125;</span></div><div class="line">iex&gt; flush()</div><div class="line"><span class="symbol">:pong</span></div><div class="line"><span class="symbol">:ok</span></div></pre></td></tr></table></figure>
<p>从我们的快速探索，我们可以得出这样的结论：每一次我们需要做一个分布式计算的时候，我们应该用node.spawn_link/2在远程节点上创建进程。但是，我们已经从本教程学到，应该尽可能避免在监督树外创建进程，所以我们需要寻找其他方式。</p>
<p>有三种比 Node.spawn_link/2 更好的方式，我们在我们的实现里可以使用它们：</p>
<ol>
<li>我们可以使用Erlang的 <a href="http://www.erlang.org/doc/man/rpc.html" target="_blank" rel="external">:rpc模块</a>在远程节点上执行函数。在上面例子的bar@computer-name shell里，你可以调用 :rpc.call(:”foo@computer-name”, Hello, :world, []) ，它将打印“hello world”。</li>
<li>我们可以有一个运行在其他节点的服务，然后通过 <a href="https://hexdocs.pm/elixir/GenServer.html" target="_blank" rel="external">GenServer</a> API发送请求到那个节点。例如，你可以用 GenServer.call({name, node}, arg) 调用远程节点上的一个服务，或者传递远程进程的PID作为此函数的第一个入参。</li>
<li>我们可以使用我们在<a href="http://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html" target="_blank" rel="external">前一章</a>学到的<a href="https://hexdocs.pm/elixir/Task.html" target="_blank" rel="external">Task</a>，因为它们可以在本地和远程节点被启动。</li>
</ol>
<p>上述三种选项有不同的特点。:rpc 和使用 GenServer 都是在一个单独服务器里顺序执行你的请求，而 Task 在远程节点上高效地异步运行，它唯一的顺序点是被监督者创建的时候。</p>
<p>对于我们的路由层，我们将使用Task，但是其他方式也可以去尝试。</p>
<h1 id="异步-等待"><a href="#异步-等待" class="headerlink" title="异步/等待"></a><span id="part-two">异步/等待</span></h1><p>到目前为止，我们已经探索了独立启动和运行的任务而不考虑它们的返回值。但是，有时候运行一个任务，然后在稍后读取它的值是有用的使用方式。为此，Task也提供了 async/await 模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task = Task.async(<span class="keyword">fn</span> -&gt; compute_something_expensive <span class="keyword">end</span>)</div><div class="line">res  = compute_something_else()</div><div class="line">res + Task.await(task)</div></pre></td></tr></table></figure>
<p>async/await 提供了一个种非常简单的机制并发地计算某些值。不仅如此，async/await 也可以被用于我们前面章节学到的 <a href="https://hexdocs.pm/elixir/Task.Supervisor.html" target="_blank" rel="external">Task.Supervisor</a> 。我们只需要用 Task.Supervisor.async/2 替换 Task.Supervisor.start_child/2 然后稍后用 Task.await/2 读取结果。</p>
<h1 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a><span id="part-three">分布式任务</span></h1><p>分布式任务和被监督任务是一样的。唯一的区别是，我们在监督者上创建任务的时候传递的是节点名。打开 :kv 应用的 lib/kv/supervisor.ex 。让我们加入一个任务监督者作为监督树的最后一个孩子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">supervisor(Task.Supervisor, [[<span class="symbol">name:</span> KV.RouterTasks]]),</div></pre></td></tr></table></figure>
<p>现在，我们在 :kv 应用里启动两个命名的节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname foo -S mix</div><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>在 bar@computer-name 里，我们现在可以通过监督者在其他节点直接创建一个任务：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, <span class="keyword">fn</span> -&gt;</div><div class="line">...&gt;   &#123;<span class="symbol">:ok</span>, node()&#125;</div><div class="line">...&gt; <span class="keyword">end</span></div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.88.0&gt;, ref: #Reference&lt;0.0.0.400&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line">&#123;<span class="symbol">:ok</span>, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;</div></pre></td></tr></table></figure>
<p>我们的第一个分布式任务获取任务运行节点的名字。注意，我们给了一个匿名函数给 Task.Supervisor.async/2 ，但是， 在分布式场景里，最好是明确地指定模块、函数和函数的入参：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iex&gt; task = Task.Supervisor.async &#123;KV.RouterTasks, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;, Kernel, <span class="symbol">:node</span>, []</div><div class="line">%Task&#123;<span class="symbol">owner:</span> <span class="comment">#PID&lt;0.122.0&gt;, pid: #PID&lt;12467.89.0&gt;, ref: #Reference&lt;0.0.0.404&gt;&#125;</span></div><div class="line">iex&gt; Task.await(task)</div><div class="line"><span class="symbol">:<span class="string">"foo@computer-name"</span></span></div></pre></td></tr></table></figure>
<p>这两者的区别是：匿名函数需要目标节点和调用者有一样的代码版本。使用模块、函数和函数入参更健壮，因为你只需要在给定的模块里找到匹配函数参数个数的函数。</p>
<p>有了这方面的知识，最后让我们来写路由代码。</p>
<h1 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a><span id="part-four">路由层</span></h1><p>创建一个有如下内容的文件 lib/kv/router.ex ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.Router <span class="keyword">do</span></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  Dispatch the given `mod`, `fun`, `args` request</div><div class="line">  to the appropriate node based on the `bucket`.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">route</span></span>(bucket, mod, fun, args) <span class="keyword">do</span></div><div class="line">    <span class="comment"># Get the first byte of the binary</span></div><div class="line">    first = <span class="symbol">:binary</span>.first(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># Try to find an entry in the table() or raise</span></div><div class="line">    entry =</div><div class="line">      Enum.find(table(), <span class="keyword">fn</span> &#123;enum, _node&#125; -&gt;</div><div class="line">        first <span class="keyword">in</span> enum</div><div class="line">      <span class="keyword">end</span>) || no_entry_error(bucket)</div><div class="line"></div><div class="line">    <span class="comment"># If the entry node is the current node</span></div><div class="line">    if elem(entry, <span class="number">1</span>) == node() <span class="keyword">do</span></div><div class="line">      apply(mod, fun, args)</div><div class="line">    else</div><div class="line">      &#123;KV.RouterTasks, elem(entry, <span class="number">1</span>)&#125;</div><div class="line">      |&gt; Task.Supervisor.async(KV.Router, <span class="symbol">:route</span>, [bucket, mod, fun, args])</div><div class="line">      |&gt; Task.await()</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">no_entry_error</span></span>(bucket) <span class="keyword">do</span></div><div class="line">    raise <span class="string">"could not find entry for <span class="subst">#&#123;inspect bucket&#125;</span> in table <span class="subst">#&#123;inspect table()&#125;</span>"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">  The routing table.</div><div class="line">  "<span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">    <span class="comment"># Replace computer-name with your local machine name.</span></div><div class="line">    [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">     &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>让我们写一个测试来验证我们的路由器是否正常。创建一个名为 test/kv/router_test.exs 文件，其内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">KV</span></span>.RouterTest <span class="keyword">do</span></div><div class="line">  <span class="keyword">use</span> ExUnit.Case, <span class="symbol">async:</span> <span class="keyword">true</span></div><div class="line"></div><div class="line">  test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div><div class="line">    assert KV.Router.route(<span class="string">"hello"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"foo@computer-name"</span></span></div><div class="line">    assert KV.Router.route(<span class="string">"world"</span>, Kernel, <span class="symbol">:node</span>, []) ==</div><div class="line">           <span class="symbol">:<span class="string">"bar@computer-name"</span></span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  test <span class="string">"raises on unknown entries"</span> <span class="keyword">do</span></div><div class="line">    assert_raise RuntimeError, ~r/could <span class="keyword">not</span> find entry/, <span class="keyword">fn</span> -&gt;</div><div class="line">      KV.Router.route(&lt;&lt;<span class="number">0</span>&gt;&gt;, Kernel, <span class="symbol">:node</span>, [])</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>第一个测试用例调用 Kernel.node/0 ，它将返回基于bucket的名字是 “hello” 和 “world”的当前节点的名字。根据我们目前的路由表，我们应该分别获得 foo@computer-name 和 bar@computer-name 作为响应。</p>
<p>第二个测试检查未知条目引起的代码异常。</p>
<p>为了运行第一个测试，我们需要两个节点来运行。来到 apps/kv 目录，启动一个名叫 bar 节点，它将被用来运行测试用例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div></pre></td></tr></table></figure>
<p>然后运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>测试将通过。</p>
<h1 id="测试过滤器和标签"><a href="#测试过滤器和标签" class="headerlink" title="测试过滤器和标签"></a><span id="part-five">测试过滤器和标签</span></h1><p>虽然我们的测试通过了，但是我们的测试结构变得越来越复杂。特别是，在我们的测试套件里只用 mix test 运行测试引起失败，因为我们的测试需要链接另一个节点。</p>
<p>幸运地，ExUnit有一个工具用来标签测试，允许我们运行指定的回调函数或者甚至完全基于那些标签过滤测试。我们已经在前面的章节里使用了 :capture_log 标签，它有被ExUnit指定的自己的语义。</p>
<p>这次让我们增加一个标签到 test/kv/router_test.exs ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@tag</span> <span class="symbol">:distributed</span></div><div class="line">test <span class="string">"route requests across nodes"</span> <span class="keyword">do</span></div></pre></td></tr></table></figure>
<p>写 @tag :distributed 等价于写 @tag distributed: true 。</p>
<p>测试被正确地标签，我们现在可以检查节点是否活在在网络里，如果没有节点没有在网络里活着，我们可以不考虑所有分布式测试。在 :kv 应用里打开 test/test_helper.exs ，然后加入如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exclude =</div><div class="line">  if Node.alive?, <span class="symbol">do:</span> [], <span class="symbol">else:</span> [<span class="symbol">distributed:</span> <span class="keyword">true</span>]</div><div class="line"></div><div class="line">ExUnit.start(<span class="symbol">exclude:</span> exclude)</div></pre></td></tr></table></figure>
<p>现在用 mix test 运行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mix <span class="built_in">test</span></div><div class="line">Excluding tags: [distributed: <span class="literal">true</span>]</div><div class="line"></div><div class="line">.......</div><div class="line"></div><div class="line">Finished <span class="keyword">in</span> 0.1 seconds (0.1s on load, 0.01s on tests)</div><div class="line">7 tests, 0 failures, 1 skipped</div></pre></td></tr></table></figure>
<p>这一次所有测试都通过了并且ExUnit警告我们，分布式测试被忽略了。如果你用 $ elixir --sname foo -S mix test 运行测试，只要 bar@computer-name 这个节点可用，则刚才被忽略的那个测试将被运行并成功通过。</p>
<p>mix test 命令也允许我们动态包括和排除标签。例如，我们可以运行 $ mix test --include distributed 来运行分布式测试，而不管 test/test_helper.exs 里设置的值。我们也可以传递 --exclude 从命令行排除特定的标签。最后，--only 可以被用来运行只有特别标签的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html" target="_blank" rel="external">ExUnit.Case 模块文档</a>里阅读到更多的过滤器、标签和默认标签的内容。</p>
<h1 id="应用环境和配置"><a href="#应用环境和配置" class="headerlink" title="应用环境和配置"></a><span id="part-six">应用环境和配置</span></h1><p>目前我们硬编码路由表在 KV.Router 模块里。但是，我们想使得路由表是动态的。这不仅让我们配置开发/测试/生产环境，也允许不同节点在路由表里有不同内容。有一个OTP特性正好做这个事情：应用环境。</p>
<p>每一个应用有一个环境通过键来存储应用的特定配置。例如，我们可以存储路由表在 :kv 应用环境里，给它一个默认值，并且让其他应用在需要的时候修改这个表。</p>
<p>打开 apps/kv/mix.exs ，修改 application/0 函数返回如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span> <span class="keyword">do</span></div><div class="line">  [<span class="symbol">extra_applications:</span> [<span class="symbol">:logger</span>],</div><div class="line">   <span class="symbol">env:</span> [<span class="symbol">routing_table:</span> []],</div><div class="line">   <span class="symbol">mod:</span> &#123;KV, []&#125;]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们增加了一个新的键 :env 到应用里。它返回应用的默认环境，默认环境里有一个键为 :routing_table 的条目，其值为一个空的列表。应用程序环境与空表一起工作是有意义的，因为特定的路由表依赖于测试/部署结构。</p>
<p>为了在我们的代码里使用应用环境，我们需要用下面的内容来替换 KV.Router.table/0 ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@doc</span> <span class="string">""</span><span class="string">"</span></div><div class="line">The routing table.</div><div class="line">"<span class="string">""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span></span> <span class="keyword">do</span></div><div class="line">  Application.fetch_env!(<span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>我们用 Application.fetch_env!/2 来读取 :kv 的环境的 :routing_table 条目。你可以在 <a href="https://hexdocs.pm/elixir/Application.html" target="_blank" rel="external">Application 模块文档</a>里找到更多操作应用环境的信息和其他函数。</p>
<p>因为我们的路由表现在是空的，我们的分布式测试将会失败。重启应用并且重新运行测试来看它的失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ iex --sname bar -S mix</div><div class="line">$ elixir --sname foo -S mix <span class="built_in">test</span> --only distributed</div></pre></td></tr></table></figure>
<p>应用环境有趣的是，它不仅被配置为当前应用，而是可以被配置为所有应用。这样的设置可以用 config/config.exs 文件来做到。例如，我们可以配置来修改IEx的默认提示符为其他值。只要打开 apps/kv/config/config.exs ，增加如下内容：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">config <span class="symbol">:iex</span>, <span class="symbol">default_prompt:</span> <span class="string">"&gt;&gt;&gt;"</span></div></pre></td></tr></table></figure>
<p>用 iex -S mix 启动IEx，你可以看到IEx的提示符已经改变。</p>
<p>这意味着，我们也可以在 apps/kv/config/config.exs 文件里直接配置我们的 :routing_table ：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用你的本地节点替换 computer-name 。</span></div><div class="line">config <span class="symbol">:kv</span>, <span class="symbol">:routing_table</span>,</div><div class="line">       [&#123;?a..?m, <span class="symbol">:<span class="string">"foo@computer-name"</span></span>&#125;,</div><div class="line">        &#123;?n..?z, <span class="symbol">:<span class="string">"bar@computer-name"</span></span>&#125;]</div></pre></td></tr></table></figure>
<p>重启节点并再次运行分布式测试。现在它们应该全部通过。</p>
<p>从 Elixir v1.2 开始，所有伞型应用共享它们的配置，由于在伞型应用的根目录的 config/config.exs 文件里的如下一行，装载所有子应用的配置：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import_config <span class="string">"../apps/*/config/config.exs"</span></div></pre></td></tr></table></figure>
<p>mix run 命令也接收 --config 标签，允许配置文件按需提供。这个方法可以用来启动不同的节点，每个节点有它自己特定的配置（例如，不同的路由表）。</p>
<p>总体而言，内置配置应用的能力以及我们已经建立了我们的软件作为一个伞应用的事实，给我们在部署软件的时候提供了很多选择。</p>
<p>我们可以：</p>
<ul>
<li>部署伞型应用在一个节点将使得它既作为TCP服务器也作为键值存储。</li>
<li>部署 :kv_server 应用只作为TCP服务器只要路由表指向其他节点。</li>
<li>当我们想一个节点只作为一个存储（没有TCP访问）的时候，则只不是 :kv 应用。</li>
</ul>
<p>当我们在将来添加更多的应用程序时，我们可以继续使用粒度相同的级别来控制我们的部署，也可以继续选择用哪个配置给将要在生产上运行的应用。</p>
<p>我们也可以考虑用一个像<a href="https://github.com/bitwalker/distillery" target="_blank" rel="external">Distillery</a>的工具构建多发布版本，Distillery将打包被选择的应用和配置，包括当前安装的Erlang和Elixir安装，所以我们可以部署应用即使运行时没有预先在目标系统里被安装。</p>
<p>最后，我们在本章也学到一些新的东西，并且它也可以被应用到 :kv_server 。我们将留下一步作为一个练习：</p>
<ul>
<li>修改 :kv_server 应用从它的应用环境读取端口号而不是用硬编码值 4040 。</li>
<li>修改和配置 :kv_server 应用使用路由功能而不是直接派发给本地 KV.Registry 。为了 :kv_server 的测试，你可以使得路由表指向它自己的当前节点。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="part-seven">总结</span></h1><p>在本章，我们构建了一个简单的路由器作为一个方法来探索Elixir和Erlang虚拟机的分布式特性，也学会了如果配置它的路由表。这是我们的Mix和OTP教程的最后一章。</p>
<p>通过这个教程，我们已经构建一个简单的分布式键值存储当做一个机会来探索许多结构，像通用服务器、监督者、任务、agent、应用以及其他事物。不仅如此，我们为整个应用写了测试，熟悉 ExUnit ，并学习如何用 Mix 这个构建工具来完成很多任务。</p>
<p>如果你正在找用于生产的一个分布式键值存储，那么应该你一定去看看<a href="http://basho.com/riak/" target="_blank" rel="external">Riak</a>，它也运行在Erlang虚拟机里。在Riak里，bucket被复制，避免数据丢失；不是用路由表，它们而是使用 <a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="external">一致性哈希</a> 映射一个bucket到一个节点。当存储bucket的新的节点被加入到你的基础设施的时候，一致性哈希有助于减少需要被迁移的数据量。</p>
<p>这里有更多的课程可以学，希望目前为止你玩得开心！</p>
<blockquote>
<p><em>原文链接：</em>  <a href="http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html" target="_blank" rel="external">http://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Elixir/" rel="tag">#Elixir</a>
          
            <a href="/tags/distributed-task/" rel="tag">#distributed-task</a>
          
            <a href="/tags/configuration/" rel="tag">#configuration</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/23/elixir-getting-started-mix-otp-docs-tests-and-with/" rel="next" title="Mix 和 OTP－Docs、tests 和 with">
                <i class="fa fa-chevron-left"></i> Mix 和 OTP－Docs、tests 和 with
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/25/elixir-getting-started-meta-quote-and-unquote/" rel="prev" title="Elixir中的元编程－Quote 和 Unquote">
                Elixir中的元编程－Quote 和 Unquote <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="彭政生" />
          <p class="site-author-name" itemprop="name">彭政生</p>
          <p class="site-description motion-element" itemprop="description">盛年不重来，</br>一日难再晨，</br>及时当勉励，</br>岁月不待人。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">168</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">117</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">237</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/szpzs" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/szpengvictor" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://joearms.github.io/index.html" title="Joe Armstrong" target="_blank">Joe Armstrong</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.proctor-it.com/" title="Proctor It" target="_blank">Proctor It</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.yufeng.info/" title="系统技术非业余研究" target="_blank">系统技术非业余研究</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/me-sa/" title="回头再说 坚强2002的博客" target="_blank">回头再说 坚强2002的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/zhengsyao/" title="siyao zheng" target="_blank">siyao zheng</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ferd.ca/" title="As bad as anything else" target="_blank">As bad as anything else</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/bicowang/" title="Bico 笔记" target="_blank">Bico 笔记</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://coyee.com/" title="可译网" target="_blank">可译网</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#我们第一个分布式代码"><span class="nav-number">1.</span> <span class="nav-text">我们第一个分布式代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步-等待"><span class="nav-number">2.</span> <span class="nav-text">异步/等待</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式任务"><span class="nav-number">3.</span> <span class="nav-text">分布式任务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路由层"><span class="nav-number">4.</span> <span class="nav-text">路由层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试过滤器和标签"><span class="nav-number">5.</span> <span class="nav-text">测试过滤器和标签</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用环境和配置"><span class="nav-number">6.</span> <span class="nav-text">应用环境和配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">彭政生</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
